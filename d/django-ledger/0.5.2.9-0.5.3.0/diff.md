# Comparing `tmp/django_ledger-0.5.2.9-py3-none-any.whl.zip` & `tmp/django_ledger-0.5.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,35 @@
-Zip file size: 255951 bytes, number of entries: 162
--rw-r--r--  2.0 unx      452 b- defN 23-Jan-26 15:19 django_ledger/__init__.py
+Zip file size: 2639054 bytes, number of entries: 331
+-rw-r--r--  2.0 unx      458 b- defN 23-May-08 16:34 django_ledger/__init__.py
 -rw-r--r--  2.0 unx     3723 b- defN 22-Oct-21 23:13 django_ledger/admin.py
 -rw-r--r--  2.0 unx      163 b- defN 22-Oct-18 09:39 django_ledger/apps.py
--rw-r--r--  2.0 unx      431 b- defN 23-Jan-03 12:20 django_ledger/exceptions.py
--rw-r--r--  2.0 unx     5559 b- defN 23-Jan-11 01:18 django_ledger/settings.py
+-rw-r--r--  2.0 unx      491 b- defN 23-May-06 18:26 django_ledger/exceptions.py
+-rw-r--r--  2.0 unx     5964 b- defN 23-May-08 16:33 django_ledger/settings.py
 -rw-r--r--  2.0 unx     5064 b- defN 22-Nov-18 00:44 django_ledger/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-18 09:39 django_ledger/contrib/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/__init__.py
--rw-r--r--  2.0 unx      892 b- defN 23-Jan-20 23:38 django_ledger/contrib/django_ledger_graphene/api.py
+-rw-r--r--  2.0 unx      871 b- defN 23-May-06 18:26 django_ledger/contrib/django_ledger_graphene/api.py
 -rw-r--r--  2.0 unx      173 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/apps.py
--rw-r--r--  2.0 unx      365 b- defN 23-Jan-11 01:04 django_ledger/contrib/django_ledger_graphene/views.py
+-rw-r--r--  2.0 unx      368 b- defN 23-May-06 18:26 django_ledger/contrib/django_ledger_graphene/views.py
 -rw-r--r--  2.0 unx     1041 b- defN 22-Dec-28 18:54 django_ledger/contrib/django_ledger_graphene/accounts/schema.py
 -rw-r--r--  2.0 unx     1871 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/auth/mutations.py
 -rw-r--r--  2.0 unx      135 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/auth/schema.py
 -rw-r--r--  2.0 unx     1923 b- defN 22-Dec-28 18:51 django_ledger/contrib/django_ledger_graphene/bank_account/mutations.py
 -rw-r--r--  2.0 unx     1277 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/bank_account/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/bill/mutations.py
 -rw-r--r--  2.0 unx     1186 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/bill/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/coa/mutations.py
--rw-r--r--  2.0 unx      865 b- defN 23-Jan-20 23:56 django_ledger/contrib/django_ledger_graphene/coa/schema.py
+-rw-r--r--  2.0 unx      882 b- defN 23-May-06 18:26 django_ledger/contrib/django_ledger_graphene/coa/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/customers/__init__.py
 -rw-r--r--  2.0 unx     2131 b- defN 22-Dec-26 20:22 django_ledger/contrib/django_ledger_graphene/customers/mutations.py
 -rw-r--r--  2.0 unx     1561 b- defN 22-Dec-28 18:50 django_ledger/contrib/django_ledger_graphene/customers/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/data_import/mutations.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/data_import/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/entity/mutations.py
--rw-r--r--  2.0 unx     3128 b- defN 23-Jan-20 23:58 django_ledger/contrib/django_ledger_graphene/entity/schema.py
+-rw-r--r--  2.0 unx     3207 b- defN 23-May-06 18:26 django_ledger/contrib/django_ledger_graphene/entity/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/item/mutations.py
 -rw-r--r--  2.0 unx     1068 b- defN 22-Dec-28 18:52 django_ledger/contrib/django_ledger_graphene/item/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/journal_entry/mutations.py
 -rw-r--r--  2.0 unx     1243 b- defN 23-Jan-03 02:05 django_ledger/contrib/django_ledger_graphene/journal_entry/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/ledger/mutations.py
 -rw-r--r--  2.0 unx     1000 b- defN 22-Dec-28 18:49 django_ledger/contrib/django_ledger_graphene/ledger/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/purchase_order/mutations.py
@@ -37,128 +37,297 @@
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/transaction/mutations.py
 -rw-r--r--  2.0 unx     1297 b- defN 23-Jan-09 16:48 django_ledger/contrib/django_ledger_graphene/transaction/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/unit/mutations.py
 -rw-r--r--  2.0 unx      889 b- defN 22-Dec-28 18:49 django_ledger/contrib/django_ledger_graphene/unit/schema.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-21 23:13 django_ledger/contrib/django_ledger_graphene/vendor/mutations.py
 -rw-r--r--  2.0 unx     1453 b- defN 22-Dec-28 18:53 django_ledger/contrib/django_ledger_graphene/vendor/schema.py
 -rw-r--r--  2.0 unx      205 b- defN 22-Oct-18 09:39 django_ledger/forms/__init__.py
--rw-r--r--  2.0 unx     4894 b- defN 22-Dec-18 18:26 django_ledger/forms/account.py
+-rw-r--r--  2.0 unx     4980 b- defN 23-May-06 18:26 django_ledger/forms/account.py
 -rw-r--r--  2.0 unx     2293 b- defN 22-Oct-21 23:13 django_ledger/forms/app_filters.py
 -rw-r--r--  2.0 unx      736 b- defN 22-Oct-18 09:39 django_ledger/forms/auth.py
 -rw-r--r--  2.0 unx     4513 b- defN 22-Dec-26 18:33 django_ledger/forms/bank_account.py
--rw-r--r--  2.0 unx    10988 b- defN 22-Dec-26 21:03 django_ledger/forms/bill.py
+-rw-r--r--  2.0 unx    11007 b- defN 23-Feb-15 14:27 django_ledger/forms/bill.py
 -rw-r--r--  2.0 unx     1485 b- defN 22-Oct-18 09:39 django_ledger/forms/coa.py
--rw-r--r--  2.0 unx     2458 b- defN 22-Oct-21 23:13 django_ledger/forms/customer.py
+-rw-r--r--  2.0 unx     2502 b- defN 23-May-06 18:26 django_ledger/forms/customer.py
 -rw-r--r--  2.0 unx     3737 b- defN 22-Dec-26 18:35 django_ledger/forms/data_import.py
 -rw-r--r--  2.0 unx     7339 b- defN 22-Nov-24 18:01 django_ledger/forms/entity.py
 -rw-r--r--  2.0 unx     5171 b- defN 22-Oct-21 23:13 django_ledger/forms/estimate.py
 -rw-r--r--  2.0 unx     1850 b- defN 22-Oct-18 09:39 django_ledger/forms/feedback.py
--rw-r--r--  2.0 unx     9748 b- defN 22-Dec-26 21:03 django_ledger/forms/invoice.py
--rw-r--r--  2.0 unx     9685 b- defN 22-Dec-26 18:35 django_ledger/forms/item.py
--rw-r--r--  2.0 unx     1606 b- defN 22-Dec-26 23:31 django_ledger/forms/journal_entry.py
+-rw-r--r--  2.0 unx     9782 b- defN 23-Feb-15 14:27 django_ledger/forms/invoice.py
+-rw-r--r--  2.0 unx    12308 b- defN 23-Feb-15 14:27 django_ledger/forms/item.py
+-rw-r--r--  2.0 unx     1636 b- defN 23-Feb-17 19:45 django_ledger/forms/journal_entry.py
 -rw-r--r--  2.0 unx     1178 b- defN 22-Oct-18 09:39 django_ledger/forms/ledger.py
 -rw-r--r--  2.0 unx     7479 b- defN 22-Oct-21 23:13 django_ledger/forms/purchase_order.py
--rw-r--r--  2.0 unx     3254 b- defN 23-Jan-09 16:48 django_ledger/forms/transactions.py
+-rw-r--r--  2.0 unx     3075 b- defN 23-May-06 18:26 django_ledger/forms/transactions.py
 -rw-r--r--  2.0 unx     1131 b- defN 22-Oct-21 23:13 django_ledger/forms/unit.py
 -rw-r--r--  2.0 unx      513 b- defN 22-Oct-18 09:39 django_ledger/forms/utils.py
--rw-r--r--  2.0 unx     2171 b- defN 22-Oct-21 23:13 django_ledger/forms/vendor.py
+-rw-r--r--  2.0 unx     2215 b- defN 23-May-06 18:26 django_ledger/forms/vendor.py
 -rw-r--r--  2.0 unx      322 b- defN 22-Oct-18 09:39 django_ledger/io/__init__.py
--rw-r--r--  2.0 unx    31656 b- defN 23-Jan-26 13:57 django_ledger/io/data_generator.py
--rw-r--r--  2.0 unx     5836 b- defN 22-Nov-14 22:17 django_ledger/io/financial_statements.py
--rw-r--r--  2.0 unx     8039 b- defN 22-Oct-21 23:13 django_ledger/io/io_context.py
--rw-r--r--  2.0 unx    18455 b- defN 23-Jan-08 15:01 django_ledger/io/io_mixin.py
+-rw-r--r--  2.0 unx    33115 b- defN 23-May-06 18:26 django_ledger/io/data_generator.py
+-rw-r--r--  2.0 unx    19213 b- defN 23-May-06 18:26 django_ledger/io/io_context.py
+-rw-r--r--  2.0 unx    19863 b- defN 23-May-06 18:26 django_ledger/io/io_mixin.py
 -rw-r--r--  2.0 unx     1488 b- defN 22-Oct-18 09:39 django_ledger/io/ofx.py
 -rw-r--r--  2.0 unx     3568 b- defN 22-Oct-18 09:39 django_ledger/io/ratios.py
--rw-r--r--  2.0 unx    12386 b- defN 22-Dec-18 17:47 django_ledger/io/roles.py
+-rw-r--r--  2.0 unx    19348 b- defN 23-May-06 18:26 django_ledger/io/roles.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jan-11 14:51 django_ledger/management/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jan-11 14:51 django_ledger/management/commands/__init__.py
 -rw-r--r--  2.0 unx     1495 b- defN 23-Jan-11 18:26 django_ledger/management/commands/generate_oauth2_codes.py
 -rw-r--r--  2.0 unx    74729 b- defN 22-Dec-27 23:22 django_ledger/migrations/0001_initial.py
 -rw-r--r--  2.0 unx      703 b- defN 23-Jan-09 17:12 django_ledger/migrations/0002_alter_journalentrymodel_managers_and_more.py
+-rw-r--r--  2.0 unx     6069 b- defN 23-Feb-04 16:10 django_ledger/migrations/0003_remove_accountmodel_django_ledg_role_1bff96_idx_and_more.py
+-rw-r--r--  2.0 unx      586 b- defN 23-Feb-10 19:09 django_ledger/migrations/0004_remove_itemmodel_depth_remove_itemmodel_numchild_and_more.py
+-rw-r--r--  2.0 unx     1569 b- defN 23-Feb-15 14:27 django_ledger/migrations/0005_remove_itemmodel_django_ledg_invento_dbf206_idx_and_more.py
+-rw-r--r--  2.0 unx      749 b- defN 23-Feb-17 19:45 django_ledger/migrations/0006_alter_journalentrymodel_je_number_and_more.py
+-rw-r--r--  2.0 unx     4027 b- defN 23-May-06 18:26 django_ledger/migrations/0007_remove_customermodel_django_ledg_custome_16f95a_idx_and_more.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Dec-27 23:22 django_ledger/migrations/__init__.py
 -rw-r--r--  2.0 unx      745 b- defN 23-Jan-09 16:38 django_ledger/models/__init__.py
--rw-r--r--  2.0 unx    18725 b- defN 22-Dec-27 22:25 django_ledger/models/accounts.py
--rw-r--r--  2.0 unx     7259 b- defN 22-Dec-27 23:01 django_ledger/models/bank_account.py
--rw-r--r--  2.0 unx    55784 b- defN 23-Jan-21 04:44 django_ledger/models/bill.py
--rw-r--r--  2.0 unx     6349 b- defN 23-Jan-21 04:44 django_ledger/models/coa.py
--rw-r--r--  2.0 unx    12379 b- defN 22-Oct-21 23:13 django_ledger/models/coa_default.py
--rw-r--r--  2.0 unx    11998 b- defN 22-Dec-27 23:06 django_ledger/models/customer.py
+-rw-r--r--  2.0 unx    25403 b- defN 23-May-06 18:26 django_ledger/models/accounts.py
+-rw-r--r--  2.0 unx     7658 b- defN 23-May-06 18:26 django_ledger/models/bank_account.py
+-rw-r--r--  2.0 unx    57733 b- defN 23-May-08 15:46 django_ledger/models/bill.py
+-rw-r--r--  2.0 unx    12561 b- defN 23-May-06 18:26 django_ledger/models/coa.py
+-rw-r--r--  2.0 unx    27087 b- defN 23-May-06 18:26 django_ledger/models/coa_default.py
+-rw-r--r--  2.0 unx    12057 b- defN 23-May-06 18:26 django_ledger/models/customer.py
 -rw-r--r--  2.0 unx     3485 b- defN 22-Oct-18 09:39 django_ledger/models/data_import.py
--rw-r--r--  2.0 unx    43341 b- defN 23-Jan-20 22:33 django_ledger/models/entity.py
--rw-r--r--  2.0 unx    52047 b- defN 23-Jan-26 15:18 django_ledger/models/estimate.py
--rw-r--r--  2.0 unx    53061 b- defN 22-Dec-27 23:08 django_ledger/models/invoice.py
--rw-r--r--  2.0 unx    36502 b- defN 23-Jan-25 20:49 django_ledger/models/items.py
--rw-r--r--  2.0 unx    44155 b- defN 23-Jan-09 16:38 django_ledger/models/journal_entry.py
--rw-r--r--  2.0 unx     4411 b- defN 22-Dec-27 22:19 django_ledger/models/ledger.py
--rw-r--r--  2.0 unx    31738 b- defN 23-Jan-08 15:13 django_ledger/models/mixins.py
--rw-r--r--  2.0 unx    22708 b- defN 23-Jan-26 15:21 django_ledger/models/purchase_order.py
--rw-r--r--  2.0 unx    19373 b- defN 23-Jan-10 00:36 django_ledger/models/transactions.py
--rw-r--r--  2.0 unx     7845 b- defN 22-Dec-26 19:30 django_ledger/models/unit.py
--rw-r--r--  2.0 unx     4656 b- defN 23-Jan-08 20:30 django_ledger/models/utils.py
--rw-r--r--  2.0 unx     9596 b- defN 22-Dec-27 23:13 django_ledger/models/vendor.py
+-rw-r--r--  2.0 unx    70525 b- defN 23-May-08 16:00 django_ledger/models/entity.py
+-rw-r--r--  2.0 unx    53553 b- defN 23-May-06 18:26 django_ledger/models/estimate.py
+-rw-r--r--  2.0 unx    54335 b- defN 23-May-08 15:46 django_ledger/models/invoice.py
+-rw-r--r--  2.0 unx    55542 b- defN 23-May-06 18:26 django_ledger/models/items.py
+-rw-r--r--  2.0 unx    44797 b- defN 23-May-06 18:26 django_ledger/models/journal_entry.py
+-rw-r--r--  2.0 unx    10730 b- defN 23-May-06 18:26 django_ledger/models/ledger.py
+-rw-r--r--  2.0 unx    46220 b- defN 23-May-08 13:03 django_ledger/models/mixins.py
+-rw-r--r--  2.0 unx    40708 b- defN 23-May-06 18:26 django_ledger/models/purchase_order.py
+-rw-r--r--  2.0 unx    19622 b- defN 23-May-06 18:26 django_ledger/models/transactions.py
+-rw-r--r--  2.0 unx     7962 b- defN 23-Feb-10 22:26 django_ledger/models/unit.py
+-rw-r--r--  2.0 unx     5193 b- defN 23-May-06 18:26 django_ledger/models/utils.py
+-rw-r--r--  2.0 unx    11361 b- defN 23-May-06 18:26 django_ledger/models/vendor.py
 -rw-r--r--  2.0 unx      157 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/__init__.py
 -rw-r--r--  2.0 unx     1077 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/digest.py
 -rw-r--r--  2.0 unx      958 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/net_payable.py
 -rw-r--r--  2.0 unx      967 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/net_receivable.py
 -rw-r--r--  2.0 unx      573 b- defN 22-Oct-18 09:39 django_ledger/models/schemas/pnl.py
+-rw-r--r--  2.0 unx   533507 b- defN 22-Oct-21 23:13 django_ledger/static/django_ledger/bundle/djetler.bundle.js
+-rw-r--r--  2.0 unx   505388 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/bundle/styles.bundle.js
+-rw-r--r--  2.0 unx   276317 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/img/daniel-weiss-aj2Os9mYgJU-unsplash.jpg
+-rw-r--r--  2.0 unx  1053303 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/img/django_ledger_screenshot.png
+-rw-r--r--  2.0 unx    19456 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/img/made-with-bulma.png
+-rw-r--r--  2.0 unx    30821 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo.png
+-rw-r--r--  2.0 unx    70668 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo@2x.png
+-rw-r--r--  2.0 unx   119189 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo@3x.png
+-rw-r--r--  2.0 unx   183277 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo@4x.png
+-rw-r--r--  2.0 unx     6434 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo_1.png
+-rw-r--r--  2.0 unx    15445 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo_1@2x.png
+-rw-r--r--  2.0 unx    28997 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo_1@3x.png
+-rw-r--r--  2.0 unx    47266 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-logo_1@4x.png
+-rw-r--r--  2.0 unx    23440 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-tagline.png
+-rw-r--r--  2.0 unx    53087 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-tagline@2x.png
+-rw-r--r--  2.0 unx    86167 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-tagline@3x.png
+-rw-r--r--  2.0 unx   125162 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-tagline@4x.png
+-rw-r--r--  2.0 unx    17943 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-text.png
+-rw-r--r--  2.0 unx    41164 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-text@2x.png
+-rw-r--r--  2.0 unx    67707 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-text@3x.png
+-rw-r--r--  2.0 unx    99253 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/django-ledger-text@4x.png
+-rw-r--r--  2.0 unx     6434 b- defN 22-Oct-18 09:39 django_ledger/static/django_ledger/logo/favicon.png
+-rw-r--r--  2.0 unx      860 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/account/account_create.html
+-rw-r--r--  2.0 unx     1089 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/account/account_create_child.html
+-rw-r--r--  2.0 unx      934 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/account/account_detail.html
+-rw-r--r--  2.0 unx      796 b- defN 23-Feb-04 16:09 django_ledger/templates/django_ledger/account/account_list.html
+-rw-r--r--  2.0 unx      851 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/account/account_update.html
+-rw-r--r--  2.0 unx     3098 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/account/tags/account_txs_table.html
+-rw-r--r--  2.0 unx     5773 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/account/tags/accounts_table.html
+-rw-r--r--  2.0 unx     1849 b- defN 23-Feb-06 16:33 django_ledger/templates/django_ledger/auth/login.html
+-rw-r--r--  2.0 unx      952 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bank_account/bank_account_create.html
+-rw-r--r--  2.0 unx      701 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bank_account/bank_account_list.html
+-rw-r--r--  2.0 unx     1524 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bank_account/bank_account_update.html
+-rw-r--r--  2.0 unx     3476 b- defN 22-Nov-14 15:36 django_ledger/templates/django_ledger/bank_account/tags/bank_accounts_table.html
+-rw-r--r--  2.0 unx     2162 b- defN 22-Nov-13 00:20 django_ledger/templates/django_ledger/bills/bill_create.html
+-rw-r--r--  2.0 unx     1606 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bills/bill_delete.html
+-rw-r--r--  2.0 unx     9196 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bills/bill_detail.html
+-rw-r--r--  2.0 unx     6337 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/bills/bill_list.html
+-rw-r--r--  2.0 unx     8650 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bills/bill_update.html
+-rw-r--r--  2.0 unx     1354 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/bills/bill_void.html
+-rw-r--r--  2.0 unx     2864 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/bills/includes/bill_table.html
+-rw-r--r--  2.0 unx    14065 b- defN 22-Nov-14 17:17 django_ledger/templates/django_ledger/bills/includes/card_bill.html
+-rw-r--r--  2.0 unx     4082 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/bills/tags/bill_item_formset.html
+-rw-r--r--  2.0 unx      867 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/code_of_accounts/coa_update.html
+-rw-r--r--  2.0 unx      772 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/activity_form.html
+-rw-r--r--  2.0 unx     1147 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/breadcrumbs.html
+-rw-r--r--  2.0 unx      115 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/chart_container.html
+-rw-r--r--  2.0 unx      240 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/date_picker.html
+-rw-r--r--  2.0 unx      361 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/default_entity.html
+-rw-r--r--  2.0 unx     3333 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/feedback_button.html
+-rw-r--r--  2.0 unx      219 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/filters.html
+-rw-r--r--  2.0 unx       85 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/icon.html
+-rw-r--r--  2.0 unx     2077 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/menu.html
+-rw-r--r--  2.0 unx     1517 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/modals.html
+-rw-r--r--  2.0 unx      804 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/components/modals_v2.html
+-rw-r--r--  2.0 unx     1828 b- defN 22-Oct-22 14:55 django_ledger/templates/django_ledger/components/period_navigator.html
+-rw-r--r--  2.0 unx     1328 b- defN 22-Nov-14 16:18 django_ledger/templates/django_ledger/customer/customer_create.html
+-rw-r--r--  2.0 unx      689 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/customer/customer_list.html
+-rw-r--r--  2.0 unx     1354 b- defN 22-Nov-14 16:21 django_ledger/templates/django_ledger/customer/customer_update.html
+-rw-r--r--  2.0 unx     1306 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/customer/includes/card_customer.html
+-rw-r--r--  2.0 unx     3411 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/customer/tags/customer_table.html
+-rw-r--r--  2.0 unx      592 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/data_import/data_import_job_list.html
+-rw-r--r--  2.0 unx      833 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/data_import/data_import_job_txs.html
+-rw-r--r--  2.0 unx     2530 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/data_import/data_import_ofx.html
+-rw-r--r--  2.0 unx     2360 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/data_import/tags/data_import_job_list_table.html
+-rw-r--r--  2.0 unx     1065 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/data_import/tags/data_import_job_txs_imported.html
+-rw-r--r--  2.0 unx     2088 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/data_import/tags/data_import_job_txs_table.html
+-rw-r--r--  2.0 unx     1507 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/entitiy_list.html
+-rw-r--r--  2.0 unx     1387 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/entity_create.html
+-rw-r--r--  2.0 unx     5365 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/entity_dashboard.html
+-rw-r--r--  2.0 unx     1239 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/entity_delete.html
+-rw-r--r--  2.0 unx     1024 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/entity_update.html
+-rw-r--r--  2.0 unx      995 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/home.html
+-rw-r--r--  2.0 unx     1257 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/entity/includes/card_entity.html
+-rw-r--r--  2.0 unx     1393 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/estimate/estimate_create.html
+-rw-r--r--  2.0 unx     6316 b- defN 23-Jan-26 14:53 django_ledger/templates/django_ledger/estimate/estimate_detail.html
+-rw-r--r--  2.0 unx     6374 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/estimate/estimate_list.html
+-rw-r--r--  2.0 unx     2014 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/estimate/estimate_update.html
+-rw-r--r--  2.0 unx     5608 b- defN 23-Jan-26 14:54 django_ledger/templates/django_ledger/estimate/includes/card_estimate.html
+-rw-r--r--  2.0 unx     1775 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/estimate/includes/estimate_item_table.html
+-rw-r--r--  2.0 unx     3647 b- defN 23-Jan-26 15:09 django_ledger/templates/django_ledger/estimate/includes/estimate_table.html
+-rw-r--r--  2.0 unx     3917 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/estimate/tags/ce_item_formset.html
+-rw-r--r--  2.0 unx     1424 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/expense/expense_create.html
+-rw-r--r--  2.0 unx      867 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/expense/expense_list.html
+-rw-r--r--  2.0 unx     1439 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/expense/expense_update.html
+-rw-r--r--  2.0 unx     1962 b- defN 22-Oct-22 17:32 django_ledger/templates/django_ledger/expense/tags/expense_item_table.html
+-rw-r--r--  2.0 unx     2688 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/financial_statements/balance_sheet.html
+-rw-r--r--  2.0 unx     2891 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/financial_statements/cash_flow.html
+-rw-r--r--  2.0 unx     2627 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/financial_statements/income_statement.html
+-rw-r--r--  2.0 unx     5841 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/financial_statements/tags/balance_sheet_statement.html
+-rw-r--r--  2.0 unx     8941 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/financial_statements/tags/cash_flow_statement.html
+-rw-r--r--  2.0 unx    10195 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/financial_statements/tags/income_statement.html
+-rw-r--r--  2.0 unx      183 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/breadcrumbs.html
+-rw-r--r--  2.0 unx      804 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/card_markdown.html
+-rw-r--r--  2.0 unx      523 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/footer.html
+-rw-r--r--  2.0 unx      322 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/messages.html
+-rw-r--r--  2.0 unx     1408 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/nav.html
+-rw-r--r--  2.0 unx     2353 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/page_header.html
+-rw-r--r--  2.0 unx      949 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/widget_bs.html
+-rw-r--r--  2.0 unx     1129 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/widget_ic.html
+-rw-r--r--  2.0 unx     3252 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/includes/widget_ratios.html
+-rw-r--r--  2.0 unx     1438 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/inventory/inventory_item_create.html
+-rw-r--r--  2.0 unx      883 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/inventory/inventory_item_list.html
+-rw-r--r--  2.0 unx     1456 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/inventory/inventory_item_update.html
+-rw-r--r--  2.0 unx     2249 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/inventory/inventory_list.html
+-rw-r--r--  2.0 unx     3149 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/inventory/inventory_recount.html
+-rw-r--r--  2.0 unx     2056 b- defN 22-Oct-22 17:23 django_ledger/templates/django_ledger/inventory/tags/inventory_item_table.html
+-rw-r--r--  2.0 unx      945 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/inventory/tags/inventory_table.html
+-rw-r--r--  2.0 unx     2218 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/invoice/invoice_create.html
+-rw-r--r--  2.0 unx     1482 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/invoice/invoice_delete.html
+-rw-r--r--  2.0 unx     8006 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/invoice/invoice_detail.html
+-rw-r--r--  2.0 unx     6356 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/invoice/invoice_list.html
+-rw-r--r--  2.0 unx     8640 b- defN 22-Nov-14 17:29 django_ledger/templates/django_ledger/invoice/invoice_update.html
+-rw-r--r--  2.0 unx     9934 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/invoice/includes/card_invoice.html
+-rw-r--r--  2.0 unx     3413 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/invoice/tags/invoice_item_formset.html
+-rw-r--r--  2.0 unx     2596 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/invoice/tags/invoice_table.html
+-rw-r--r--  2.0 unx      903 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/journal_entry/je_create.html
+-rw-r--r--  2.0 unx     1234 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/journal_entry/je_detail.html
+-rw-r--r--  2.0 unx     2989 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/journal_entry/je_detail_txs.html
+-rw-r--r--  2.0 unx      668 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/journal_entry/je_list.html
+-rw-r--r--  2.0 unx      927 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/journal_entry/je_update.html
+-rw-r--r--  2.0 unx     1323 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/journal_entry/includes/card_journal_entry.html
+-rw-r--r--  2.0 unx     5033 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/journal_entry/tags/je_table.html
+-rw-r--r--  2.0 unx     2877 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/journal_entry/tags/je_txs_table.html
+-rw-r--r--  2.0 unx     1741 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/layouts/base.html
+-rw-r--r--  2.0 unx      936 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/layouts/content_layout_1.html
+-rw-r--r--  2.0 unx      355 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/layouts/content_layout_2.html
+-rw-r--r--  2.0 unx      896 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/ledger/ledger_create.html
+-rw-r--r--  2.0 unx      496 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/ledger/ledger_list.html
+-rw-r--r--  2.0 unx      921 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/ledger/ledger_update.html
+-rw-r--r--  2.0 unx     2878 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/ledger/tags/ledgers_table.html
+-rw-r--r--  2.0 unx     1431 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/product/product_create.html
+-rw-r--r--  2.0 unx     1147 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/product/product_delete.html
+-rw-r--r--  2.0 unx      855 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/product/product_list.html
+-rw-r--r--  2.0 unx     1440 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/product/product_update.html
+-rw-r--r--  2.0 unx     2434 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/product/tags/product_table.html
+-rw-r--r--  2.0 unx     1240 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/purchase_order/po_create.html
+-rw-r--r--  2.0 unx     1462 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/purchase_order/po_delete.html
+-rw-r--r--  2.0 unx     2519 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/purchase_order/po_detail.html
+-rw-r--r--  2.0 unx     6329 b- defN 22-Oct-18 09:39 django_ledger/templates/django_ledger/purchase_order/po_list.html
+-rw-r--r--  2.0 unx     4815 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/purchase_order/po_update.html
+-rw-r--r--  2.0 unx     8289 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/purchase_order/includes/card_po.html
+-rw-r--r--  2.0 unx     5092 b- defN 22-Nov-14 17:40 django_ledger/templates/django_ledger/purchase_order/includes/po_item_formset.html
+-rw-r--r--  2.0 unx     2228 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/purchase_order/includes/po_table.html
+-rw-r--r--  2.0 unx     1998 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/purchase_order/tags/po_item_table.html
+-rw-r--r--  2.0 unx     1431 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/service/service_create.html
+-rw-r--r--  2.0 unx     1101 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/service/service_delete.html
+-rw-r--r--  2.0 unx      854 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/service/service_list.html
+-rw-r--r--  2.0 unx     1440 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/service/service_update.html
+-rw-r--r--  2.0 unx     2434 b- defN 23-Feb-15 14:27 django_ledger/templates/django_ledger/service/tags/services_table.html
+-rw-r--r--  2.0 unx     1194 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/unit/unit_create.html
+-rw-r--r--  2.0 unx     1709 b- defN 22-Nov-14 19:14 django_ledger/templates/django_ledger/unit/unit_detail.html
+-rw-r--r--  2.0 unx     1973 b- defN 22-Dec-26 19:43 django_ledger/templates/django_ledger/unit/unit_list.html
+-rw-r--r--  2.0 unx     1214 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/unit/unit_update.html
+-rw-r--r--  2.0 unx     1380 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/uom/uom_create.html
+-rw-r--r--  2.0 unx     1605 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/uom/uom_delete.html
+-rw-r--r--  2.0 unx      854 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/uom/uom_list.html
+-rw-r--r--  2.0 unx     1436 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/uom/uom_update.html
+-rw-r--r--  2.0 unx     2472 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/uom/tags/uom_table.html
+-rw-r--r--  2.0 unx     1319 b- defN 22-Nov-14 15:42 django_ledger/templates/django_ledger/vendor/vendor_create.html
+-rw-r--r--  2.0 unx      672 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/vendor/vendor_list.html
+-rw-r--r--  2.0 unx     1341 b- defN 22-Nov-14 16:22 django_ledger/templates/django_ledger/vendor/vendor_update.html
+-rw-r--r--  2.0 unx     1290 b- defN 22-Oct-21 23:13 django_ledger/templates/django_ledger/vendor/includes/card_vendor.html
+-rw-r--r--  2.0 unx     3400 b- defN 23-May-06 18:26 django_ledger/templates/django_ledger/vendor/tags/vendor_table.html
 -rw-r--r--  2.0 unx      205 b- defN 22-Oct-18 09:39 django_ledger/templatetags/__init__.py
--rw-r--r--  2.0 unx    29932 b- defN 23-Jan-09 16:59 django_ledger/templatetags/django_ledger.py
+-rw-r--r--  2.0 unx    30805 b- defN 23-May-08 15:56 django_ledger/templatetags/django_ledger.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-18 09:39 django_ledger/tests/__init__.py
--rw-r--r--  2.0 unx     4462 b- defN 22-Dec-26 18:26 django_ledger/tests/base.py
+-rw-r--r--  2.0 unx     4585 b- defN 23-May-08 12:50 django_ledger/tests/base.py
 -rw-r--r--  2.0 unx     3059 b- defN 22-Oct-18 09:39 django_ledger/tests/test_auth.py
--rw-r--r--  2.0 unx    18226 b- defN 22-Nov-13 01:11 django_ledger/tests/test_bill.py
--rw-r--r--  2.0 unx    12133 b- defN 22-Nov-13 01:43 django_ledger/tests/test_entity.py
+-rw-r--r--  2.0 unx    18178 b- defN 23-May-08 16:12 django_ledger/tests/test_bill.py
+-rw-r--r--  2.0 unx    12180 b- defN 23-May-06 18:26 django_ledger/tests/test_entity.py
+-rw-r--r--  2.0 unx     8595 b- defN 23-May-07 03:01 django_ledger/tests/test_purchase_order.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Oct-18 09:39 django_ledger/tests/bdd/__init__.py
 -rw-r--r--  2.0 unx      599 b- defN 22-Oct-18 09:39 django_ledger/tests/bdd/features/steps/README.py
 -rw-r--r--  2.0 unx     1905 b- defN 23-Jan-11 00:55 django_ledger/urls/__init__.py
--rw-r--r--  2.0 unx     1481 b- defN 22-Oct-18 09:39 django_ledger/urls/account.py
+-rw-r--r--  2.0 unx     1310 b- defN 23-Feb-03 12:23 django_ledger/urls/account.py
 -rw-r--r--  2.0 unx      230 b- defN 22-Oct-18 09:39 django_ledger/urls/auth.py
 -rw-r--r--  2.0 unx      887 b- defN 22-Nov-14 15:34 django_ledger/urls/bank_account.py
 -rw-r--r--  2.0 unx     2884 b- defN 22-Oct-18 09:39 django_ledger/urls/bill.py
 -rw-r--r--  2.0 unx      199 b- defN 22-Oct-18 09:39 django_ledger/urls/chart_of_accounts.py
 -rw-r--r--  2.0 unx      426 b- defN 22-Oct-18 09:39 django_ledger/urls/customer.py
 -rw-r--r--  2.0 unx      475 b- defN 22-Oct-18 09:39 django_ledger/urls/data_import.py
 -rw-r--r--  2.0 unx      952 b- defN 23-Jan-11 12:57 django_ledger/urls/djl_api.py
 -rw-r--r--  2.0 unx     1279 b- defN 22-Oct-18 09:39 django_ledger/urls/entity.py
 -rw-r--r--  2.0 unx     2058 b- defN 22-Oct-18 09:39 django_ledger/urls/estimate.py
 -rw-r--r--  2.0 unx      273 b- defN 22-Oct-18 09:39 django_ledger/urls/feedback.py
--rw-r--r--  2.0 unx     7678 b- defN 22-Dec-21 21:33 django_ledger/urls/financial_statement.py
+-rw-r--r--  2.0 unx     8734 b- defN 23-Feb-15 14:27 django_ledger/urls/financial_statement.py
 -rw-r--r--  2.0 unx      152 b- defN 22-Oct-21 23:13 django_ledger/urls/home.py
 -rw-r--r--  2.0 unx      317 b- defN 22-Oct-18 09:39 django_ledger/urls/inventory.py
 -rw-r--r--  2.0 unx     2999 b- defN 22-Oct-18 09:39 django_ledger/urls/invoice.py
--rw-r--r--  2.0 unx     2106 b- defN 22-Oct-21 23:13 django_ledger/urls/item.py
--rw-r--r--  2.0 unx     1387 b- defN 22-Oct-21 23:13 django_ledger/urls/journal_entry.py
+-rw-r--r--  2.0 unx     2609 b- defN 23-Feb-15 14:27 django_ledger/urls/item.py
+-rw-r--r--  2.0 unx     1549 b- defN 23-Feb-15 14:27 django_ledger/urls/journal_entry.py
 -rw-r--r--  2.0 unx      394 b- defN 22-Oct-18 09:39 django_ledger/urls/ledger.py
 -rw-r--r--  2.0 unx     2388 b- defN 22-Oct-21 23:13 django_ledger/urls/purchase_order.py
--rw-r--r--  2.0 unx      243 b- defN 22-Oct-18 09:39 django_ledger/urls/transactions.py
+-rw-r--r--  2.0 unx       80 b- defN 23-Feb-15 14:27 django_ledger/urls/transactions.py
 -rw-r--r--  2.0 unx     1499 b- defN 22-Oct-18 09:39 django_ledger/urls/unit.py
 -rw-r--r--  2.0 unx      393 b- defN 22-Oct-18 09:39 django_ledger/urls/vendor.py
 -rw-r--r--  2.0 unx     1056 b- defN 22-Oct-18 09:39 django_ledger/views/__init__.py
--rw-r--r--  2.0 unx     8319 b- defN 22-Dec-26 18:38 django_ledger/views/account.py
+-rw-r--r--  2.0 unx     6863 b- defN 23-May-06 18:26 django_ledger/views/account.py
 -rw-r--r--  2.0 unx      771 b- defN 22-Oct-18 09:39 django_ledger/views/auth.py
--rw-r--r--  2.0 unx     5178 b- defN 22-Nov-14 15:37 django_ledger/views/bank_account.py
--rw-r--r--  2.0 unx    23769 b- defN 22-Dec-26 20:55 django_ledger/views/bill.py
--rw-r--r--  2.0 unx     1470 b- defN 22-Oct-21 23:13 django_ledger/views/coa.py
--rw-r--r--  2.0 unx     3673 b- defN 22-Dec-26 20:22 django_ledger/views/customer.py
+-rw-r--r--  2.0 unx     5172 b- defN 23-Feb-08 23:43 django_ledger/views/bank_account.py
+-rw-r--r--  2.0 unx    23049 b- defN 23-May-08 15:55 django_ledger/views/bill.py
+-rw-r--r--  2.0 unx     1704 b- defN 23-Feb-09 00:02 django_ledger/views/coa.py
+-rw-r--r--  2.0 unx     3668 b- defN 23-Feb-08 23:43 django_ledger/views/customer.py
 -rw-r--r--  2.0 unx    10554 b- defN 22-Nov-14 14:57 django_ledger/views/data_import.py
 -rw-r--r--  2.0 unx     4322 b- defN 22-Dec-27 00:20 django_ledger/views/djl_api.py
--rw-r--r--  2.0 unx    17429 b- defN 22-Dec-27 23:01 django_ledger/views/entity.py
--rw-r--r--  2.0 unx    13009 b- defN 23-Jan-26 15:02 django_ledger/views/estimate.py
+-rw-r--r--  2.0 unx    16074 b- defN 23-Feb-15 14:27 django_ledger/views/entity.py
+-rw-r--r--  2.0 unx    12833 b- defN 23-Feb-08 23:43 django_ledger/views/estimate.py
 -rw-r--r--  2.0 unx     2460 b- defN 22-Oct-21 23:13 django_ledger/views/feedback.py
 -rw-r--r--  2.0 unx     1365 b- defN 22-Oct-21 23:13 django_ledger/views/home.py
--rw-r--r--  2.0 unx     4838 b- defN 22-Nov-22 02:18 django_ledger/views/inventory.py
--rw-r--r--  2.0 unx    20412 b- defN 22-Dec-26 20:56 django_ledger/views/invoice.py
--rw-r--r--  2.0 unx    16318 b- defN 22-Nov-14 22:11 django_ledger/views/item.py
--rw-r--r--  2.0 unx     6941 b- defN 23-Jan-03 02:05 django_ledger/views/journal_entry.py
--rw-r--r--  2.0 unx     7227 b- defN 22-Dec-21 21:34 django_ledger/views/ledger.py
--rw-r--r--  2.0 unx    17261 b- defN 22-Dec-21 21:40 django_ledger/views/mixins.py
--rw-r--r--  2.0 unx    20906 b- defN 23-Jan-23 22:57 django_ledger/views/purchase_order.py
--rw-r--r--  2.0 unx     4171 b- defN 22-Oct-21 23:13 django_ledger/views/transactions.py
--rw-r--r--  2.0 unx     8696 b- defN 22-Dec-26 19:48 django_ledger/views/unit.py
--rw-r--r--  2.0 unx     3554 b- defN 22-Dec-27 22:04 django_ledger/views/vendor.py
--rw-r--r--  2.0 unx      713 b- defN 23-Jan-26 15:26 django_ledger-0.5.2.9.dist-info/AUTHORS.md
--rw-r--r--  2.0 unx    35148 b- defN 23-Jan-26 15:26 django_ledger-0.5.2.9.dist-info/LICENSE
--rw-r--r--  2.0 unx    10719 b- defN 23-Jan-26 15:26 django_ledger-0.5.2.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jan-26 15:26 django_ledger-0.5.2.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       26 b- defN 23-Jan-26 15:26 django_ledger-0.5.2.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    15394 b- defN 23-Jan-26 15:26 django_ledger-0.5.2.9.dist-info/RECORD
-162 files, 1097910 bytes uncompressed, 231051 bytes compressed:  79.0%
+-rw-r--r--  2.0 unx     5020 b- defN 23-Feb-15 14:27 django_ledger/views/inventory.py
+-rw-r--r--  2.0 unx    20253 b- defN 23-Feb-10 19:09 django_ledger/views/invoice.py
+-rw-r--r--  2.0 unx    21278 b- defN 23-Feb-15 14:27 django_ledger/views/item.py
+-rw-r--r--  2.0 unx    10774 b- defN 23-May-06 18:26 django_ledger/views/journal_entry.py
+-rw-r--r--  2.0 unx     8628 b- defN 23-Feb-15 14:27 django_ledger/views/ledger.py
+-rw-r--r--  2.0 unx    17325 b- defN 23-May-08 12:23 django_ledger/views/mixins.py
+-rw-r--r--  2.0 unx    21078 b- defN 23-May-07 03:06 django_ledger/views/purchase_order.py
+-rw-r--r--  2.0 unx      206 b- defN 23-Feb-15 14:27 django_ledger/views/transactions.py
+-rw-r--r--  2.0 unx     9501 b- defN 23-Feb-15 14:27 django_ledger/views/unit.py
+-rw-r--r--  2.0 unx     3457 b- defN 23-Feb-08 23:43 django_ledger/views/vendor.py
+-rw-r--r--  2.0 unx      713 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/AUTHORS.md
+-rw-r--r--  2.0 unx    35148 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx    11091 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       26 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    36443 b- defN 23-May-08 16:35 django_ledger-0.5.3.0.dist-info/RECORD
+331 files, 5043134 bytes uncompressed, 2578464 bytes compressed:  48.9%
```

## zipnote {}

```diff
@@ -186,17 +186,14 @@
 
 Filename: django_ledger/io/__init__.py
 Comment: 
 
 Filename: django_ledger/io/data_generator.py
 Comment: 
 
-Filename: django_ledger/io/financial_statements.py
-Comment: 
-
 Filename: django_ledger/io/io_context.py
 Comment: 
 
 Filename: django_ledger/io/io_mixin.py
 Comment: 
 
 Filename: django_ledger/io/ofx.py
@@ -219,14 +216,29 @@
 
 Filename: django_ledger/migrations/0001_initial.py
 Comment: 
 
 Filename: django_ledger/migrations/0002_alter_journalentrymodel_managers_and_more.py
 Comment: 
 
+Filename: django_ledger/migrations/0003_remove_accountmodel_django_ledg_role_1bff96_idx_and_more.py
+Comment: 
+
+Filename: django_ledger/migrations/0004_remove_itemmodel_depth_remove_itemmodel_numchild_and_more.py
+Comment: 
+
+Filename: django_ledger/migrations/0005_remove_itemmodel_django_ledg_invento_dbf206_idx_and_more.py
+Comment: 
+
+Filename: django_ledger/migrations/0006_alter_journalentrymodel_je_number_and_more.py
+Comment: 
+
+Filename: django_ledger/migrations/0007_remove_customermodel_django_ledg_custome_16f95a_idx_and_more.py
+Comment: 
+
 Filename: django_ledger/migrations/__init__.py
 Comment: 
 
 Filename: django_ledger/models/__init__.py
 Comment: 
 
 Filename: django_ledger/models/accounts.py
@@ -297,14 +309,506 @@
 
 Filename: django_ledger/models/schemas/net_receivable.py
 Comment: 
 
 Filename: django_ledger/models/schemas/pnl.py
 Comment: 
 
+Filename: django_ledger/static/django_ledger/bundle/djetler.bundle.js
+Comment: 
+
+Filename: django_ledger/static/django_ledger/bundle/styles.bundle.js
+Comment: 
+
+Filename: django_ledger/static/django_ledger/img/daniel-weiss-aj2Os9mYgJU-unsplash.jpg
+Comment: 
+
+Filename: django_ledger/static/django_ledger/img/django_ledger_screenshot.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/img/made-with-bulma.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo@2x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo@3x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo@4x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo_1.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo_1@2x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo_1@3x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-logo_1@4x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-tagline.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-tagline@2x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-tagline@3x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-tagline@4x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-text.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-text@2x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-text@3x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/django-ledger-text@4x.png
+Comment: 
+
+Filename: django_ledger/static/django_ledger/logo/favicon.png
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/account_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/account_create_child.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/account_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/account_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/account_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/tags/account_txs_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/account/tags/accounts_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/auth/login.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bank_account/bank_account_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bank_account/bank_account_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bank_account/bank_account_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bank_account/tags/bank_accounts_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/bill_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/bill_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/bill_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/bill_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/bill_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/bill_void.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/includes/bill_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/includes/card_bill.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/bills/tags/bill_item_formset.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/code_of_accounts/coa_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/activity_form.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/breadcrumbs.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/chart_container.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/date_picker.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/default_entity.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/feedback_button.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/filters.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/icon.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/menu.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/modals.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/modals_v2.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/components/period_navigator.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/customer/customer_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/customer/customer_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/customer/customer_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/customer/includes/card_customer.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/customer/tags/customer_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/data_import/data_import_job_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/data_import/data_import_job_txs.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/data_import/data_import_ofx.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/data_import/tags/data_import_job_list_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/data_import/tags/data_import_job_txs_imported.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/data_import/tags/data_import_job_txs_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/entitiy_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/entity_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/entity_dashboard.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/entity_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/entity_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/home.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/entity/includes/card_entity.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/estimate_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/estimate_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/estimate_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/estimate_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/includes/card_estimate.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/includes/estimate_item_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/includes/estimate_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/estimate/tags/ce_item_formset.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/expense/expense_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/expense/expense_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/expense/expense_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/expense/tags/expense_item_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/financial_statements/balance_sheet.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/financial_statements/cash_flow.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/financial_statements/income_statement.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/financial_statements/tags/balance_sheet_statement.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/financial_statements/tags/cash_flow_statement.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/financial_statements/tags/income_statement.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/breadcrumbs.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/card_markdown.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/footer.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/messages.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/nav.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/page_header.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/widget_bs.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/widget_ic.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/includes/widget_ratios.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/inventory_item_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/inventory_item_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/inventory_item_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/inventory_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/inventory_recount.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/tags/inventory_item_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/inventory/tags/inventory_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/invoice_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/invoice_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/invoice_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/invoice_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/invoice_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/includes/card_invoice.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/tags/invoice_item_formset.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/invoice/tags/invoice_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/je_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/je_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/je_detail_txs.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/je_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/je_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/includes/card_journal_entry.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/tags/je_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/journal_entry/tags/je_txs_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/layouts/base.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/layouts/content_layout_1.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/layouts/content_layout_2.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/ledger/ledger_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/ledger/ledger_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/ledger/ledger_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/ledger/tags/ledgers_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/product/product_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/product/product_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/product/product_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/product/product_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/product/tags/product_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/po_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/po_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/po_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/po_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/po_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/includes/card_po.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/includes/po_item_formset.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/includes/po_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/purchase_order/tags/po_item_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/service/service_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/service/service_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/service/service_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/service/service_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/service/tags/services_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/unit/unit_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/unit/unit_detail.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/unit/unit_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/unit/unit_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/uom/uom_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/uom/uom_delete.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/uom/uom_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/uom/uom_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/uom/tags/uom_table.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/vendor/vendor_create.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/vendor/vendor_list.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/vendor/vendor_update.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/vendor/includes/card_vendor.html
+Comment: 
+
+Filename: django_ledger/templates/django_ledger/vendor/tags/vendor_table.html
+Comment: 
+
 Filename: django_ledger/templatetags/__init__.py
 Comment: 
 
 Filename: django_ledger/templatetags/django_ledger.py
 Comment: 
 
 Filename: django_ledger/tests/__init__.py
@@ -318,14 +822,17 @@
 
 Filename: django_ledger/tests/test_bill.py
 Comment: 
 
 Filename: django_ledger/tests/test_entity.py
 Comment: 
 
+Filename: django_ledger/tests/test_purchase_order.py
+Comment: 
+
 Filename: django_ledger/tests/bdd/__init__.py
 Comment: 
 
 Filename: django_ledger/tests/bdd/features/steps/README.py
 Comment: 
 
 Filename: django_ledger/urls/__init__.py
@@ -462,26 +969,26 @@
 
 Filename: django_ledger/views/unit.py
 Comment: 
 
 Filename: django_ledger/views/vendor.py
 Comment: 
 
-Filename: django_ledger-0.5.2.9.dist-info/AUTHORS.md
+Filename: django_ledger-0.5.3.0.dist-info/AUTHORS.md
 Comment: 
 
-Filename: django_ledger-0.5.2.9.dist-info/LICENSE
+Filename: django_ledger-0.5.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: django_ledger-0.5.2.9.dist-info/METADATA
+Filename: django_ledger-0.5.3.0.dist-info/METADATA
 Comment: 
 
-Filename: django_ledger-0.5.2.9.dist-info/WHEEL
+Filename: django_ledger-0.5.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: django_ledger-0.5.2.9.dist-info/top_level.txt
+Filename: django_ledger-0.5.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: django_ledger-0.5.2.9.dist-info/RECORD
+Filename: django_ledger-0.5.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## django_ledger/__init__.py

```diff
@@ -1,18 +1,18 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
-Miguel Sanda <msanda@arrobalytics.com>
+    * Miguel Sanda <msanda@arrobalytics.com>
 """
 
 default_app_config = 'django_ledger.apps.DjangoLedgerConfig'
 
 """Django Ledger"""
-__version__ = '0.5.2.9'
+__version__ = '0.5.3.0'
 __license__ = 'GPLv3 License'
 
 __author__ = 'Miguel Sanda'
 __email__ = 'msanda@arrobalytics.com'
 
 __url__ = 'https://www.djangoledger.com'
```

## django_ledger/exceptions.py

```diff
@@ -5,14 +5,18 @@
 Contributions to this module:
 Miguel Sanda <msanda@arrobalytics.com>
 """
 
 from django.core.exceptions import ValidationError
 
 
+class DjangoLedgerConfigurationError(Exception):
+    pass
+
+
 class InvalidDateInputError(ValidationError):
     pass
 
 
 class InvalidRoleError(ValidationError):
     pass
```

## django_ledger/settings.py

```diff
@@ -39,14 +39,17 @@
                                                   'DJANGO_LEDGER_TRANSACTION_MAX_TOLERANCE',
                                                   Decimal('0.02'))
 
 DJANGO_LEDGER_TRANSACTION_CORRECTION = getattr(settings,
                                                'DJANGO_LEDGER_TRANSACTION_CORRECTION',
                                                Decimal('0.01'))
 
+DJANGO_LEDGER_ACCOUNT_CODE_GENERATE = getattr(settings, 'DJANGO_LEDGER_ACCOUNT_CODE_GENERATE', True)
+DJANGO_LEDGER_ACCOUNT_CODE_GENERATE_LENGTH = getattr(settings, 'DJANGO_LEDGER_ACCOUNT_CODE_GENERATE_LENGTH', 5)
+DJANGO_LEDGER_ACCOUNT_CODE_USE_PREFIX = getattr(settings, 'DJANGO_LEDGER_ACCOUNT_CODE_GENERATE_LENGTH', True)
 DJANGO_LEDGER_JE_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_JE_NUMBER_PREFIX', 'JE')
 DJANGO_LEDGER_PO_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_PO_NUMBER_PREFIX', 'PO')
 DJANGO_LEDGER_ESTIMATE_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_ESTIMATE_NUMBER_PREFIX', 'E')
 DJANGO_LEDGER_INVOICE_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_INVOICE_NUMBER_PREFIX', 'I')
 DJANGO_LEDGER_BILL_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_BILL_NUMBER_PREFIX', 'B')
 DJANGO_LEDGER_VENDOR_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_VENDOR_NUMBER_PREFIX', 'V')
 DJANGO_LEDGER_CUSTOMER_NUMBER_PREFIX = getattr(settings, 'DJANGO_LEDGER_CUSTOMER_NUMBER_PREFIX', 'C')
@@ -60,14 +63,16 @@
                                                   'DJANGO_LEDGER_BILL_MODEL_ABSTRACT_CLASS',
                                                   'django_ledger.models.bill.BillModelAbstract')
 
 DJANGO_LEDGER_INVOICE_MODEL_ABSTRACT_CLASS = getattr(settings,
                                                      'DJANGO_LEDGER_INVOICE_MODEL_ABSTRACT_CLASS',
                                                      'django_ledger.models.invoice.InvoiceModelAbstract')
 
+DJANGO_LEDGER_DEFAULT_COA = getattr(settings, 'DJANGO_LEDGER_DEFAULT_COA', None)
+
 DJANGO_LEDGER_FINANCIAL_ANALYSIS = {
     'ratios': {
         'current_ratio': {
             'good_incremental': True,
             'ranges': {
                 'healthy': 2,
                 'watch': 1,
```

## django_ledger/contrib/django_ledger_graphene/api.py

```diff
@@ -1,42 +1,42 @@
 import graphene
-from django.urls import reverse
-from django.utils.functional import SimpleLazyObject
 
-from django_ledger.contrib.django_ledger_graphene.coa.schema import ChartOfAccountsQuery
-from django_ledger.contrib.django_ledger_graphene.entity.schema import EntityModelQuery
-
-API_PATH = SimpleLazyObject(lambda: reverse("api"))
+from django_ledger.contrib.django_ledger_graphene.coa.schema import ChartOfAccountsModelType
+from django_ledger.contrib.django_ledger_graphene.entity.schema import EntityModelQuery, EntityModelType
 
 
 class Query(
+    EntityModelQuery,
+    # ChartOfAccountsModelQuery
     # CustomerQuery,
     # Bill_list_Query,
     # Accountlist_Query,
     # Bank_account_Query        ,
     # ChartOfAccountsQuery,
-    EntityModelQuery,
-    ChartOfAccountsQuery
     # UnitOfMeasureQuery,
     # VendorsQuery,
     # EntityUnitQuery,
     # LedgerQuery,
     # TransactionsQuery,
     # JournalEntryQuery,
     # PurchaseOrderQuery,
     # QueryUser,
 ):
     pass
 
 
-class Mutation(
-    # CustomerMutations,
-    # BankAccountMutations,
-    # AuthMutation,
-):
-    pass
+# class Mutation(
+#     # CustomerMutations,
+#     # BankAccountMutations,
+#     # AuthMutation,
+# ):
+#     pass
 
 
 schema = graphene.Schema(
+    types=[
+        EntityModelType,
+        ChartOfAccountsModelType
+    ],
     query=Query,
     # mutation=Mutation
 )
```

## django_ledger/contrib/django_ledger_graphene/views.py

```diff
@@ -1,12 +1,12 @@
 from django.utils.decorators import method_decorator
 from django.views.decorators.csrf import csrf_exempt
 from graphene_django.views import GraphQLView
 from oauth2_provider.views import ProtectedResourceView
 
 
 @method_decorator(csrf_exempt, name='dispatch')
-class ProtectedOAuth2GraphQLView(
+class DjangoLedgerOAuth2GraphQLView(
     ProtectedResourceView,
     GraphQLView
 ):
     raise_exception = True
```

## django_ledger/contrib/django_ledger_graphene/coa/schema.py

```diff
@@ -1,32 +1,30 @@
-
 import graphene
 from graphene import relay
 from graphene_django import DjangoObjectType
 
 from django_ledger.models import ChartOfAccountModel
 
 
-class ChartOfAccountsModelListNode(DjangoObjectType):
+class ChartOfAccountsModelType(DjangoObjectType):
     class Meta:
         model = ChartOfAccountModel
         fields = [
             'uuid',
             'slug',
             'name',
             'locked'
         ]
         interfaces = (relay.Node,)
 
-
-class ChartOfAccountsQuery(graphene.ObjectType):
-    all_coa = graphene.List(ChartOfAccountsModelListNode, slug=graphene.String(required=True))
-
-    def resolve_all_coa(self, info, slug, **kwargs):
-
-        if info.context.user.is_authenticated:
-            return ChartOfAccountModel.objects.for_entity(
-                entity_slug=slug,
-                user_model=info.context.user,
-            )
-        else:
-            return ChartOfAccountModel.objects.none()
+# class ChartOfAccountsModelQuery(graphene.ObjectType):
+#     all_coa = graphene.List(ChartOfAccountsModelType, slug=graphene.String(required=True))
+#
+#     def resolve_all_coa(self, info, slug, **kwargs):
+#
+#         if info.context.user.is_authenticated:
+#             return ChartOfAccountModel.objects.for_entity(
+#                 entity_slug=slug,
+#                 user_model=info.context.user,
+#             )
+#         else:
+#             return ChartOfAccountModel.objects.none()
```

## django_ledger/contrib/django_ledger_graphene/entity/schema.py

```diff
@@ -14,78 +14,81 @@
     'is_admin',
     'hidden',
     'created',
     'updated'
 ]
 
 
-class EntityModelListNode(DjangoObjectType):
+class EntityModelType(DjangoObjectType):
     is_admin = graphene.Boolean()
 
     def resolve_is_admin(self, info):
         entity_model: EntityModel = self
         return entity_model.is_admin_user(user_model=info.context.resource_owner)
 
     class Meta:
         model = EntityModel
         fields = ENTITY_MODEL_BASE_FIELDS
         filter_fields = {
-            'name': ['exact', 'icontains', 'istartswith'],
+            'name': [
+                'exact',
+                'icontains',
+                'istartswith'
+            ],
         }
         interfaces = (relay.Node,)
 
 
-class EntityModelDetailNode(EntityModelListNode):
+class EntityModelTypeDetail(EntityModelType):
     class Meta:
         model = EntityModel
         fields = ENTITY_MODEL_BASE_FIELDS + [
-            'default_coa',
-            # 'chartofaccountmodel_set'
+            'default_coa'
         ]
 
 
 class EntityModelQuery(graphene.ObjectType):
-    all_entity_list = graphene.List(EntityModelListNode)
-    visible_entity_list = graphene.List(EntityModelListNode)
-    hidden_entity_list = graphene.List(EntityModelListNode)
-    managed_entity_list = graphene.List(EntityModelListNode)
-    admin_entity_list = graphene.List(EntityModelListNode)
+    entity_model_list_all = graphene.List(EntityModelType)
+    entity_model_list_visible = graphene.List(EntityModelType)
+    entity_model_list_hidden = graphene.List(EntityModelType)
+    entity_model_list_managed = graphene.List(EntityModelType)
+    entity_model_list_is_admin = graphene.List(EntityModelType)
 
-    entity_detail_by_uuid = graphene.Field(EntityModelDetailNode, uuid=graphene.String(required=True))
-    entity_detail_by_slug = graphene.Field(EntityModelDetailNode, slug=graphene.String(required=True))
+    entity_model_detail_by_uuid = graphene.Field(EntityModelTypeDetail, uuid=graphene.String(required=True))
+    entity_model_detail_by_slug = graphene.Field(EntityModelTypeDetail, slug=graphene.String(required=True))
 
     @staticmethod
     def get_base_queryset(info):
         if info.context.resource_owner.is_authenticated:
             return EntityModel.objects.for_user(user_model=info.context.resource_owner)
         return EntityModel.objects.none()
 
     # list ....
-    def resolve_all_entity_list(self, info, **kwargs):
+    def resolve_entity_model_list_all(self, info, **kwargs):
         return EntityModelQuery.get_base_queryset(info)
 
-    def resolve_visible_entity_list(self, info, **kwargs):
+    def resolve_entity_model_list_visible(self, info, **kwargs):
         qs = EntityModelQuery.get_base_queryset(info)
         return qs.visible()
 
-    def resolve_hidden_entity_list(self, info, **kwargs):
+    def resolve_entity_model_list_hidden(self, info, **kwargs):
         qs = EntityModelQuery.get_base_queryset(info)
         return qs.hidden()
 
-    def resolve_managed_entity_list(self, info, **kwargs):
+    def resolve_entity_model_list_managed(self, info, **kwargs):
         qs: EntityModelQuerySet = EntityModelQuery.get_base_queryset(info)
         user_model = info.context.resource_owner
         return qs.filter(managers__in=[user_model])
 
-    def resolve_admin_entity_list(self, info, **kwargs):
+    def resolve_entity_model_list_is_admin(self, info, **kwargs):
         qs: EntityModelQuerySet = EntityModelQuery.get_base_queryset(info)
         user_model = info.context.resource_owner
         return qs.filter(admin=user_model)
 
     # detail...
-    def resolve_entity_detail_by_slug(self, info, slug, **kwargs):
+    def resolve_entity_model_detail_by_slug(self, info, slug, **kwargs):
         qs: EntityModelQuerySet = EntityModelQuery.get_base_queryset(info)
-        return qs.select_related('default_coa', ).get(slug__exact=slug)
+        return qs.select_related('default_coa').get(slug__exact=slug)
 
-    def resolve_entity_detail_by_uuid(self, info, uuid, **kwargs):
+    def resolve_entity_model_detail_by_uuid(self, info, uuid, **kwargs):
         qs: EntityModelQuerySet = EntityModelQuery.get_base_queryset(info)
-        return qs.select_related('default_coa', ).get(uuid__exact=uuid)
+        return qs.select_related('default_coa').get(uuid__exact=uuid)
```

## django_ledger/forms/account.py

```diff
@@ -1,143 +1,135 @@
-from django.forms import TextInput, Select, ModelForm
+from typing import Optional
 
+from django.forms import TextInput, Select, ModelForm, ChoiceField, ValidationError, CheckboxInput
+from django.utils.translation import gettext_lazy as _
+from treebeard.forms import MoveNodeForm
+
+from django_ledger.io import ACCOUNT_CHOICES_NO_ROOT
 from django_ledger.models.accounts import AccountModel
 from django_ledger.settings import DJANGO_LEDGER_FORM_INPUT_CLASSES
 
-
 """
 The account Model has the below forms: All these form have Account Model as their base.
 
 CreateForm
 CreateChildForm
 Update Form
 """
 
-class AccountModelCreateForm(ModelForm):
 
+class AccountModelCreateForm(ModelForm):
     """
     Create Form: 
     This Form is used for creation of a new account that does not exist in the default Chart of Accounts. It has some external as well as some internal field.
     The entity slug and the user model are the field which are internal and are predetermined in the lass itself
 
     Remaining fields which needs to be defined by user are :
 
-    code: The code will be used to uniquely identify the partiular account
+    code: The code will be used to uniquely identify the particular account
     name: The name of the account. The name of the account should be resemblance of the nature of the transactions that will be in the account
     role: The role needs to be selected rom list of the options available. Choices are given under ACCOUNT ROLES. Refer the account model documentation for more info
     balance_type: Need to be selected from drop down as "Debit" or Credit"
-
     """
+
     def __init__(self, entity_slug, user_model, *args, **kwargs):
-        super().__init__(*args, **kwargs)
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
+        super().__init__(*args, **kwargs)
+        self.fields['role'].choices = ACCOUNT_CHOICES_NO_ROOT
+        self.fields['code'].required = False
+
+    def clean_role_default(self):
+        role_default = self.cleaned_data['role_default']
+        if not role_default:
+            return None
+        return role_default
 
     class Meta:
         model = AccountModel
         fields = [
             'code',
             'name',
             'role',
+            'role_default',
             'balance_type',
         ]
         widgets = {
             'code': TextInput(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
+                'placeholder': _('Alpha Numeric (auto generated if not provided)...')
             }),
             'name': TextInput(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
+                'placeholder': _('Account Name...')
             }),
             'role': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
+            'role_default': CheckboxInput(),
             'balance_type': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
         }
 
 
-class AccountModelCreateChildForm(AccountModelCreateForm):
-
+class AccountModelUpdateForm(MoveNodeForm):
     """
-        
-    Create Child Form: 
-    This form is for creating of a child account .
-    The UI is designed such that, at the time of creating the child account, we have to automatically select that particular parent
-    So, we know under which parent the said Child is being created.
-    
-    User need to only mention the Account COde , Name and type: (Role will be same as the role of the Parent Account)
-
-    code: The code will be used to uniquely identify the partiular account
-    name: The name of the account. The name of the account should be resemblance of the nature of the transactions that will be in the account
-    balance_type: Need to be selected from drop down as "Debit" or Credit"
-
-    """
-
-    class Meta:
-        model = AccountModel
-        fields = [
-            'code',
-            'name',
-            'balance_type',
-        ]
-        widgets = {
-            'code': TextInput(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
-            }),
-            'name': TextInput(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
-            }),
-            'balance_type': Select(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
-            }),
-        }
-
-
-class AccountModelUpdateForm(ModelForm):
-    """
-        
-    Update Account Form: 
+    Update Account Form:
     This form is for updating the account. This works for both the parent or the child Account .
-    
     We can update the Parent , or The Code or even the Name of the Account.
-    
     """
 
+    _position = ChoiceField(required=True,
+                            label=_("Position"),
+                            widget=Select(attrs={
+                                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+                            }))
+    _ref_node_id = ChoiceField(required=False,
+                               label=_("Relative to"),
+                               widget=Select(attrs={
+                                   'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+                               }))
+
     def __init__(self, entity_slug, user_model, *args, **kwargs):
-        super().__init__(*args, **kwargs)
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
-        # self.PARENT_ACCOUNT: AccountModel = self.instance.parent
-        #
-        # if self.PARENT_ACCOUNT:
-        #     self.fields['parent'].queryset = AccountModel.on_coa.with_roles_available(
-        #         entity_slug=self.ENTITY_SLUG,
-        #         user_model=self.USER_MODEL,
-        #         roles=[self.PARENT_ACCOUNT.role]
-        #     )
-        # else:
-        #     self.fields['parent'].queryset = AccountModel.on_coa.for_entity_available(
-        #         user_model=self.USER_MODEL,
-        #         entity_slug=self.ENTITY_SLUG,
-        #     )
+        super().__init__(*args, **kwargs)
+        # self.fields['_ref_node_id'].choices = self.mk_dropdown_tree_choices()
+
+    @classmethod
+    def mk_dropdown_tree(cls, model, for_node: Optional[AccountModel] = None):
+        """ Creates a tree-like list of choices """
+
+        if not for_node:
+            raise ValidationError(message='Must provide for_node argument.')
+
+        options = list()
+        qs = for_node.get_account_move_choice_queryset()
+
+        # for node in qs:
+        #     cls.add_subtree(for_node, node, options)
+        return [
+            (i.uuid, f'{"-" * (i.depth - 1)} {i}') for i in qs
+        ]
+
+    def clean_role_default(self):
+        role_default = self.cleaned_data['role_default']
+        if not role_default:
+            return None
+        return role_default
 
     class Meta:
         model = AccountModel
-        fields = [
-            # 'parent',
-            'code',
-            'name',
-            'locked',
-            'active'
-        ]
+        exclude = ('depth', 'numchild', 'path', 'balance_type', 'role')
         widgets = {
             'parent': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'code': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'name': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
+            'role_default': CheckboxInput(),
         }
```

## django_ledger/forms/bill.py

```diff
@@ -1,10 +1,10 @@
 from django.forms import (ModelForm, DateInput, TextInput, Select,
                           CheckboxInput, BaseModelFormSet,
-                          modelformset_factory, Textarea)
+                          modelformset_factory, Textarea, DateTimeInput)
 from django.forms import ValidationError
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.io.roles import ASSET_CA_CASH, ASSET_CA_PREPAID, LIABILITY_CL_ACC_PAYABLE
 from django_ledger.models import (ItemModel, AccountModel, BillModel, ItemTransactionModel,
                                   VendorModel, EntityUnitModel)
 from django_ledger.settings import DJANGO_LEDGER_FORM_INPUT_CLASSES
@@ -129,15 +129,15 @@
         model = BillModel
         fields = [
             'markdown_notes'
         ]
         widgets = {
             'xref': TextInput(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
                                      'placeholder': 'External Reference...'}),
-            'timestamp': DateInput(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
+            'timestamp': DateTimeInput(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'amount_due': TextInput(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES, 'placeholder': '$$$'}),
             'terms': Select(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'bill_status': Select(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'date_paid': DateInput(
                 attrs={
                     'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
                     'placeholder': _('Date (YYYY-MM-DD)...')}
```

## django_ledger/forms/customer.py

```diff
@@ -28,15 +28,17 @@
             'city',
             'state',
             'zip_code',
             'country',
             'phone',
             'email',
             'website',
-            'sales_tax_rate'
+            'sales_tax_rate',
+            'active',
+            'hidden'
         ]
         help_texts = {
             'sales_tax_rate': _('Example: 3.50% should be entered as 0.0035')
         }
         widgets = {
             'customer_name': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
```

## django_ledger/forms/invoice.py

```diff
@@ -3,15 +3,16 @@
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
 Miguel Sanda <msanda@arrobalytics.com>
 """
 
 from django.core.exceptions import ValidationError
-from django.forms import ModelForm, DateInput, TextInput, Select, CheckboxInput, modelformset_factory, Textarea
+from django.forms import (ModelForm, DateInput, TextInput, Select, CheckboxInput, modelformset_factory, Textarea,
+                          DateTimeInput)
 from django.forms.models import BaseModelFormSet
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.io.roles import ASSET_CA_CASH, ASSET_CA_RECEIVABLES, LIABILITY_CL_DEFERRED_REVENUE
 from django_ledger.models import (AccountModel, CustomerModel, InvoiceModel, ItemTransactionModel, ItemModel)
 from django_ledger.settings import DJANGO_LEDGER_FORM_INPUT_CLASSES
 
@@ -116,15 +117,15 @@
         ]
         labels = {
             'progress': _('Progress Amount 0.00 -> 1.00 (percent)'),
             'accrue': _('Will this Bill be Accrued?'),
             'amount_paid': _('Amount Received')
         }
         widgets = {
-            'timestamp': DateInput(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
+            'timestamp': DateTimeInput(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'terms': Select(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'invoice_status': Select(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'customer': Select(attrs={'class': DJANGO_LEDGER_FORM_INPUT_CLASSES}),
             'date_paid': DateInput(
                 attrs={
                     'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
                     'placeholder': _('Paid Date (YYYY-MM-DD)...')}
@@ -233,15 +234,15 @@
                  invoice_model,
                  **kwargs):
         super().__init__(*args, **kwargs)
         self.USER_MODEL = user_model
         self.INVOICE_MODEL: InvoiceModel = invoice_model
         self.ENTITY_SLUG = entity_slug
 
-        items_qs = ItemModel.objects.products_and_services(
+        items_qs = ItemModel.objects.products(
             entity_slug=self.ENTITY_SLUG,
             user_model=self.USER_MODEL
         )
 
         for form in self.forms:
             if not self.INVOICE_MODEL.can_edit_items():
                 form.fields['item_model'].disabled = True
```

## django_ledger/forms/item.py

```diff
@@ -1,14 +1,16 @@
-from django.forms import ModelForm, TextInput, Select, HiddenInput
+from django.forms import ModelForm, TextInput, Select, ChoiceField
+from django.utils.translation import gettext_lazy as _
 
-from django_ledger.io.roles import GROUP_INCOME, GROUP_EXPENSES_NO_COGS, COGS, ASSET_CA_INVENTORY
+from django_ledger.io.roles import GROUP_INCOME, ASSET_CA_INVENTORY, GROUP_EXPENSES, GROUP_COGS
 from django_ledger.models import AccountModel, ItemModel, UnitOfMeasureModel
 from django_ledger.settings import DJANGO_LEDGER_FORM_INPUT_CLASSES
 
 
+# #### UNIT OF MEASURES #######
 class UnitOfMeasureModelCreateForm(ModelForm):
 
     def __init__(self, entity_slug: str, user_model, *args, **kwargs):
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
         super().__init__(*args, **kwargs)
 
@@ -29,229 +31,309 @@
         }
 
 
 class UnitOfMeasureModelUpdateForm(UnitOfMeasureModelCreateForm):
     pass
 
 
-class ProductOrServiceUpdateForm(ModelForm):
+# #### PRODUCT ITEMS #######
+
+class ProductCreateForm(ModelForm):
+    PRODUCT_OR_SERVICE_ROLES = GROUP_INCOME + GROUP_COGS
+    PRODUCT_OR_SERVICE_ROLES.append(ASSET_CA_INVENTORY)
 
     def __init__(self, entity_slug: str, user_model, *args, **kwargs):
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
         super().__init__(*args, **kwargs)
 
         accounts_qs = AccountModel.objects.with_roles(
-            roles=GROUP_INCOME,
+            roles=self.PRODUCT_OR_SERVICE_ROLES,
             entity_slug=self.ENTITY_SLUG,
             user_model=self.USER_MODEL).active()
 
+        # caches the QS for filtering...
+        len(accounts_qs)
+
         self.fields['earnings_account'].queryset = accounts_qs.filter(role__in=GROUP_INCOME)
+        self.fields['cogs_account'].queryset = accounts_qs.filter(role__in=GROUP_COGS)
+        self.fields['inventory_account'].queryset = accounts_qs.filter(role__in=[ASSET_CA_INVENTORY])
 
-        uom_qs = UnitOfMeasureModel.objects.for_entity(
-            entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL
-        )
-        self.fields['uom'].queryset = uom_qs
+        if 'uom' in self.fields:
+            uom_qs = UnitOfMeasureModel.objects.for_entity_active(
+                entity_slug=self.ENTITY_SLUG,
+                user_model=self.USER_MODEL
+            )
+            self.fields['uom'].queryset = uom_qs
+
+        if 'item_type' in self.fields:
+            self.fields['item_type'].choices = ItemModel.ITEM_TYPE_CHOICES_PRODUCT
 
     class Meta:
         model = ItemModel
         fields = [
             'name',
             'sku',
             'upc',
             'item_id',
             'uom',
-            'item_type',
             'default_amount',
             'earnings_account',
+            'cogs_account',
+            'inventory_account',
+            'sold_as_unit'
         ]
         widgets = {
             'name': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'uom': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
-            'item_type': Select(attrs={
+            'earnings_account': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
-            'earnings_account': Select(attrs={
+            'cogs_account': Select(attrs={
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+            }),
+            'inventory_account': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'sku': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'upc': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'item_id': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
+            'item_type': Select(attrs={
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+            }),
             'default_amount': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
         }
+        labels = {
+            'name': _('Product Name'),
+            'item_type': _('Product Type')
+        }
+
+    def clean(self):
+        item_model: ItemModel = self.instance
+        item_model.item_role = ItemModel.ITEM_ROLE_PRODUCT
+        return super().clean()
+
+
+class ProductUpdateForm(ProductCreateForm):
+    pass
+
 
+# #### SERVICE ITEMS #######
 
-class ProductOrServiceCreateForm(ProductOrServiceUpdateForm):
+class ServiceCreateForm(ModelForm):
+    SERVICE_ROLES = GROUP_INCOME + GROUP_COGS
 
     def __init__(self, entity_slug: str, user_model, *args, **kwargs):
-        super().__init__(entity_slug=entity_slug, user_model=user_model, *args, **kwargs)
-        uom_qs = UnitOfMeasureModel.objects.for_entity_active(
+        self.ENTITY_SLUG = entity_slug
+        self.USER_MODEL = user_model
+        super().__init__(*args, **kwargs)
+
+        accounts_qs = AccountModel.objects.with_roles(
+            roles=self.SERVICE_ROLES,
             entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL
-        )
-        self.fields['uom'].queryset = uom_qs
+            user_model=self.USER_MODEL).active()
 
-    class Meta(ProductOrServiceUpdateForm.Meta):
+        # caches the QS for filtering...
+        len(accounts_qs)
+
+        self.fields['earnings_account'].queryset = accounts_qs.filter(role__in=GROUP_INCOME)
+        self.fields['cogs_account'].queryset = accounts_qs.filter(role__in=GROUP_COGS)
+
+        if 'uom' in self.fields:
+            uom_qs = UnitOfMeasureModel.objects.for_entity_active(
+                entity_slug=self.ENTITY_SLUG,
+                user_model=self.USER_MODEL
+            )
+            self.fields['uom'].queryset = uom_qs
+
+    class Meta:
+        model = ItemModel
         fields = [
             'name',
             'sku',
             'upc',
             'item_id',
             'uom',
-            'item_type',
             'default_amount',
             'earnings_account',
+            'cogs_account',
+            'sold_as_unit'
         ]
         widgets = {
             'name': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'uom': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
-            'item_type': Select(attrs={
+            'earnings_account': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
-            'earnings_account': Select(attrs={
+            'cogs_account': Select(attrs={
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+            }),
+            'inventory_account': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'sku': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'upc': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'item_id': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
+            'item_type': Select(attrs={
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+            }),
             'default_amount': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
-            })
+            }),
         }
+        labels = {
+            'name': _('Service Name'),
+            'sold_as_unit': _('Sold as Unit?')
+        }
+
+    def clean(self):
+        item_model: ItemModel = self.instance
+        item_model.item_role = ItemModel.ITEM_ROLE_SERVICE
+        return super().clean()
+
+
+class ServiceUpdateForm(ServiceCreateForm):
+    pass
 
 
-class ExpenseItemUpdateForm(ModelForm):
+# #### EXPENSE ITEMS #######
+class ExpenseItemCreateForm(ModelForm):
     def __init__(self, entity_slug: str, user_model, *args, **kwargs):
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
         super().__init__(*args, **kwargs)
 
         accounts_qs = AccountModel.objects.with_roles(
-            roles=GROUP_EXPENSES_NO_COGS,
+            roles=GROUP_EXPENSES,
             entity_slug=self.ENTITY_SLUG,
             user_model=self.USER_MODEL).active()
 
-        self.fields['expense_account'].queryset = accounts_qs.filter(role__in=GROUP_EXPENSES_NO_COGS)
+        self.fields['expense_account'].queryset = accounts_qs.filter(role__in=GROUP_EXPENSES)
 
-        uom_qs = UnitOfMeasureModel.objects.for_entity(
-            entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL
-        )
-        self.fields['uom'].queryset = uom_qs
+        if 'uom' in self.fields:
+            uom_qs = UnitOfMeasureModel.objects.for_entity(
+                entity_slug=self.ENTITY_SLUG,
+                user_model=self.USER_MODEL
+            )
+            self.fields['uom'].queryset = uom_qs
 
     class Meta:
         model = ItemModel
         fields = [
             'name',
+            'upc',
+            'sku',
             'uom',
             'item_type',
             'default_amount',
             'expense_account',
         ]
         widgets = {
             'name': TextInput(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
+                'placeholder': _('The item name...')
             }),
             'uom': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'item_type': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'expense_account': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'sku': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'upc': TextInput(attrs={
-                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES,
+                'placeholder': _('The UPC code of the item, if any...')
             }),
             'item_id': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'default_amount': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
         }
+        labels = {
+            'name': _('Expense Name')
+        }
 
+    def clean(self):
+        item_model: ItemModel = self.instance
+        item_model.item_role = ItemModel.ITEM_ROLE_EXPENSE
+        return super().clean()
 
-class ExpenseItemCreateForm(ExpenseItemUpdateForm):
 
-    def __init__(self, entity_slug: str, user_model, *args, **kwargs):
-        super().__init__(entity_slug=entity_slug, user_model=user_model, *args, **kwargs)
-        uom_qs = UnitOfMeasureModel.objects.for_entity_active(
-            entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL
-        )
-        self.fields['uom'].queryset = uom_qs
+class ExpenseItemUpdateForm(ExpenseItemCreateForm):
+    class Meta(ExpenseItemCreateForm.Meta):
+        fields = [
+            'name',
+            'upc',
+            'sku',
+            'default_amount',
+            'expense_account',
+        ]
 
 
-class InventoryItemUpdateForm(ModelForm):
-    INVENTORY_ROLES = [COGS, ASSET_CA_INVENTORY] + GROUP_INCOME
+# #### INVENTORY ITEMS #######
+class InventoryItemCreateForm(ModelForm):
 
     def __init__(self, entity_slug: str, user_model, *args, **kwargs):
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
         super().__init__(*args, **kwargs)
 
         accounts_qs = AccountModel.objects.with_roles(
-            roles=self.INVENTORY_ROLES,
+            roles=[ASSET_CA_INVENTORY],
             entity_slug=self.ENTITY_SLUG,
             user_model=self.USER_MODEL).active()
+        self.fields['inventory_account'].queryset = accounts_qs
 
-        # evaluating qs...
-        len(accounts_qs)
-
-        self.fields['earnings_account'].queryset = accounts_qs.filter(role__in=GROUP_INCOME)
-        self.fields['inventory_account'].queryset = accounts_qs.filter(role__in=[ASSET_CA_INVENTORY])
-        self.fields['cogs_account'].queryset = accounts_qs.filter(role__in=[COGS])
-
-        uom_qs = UnitOfMeasureModel.objects.for_entity(
-            entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL
-        )
-        self.fields['uom'].queryset = uom_qs
+        if 'uom' in self.fields:
+            uom_qs = UnitOfMeasureModel.objects.for_entity_active(
+                entity_slug=self.ENTITY_SLUG,
+                user_model=self.USER_MODEL
+            )
+            self.fields['uom'].queryset = uom_qs
 
     class Meta:
         model = ItemModel
         fields = [
             'name',
             'uom',
-            'item_type',
             'upc',
+            'sku',
             'item_id',
-            'inventory_account',
-            'cogs_account',
+            'item_type',
             'default_amount',
-            'is_product_or_service',
-            'earnings_account',
+            'inventory_account',
         ]
         widgets = {
             'name': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'uom': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
@@ -267,25 +349,37 @@
             }),
             'cogs_account': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'upc': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
+            'sku': TextInput(attrs={
+                'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
+            }),
             'item_id': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'default_amount': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
         }
+        labels = {
+            'name': _('Inventory Name')
+        }
 
+    def clean(self):
+        item_model: ItemModel = self.instance
+        item_model.item_role = ItemModel.ITEM_ROLE_INVENTORY
+        return super().clean()
 
-class InventoryItemCreateForm(InventoryItemUpdateForm):
 
-    def __init__(self, entity_slug: str, user_model, *args, **kwargs):
-        super().__init__(entity_slug=entity_slug, user_model=user_model, *args, **kwargs)
-        uom_qs = UnitOfMeasureModel.objects.for_entity_active(
-            entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL
-        )
-        self.fields['uom'].queryset = uom_qs
+class InventoryItemUpdateForm(InventoryItemCreateForm):
+    class Meta(InventoryItemCreateForm.Meta):
+        fields = [
+            'name',
+            'upc',
+            'sku',
+            'item_id',
+            'default_amount',
+            'inventory_account',
+        ]
```

## django_ledger/forms/journal_entry.py

```diff
@@ -6,19 +6,19 @@
 
 class JournalEntryModelCreateForm(ModelForm):
     def __init__(self, entity_slug: str, ledger_pk: str, user_model, *args, **kwargs):
         super().__init__(*args, **kwargs)
         self.ENTITY_SLUG = entity_slug
         self.USER_MODEL = user_model
         self.LEDGER_PK = ledger_pk
+        self.fields['timestamp'].required = False
 
     class Meta:
         model = JournalEntryModel
         fields = [
-            # 'parent',
             'timestamp',
             'description'
         ]
         widgets = {
             'parent': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
@@ -38,14 +38,14 @@
             'timestamp',
             'description'
         ]
         widgets = {
             'parent': Select(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
-            'timestamp': DateInput(attrs={
+            'timestamp': DateTimeInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'description': Textarea(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             })
         }
```

## django_ledger/forms/transactions.py

```diff
@@ -45,35 +45,28 @@
 
     def __init__(self, *args, entity_slug, user_model, ledger_pk, je_model=None, **kwargs):
         super().__init__(*args, **kwargs)
         self.USER_MODEL = user_model
         self.JE_MODEL: JournalEntryModel = je_model
         self.LEDGER_PK = ledger_pk
         self.ENTITY_SLUG = entity_slug
+        self.queryset = self.JE_MODEL.transactionmodel_set.all().order_by('account__code')
 
         account_qs = AccountModel.objects.for_entity_available(
             user_model=self.USER_MODEL,
             entity_slug=self.ENTITY_SLUG
-        )
+        ).order_by('code')
 
         for form in self.forms:
             form.fields['account'].queryset = account_qs
             if self.JE_MODEL.locked:
                 form.fields['account'].disabled = True
                 form.fields['tx_type'].disabled = True
                 form.fields['amount'].disabled = True
 
-    def get_queryset(self):
-        return TransactionModel.objects.for_journal_entry(
-            entity_slug=self.ENTITY_SLUG,
-            user_model=self.USER_MODEL,
-            je_model=self.JE_MODEL.uuid,
-            ledger_model=self.LEDGER_PK
-        ).order_by('account__code')
-
     def clean(self):
         if any(self.errors):
             return
         for form in self.forms:
             if self.can_delete and self._should_delete_form(form):
                 continue
         txs_balances = [{
```

## django_ledger/forms/vendor.py

```diff
@@ -27,15 +27,17 @@
             'city',
             'state',
             'zip_code',
             'country',
             'phone',
             'email',
             'website',
-            'tax_id_number'
+            'tax_id_number',
+            'hidden',
+            'active'
         ]
         widgets = {
             'vendor_name': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
             }),
             'address_1': TextInput(attrs={
                 'class': DJANGO_LEDGER_FORM_INPUT_CLASSES
```

## django_ledger/io/data_generator.py

```diff
@@ -13,20 +13,20 @@
 from string import ascii_uppercase
 from typing import Union
 
 from django.core.exceptions import ImproperlyConfigured, ValidationError
 from django.utils.timezone import localtime, localdate
 
 from django_ledger.io.roles import (INCOME_OPERATIONAL, ASSET_CA_INVENTORY, COGS, ASSET_CA_CASH, ASSET_CA_PREPAID,
-                                    LIABILITY_CL_DEFERRED_REVENUE, EXPENSE_REGULAR, EQUITY_CAPITAL,
+                                    LIABILITY_CL_DEFERRED_REVENUE, EXPENSE_OPERATIONAL, EQUITY_CAPITAL,
                                     ASSET_CA_RECEIVABLES, LIABILITY_CL_ACC_PAYABLE)
 from django_ledger.models import (EntityModel, TransactionModel, AccountModel, VendorModel, CustomerModel,
                                   EntityUnitModel, BankAccountModel, LedgerModel, UnitOfMeasureModel, ItemModel,
                                   BillModel, ItemTransactionModel, PurchaseOrderModel, InvoiceModel,
-                                  EstimateModel, LoggingMixIn)
+                                  EstimateModel, LoggingMixIn, InvoiceModelValidationError)
 from django_ledger.utils import (generate_random_sku, generate_random_upc, generate_random_item_id)
 
 try:
     from faker import Faker
     from faker.providers import company, address, phone_number, bank
 
     FAKER_IMPORTED = True
@@ -72,15 +72,16 @@
 
         self.vendor_models = None
         self.customer_models = None
         self.bank_account_models = None
         self.entity_unit_models = None
         self.uom_models = None
         self.expense_models = None
-        self.product_and_services_models = None
+        self.product_models = None
+        self.service_models = None
         self.inventory_models = None
 
         self.account_models = None
         self.accounts_by_role = None
 
         self.COUNTRY = 'US'
         self.NB_UNITS: int = 4
@@ -119,31 +120,32 @@
         }
 
         self.create_vendors()
         self.create_customers()
         self.create_entity_units()
         self.create_bank_accounts()
         self.create_uom_models()
+
         self.create_products()
-        self.create_expenses()
+        self.create_services()
         self.create_inventories()
-        self.fund_entity()
+        self.create_expenses()
 
-        count_inventory = True
+        self.fund_entity()
 
         for i in range(self.tx_quantity):
             start_dttm = self.start_date + timedelta(days=randint(0, self.DAYS_FORWARD))
             self.create_estimate(date_draft=start_dttm)
-
-            if random() > 0.4:
-                self.create_po(date_draft=start_dttm)
-                self.recount_inventory()
-                self.update_products()
-
+            self.create_po(date_draft=start_dttm)
+            self.recount_inventory()
+            self.update_products()
             self.create_bill(date_draft=start_dttm)
+
+        for i in range(self.tx_quantity):
+            start_dttm = self.start_date + timedelta(days=randint(0, self.DAYS_FORWARD))
             self.create_invoice(date_draft=start_dttm)
 
     def get_next_date(self, prev_date: date = None) -> date:
         if not prev_date:
             prev_date = self.start_date
         next_date = prev_date + timedelta(days=randint(
             self.MIN_DAYS_FORWARD,
@@ -272,58 +274,80 @@
         self.uom_models = UnitOfMeasureModel.objects.bulk_create(uom_models)
 
     def create_products(self):
         self.logger.info(f'Creating entity product items...')
         product_count = randint(self.PRODUCTS_MIN, self.PRODUCTS_MAX)
         product_models = list()
         for i in range(product_count):
-            is_inventory = random() > 0.75
-            if is_inventory:
-                product_models.append(ItemModel.add_root(
-                    name=f'Product or Service {randint(1000, 9999)}',
-                    uom=choice(self.uom_models),
-                    item_type=choice(ItemModel.ITEM_CHOICES)[0],
-                    sku=generate_random_sku(),
-                    upc=generate_random_upc(),
-                    item_id=generate_random_item_id(),
-                    entity=self.entity_model,
-                    for_inventory=is_inventory,
-                    is_product_or_service=True,
-                    earnings_account=choice(self.accounts_by_role[INCOME_OPERATIONAL]),
-                    cogs_account=choice(self.accounts_by_role[COGS]),
-                    inventory_account=choice(self.accounts_by_role[ASSET_CA_INVENTORY]),
-                    additional_info=dict()
-                ))
-            else:
-                product_models.append(ItemModel.add_root(
-                    name=f'Product or Service {randint(1000, 9999)}',
-                    uom=choice(self.uom_models),
-                    item_type=choice(ItemModel.ITEM_CHOICES)[0],
-                    sku=generate_random_sku(),
-                    upc=generate_random_upc(),
-                    item_id=generate_random_item_id(),
-                    entity=self.entity_model,
-                    for_inventory=is_inventory,
-                    is_product_or_service=True,
-                    earnings_account=choice(self.accounts_by_role[INCOME_OPERATIONAL]),
-                    additional_info=dict()
-                ))
+            # is Product....
+            product_models.append(ItemModel(
+                name=f'Product #{randint(1000, 9999)}',
+                uom=choice(self.uom_models),
+                item_role=ItemModel.ITEM_ROLE_PRODUCT,
+                sku=generate_random_sku(),
+                upc=generate_random_upc(),
+                item_id=generate_random_item_id(),
+                entity=self.entity_model,
+                for_inventory=True,
+                is_product_or_service=True,
+                inventory_account=choice(self.accounts_by_role[ASSET_CA_INVENTORY]),
+                earnings_account=choice(self.accounts_by_role[INCOME_OPERATIONAL]),
+                cogs_account=choice(self.accounts_by_role[COGS]),
+                additional_info=dict()
+            ))
 
+        for product in product_models:
+            product.full_clean()
+
+        ItemModel.objects.bulk_create(product_models)
         self.update_products()
 
+    def create_services(self):
+        self.logger.info(f'Creating entity service items...')
+        product_count = randint(self.PRODUCTS_MIN, self.PRODUCTS_MAX)
+        service_item_models = list()
+        for i in range(product_count):
+            service_item_models.append(ItemModel(
+                name=f'Service #{randint(1000, 9999)}',
+                uom=choice(self.uom_models),
+                item_role=ItemModel.ITEM_ROLE_SERVICE,
+                sku=generate_random_sku(),
+                upc=generate_random_upc(),
+                item_id=generate_random_item_id(),
+                entity=self.entity_model,
+                for_inventory=False,
+                is_product_or_service=True,
+                earnings_account=choice(self.accounts_by_role[INCOME_OPERATIONAL]),
+                cogs_account=choice(self.accounts_by_role[COGS]),
+                additional_info=dict()
+            ))
+
+        for service in service_item_models:
+            service.full_clean()
+
+        ItemModel.objects.bulk_create(service_item_models)
+        self.update_services()
+
     def update_products(self):
         self.logger.info(f'Updating product catalog...')
-        self.product_and_services_models = ItemModel.objects.products_and_services(
+        self.product_models = ItemModel.objects.products(
+            entity_slug=self.entity_model.slug,
+            user_model=self.user_model
+        )
+
+    def update_services(self):
+        self.logger.info(f'Updating service catalog...')
+        self.service_models = ItemModel.objects.services(
             entity_slug=self.entity_model.slug,
             user_model=self.user_model
         )
 
     def update_inventory(self):
         self.logger.info(f'Updating inventory...')
-        self.inventory_models = ItemModel.objects.inventory(
+        self.inventory_models = ItemModel.objects.inventory_all(
             entity_slug=self.entity_model.slug,
             user_model=self.user_model
         )
 
     def update_expenses(self):
         self.logger.info(f'Updating expenses...')
         self.expense_models = ItemModel.objects.expenses(
@@ -331,49 +355,60 @@
             user_model=self.user_model
         )
 
     def create_expenses(self):
         self.logger.info(f'Creating entity expense items...')
         expense_count = randint(self.PRODUCTS_MIN, self.PRODUCTS_MAX)
         expense_models = [
-            ItemModel.add_root(
+            ItemModel(
                 name=f'Expense Item {randint(1000, 9999)}',
                 uom=choice(self.uom_models),
-                item_type=choice(ItemModel.ITEM_CHOICES)[0],
+                item_type=choice(ItemModel.ITEM_TYPE_CHOICES)[0],
+                item_role=ItemModel.ITEM_ROLE_EXPENSE,
                 sku=generate_random_sku(),
                 upc=generate_random_upc(),
                 item_id=generate_random_item_id(),
                 entity=self.entity_model,
                 is_product_or_service=False,
                 for_inventory=False,
-                expense_account=choice(self.accounts_by_role[EXPENSE_REGULAR]),
+                expense_account=choice(self.accounts_by_role[EXPENSE_OPERATIONAL]),
             ) for _ in range(expense_count)
         ]
 
+        for exp in expense_models:
+            exp.full_clean()
+
+        ItemModel.objects.bulk_create(expense_models)
         self.update_expenses()
 
     def create_inventories(self):
         self.logger.info(f'Creating entity inventory items...')
         inv_count = randint(self.PRODUCTS_MIN, self.PRODUCTS_MAX)
         inventory_models = [
-            ItemModel.add_root(
+            ItemModel(
                 name=f'Inventory {randint(1000, 9999)}',
                 uom=choice(self.uom_models),
-                item_type=choice(ItemModel.ITEM_CHOICES)[0],
+                item_role=ItemModel.ITEM_ROLE_INVENTORY,
+                item_type=choice(ItemModel.ITEM_TYPE_CHOICES)[0],
                 item_id=generate_random_item_id(),
                 entity=self.entity_model,
                 for_inventory=True,
                 is_product_or_service=True if random() > 0.6 else False,
+                sku=generate_random_sku(),
+                upc=generate_random_upc(),
                 earnings_account=choice(self.accounts_by_role[INCOME_OPERATIONAL]),
                 cogs_account=choice(self.accounts_by_role[COGS]),
                 inventory_account=choice(self.accounts_by_role[ASSET_CA_INVENTORY]),
             ) for _ in range(inv_count)
         ]
 
-        self.update_inventory()
+        for inv in inventory_models:
+            inv.full_clean()
+
+        self.inventory_models = ItemModel.objects.bulk_create(inventory_models)
 
     def create_estimate(self, date_draft: date):
         estimate_model: EstimateModel = EstimateModel(
             terms=choice(EstimateModel.CONTRACT_TERMS)[0],
             title=f'Customer Estimate {date_draft}',
             date_draft=date_draft
         )
@@ -383,15 +418,15 @@
 
         estimate_model.save()
         self.logger.info(f'Creating entity estimate {estimate_model.estimate_number}...')
 
         estimate_items = [
             ItemTransactionModel(
                 ce_model=estimate_model,
-                item_model=choice(self.product_and_services_models),
+                item_model=choice(self.product_models),
                 ce_quantity=round(random() * randint(5, 15), 2),
                 ce_unit_cost_estimate=round(random() * randint(50, 100), 2),
                 ce_unit_revenue_estimate=round(random() * randint(80, 120) * (1 + 0.2 * random()), 2),
                 entity_unit=choice(self.entity_unit_models) if random() > .75 else None
             ) for _ in range(randint(1, 10))
         ]
 
@@ -419,28 +454,28 @@
             elif random() > 0.8:
                 date_canceled = self.get_next_date(date_in_review)
                 estimate_model.mark_as_canceled(commit=True, date_canceled=date_canceled)
 
     def create_bill(self, date_draft):
         bill_model: BillModel = BillModel(
             vendor=choice(self.vendor_models),
-            accrue=random() > 0.65,
             progress=Decimal(str(round(random(), 2))),
-            terms=choice(BillModel.TERMS)[0],
+            terms=choice(BillModel.TERM_CHOICES)[0],
             amount_due=0,
             cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
             prepaid_account=choice(self.accounts_by_role[ASSET_CA_PREPAID]),
             unearned_account=choice(self.accounts_by_role[LIABILITY_CL_ACC_PAYABLE]),
             date_draft=date_draft,
             additional_info=dict()
         )
 
         ledger_model, bill_model = bill_model.configure(
             entity_slug=self.entity_model,
-            user_model=self.user_model)
+            user_model=self.user_model,
+            commit_ledger=True)
 
         bill_model.full_clean()
         bill_model.save()
         self.logger.info(f'Creating entity bill {bill_model.bill_number}...')
 
         bill_items = [
             ItemTransactionModel(
@@ -456,15 +491,15 @@
             bi.full_clean()
 
         bill_model.update_amount_due(itemtxs_qs=bill_items)
         bill_model.itemtransactionmodel_set.bulk_create(bill_items)
         bill_model.full_clean()
         bill_model.save()
 
-        if random() > 0.25:
+        if random() > 0.25 and bill_model.amount_due:
             date_in_review = self.get_next_date(date_draft)
             bill_model.mark_as_review(commit=True, date_in_review=date_in_review)
 
             if random() > 0.50:
                 date_approved = self.get_next_date(date_in_review)
                 bill_model.mark_as_approved(commit=True,
                                             entity_slug=self.entity_model.slug,
@@ -496,36 +531,34 @@
         po_model = po_model.configure(entity_slug=self.entity_model, user_model=self.user_model)
         po_model.po_title = f'PO Title for {po_model.po_number}'
         po_model.save()
 
         po_items = [
             ItemTransactionModel(
                 po_model=po_model,
-                item_model=choice(self.inventory_models),
-                po_quantity=round(random() * randint(3, 10), 2),
+                item_model=choice(self.product_models),
+                po_quantity=round(random() * randint(3, 10) + 3, 2),
                 po_unit_cost=round(random() * randint(100, 800), 2),
                 entity_unit=choice(self.entity_unit_models) if random() > .75 else None
             ) for _ in range(randint(1, 10))
         ]
 
         for poi in po_items:
             poi.full_clean()
 
-        po_model.update_state(itemtxs_list=po_items)
-        po_model.full_clean()
-        po_model.save()
         self.logger.info(f'Creating entity purchase order {po_model.po_number}...')
-
-        # pylint: disable=no-member
         po_items = po_model.itemtransactionmodel_set.bulk_create(po_items)
+        po_model.update_state(itemtxs_qs=po_items)
+        po_model.full_clean()
+        po_model.save()
 
         # mark as approved...
-        if random() > 0.25:
+        if random() > 0.25 and po_model.po_amount:
             date_review = self.get_next_date(date_draft)
-            po_model.mark_as_review(commit=True, date_review=date_review)
+            po_model.mark_as_review(commit=True, date_in_review=date_review)
             if random() > 0.5:
                 date_approved = self.get_next_date(date_review)
                 po_model.mark_as_approved(commit=True, date_approved=date_approved)
                 if random() > 0.25:
                     # add a PO bill...
                     date_fulfilled = self.get_next_date(date_approved)
                     date_bill_draft = date_fulfilled - timedelta(days=randint(1, 3))
@@ -536,15 +569,16 @@
 
                     bill_model.cash_account = choice(self.accounts_by_role[ASSET_CA_CASH])
                     bill_model.prepaid_account = choice(self.accounts_by_role[ASSET_CA_PREPAID])
                     bill_model.unearned_account = choice(self.accounts_by_role[LIABILITY_CL_ACC_PAYABLE])
 
                     ledger_model, bill_model = bill_model.configure(
                         entity_slug=self.entity_model.slug,
-                        user_model=self.user_model
+                        user_model=self.user_model,
+                        commit_ledger=True
                     )
 
                     bill_model.terms = choice([
                         BillModel.TERMS_ON_RECEIPT,
                         BillModel.TERMS_NET_30,
                         BillModel.TERMS_NET_60,
                         BillModel.TERMS_NET_90
@@ -596,62 +630,65 @@
                                     entity_slug=self.entity_model.slug,
                                     commit=True,
                                     date_paid=bill_paid_date)
 
                                 if random() > 0.20:
                                     for po_i in po_items:
                                         po_i.po_item_status = ItemTransactionModel.STATUS_RECEIVED
+                                        po_i.po_item_status = ItemTransactionModel.STATUS_RECEIVED
                                         po_i.full_clean()
 
                                     # todo: can pass po items??..
                                     po_model.itemtransactionmodel_set.bulk_update(po_items,
                                                                                   fields=[
                                                                                       'po_item_status',
                                                                                       'updated'
                                                                                   ])
                                     po_model.mark_as_fulfilled(
                                         date_fulfilled=date_fulfilled,
                                         commit=True)
+
                                     self.entity_model.update_inventory(
                                         user_model=self.user_model,
                                         commit=True)
+
                                     self.update_products()
                                     self.update_inventory()
 
     def create_invoice(self, date_draft: date):
         invoice_model = InvoiceModel(
             customer=choice(self.customer_models),
-            accrue=random() > 0.75,
             progress=Decimal(str(round(random(), 2))),
-            terms=choice(InvoiceModel.TERMS)[0],
+            terms=choice(InvoiceModel.TERM_CHOICES)[0],
             cash_account=choice(self.accounts_by_role[ASSET_CA_CASH]),
             prepaid_account=choice(self.accounts_by_role[ASSET_CA_RECEIVABLES]),
             unearned_account=choice(self.accounts_by_role[LIABILITY_CL_DEFERRED_REVENUE]),
             date_draft=date_draft,
             additional_info=dict()
         )
         self.logger.info(f'Creating entity invoice {invoice_model.invoice_number}...')
         ledger_model, invoice_model = invoice_model.configure(
             entity_slug=self.entity_model,
-            user_model=self.user_model)
+            user_model=self.user_model,
+            commit_ledger=True
+        )
 
         invoice_model.full_clean()
         invoice_model.save()
 
         invoice_items = list()
 
         for i in range(randint(1, 10)):
-            item_model: ItemModel = choice(self.product_and_services_models)
-            quantity = Decimal.from_float(round(random() * randint(1, 5), 2))
+            item_model: ItemModel = choice(self.product_models)
+            quantity = Decimal.from_float(round(random() * randint(1, 2), 2))
             entity_unit = choice(self.entity_unit_models) if random() > .75 else None
             margin = Decimal(random() + 1.5)
             avg_cost = item_model.get_average_cost()
             unit_cost = round(random() * randint(100, 999), 2)
-
-            if item_model.for_inventory and item_model.is_product_or_service:
+            if item_model.is_product():
                 if item_model.inventory_received is not None and item_model.inventory_received > 0.0:
                     if quantity > item_model.inventory_received:
                         quantity = item_model.inventory_received
 
                     # reducing inventory qty...
                     item_model.inventory_received -= quantity
                     item_model.inventory_received_value -= avg_cost * quantity
@@ -671,17 +708,23 @@
             invoice_items.append(itm)
 
         invoice_items = invoice_model.itemtransactionmodel_set.bulk_create(invoice_items)
         invoice_model.update_amount_due(itemtxs_qs=invoice_items)
         invoice_model.full_clean()
         invoice_model.save()
 
-        if random() > 0.25:
+        if random() > 0.25 and invoice_model.amount_due:
             date_review = self.get_next_date(date_draft)
-            invoice_model.mark_as_review(commit=True, date_in_review=date_review)
+
+            try:
+                invoice_model.mark_as_review(commit=True, date_in_review=date_review)
+            except InvoiceModelValidationError as e:
+                # invoice cannot be marked as in review...
+                return
+
             if random() > 0.50:
                 date_approved = self.get_next_date(date_review)
                 invoice_model.mark_as_approved(entity_slug=self.entity_model.slug,
                                                user_model=self.user_model,
                                                commit=True,
                                                date_approved=date_approved)
                 if random() > 0.25:
```

## django_ledger/io/io_context.py

```diff
@@ -1,16 +1,19 @@
 from collections import defaultdict
+from itertools import groupby, chain
+
+from django.core.exceptions import ValidationError
 
 from django_ledger.io import roles as roles_module
-from django_ledger.models.utils import LazyLoader
+from django_ledger.models.utils import LazyLoader, lazy_loader
 
 lazy_importer = LazyLoader()
 
 
-class RoleManager:
+class RoleContextManager:
 
     def __init__(self,
                  tx_digest: dict,
                  by_period: bool = False,
                  by_unit: bool = False):
 
         self.BY_PERIOD = by_period
@@ -20,14 +23,15 @@
         self.DIGEST['role_account'] = None
         self.DIGEST['role_balance'] = None
 
         self.ACCOUNTS = tx_digest['accounts']
 
         self.ROLES_ACCOUNTS = dict()
         self.ROLES_BALANCES = dict()
+        self.ROLES_BALANCE_SHEET = dict()
 
         if self.BY_PERIOD:
             self.ROLES_BALANCES_BY_PERIOD = defaultdict(lambda: dict())
             self.DIGEST['role_balance_by_period'] = None
         if self.BY_UNIT:
             self.ROLES_BALANCES_BY_UNIT = defaultdict(lambda: dict())
             self.DIGEST['role_balance_by_unit'] = None
@@ -67,15 +71,15 @@
                             ))
                         if self.BY_UNIT:
                             key = (acc['unit_uuid'], acc['unit_name'])
                             self.ROLES_BALANCES_BY_UNIT[key][r] = sum(
                                 acc['balance'] for acc in acc_list if acc['unit_uuid'] == key[0])
 
 
-class GroupManager:
+class GroupContextManager:
     GROUP_ACCOUNTS_KEY = 'group_account'
     GROUP_BALANCE_KEY = 'group_balance'
     GROUP_BALANCE_BY_UNIT_KEY = 'group_balance_by_unit'
     GROUP_BALANCE_BY_PERIOD_KEY = 'group_balance_by_period'
 
     def __init__(self,
                  io_digest: dict,
@@ -140,15 +144,15 @@
                     if self.BY_UNIT:
                         key = (acc['unit_uuid'], acc['unit_name'])
                         self.GROUPS_BALANCES_BY_UNIT[key][g] = sum(
                             acc['balance'] for acc in acc_list if acc['unit_uuid'] == key[0]
                         )
 
 
-class ActivityManager:
+class ActivityContextManager:
 
     def __init__(self,
                  tx_digest: dict,
                  by_unit: bool = False,
                  by_period: bool = False):
 
         self.DIGEST = tx_digest
@@ -200,7 +204,238 @@
                             acc['period_year'] == key[0],
                             acc['period_month'] == key[1]]
                         ))
                     if self.BY_UNIT:
                         key = (acc['unit_uuid'], acc['unit_name'])
                         self.ACTIVITY_BALANCES_BY_UNIT[key][act] = sum(
                             acc['balance'] for acc in acc_list if acc['unit_uuid'] == key[0])
+
+
+class BalanceSheetStatementContextManager:
+    def __init__(self, tx_digest: dict):
+        self.DIGEST = tx_digest
+
+    def digest(self):
+        if 'group_account' in self.DIGEST:
+            gb_bs = {
+                bsr: list(l) for bsr, l in groupby(
+                    chain.from_iterable(
+                        [
+                            self.DIGEST['group_account']['GROUP_ASSETS'],
+                            self.DIGEST['group_account']['GROUP_LIABILITIES'],
+                            self.DIGEST['group_account']['GROUP_CAPITAL'],
+                        ]
+                    ),
+                    key=lambda acc: acc['role_bs'])
+            }
+            self.DIGEST['balance_sheet'] = {
+                bs_role: {
+                    'total_balance': sum(a['balance'] for a in gb),
+                    'roles': {
+                        r: {
+                            'accounts': list(a)
+                        } for r, a in groupby(list(gb), key=lambda acc: acc['role'])
+                    }
+                } for bs_role, gb in gb_bs.items()
+            }
+            for bs_role, bs_role_data in self.DIGEST['balance_sheet'].items():
+                for acc_role, role_data in bs_role_data['roles'].items():
+                    role_data['total_balance'] = sum(a['balance'] for a in role_data['accounts'])
+                    role_data['role_name'] = roles_module.ACCOUNT_LIST_ROLE_VERBOSE[acc_role]
+        return self.DIGEST
+
+
+class IncomeStatementContextManager:
+
+    def __init__(self, tx_digest: dict):
+        self.DIGEST = tx_digest
+
+    def digest(self):
+        if 'group_account' in self.DIGEST:
+            self.DIGEST['income_statement'] = {
+                'operating': {
+                    'revenues': [
+                        acc for acc in self.DIGEST['group_account']['GROUP_INCOME'] if
+                        acc['role'] in roles_module.GROUP_IC_OPERATING_REVENUES
+                    ],
+                    'cogs': [
+                        acc for acc in self.DIGEST['group_account']['GROUP_COGS'] if
+                        acc['role'] in roles_module.GROUP_IC_OPERATING_COGS
+                    ],
+                    'expenses': [
+                        acc for acc in self.DIGEST['group_account']['GROUP_EXPENSES'] if
+                        acc['role'] in roles_module.GROUP_IC_OPERATING_EXPENSES
+                    ]
+                },
+                'other': {
+                    'revenues': [acc for acc in self.DIGEST['group_account']['GROUP_INCOME'] if
+                                 acc['role'] in roles_module.GROUP_IC_OTHER_REVENUES],
+                    'expenses': [acc for acc in self.DIGEST['group_account']['GROUP_INCOME'] if
+                                 acc['role'] in roles_module.GROUP_IC_OTHER_EXPENSES],
+                }
+            }
+
+            # OPERATING INCOME...
+            self.DIGEST['income_statement']['operating']['gross_profit'] = sum(
+                acc['balance'] for acc in chain.from_iterable(
+                    [
+                        self.DIGEST['income_statement']['operating']['revenues'],
+                        self.DIGEST['income_statement']['operating']['cogs']
+                    ]
+                ))
+            self.DIGEST['income_statement']['operating']['net_operating_income'] = sum(
+                acc['balance'] for acc in chain.from_iterable(
+                    [
+                        self.DIGEST['income_statement']['operating']['revenues'],
+                        self.DIGEST['income_statement']['operating']['cogs'],
+                        self.DIGEST['income_statement']['operating']['expenses'],
+                    ]
+                ))
+            self.DIGEST['income_statement']['operating']['net_operating_revenue'] = sum(
+                acc['balance'] for acc in self.DIGEST['income_statement']['operating']['revenues']
+            )
+            self.DIGEST['income_statement']['operating']['net_cogs'] = sum(
+                acc['balance'] for acc in self.DIGEST['income_statement']['operating']['cogs']
+            )
+            self.DIGEST['income_statement']['operating']['net_operating_expenses'] = sum(
+                acc['balance'] for acc in self.DIGEST['income_statement']['operating']['expenses']
+            )
+
+
+            # OTHER INCOME....
+            self.DIGEST['income_statement']['other']['net_other_revenues'] = sum(
+                acc['balance'] for acc in self.DIGEST['income_statement']['other']['revenues']
+            )
+            self.DIGEST['income_statement']['other']['net_other_expenses'] = sum(
+                acc['balance'] for acc in self.DIGEST['income_statement']['other']['expenses']
+            )
+            self.DIGEST['income_statement']['other']['net_other_income'] = sum(
+                acc['balance'] for acc in chain.from_iterable(
+                    [
+                        self.DIGEST['income_statement']['other']['revenues'],
+                        self.DIGEST['income_statement']['other']['expenses']
+                    ]
+                ))
+
+            # NET INCOME...
+            self.DIGEST['income_statement']['net_income'] = self.DIGEST['income_statement']['operating'][
+                'net_operating_income']
+            self.DIGEST['income_statement']['net_income'] += self.DIGEST['income_statement']['other'][
+                'net_other_income']
+        return self.DIGEST
+
+
+class CashFlowStatementContextManager:
+    CFS_DIGEST_KEY = 'cash_flow_statement'
+
+    def __init__(self,
+                 io_digest: dict,
+                 by_period: bool = False,
+                 by_unit: bool = False):
+        self.IO_DIGEST = io_digest
+        self.CASH_ACCOUNTS = [a for a in self.IO_DIGEST['accounts'] if a['role'] == roles_module.ASSET_CA_CASH]
+        self.JE_MODEL = lazy_loader.get_journal_entry_model()
+
+    def check_io_digest(self):
+        if GroupContextManager.GROUP_BALANCE_KEY not in self.IO_DIGEST:
+            raise ValidationError(
+                'IO Digest must have groups for Cash Flow Statement'
+            )
+
+    def operating(self):
+        group_balances = self.IO_DIGEST[GroupContextManager.GROUP_BALANCE_KEY]
+        operating_activities = dict()
+        operating_activities['GROUP_CFS_NET_INCOME'] = {
+            'description': 'Net Income',
+            'balance': group_balances['GROUP_CFS_NET_INCOME']
+        }
+        operating_activities['GROUP_CFS_OP_DEPRECIATION_AMORTIZATION'] = {
+            'description': 'Depreciation & Amortization of Assets',
+            'balance': -group_balances['GROUP_CFS_OP_DEPRECIATION_AMORTIZATION']
+        }
+        operating_activities['GROUP_CFS_OP_INVESTMENT_GAINS'] = {
+            'description': 'Gain/Loss Sale of Assets',
+            'balance': group_balances['GROUP_CFS_OP_INVESTMENT_GAINS']
+        }
+        operating_activities['GROUP_CFS_OP_ACCOUNTS_RECEIVABLE'] = {
+            'description': 'Accounts Receivable',
+            'balance': -group_balances['GROUP_CFS_OP_ACCOUNTS_RECEIVABLE']
+        }
+        operating_activities['GROUP_CFS_OP_INVENTORY'] = {
+            'description': 'Inventories',
+            'balance': -group_balances['GROUP_CFS_OP_INVENTORY']
+        }
+
+        operating_activities['GROUP_CFS_OP_ACCOUNTS_PAYABLE'] = {
+            'description': 'Accounts Payable',
+            'balance': group_balances['GROUP_CFS_OP_ACCOUNTS_PAYABLE']
+        }
+        operating_activities['GROUP_CFS_OP_OTHER_CURRENT_ASSETS_ADJUSTMENT'] = {
+            'description': 'Other Current Assets',
+            'balance': -group_balances['GROUP_CFS_OP_OTHER_CURRENT_ASSETS_ADJUSTMENT']
+        }
+        operating_activities['GROUP_CFS_OP_OTHER_CURRENT_LIABILITIES_ADJUSTMENT'] = {
+            'description': 'Other Current Liabilities',
+            'balance': group_balances['GROUP_CFS_OP_OTHER_CURRENT_LIABILITIES_ADJUSTMENT']
+        }
+
+        net_cash_by_op_activities = sum(i['balance'] for g, i in operating_activities.items())
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['operating'] = operating_activities
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['net_cash_by_activity'] = dict(
+            OPERATING=net_cash_by_op_activities
+        )
+
+    def financing(self):
+        group_balances = self.IO_DIGEST[GroupContextManager.GROUP_BALANCE_KEY]
+        financing_activities = dict()
+        financing_activities['GROUP_CFS_FIN_ISSUING_EQUITY'] = {
+            'description': 'Common Stock, Preferred Stock and Capital Raised',
+            'balance': sum(a['balance'] for a in self.CASH_ACCOUNTS if a['activity'] == self.JE_MODEL.FINANCING_EQUITY)
+        }
+        financing_activities['GROUP_CFS_FIN_DIVIDENDS'] = {
+            'description': 'Dividends Payed Out to Shareholders',
+            'balance': sum(
+                a['balance'] for a in self.CASH_ACCOUNTS if a['activity'] == self.JE_MODEL.FINANCING_DIVIDENDS)
+        }
+        financing_activities['GROUP_CFS_FIN_ST_DEBT_PAYMENTS'] = {
+            'description': 'Increase/Reduction of Short-Term Debt Principal',
+            'balance': sum(a['balance'] for a in self.CASH_ACCOUNTS if a['activity'] == self.JE_MODEL.FINANCING_STD)
+        }
+        financing_activities['GROUP_CFS_FIN_LT_DEBT_PAYMENTS'] = {
+            'description': 'Increase/Reduction of Long-Term Debt Principal',
+            'balance': sum(a['balance'] for a in self.CASH_ACCOUNTS if a['activity'] == self.JE_MODEL.FINANCING_LTD)
+        }
+
+        net_cash = sum(i['balance'] for g, i in financing_activities.items())
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['financing'] = financing_activities
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['net_cash_by_activity']['FINANCING'] = net_cash
+
+    def investing(self):
+        group_balances = self.IO_DIGEST[GroupContextManager.GROUP_BALANCE_KEY]
+        investing_activities = dict()
+        investing_activities['GROUP_CFS_INVESTING_SECURITIES'] = {
+            'description': 'Purchase, Maturity and Sales of Investments & Securities',
+            'balance': sum(
+                a['balance'] for a in self.CASH_ACCOUNTS if a['activity'] == self.JE_MODEL.INVESTING_SECURITIES)
+        }
+        investing_activities['GROUP_CFS_INVESTING_PPE'] = {
+            'description': 'Addition and Disposition of Property, Plant & Equipment',
+            'balance': sum(
+                a['balance'] for a in self.CASH_ACCOUNTS if a['activity'] == self.JE_MODEL.INVESTING_PPE)
+        }
+
+        net_cash = sum(i['balance'] for g, i in investing_activities.items())
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['investing'] = investing_activities
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['net_cash_by_activity']['INVESTING'] = net_cash
+
+    def net_cash(self):
+        self.IO_DIGEST[self.CFS_DIGEST_KEY]['net_cash'] = sum([
+            bal for act, bal in self.IO_DIGEST[self.CFS_DIGEST_KEY]['net_cash_by_activity'].items()
+        ])
+
+    def digest(self):
+        self.check_io_digest()
+        self.operating()
+        self.financing()
+        self.investing()
+        self.net_cash()
+        return self.IO_DIGEST
```

## django_ledger/io/io_mixin.py

```diff
@@ -17,29 +17,28 @@
 from django.db.models.functions import TruncMonth
 from django.http import Http404
 from django.utils.dateparse import parse_date, parse_datetime
 from django.utils.timezone import localdate, make_aware, is_naive
 
 from django_ledger.exceptions import InvalidDateInputError, TransactionNotInBalanceError
 from django_ledger.io import roles as roles_module
-from django_ledger.io.financial_statements import CashFlowStatement
-from django_ledger.io.io_context import RoleManager, GroupManager, ActivityManager
+from django_ledger.io.io_context import (RoleContextManager, GroupContextManager, ActivityContextManager,
+                                         BalanceSheetStatementContextManager, IncomeStatementContextManager,
+                                         CashFlowStatementContextManager)
 from django_ledger.io.ratios import FinancialRatioManager
-from django_ledger.models.utils import LazyLoader
+from django_ledger.models.utils import lazy_loader
 from django_ledger.settings import (DJANGO_LEDGER_TRANSACTION_MAX_TOLERANCE,
                                     DJANGO_LEDGER_TRANSACTION_CORRECTION)
 
 UserModel = get_user_model()
 
-lazy_importer = LazyLoader()
-
 
 def diff_tx_data(tx_data: list, raise_exception: bool = True):
     IS_TX_MODEL = False
-    TransactionModel = lazy_importer.get_txs_model()
+    TransactionModel = lazy_loader.get_txs_model()
 
     if isinstance(tx_data[0], TransactionModel):
         CREDITS = sum(tx.amount for tx in tx_data if tx.tx_type == 'credit')
         DEBITS = sum(tx.amount for tx in tx_data if tx.tx_type == 'debit')
         IS_TX_MODEL = True
     elif isinstance(tx_data[0], dict):
         CREDITS = sum(tx['amount'] for tx in tx_data if tx['tx_type'] == 'credit')
@@ -131,15 +130,15 @@
     from_date = validate_io_date(from_date, no_parse_localdate=False)
     to_date = validate_io_date(to_date)
     return from_date, to_date
 
 
 def validate_activity(activity: str, raise_404: bool = False):
     # idea: move to model???...
-    JournalEntryModel = lazy_importer.get_journal_entry_model()
+    JournalEntryModel = lazy_loader.get_journal_entry_model()
     valid = activity in JournalEntryModel.VALID_ACTIVITIES
     if activity and not valid:
         exception = ValidationError(f'{activity} is invalid. Choices are {JournalEntryModel.VALID_ACTIVITIES}.')
         if raise_404:
             raise Http404(exception)
         raise exception
     return activity
@@ -152,91 +151,89 @@
 class IOMixIn:
     """
     Controls how transactions are recorded into the ledger.
     """
 
     def database_digest(self,
                         user_model: UserModel,
-                        queryset: QuerySet,
+                        txs_queryset: QuerySet,
                         from_date: date = None,
                         to_date: date = None,
                         activity: str = None,
                         role: str = None,
                         entity_slug: str = None,
                         unit_slug: str = None,
                         accounts: str or List[str] or Set[str] = None,
                         posted: bool = True,
                         exclude_zero_bal: bool = True,
                         by_activity: bool = False,
                         by_tx_type: bool = False,
                         by_period: bool = False,
                         by_unit: bool = False):
 
-        if not queryset:
-            TransactionModel = lazy_importer.get_txs_model()
+        if not txs_queryset:
+            TransactionModel = lazy_loader.get_txs_model()
 
             # If IO is on entity model....
-            if isinstance(self, lazy_importer.get_entity_model()):
+            if isinstance(self, lazy_loader.get_entity_model()):
                 if unit_slug:
-                    txs_qs = TransactionModel.objects.for_unit(
+                    txs_queryset = TransactionModel.objects.for_unit(
                         user_model=user_model,
                         entity_slug=entity_slug or self.slug,
                         unit_slug=unit_slug
                     )
                 else:
-                    txs_qs = TransactionModel.objects.for_entity(
+                    txs_queryset = TransactionModel.objects.for_entity(
                         user_model=user_model,
                         entity_slug=self
                     )
 
             # If IO is on ledger model....
-            elif isinstance(self, lazy_importer.get_ledger_model()):
-                txs_qs = TransactionModel.objects.for_ledger(
+            elif isinstance(self, lazy_loader.get_ledger_model()):
+                txs_queryset = TransactionModel.objects.for_ledger(
                     user_model=user_model,
                     entity_slug=entity_slug,
                     ledger_model=self
                 )
             # If IO is on unit model....
-            elif isinstance(self, lazy_importer.get_unit_model()):
+            elif isinstance(self, lazy_loader.get_unit_model()):
                 if not entity_slug:
                     raise ValidationError('Calling digest from Entity Unit requires entity_slug')
-                txs_qs = TransactionModel.objects.for_unit(
+                txs_queryset = TransactionModel.objects.for_unit(
                     user_model=user_model,
                     entity_slug=entity_slug,
-                    unit_model=self
+                    unit_slug=self
                 )
             else:
-                txs_qs = TransactionModel.objects.none()
-        else:
-            txs_qs = queryset
+                txs_queryset = TransactionModel.objects.none()
 
         if exclude_zero_bal:
-            txs_qs = txs_qs.filter(amount__gt=0)
+            txs_queryset = txs_queryset.filter(amount__gt=0)
 
         if posted:
-            txs_qs = txs_qs.posted()
+            txs_queryset = txs_queryset.posted()
 
         if from_date:
-            txs_qs = txs_qs.from_date(from_date=from_date)
+            txs_queryset = txs_queryset.from_date(from_date=from_date)
 
         if to_date:
-            txs_qs = txs_qs.to_date(to_date=to_date)
+            txs_queryset = txs_queryset.to_date(to_date=to_date)
 
         if accounts:
             if not isinstance(accounts, str):
                 accounts = [accounts]
-            txs_qs = txs_qs.for_accounts(account_list=accounts)
+            txs_queryset = txs_queryset.for_accounts(account_list=accounts)
 
         if activity:
             if isinstance(activity, str):
                 activity = [activity]
-            txs_qs = txs_qs.for_activity(activity_list=activity)
+            txs_queryset = txs_queryset.for_activity(activity_list=activity)
 
         if role:
-            txs_qs = txs_qs.for_roles(role_list=role)
+            txs_queryset = txs_queryset.for_roles(role_list=role)
 
         VALUES = [
             'account__uuid',
             'account__balance_type',
             'tx_type',
             'account__code',
             'account__name',
@@ -257,19 +254,19 @@
             VALUES.append('journal_entry__activity')
             ORDER_BY.append('journal_entry__activity')
 
         if by_tx_type:
             VALUES.append('tx_type')
             ORDER_BY.append('tx_type')
 
-        return txs_qs.values(*VALUES).annotate(**ANNOTATE).order_by(*ORDER_BY)
+        return txs_queryset.values(*VALUES).annotate(**ANNOTATE).order_by(*ORDER_BY)
 
     def python_digest(self,
                       user_model: UserModel,
-                      queryset: QuerySet,
+                      txs_queryset: QuerySet,
                       to_date: date = None,
                       from_date: date = None,
                       equity_only: bool = False,
                       activity: str = None,
                       entity_slug: str = None,
                       unit_slug: str = None,
                       role: Optional[Union[Set[str], List[str]]] = None,
@@ -279,62 +276,65 @@
                       by_activity: bool = False,
                       by_tx_type: bool = False,
                       by_period: bool = False) -> list or tuple:
 
         if equity_only:
             role = roles_module.GROUP_EARNINGS
 
-        txs_qs = self.database_digest(
+        txs_queryset = self.database_digest(
             user_model=user_model,
-            queryset=queryset,
+            txs_queryset=txs_queryset,
             to_date=to_date,
             from_date=from_date,
             entity_slug=entity_slug,
             unit_slug=unit_slug,
             activity=activity,
             role=role,
             accounts=accounts,
             by_unit=by_unit,
             by_activity=by_activity,
             by_tx_type=by_tx_type,
             by_period=by_period)
 
-        for tx in txs_qs:
-            if tx['account__balance_type'] != tx['tx_type']:
-                tx['balance'] = -tx['balance']
+        for tx_model in txs_queryset:
+            if tx_model['account__balance_type'] != tx_model['tx_type']:
+                tx_model['balance'] = -tx_model['balance']
 
-        accounts_gb_code = groupby(txs_qs,
+        accounts_gb_code = groupby(txs_queryset,
                                    key=lambda a: (
                                        a['account__uuid'],
                                        a.get('journal_entry__entity_unit__uuid') if by_unit else None,
                                        a.get('dt_idx').year if by_period else None,
                                        a.get('dt_idx').month if by_period else None,
                                        a.get('journal_entry__activity') if by_activity else None,
                                        a.get('tx_type') if by_tx_type else None,
                                    ))
 
         gb_digest = [
             self.aggregate_balances(k, g) for k, g in accounts_gb_code
         ]
 
+        for acc in gb_digest:
+            acc['balance_abs'] = abs(acc['balance'])
+
         if signs:
-            TransactionModel = lazy_importer.get_txs_model()
+            TransactionModel = lazy_loader.get_txs_model()
             for acc in gb_digest:
                 if any([
                     all([acc['role_bs'] == roles_module.BS_ASSET_ROLE,
                          acc['balance_type'] == TransactionModel.CREDIT]),
                     all([acc['role_bs'] in (
                             roles_module.BS_LIABILITIES_ROLE,
                             roles_module.BS_EQUITY_ROLE
                     ),
                          acc['balance_type'] == TransactionModel.DEBIT])
                 ]):
                     acc['balance'] = -acc['balance']
 
-        return txs_qs, gb_digest
+        return txs_queryset, gb_digest
 
     @staticmethod
     def aggregate_balances(k, g):
         gl = list(g)
         return {
             'account_uuid': k[0],
             'unit_uuid': k[1],
@@ -358,35 +358,39 @@
                role: Optional[Union[Set[str], List[str]]] = None,
                activity: str = None,
                entity_slug: str = None,
                unit_slug: str = None,
                signs: bool = True,
                to_date: Union[str, datetime, date] = None,
                from_date: Union[str, datetime, date] = None,
-               queryset: QuerySet = None,
+               txs_queryset: QuerySet = None,
                process_roles: bool = False,
                process_groups: bool = False,
                process_ratios: bool = False,
                process_activity: bool = False,
                equity_only: bool = False,
                by_period: bool = False,
                by_unit: bool = False,
                by_activity: bool = False,
                by_tx_type: bool = False,
+               digest_name: str = None,
+               balance_sheet_statement: bool = False,
+               income_statement: bool = False,
                cash_flow_statement: bool = False,
-               digest_name: str = None
                ) -> dict or tuple:
 
-        activity = validate_activity(activity)
+        if activity:
+            activity = validate_activity(activity)
         if role:
             role = roles_module.validate_roles(role)
+
         from_date, to_date = validate_dates(from_date, to_date)
 
         txs_qs, accounts_digest = self.python_digest(
-            queryset=queryset,
+            txs_queryset=txs_queryset,
             user_model=user_model,
             accounts=accounts,
             role=role,
             activity=activity,
             entity_slug=entity_slug,
             unit_slug=unit_slug,
             to_date=to_date,
@@ -401,48 +405,66 @@
 
         io_digest = defaultdict(lambda: dict())
         io_digest['accounts'] = accounts_digest
         io_digest['from_date'] = from_date
         io_digest['to_date'] = to_date
 
         if process_roles:
-            roles_mgr = RoleManager(
+            roles_mgr = RoleContextManager(
                 tx_digest=io_digest,
                 by_period=by_period,
                 by_unit=by_unit
             )
 
             # idea: change digest() name to something else? maybe aggregate, calculate?...
             io_digest = roles_mgr.digest()
 
-        if process_groups:
-            group_mgr = GroupManager(
+        if process_groups or balance_sheet_statement or income_statement or cash_flow_statement:
+            group_mgr = GroupContextManager(
                 io_digest=io_digest,
                 by_period=by_period,
                 by_unit=by_unit
             )
             io_digest = group_mgr.digest()
 
+            # todo: migrate this to group manager...
+            io_digest['group_account']['GROUP_ASSETS'].sort(
+                key=lambda acc: roles_module.ROLES_ORDER_ASSETS.index(acc['role']))
+            io_digest['group_account']['GROUP_LIABILITIES'].sort(
+                key=lambda acc: roles_module.ROLES_ORDER_LIABILITIES.index(acc['role']))
+            io_digest['group_account']['GROUP_CAPITAL'].sort(
+                key=lambda acc: roles_module.ROLES_ORDER_CAPITAL.index(acc['role']))
+
         if process_ratios:
             ratio_gen = FinancialRatioManager(tx_digest=io_digest)
             io_digest = ratio_gen.digest()
 
         if process_activity:
-            activity_manager = ActivityManager(tx_digest=io_digest, by_unit=by_unit, by_period=by_period)
+            activity_manager = ActivityContextManager(tx_digest=io_digest, by_unit=by_unit, by_period=by_period)
             activity_manager.digest()
 
+        if balance_sheet_statement:
+            balance_sheet_mgr = BalanceSheetStatementContextManager(tx_digest=io_digest)
+            io_digest = balance_sheet_mgr.digest()
+
+        if income_statement:
+            income_statement_mgr = IncomeStatementContextManager(tx_digest=io_digest)
+            io_digest = income_statement_mgr.digest()
+
         if cash_flow_statement:
-            cfs = CashFlowStatement(io_digest=io_digest)
+            cfs = CashFlowStatementContextManager(io_digest=io_digest)
             io_digest = cfs.digest()
 
         if not digest_name:
             digest_name = 'tx_digest'
 
-        digest_results = dict()
-        digest_results[digest_name] = io_digest
+        digest_results = {
+            digest_name: io_digest
+        }
+
         return txs_qs, digest_results
 
     def commit_txs(self,
                    je_date: Union[str, datetime, date],
                    je_txs: list,
                    je_posted: bool = False,
                    je_ledger=None,
@@ -469,37 +491,37 @@
         :param je_parent:
         :return:
         """
         # Validates that credits/debits balance.
         balance_tx_data(je_txs)
 
         if all([
-            isinstance(self, lazy_importer.get_entity_model()),
+            isinstance(self, lazy_loader.get_entity_model()),
             not je_ledger
         ]):
             raise ValidationError('Must pass an instance of LedgerModel')
 
         if not je_ledger:
             je_ledger = self
 
-        JournalEntryModel = lazy_importer.get_journal_entry_model()
+        JournalEntryModel = lazy_loader.get_journal_entry_model()
 
         je_date = validate_io_date(dt=je_date)
 
         je_model = JournalEntryModel(
             ledger=je_ledger,
             description=je_desc,
             timestamp=je_date,
             origin=je_origin,
         )
 
         # verify is False, no transactions are present yet....
         je_model.save(verify=False)
 
-        TransactionModel = lazy_importer.get_txs_model()
+        TransactionModel = lazy_loader.get_txs_model()
         txs_models = [
             TransactionModel(
                 account_id=tx['account_id'],
                 tx_type=tx['tx_type'],
                 amount=tx['amount'],
                 description=tx['description'],
                 journal_entry=je_model,
```

## django_ledger/io/roles.py

```diff
@@ -12,14 +12,17 @@
 
 from django.utils.translation import gettext as _
 
 from django_ledger.exceptions import InvalidRoleError
 
 mod = sys.modules[__name__]
 
+DEBIT = 'debit'
+CREDIT = 'credit'
+
 # --- ASSET ROLES ----
 # Current Assets ---
 ASSET_CA_CASH = 'asset_ca_cash'
 ASSET_CA_MKT_SECURITIES = 'asset_ca_mkt_sec'
 ASSET_CA_RECEIVABLES = 'asset_ca_recv'
 ASSET_CA_INVENTORY = 'asset_ca_inv'
 ASSET_CA_UNCOLLECTIBLES = 'asset_ca_uncoll'
@@ -72,38 +75,103 @@
 
 INCOME_OPERATIONAL = 'in_operational'
 INCOME_INVESTING = 'in_passive'
 INCOME_CAPITAL_GAIN_LOSS = 'in_gain_loss'
 INCOME_INTEREST = 'in_interest'
 INCOME_OTHER = 'in_other'
 
-COGS = 'ex_cogs'
+COGS = 'cogs_regular'
 
-EXPENSE_REGULAR = 'ex_regular'
+EXPENSE_OPERATIONAL = 'ex_regular'
 EXPENSE_CAPITAL = 'ex_capital'
 EXPENSE_DEPRECIATION = 'ex_depreciation'
 EXPENSE_AMORTIZATION = 'ex_amortization'
 EXPENSE_TAXES = 'ex_taxes'
 EXPENSE_INTEREST = 'ex_interest'
 EXPENSE_OTHER = 'ex_other'
 
+# ------> ROLES ACCOUNT ROOT <----- #
+
+ROOT_COA = 'root_coa'
+ROOT_ASSETS = 'root_assets'
+ROOT_LIABILITIES = 'root_liabilities'
+ROOT_CAPITAL = 'root_capital'
+ROOT_INCOME = 'root_income'
+ROOT_COGS = 'root_cogs'
+ROOT_EXPENSES = 'root_expenses'
+
+ROOT_GROUP = [
+    ROOT_COA,
+    ROOT_ASSETS,
+    ROOT_LIABILITIES,
+    ROOT_CAPITAL,
+    ROOT_INCOME,
+    ROOT_COGS,
+    ROOT_EXPENSES
+]
+ROOT_GROUP_LEVEL_2 = [
+    ROOT_ASSETS,
+    ROOT_LIABILITIES,
+    ROOT_CAPITAL,
+    ROOT_INCOME,
+    ROOT_COGS,
+    ROOT_EXPENSES
+]
+ROOT_GROUP_META = {
+    ROOT_COA: {
+        'code': '00000',
+        'title': 'CoA Root Node',
+        'balance_type': DEBIT
+    },
+    ROOT_ASSETS: {
+        'code': '01000',
+        'title': 'Asset Accounts Root Node',
+        'balance_type': DEBIT
+    },
+    ROOT_LIABILITIES: {
+        'code': '02000',
+        'title': 'Liability Accounts Root Node',
+        'balance_type': CREDIT
+    },
+    ROOT_CAPITAL: {
+        'code': '03000',
+        'title': 'Capital Accounts Root Node',
+        'balance_type': CREDIT
+    },
+    ROOT_INCOME: {
+        'code': '04000',
+        'title': 'Income Accounts Root Node',
+        'balance_type': CREDIT
+    },
+    ROOT_COGS: {
+        'code': '05000',
+        'title': 'COGS Accounts Root Node',
+        'balance_type': DEBIT
+    },
+    ROOT_EXPENSES: {
+        'code': '06000',
+        'title': 'Expense Accounts Root Node',
+        'balance_type': DEBIT
+    },
+}
 # ------> ROLE GROUPS <-------#
 
 # ASSET GROUPS...
 GROUP_QUICK_ASSETS = [
     ASSET_CA_CASH,
     ASSET_CA_MKT_SECURITIES
 ]
 
 GROUP_CURRENT_ASSETS = [
     ASSET_CA_CASH,
     ASSET_CA_MKT_SECURITIES,
     ASSET_CA_INVENTORY,
     ASSET_CA_RECEIVABLES,
     ASSET_CA_PREPAID,
+    ASSET_CA_UNCOLLECTIBLES,
     ASSET_CA_OTHER
 ]
 
 GROUP_NON_CURRENT_ASSETS = [
     ASSET_LTI_NOTES_RECEIVABLE,
     ASSET_LTI_LAND,
     ASSET_LTI_SECURITIES,
@@ -124,15 +192,16 @@
 GROUP_CURRENT_LIABILITIES = [
     LIABILITY_CL_ACC_PAYABLE,
     LIABILITY_CL_DEFERRED_REVENUE,
     LIABILITY_CL_INTEREST_PAYABLE,
     LIABILITY_CL_LTD_MATURITIES,
     LIABILITY_CL_OTHER,
     LIABILITY_CL_ST_NOTES_PAYABLE,
-    LIABILITY_CL_WAGES_PAYABLE
+    LIABILITY_CL_WAGES_PAYABLE,
+    LIABILITY_CL_TAXES_PAYABLE
 ]
 
 GROUP_LT_LIABILITIES = [
     LIABILITY_LTL_NOTES_PAYABLE,
     LIABILITY_LTL_BONDS_PAYABLE,
     LIABILITY_LTL_MORTGAGE_PAYABLE,
 ]
@@ -149,30 +218,23 @@
 ]
 
 GROUP_INCOME = [
     INCOME_OPERATIONAL,
     INCOME_INVESTING,
     INCOME_INTEREST,
     INCOME_CAPITAL_GAIN_LOSS,
-    INCOME_OTHER,
+    INCOME_OTHER
 ]
 
-GROUP_EXPENSES = [
-    COGS,
-    EXPENSE_REGULAR,
-    EXPENSE_INTEREST,
-    EXPENSE_TAXES,
-    EXPENSE_CAPITAL,
-    EXPENSE_DEPRECIATION,
-    EXPENSE_AMORTIZATION,
-    EXPENSE_OTHER
+GROUP_COGS = [
+    COGS
 ]
 
-GROUP_EXPENSES_NO_COGS = [
-    EXPENSE_REGULAR,
+GROUP_EXPENSES = [
+    EXPENSE_OPERATIONAL,
     EXPENSE_INTEREST,
     EXPENSE_TAXES,
     EXPENSE_CAPITAL,
     EXPENSE_DEPRECIATION,
     EXPENSE_AMORTIZATION,
     EXPENSE_OTHER
 ]
@@ -203,22 +265,46 @@
 ]
 
 GROUP_EXPENSE_DEP_AND_AMT = [
     EXPENSE_DEPRECIATION,
     EXPENSE_AMORTIZATION
 ]
 
-GROUP_EARNINGS = GROUP_INCOME + GROUP_EXPENSES
+GROUP_EARNINGS = GROUP_INCOME + GROUP_COGS + GROUP_EXPENSES
 GROUP_EQUITY = GROUP_CAPITAL + GROUP_EARNINGS
 GROUP_LIABILITIES_EQUITY = GROUP_LIABILITIES + GROUP_EQUITY
 
 GROUP_INVOICE = [ASSET_CA_CASH, ASSET_CA_RECEIVABLES, LIABILITY_CL_DEFERRED_REVENUE]
 GROUP_BILL = [ASSET_CA_CASH, ASSET_CA_PREPAID, LIABILITY_CL_ACC_PAYABLE]
 
-# ############# CASH FLOW STATEMENT GROUPS...
+# ############# INCOME STATEMENT GROUPS ###############
+
+# ---> OPERATING REV/EXP (usual & frequent) <---- #
+GROUP_IC_OPERATING_REVENUES = [INCOME_OPERATIONAL]
+GROUP_IC_OPERATING_COGS = [COGS]
+GROUP_IC_OPERATING_EXPENSES = [EXPENSE_OPERATIONAL]
+
+# ---> OTHER REV/EXP (unusual OR infrequent) <---- #
+GROUP_IC_OTHER_REVENUES = [
+    INCOME_INVESTING,
+    INCOME_INTEREST,
+    INCOME_CAPITAL_GAIN_LOSS,
+    INCOME_OTHER
+]
+GROUP_IC_OTHER_EXPENSES = [
+    EXPENSE_INTEREST,
+    EXPENSE_TAXES,
+    EXPENSE_CAPITAL,
+    EXPENSE_DEPRECIATION,
+    EXPENSE_AMORTIZATION,
+    EXPENSE_OTHER
+]
+
+
+# ############# CASH FLOW STATEMENT GROUPS ############
 GROUP_CFS_NET_INCOME = GROUP_EARNINGS
 
 # ---> OPERATING ACTIVITIES (INDIRECT) <---- #
 # Non-Cash/Non-Current...
 GROUP_CFS_OP_DEPRECIATION_AMORTIZATION = [
     EXPENSE_DEPRECIATION,
     EXPENSE_AMORTIZATION
@@ -306,15 +392,15 @@
 # ---> INVESTING & FINANCING ACTIVITIES <---- #
 GROUP_CFS_INVESTING_AND_FINANCING = GROUP_CFS_INVESTING + GROUP_CFS_FINANCING
 
 BS_ASSET_ROLE = 'assets'
 BS_LIABILITIES_ROLE = 'liabilities'
 BS_EQUITY_ROLE = 'equity'
 
-ACCOUNT_ROLES = [
+ACCOUNT_ROLE_CHOICES = [
     (BS_ASSET_ROLE.capitalize(), (
         # CURRENT ASSETS ----
         (ASSET_CA_CASH, _('Current Asset')),
         (ASSET_CA_MKT_SECURITIES, _('Marketable Securities')),
         (ASSET_CA_RECEIVABLES, _('Receivables')),
         (ASSET_CA_INVENTORY, _('Inventory')),
         (ASSET_CA_UNCOLLECTIBLES, _('Uncollectibles')),
@@ -342,25 +428,24 @@
     (BS_LIABILITIES_ROLE.capitalize(), (
 
         # CURRENT LIABILITIES ---
         (LIABILITY_CL_ACC_PAYABLE, _('Accounts Payable')),
         (LIABILITY_CL_WAGES_PAYABLE, _('Wages Payable')),
         (LIABILITY_CL_INTEREST_PAYABLE, _('Interest Payable')),
         (LIABILITY_CL_TAXES_PAYABLE, _('Taxes Payable')),
-        (LIABILITY_CL_ST_NOTES_PAYABLE, _('Notes Payable')),
+        (LIABILITY_CL_ST_NOTES_PAYABLE, _('Short Term Notes Payable')),
         (LIABILITY_CL_LTD_MATURITIES, _('Current Maturities of Long Tern Debt')),
         (LIABILITY_CL_DEFERRED_REVENUE, _('Deferred Revenue')),
         (LIABILITY_CL_OTHER, _('Other Liabilities')),
 
         # LONG TERM LIABILITIES ----
-        (LIABILITY_LTL_NOTES_PAYABLE, _('Notes Payable')),
+        (LIABILITY_LTL_NOTES_PAYABLE, _('Long Term Notes Payable')),
         (LIABILITY_LTL_BONDS_PAYABLE, _('Bonds Payable')),
         (LIABILITY_LTL_MORTGAGE_PAYABLE, _('Mortgage Payable')),
-    )
-     ),
+    )),
     (BS_EQUITY_ROLE.capitalize(), (
 
         # EQUITY ---
         (EQUITY_CAPITAL, _('Capital')),
         (EQUITY_COMMON_STOCK, _('Common Stock')),
         (EQUITY_PREFERRED_STOCK, _('Preferred Stock')),
         (EQUITY_ADJUSTMENT, _('Other Equity Adjustments')),
@@ -373,33 +458,151 @@
         (INCOME_CAPITAL_GAIN_LOSS, _('Capital Gain/Loss Income')),
         (INCOME_OTHER, _('Other Income')),
 
         # COGS ----
         (COGS, _('Cost of Goods Sold')),
 
         # EXPENSES ----
-        (EXPENSE_REGULAR, _('Regular Expense')),
+        (EXPENSE_OPERATIONAL, _('Regular Expense')),
         (EXPENSE_INTEREST, _('Interest Expense')),
         (EXPENSE_TAXES, _('Tax Expense')),
         (EXPENSE_CAPITAL, _('Capital Expense')),
         (EXPENSE_DEPRECIATION, _('Depreciation Expense')),
         (EXPENSE_AMORTIZATION, _('Amortization Expense')),
         (EXPENSE_OTHER, _('Other Expense')),
-    )
-     )
-]
+    )),
+    ('Root', (
+        (ROOT_COA, 'CoA Root Account'),
+        (ROOT_ASSETS, 'Assets Root Account'),
+        (ROOT_LIABILITIES, 'Liabilities Root Account'),
+        (ROOT_CAPITAL, 'Capital Root Account'),
+        (ROOT_INCOME, 'Income Root Account'),
+        (ROOT_COGS, 'COGS Root Account'),
+        (ROOT_EXPENSES, 'Expenses Root Account'),
+    ))
+]
+
+# ACCOUNT_ROLE_CHOICES = [
+#     (BS_ASSET_ROLE.capitalize(), (
+#         # CURRENT ASSETS ----
+#         (ASSET_CA_CASH, _('Current Asset')),
+#         (ASSET_CA_MKT_SECURITIES, _('Marketable Securities')),
+#         (ASSET_CA_RECEIVABLES, _('Receivables')),
+#         (ASSET_CA_INVENTORY, _('Inventory')),
+#         (ASSET_CA_UNCOLLECTIBLES, _('Uncollectibles')),
+#         (ASSET_CA_PREPAID, _('Prepaid')),
+#         (ASSET_CA_OTHER, _('Other Liquid Assets')),
+#
+#         # LONG TERM INVESTMENTS ---
+#         (ASSET_LTI_NOTES_RECEIVABLE, _('Notes Receivable')),
+#         (ASSET_LTI_LAND, _('Land')),
+#         (ASSET_LTI_SECURITIES, _('Securities')),
+#
+#         # PPE ...
+#         (ASSET_PPE_BUILDINGS, _('Buildings')),
+#         (ASSET_PPE_BUILDINGS_ACCUM_DEPRECIATION, _('Buildings - Accum. Depreciation')),
+#         (ASSET_PPE_PLANT, _('Plant')),
+#         (ASSET_PPE_PLANT_ACCUM_DEPRECIATION, _('Plant - Accum. Depreciation')),
+#         (ASSET_PPE_EQUIPMENT, _('Equipment')),
+#         (ASSET_PPE_EQUIPMENT_ACCUM_DEPRECIATION, _('Equipment - Accum. Depreciation')),
+#
+#         # Other Assets ...
+#         (ASSET_INTANGIBLE_ASSETS, _('Intangible Assets')),
+#         (ASSET_INTANGIBLE_ASSETS_ACCUM_AMORTIZATION, _('Intangible Assets - Accum. Amortization')),
+#         (ASSET_ADJUSTMENTS, _('Other Assets')),
+#     )),
+#     (BS_LIABILITIES_ROLE.capitalize(), (
+#
+#         # CURRENT LIABILITIES ---
+#         (LIABILITY_CL_ACC_PAYABLE, _('Accounts Payable')),
+#         (LIABILITY_CL_WAGES_PAYABLE, _('Wages Payable')),
+#         (LIABILITY_CL_INTEREST_PAYABLE, _('Interest Payable')),
+#         (LIABILITY_CL_TAXES_PAYABLE, _('Taxes Payable')),
+#         (LIABILITY_CL_ST_NOTES_PAYABLE, _('Short Term Notes Payable')),
+#         (LIABILITY_CL_LTD_MATURITIES, _('Current Maturities of Long Tern Debt')),
+#         (LIABILITY_CL_DEFERRED_REVENUE, _('Deferred Revenue')),
+#         (LIABILITY_CL_OTHER, _('Other Liabilities')),
+#
+#         # LONG TERM LIABILITIES ----
+#         (LIABILITY_LTL_NOTES_PAYABLE, _('Long Term Notes Payable')),
+#         (LIABILITY_LTL_BONDS_PAYABLE, _('Bonds Payable')),
+#         (LIABILITY_LTL_MORTGAGE_PAYABLE, _('Mortgage Payable')),
+#     )),
+#     (BS_EQUITY_ROLE.capitalize(), (
+#
+#         # EQUITY ---
+#         (EQUITY_CAPITAL, _('Capital')),
+#         (EQUITY_COMMON_STOCK, _('Common Stock')),
+#         (EQUITY_PREFERRED_STOCK, _('Preferred Stock')),
+#         (EQUITY_ADJUSTMENT, _('Other Equity Adjustments')),
+#         (EQUITY_DIVIDENDS, _('Dividends & Distributions to Shareholders')),
+#     )),
+#     ('Income', (
+#         # INCOME ---
+#         (INCOME_OPERATIONAL, _('Operational Income')),
+#         (INCOME_INVESTING, _('Investing/Passive Income')),
+#         (INCOME_INTEREST, _('Interest Income')),
+#         (INCOME_CAPITAL_GAIN_LOSS, _('Capital Gain/Loss Income')),
+#         (INCOME_OTHER, _('Other Income')),
+#     )),
+#     ('Expenses', (
+#         # COGS ----
+#         (COGS, _('Cost of Goods Sold')),
+#
+#         # EXPENSES ----
+#         (EXPENSE_REGULAR, _('Regular Expense')),
+#         (EXPENSE_INTEREST, _('Interest Expense')),
+#         (EXPENSE_TAXES, _('Tax Expense')),
+#         (EXPENSE_CAPITAL, _('Capital Expense')),
+#         (EXPENSE_DEPRECIATION, _('Depreciation Expense')),
+#         (EXPENSE_AMORTIZATION, _('Amortization Expense')),
+#         (EXPENSE_OTHER, _('Other Expense')),
+#     )),
+#     ('Root', (
+#         (ROOT_COA, 'CoA Root Account'),
+#         (ROOT_ASSETS, 'Assets Root Account'),
+#         (ROOT_LIABILITIES, 'Liabilities Root Account'),
+#         (ROOT_CAPITAL, 'Capital Root Account'),
+#         (ROOT_INCOME, 'Income Root Account'),
+#         (ROOT_COGS, 'COGS Root Account'),
+#         (ROOT_EXPENSES, 'Expenses Root Account'),
+#     ))
+# ]
+
+ACCOUNT_CHOICES_NO_ROOT = [c for c in ACCOUNT_ROLE_CHOICES if c[0] != 'Root']
+
+ROLES_ORDER_ASSETS = [a[0] for a in ACCOUNT_ROLE_CHOICES[0][1]]
+ROLES_ORDER_LIABILITIES = [a[0] for a in ACCOUNT_ROLE_CHOICES[1][1]]
+ROLES_ORDER_CAPITAL = [a[0] for a in ACCOUNT_ROLE_CHOICES[2][1]]
+# ROLES_ORDER_INCOME = [a[0] for a in ACCOUNT_ROLE_CHOICES[3][1]]
+# ROLES_ORDER_EXPENSES = [a[0] for a in ACCOUNT_ROLE_CHOICES[4][1]]
+
+ACCOUNT_LIST_ROLE_ORDER = list(r[0] for r in chain.from_iterable([i[1] for i in ACCOUNT_CHOICES_NO_ROOT]))
+ACCOUNT_LIST_ROLE_VERBOSE = {r[0]: r[1] for r in chain.from_iterable([i[1] for i in ACCOUNT_CHOICES_NO_ROOT])}
 
-ROLE_TUPLES = sum([[(r[0].lower(), s[0]) for s in r[1]] for r in ACCOUNT_ROLES], list())
-ROLE_DICT = dict([(t[0].lower(), [r[0] for r in t[1]]) for t in ACCOUNT_ROLES])
+ROLE_TUPLES = sum([[(r[0].lower(), s[0]) for s in r[1]] for r in ACCOUNT_ROLE_CHOICES], list())
+ROLE_DICT = dict([(t[0].lower(), [r[0] for r in t[1]]) for t in ACCOUNT_ROLE_CHOICES])
 VALID_ROLES = [r[1] for r in ROLE_TUPLES]
 BS_ROLES = dict((r[1], r[0]) for r in ROLE_TUPLES)
 
+BS_BUCKETS = {
+    '0': 'Root',
+    '1': 'Asset',
+    '2': 'Liability',
+    '3': 'Capital',
+    '4': 'Income',
+    '5': 'COGS',
+    '6': 'Expenses'
+}
+BS_BUCKETS_ORDER = [v for _, v in BS_BUCKETS.items() if v != 'Root']
+
 ROLES_VARS = locals().keys()
 ROLES_DIRECTORY = dict()
 ROLES_CATEGORIES = ['ASSET', 'LIABILITY', 'EQUITY', 'INCOME', 'COGS', 'EXPENSE']
+
 for cat in ROLES_CATEGORIES:
     ROLES_DIRECTORY[cat] = [c for c in ROLES_VARS if c.split('_')[0] == cat]
 
 ROLES_GROUPS = [g for g in ROLES_VARS if g.split('_')[0] == 'GROUP']
 
 GROUPS_DIRECTORY = dict()
 for group in ROLES_GROUPS:
```

## django_ledger/models/accounts.py

```diff
@@ -21,35 +21,46 @@
 In Django Ledger, all account models must be assigned a role from
 :func:`ACCOUNT_ROLES <django_ledger.io.roles.ACCOUNT_ROLES>`. Roles are a way to group accounts to a common namespace,
 regardless of its user-defined fields. Roles are an integral part to Django Ledger since they are critical when
 requesting and producing financial statements and financial ratio calculations.
 
 AccountModels may also contain parent/child relationships as implemented by the Django Treebeard functionality.
 """
-
+from itertools import groupby
+from random import randint
 from typing import Union, List, Optional
 from uuid import uuid4
 
 from django.core.exceptions import ValidationError
 from django.db import models
 from django.db.models import Q
+from django.db.models.signals import pre_save
 from django.utils.translation import gettext_lazy as _
 from treebeard.mp_tree import MP_Node, MP_NodeManager, MP_NodeQuerySet
 
-from django_ledger.io.roles import ACCOUNT_ROLES, BS_ROLES, GROUP_INVOICE, GROUP_BILL, validate_roles
+from django_ledger.io.roles import (ACCOUNT_ROLE_CHOICES, BS_ROLES, GROUP_INVOICE, GROUP_BILL, validate_roles,
+                                    GROUP_ASSETS,
+                                    GROUP_LIABILITIES, GROUP_CAPITAL, GROUP_INCOME, GROUP_EXPENSES, GROUP_COGS,
+                                    ROOT_GROUP, BS_BUCKETS, ROOT_ASSETS, ROOT_LIABILITIES,
+                                    ROOT_CAPITAL, ROOT_INCOME, ROOT_EXPENSES, ROOT_COA)
 from django_ledger.models import lazy_loader
 from django_ledger.models.mixins import CreateUpdateMixIn
+from django_ledger.settings import DJANGO_LEDGER_ACCOUNT_CODE_GENERATE, DJANGO_LEDGER_ACCOUNT_CODE_USE_PREFIX
 
 DEBIT = 'debit'
 """A constant, identifying a DEBIT Account or DEBIT transaction in the respective database fields"""
 
 CREDIT = 'credit'
 """A constant, identifying a CREDIT Account or CREDIT transaction in the respective database fields"""
 
 
+class AccountModelValidationError(ValidationError):
+    pass
+
+
 class AccountModelQuerySet(MP_NodeQuerySet):
     """
     A custom defined QuerySet, which inherits from the Materialized Path Tree implementation
     of Django Treebeard for tree-like model implementation.
     """
 
     def active(self):
@@ -92,14 +103,48 @@
             Returns a QuerySet filtered by user-provided list of Roles.
         """
         if isinstance(roles, str):
             roles = [roles]
         roles = validate_roles(roles)
         return self.filter(role__in=roles)
 
+    def is_coa_root(self):
+        return self.filter(role__in=ROOT_GROUP)
+
+    def not_coa_root(self):
+        return self.exclude(role__in=ROOT_GROUP)
+
+    def for_entity(self, entity_slug, user_model):
+        if isinstance(self, lazy_loader.get_entity_model()):
+            return self.filter(
+                Q(coa_model__entity=entity_slug) &
+                (
+                        Q(coa_model__entity__admin=user_model) |
+                        Q(coa_model__entity__managers__in=[user_model])
+                )
+            ).order_by('code')
+        return self.filter(
+            Q(coa_model__entity__slug__exact=entity_slug) &
+            (
+                    Q(coa_model__entity__admin=user_model) |
+                    Q(coa_model__entity__managers__in=[user_model])
+            )
+        ).order_by('code')
+
+    def gb_bs_role(self):
+        accounts_gb = list((r, list(gb)) for r, gb in groupby(self, key=lambda acc: acc.get_bs_bucket()))
+        return [
+            (bsr, [
+                (r, list(l)) for r, l in groupby(gb, key=lambda a: a.get_role_display())
+            ]) for bsr, gb in accounts_gb
+        ]
+
+    def is_role_default(self):
+        return self.filter(role_default=True)
+
 
 class AccountModelManager(MP_NodeManager):
     """
     This Model Manager will be used as interface through which the database query operations can be provided to the
     Account Model. It uses the custom defined AccountModelQuerySet and hence overrides the normal get_queryset
     function which return all rows of a model.
     """
@@ -107,80 +152,82 @@
     def get_queryset(self) -> AccountModelQuerySet:
         """
         Sets the custom queryset as the default.
         """
         return AccountModelQuerySet(self.model).order_by('path')
 
     # todo: search for uses and pass EntityModel whenever possible.
-    def for_entity(self, user_model, entity_slug, coa_slug: Optional[str] = None) -> AccountModelQuerySet:
+    def for_entity(self,
+                   user_model,
+                   entity_slug,
+                   coa_slug: Optional[str] = None,
+                   select_coa_model: bool = True) -> AccountModelQuerySet:
         """
         Ensures that only accounts associated with the given EntityModel are returned.
 
         Parameters
         ----------
-
         entity_slug: EntityModel or str
             The EntityModel or EntityModel slug to pull accounts from. If slug is passed and coa_slug is None will
             result in an additional Database query to determine the default code of accounts.
-
         coa_slug: str
             Explicitly specify which chart of accounts to use. If None, will pull default Chart of Accounts.
             Discussed in detail in the CoA Model CoA slug,  basically helps in identifying the complete Chart of
             Accounts for a particular EntityModel.
-
         user_model:
             The Django User Model making the request to check for permissions.
+        select_coa_model: bool
+            Pre fetches the CoA Model information in the QuerySet. Defaults to True.
 
         Returns
         -------
         AccountModelQuerySet
             A QuerySet of all requested EntityModel Chart of Accounts.
         """
         qs = self.get_queryset()
+        if select_coa_model:
+            qs = qs.select_related('coa_model')
+
         EntityModel = lazy_loader.get_entity_model()
         if isinstance(entity_slug, EntityModel):
             entity_model = entity_slug
-            slug = entity_slug.slug
+            qs = qs.filter(coa_model__entity=entity_model)
+        elif isinstance(entity_slug, str):
+            qs = qs.filter(coa_model__entity__slug__exact=entity_slug)
         else:
-            slug = entity_slug
-            entity_model = EntityModel.objects.get(slug__exact=slug)
-
-        qs = qs.filter(
-            Q(coa_model__entity=entity_model) &
-            (
-                    Q(coa_model__entity__admin=user_model) |
-                    Q(coa_model__entity__managers__in=[user_model])
-            )
-        ).order_by('code')
+            raise AccountModelValidationError(message='Must pass an instance of EntityModel or String for entity_slug.')
 
         if coa_slug:
-            return qs.filter(coa_model___slug__exact=coa_slug)
-        return qs.filter(coa_model__uuid__exact=entity_model.default_coa_id)
+            qs = qs.filter(coa_model__slug__exact=coa_slug)
+
+        return qs.filter(
+            Q(coa_model__entity__admin=user_model) |
+            Q(coa_model__entity__managers__in=[user_model])
+        ).order_by('coa_model')
 
     def for_entity_available(self, user_model, entity_slug, coa_slug: Optional[str] = None) -> AccountModelQuerySet:
         """
         Convenience method to pull only available and unlocked AccountModels for a specific EntityModel.
 
         Parameters
-        __________
-
+        ----------
         entity_slug: EntityModel or str
             The EntityModel or EntityModel slug to pull accounts from. If slug is passed and coa_slug is None will
             result in an additional Database query to determine the default code of accounts.
 
         coa_slug: str
             Explicitly specify which chart of accounts to use. If None, will pull default Chart of Accounts.
             Discussed in detail in the CoA Model CoA slug,  basically helps in identifying the complete Chart of
             Accounts for a particular EntityModel.
 
         user_model:
             The Django User Model making the request to check for permissions.
 
         Returns
-        _______
+        -------
         AccountModelQuerySet
             A QuerySet of all requested EntityModel Chart of Accounts.
         """
         qs = self.for_entity(
             user_model=user_model,
             entity_slug=entity_slug,
             coa_slug=coa_slug)
@@ -193,61 +240,90 @@
         """
         This method is used to make query of accounts with a certain role. For instance, the fixed assets like
         Buildings have all been assigned the role of  "asset_ppe_build" role is basically an aggregation of the
         accounts under a similar category. So, to query the list of all accounts under the role "asset_ppe_build",
         we can use this function.
 
         Parameters
-        __________
+        ----------
+        entity_slug: EntityModel or str
+            The EntityModel or EntityModel slug to pull accounts from. If slug is passed and coa_slug is None will
+            result in an additional Database query to determine the default code of accounts.
+        user_model
+            The Django User Model making the request to check for permissions.
         roles: list or str
             Function accepts a single str instance of a role or a list of roles. For a list of roles , refer io.roles.py
-
         Returns
-        _______
+        -------
         AccountModelQuerySet
             Returns a QuerySet filtered by user-provided list of Roles.
         """
         roles = validate_roles(roles)
         if isinstance(roles, str):
             roles = [roles]
         qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(role__in=roles)
 
-    def with_roles_available(self, roles: Union[list, str], entity_slug: str, user_model) -> AccountModelQuerySet:
+    def with_roles_available(self, roles: Union[list, str],
+                             entity_slug,
+                             user_model,
+                             coa_slug: Optional[str]) -> AccountModelQuerySet:
         """
         Convenience method to pull only available and unlocked AccountModels for a specific EntityModel and for a
         specific list of roles.
 
         Parameters
-        __________
-
+        ----------
         entity_slug: EntityModel or str
             The EntityModel or EntityModel slug to pull accounts from. If slug is passed and coa_slug is None will
             result in an additional Database query to determine the default code of accounts.
-
         coa_slug: str
             Explicitly specify which chart of accounts to use. If None, will pull default Chart of Accounts.
             Discussed in detail in the CoA Model CoA slug,  basically helps in identifying the complete Chart of
             Accounts for a particular EntityModel.
-
         user_model:
             The Django User Model making the request to check for permissions.
+        roles: list or str
+            Function accepts a single str instance of a role or a list of roles. For a list of roles , refer io.roles.py
 
         Returns
-        _______
+        -------
         AccountModelQuerySet
             A QuerySet of all requested EntityModel Chart of Accounts.
         """
 
         if isinstance(roles, str):
             roles = [roles]
         roles = validate_roles(roles)
         qs = self.for_entity_available(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(role__in=roles)
 
+    def coa_roots(self, user_model, entity_slug, coa_slug) -> AccountModelQuerySet:
+        """
+        Fetches the Code of Account Root Accounts.
+
+        Parameters
+        ----------
+        entity_slug: EntityModel or str
+            The EntityModel or EntityModel slug to pull accounts from. If slug is passed and coa_slug is None will
+            result in an additional Database query to determine the default code of accounts.
+        coa_slug: str
+            Explicitly specify which chart of accounts to use. If None, will pull default Chart of Accounts.
+            Discussed in detail in the CoA Model CoA slug,  basically helps in identifying the complete Chart of
+            Accounts for a particular EntityModel.
+        user_model:
+            The Django User Model making the request to check for permissions.
+
+        Returns
+        -------
+
+        """
+        qs = self.for_entity(user_model=user_model, entity_slug=entity_slug, coa_slug=coa_slug)
+        return qs.is_coa_root()
+
     def for_invoice(self, user_model, entity_slug: str, coa_slug: Optional[str] = None) -> AccountModelQuerySet:
         """
         Convenience method to pull only available and unlocked AccountModels for a specific EntityModel relevant only
         for creating and management of Invoices. See :func:`GROUP_INVOICE <django_ledger.io.roles.GROUP_INVOICE>`.
 
         Roles in GROUP_INVOICE: ASSET_CA_CASH, ASSET_CA_RECEIVABLES, LIABILITY_CL_DEFERRED_REVENUE.
 
@@ -307,26 +383,30 @@
         qs = self.for_entity_available(
             user_model=user_model,
             entity_slug=entity_slug,
             coa_slug=coa_slug)
         return qs.filter(role__in=GROUP_BILL)
 
 
+def account_code_validator(value: str):
+    if not value.isalnum():
+        raise AccountModelValidationError(_('Account code must be alpha numeric, got {%s}') % value)
+
+
 class AccountModelAbstract(MP_Node, CreateUpdateMixIn):
     """
     Django Ledger Base Account Model Abstract. This is the main abstract class which the Account Model database will
     inherit, and it contains the fields/columns/attributes which the said ledger table will have. In addition to the
     attributes mentioned below, it also has the fields/columns/attributes mentioned in the ParentChileMixin & the
     CreateUpdateMixIn. Read about these mixin here.
 
     Below are the fields specific to the accounts model.
 
     Attributes
-    __________
-
+    ----------
     uuid: UUID
         This is a unique primary key generated for the table. The default value of this field is uuid4().
 
     code: str
         Each account will have its own alphanumeric code.
         For example:
            * Cash Account -> Code 1010.
@@ -351,30 +431,28 @@
         This determines whether any transactions can be added in the account. Before making any update to the
         account, the account needs to be unlocked. Default value is set to False i.e. Unlocked.
 
     active: bool
         Determines whether the concerned account is active. Any Account can be used only when it is unlocked and
         Active. Default value is set to True.
 
-    coa: ChartOfAccountsModel
+    coa_model: ChartOfAccountsModel
         Each Accounts must be assigned a ChartOfAccountsModel. By default, one CoA will be created for each entity.
         However, the creating of a new AccountModel must have an explicit assignment of a ChartOfAccountModel.
-
-    on_coa: AccountModelManager
-        This object has been created for the purpose of the managing the models and in turn handling the database
     """
     BALANCE_TYPE = [
         (CREDIT, _('Credit')),
         (DEBIT, _('Debit'))
     ]
 
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
-    code = models.CharField(max_length=10, verbose_name=_('Account Code'))
+    code = models.CharField(max_length=10, verbose_name=_('Account Code'), validators=[account_code_validator])
     name = models.CharField(max_length=100, verbose_name=_('Account Name'))
-    role = models.CharField(max_length=30, choices=ACCOUNT_ROLES, verbose_name=_('Account Role'))
+    role = models.CharField(max_length=30, choices=ACCOUNT_ROLE_CHOICES, verbose_name=_('Account Role'))
+    role_default = models.BooleanField(null=True, blank=True, verbose_name=_('Coa Role Default Account'))
     balance_type = models.CharField(max_length=6, choices=BALANCE_TYPE, verbose_name=_('Account Balance Type'))
     locked = models.BooleanField(default=False, verbose_name=_('Locked'))
     active = models.BooleanField(default=False, verbose_name=_('Active'))
     coa_model = models.ForeignKey('django_ledger.ChartOfAccountModel',
                                   on_delete=models.CASCADE,
                                   editable=False,
                                   verbose_name=_('Chart of Accounts'))
@@ -383,22 +461,23 @@
 
     class Meta:
         abstract = True
         ordering = ['-created']
         verbose_name = _('Account')
         verbose_name_plural = _('Accounts')
         unique_together = [
-            ('coa_model', 'code')
+            ('coa_model', 'code'),
+            ('coa_model', 'role', 'role_default')
         ]
         indexes = [
             models.Index(fields=['role']),
             models.Index(fields=['balance_type']),
             models.Index(fields=['active']),
-            models.Index(fields=['coa_model']),
-            models.Index(fields=['role', 'balance_type', 'active']),
+            models.Index(fields=['locked']),
+            models.Index(fields=['coa_model'])
         ]
 
     def __str__(self):
         return '{x1} - {x5}: {x2} ({x3}/{x4})'.format(x1=self.role_bs.upper(),
                                                       x2=self.name,
                                                       x3=self.role.upper(),
                                                       x4=self.balance_type,
@@ -416,14 +495,17 @@
         Returns
         -------
         str
             A String representing the principal role of the account on the balance sheet.
         """
         return BS_ROLES.get(self.role)
 
+    def is_root_account(self):
+        return self.role in ROOT_GROUP
+
     def is_debit(self) -> bool:
         """
         Checks if the account has a DEBIT balance.
         Returns
         -------
         bool
             True if account has a DEBIT balance, else False.
@@ -436,20 +518,114 @@
         Returns
         -------
         bool
             True if account has a CREDIT balance, else False.
         """
         return self.balance_type == CREDIT
 
+    def is_coa_root(self):
+        return self.role in ROOT_GROUP
+
+    def is_asset(self) -> bool:
+        return self.role in GROUP_ASSETS
+
+    def is_liability(self) -> bool:
+        return self.role in GROUP_LIABILITIES
+
+    def is_capital(self) -> bool:
+        return self.role in GROUP_CAPITAL
+
+    def is_income(self) -> bool:
+        return self.role in GROUP_INCOME
+
+    def is_cogs(self) -> bool:
+        return self.role in GROUP_COGS
+
+    def is_expense(self) -> bool:
+        return self.role in GROUP_EXPENSES
+
+    def get_code_prefix(self) -> str:
+
+        if self.is_asset():
+            return '1'
+        elif self.is_liability():
+            return '2'
+        elif self.is_capital():
+            return '3'
+        elif self.is_income():
+            return '4'
+        elif self.is_cogs():
+            return '5'
+        elif self.is_expense():
+            return '6'
+        elif self.is_coa_root():
+            return '0'
+        else:
+            raise AccountModelValidationError(f'Invalid role match for role {self.role}...')
+
+    def get_root_role(self) -> str:
+        if self.is_asset():
+            return ROOT_ASSETS
+        elif self.is_liability():
+            return ROOT_LIABILITIES
+        elif self.is_capital():
+            return ROOT_CAPITAL
+        elif self.is_income():
+            return ROOT_INCOME
+        elif self.is_cogs():
+            return ROOT_GROUP
+        elif self.is_expense():
+            return ROOT_EXPENSES
+        elif self.is_coa_root():
+            return ROOT_COA
+        else:
+            raise AccountModelValidationError(f'Invalid role match for role {self.role}...')
+
+    def get_account_move_choice_queryset(self):
+        return self.coa_model.accountmodel_set.filter(
+            role__in=[
+                self.role,
+                self.get_root_role()
+            ],
+        ).exclude(uuid__exact=self.uuid)
+
+    def get_bs_bucket(self) -> str:
+        return BS_BUCKETS[self.get_code_prefix()]
+
+    def is_indented(self):
+        return self.depth > 2
+
+    def get_html_pixel_indent(self):
+        return f'{(self.depth - 2) * 40}px'
+
+    def generate_random_code(self):
+        if not self.role:
+            raise AccountModelValidationError('Must assign account role before generate random code')
+
+        prefix = self.get_code_prefix()
+        ri = randint(10000, 99999)
+        return f'{prefix}{ri}'
+
     def clean(self):
-        if not self.code.isalnum():
-            raise ValidationError(_('Account code must be alpha numeric, got {%s}') % self.code)
 
-    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
-        self.clean()
-        super(AccountModelAbstract, self).save(force_insert=False, force_update=False, using=None, update_fields=None)
+        if not self.code and DJANGO_LEDGER_ACCOUNT_CODE_GENERATE:
+            self.code = self.generate_random_code()
+
+        if DJANGO_LEDGER_ACCOUNT_CODE_USE_PREFIX:
+            pf = self.get_code_prefix()
+            if self.code[0] != pf:
+                raise AccountModelValidationError(f'Account {self.get_role_display()} code {self.code} '
+                                                  f'must start with {pf} for CoA consistency')
 
 
 class AccountModel(AccountModelAbstract):
     """
     Base Account Model from Account Model Abstract Class
     """
+
+
+def accountmodel_presave(instance: AccountModel, **kwargs):
+    if instance.role_default is False:
+        instance.role_default = None
+
+
+pre_save.connect(receiver=accountmodel_presave, sender=AccountModel)
```

## django_ledger/models/bank_account.py

```diff
@@ -6,26 +6,33 @@
     * Miguel Sanda <msanda@arrobalytics.com>
     * Pranav P Tulshyan <ptulshyan77@gmail.com>
 
 A Bank Account refers to the financial institution which holds financial assets for the EntityModel.
 A bank account usually holds cash, which is a Current Asset. Transactions may be imported using the open financial
 format specification OFX into a staging area for final disposition into the EntityModel ledger.
 """
-
+from typing import Optional
 from uuid import uuid4
 
+from django.contrib.auth import get_user_model
 from django.core.exceptions import ValidationError
 from django.db import models
 from django.db.models import Q, QuerySet
 from django.shortcuts import get_object_or_404
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.models import CreateUpdateMixIn, BankAccountInfoMixIn
 from django_ledger.models.utils import lazy_loader
 
+UserModel = get_user_model()
+
+
+class BankAccountValidationError(ValidationError):
+    pass
+
 
 class BankAccountModelQuerySet(QuerySet):
     """
     A custom defined QuerySet for the BankAccountModel.
     """
 
     def active(self) -> QuerySet:
@@ -93,30 +100,25 @@
     The BankAccountModel inherits functionality from the following MixIns:
 
         1. :func:`BankAccountInfoMixIn <django_ledger.models.mixins.BankAccountInfoMixIn>`
         2. :func:`CreateUpdateMixIn <django_ledger.models.mixins.CreateUpdateMixIn>`
 
 
     Attributes
-    __________
+    ----------
     uuid : UUID
         This is a unique primary key generated for the table. The default value of this field is uuid4().
-
     name: str
         A user defined name for the bank account as a String.
-
     entity_model: EntityModel
         The EntityModel associated with the BankAccountModel instance.
-
     cash_account: AccountModel
         The AccountModel associated with the BankAccountModel instance. Must be an account with role ASSET_CA_CASH.
-
     active: bool
         Determines whether the BackAccountModel instance bank account is active. Defaults to True.
-
     hidden: bool
         Determines whether the BackAccountModel instance bank account is hidden. Defaults to False.
     """
     REL_NAME_PREFIX = 'bank'
 
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
 
@@ -131,25 +133,27 @@
                                      related_name=f'{REL_NAME_PREFIX}_cash_account')
     active = models.BooleanField(default=False)
     hidden = models.BooleanField(default=False)
     objects = BankAccountModelManager.from_queryset(queryset_class=BankAccountModelQuerySet)()
 
     def configure(self,
                   entity_slug,
-                  user_model,
+                  user_model: Optional[UserModel],
                   commit: bool = False):
 
         EntityModel = lazy_loader.get_entity_model()
         if isinstance(entity_slug, str):
+            if not user_model:
+                raise BankAccountValidationError(_('Must pass user_model when using entity_slug.'))
             entity_model_qs = EntityModel.objects.for_user(user_model=user_model)
             entity_model = get_object_or_404(entity_model_qs, slug__exact=entity_slug)
         elif isinstance(entity_slug, EntityModel):
             entity_model = entity_slug
         else:
-            raise ValidationError('entity_slug must be an instance of str or EntityModel')
+            raise BankAccountValidationError('entity_slug must be an instance of str or EntityModel')
 
         self.entity_model = entity_model
         self.clean()
         if commit:
             self.save(update_fields=[
                 'entity_model',
                 'updated'
@@ -165,37 +169,37 @@
         ]
         unique_together = [
             ('entity_model', 'account_number'),
             ('entity_model', 'cash_account', 'account_number', 'routing_number')
         ]
 
     def __str__(self):
-        return self.name
+        return f'{self.get_account_type_display()} Bank Account: {self.name}'
 
     def can_activate(self) -> bool:
         return self.active is False
 
     def can_inactivate(self) -> bool:
         return self.active is True
 
     def mark_as_active(self, commit: bool = False, raise_exception: bool = True, **kwargs):
         if not self.can_activate():
             if raise_exception:
-                raise ValidationError('Bank Account cannot be activated.')
+                raise BankAccountValidationError('Bank Account cannot be activated.')
         self.active = True
         if commit:
             self.save(update_fields=[
                 'active',
                 'updated'
             ])
 
     def mark_as_inactive(self, commit: bool = False, raise_exception: bool = True, **kwargs):
         if not self.can_inactivate():
             if raise_exception:
-                raise ValidationError('Bank Account cannot be deactivated.')
+                raise BankAccountValidationError('Bank Account cannot be deactivated.')
         self.active = False
         if commit:
             self.save(update_fields=[
                 'active',
                 'updated'
             ])
```

## django_ledger/models/bill.py

```diff
@@ -17,32 +17,39 @@
 >>> bill_model = BillModel()
 >>> ledger_model, bill_model = bill_model.configure(entity_slug=entity_slug, user_model=user_model)
 >>> bill_model.save()
 """
 
 from datetime import date
 from decimal import Decimal
-from typing import Union, Optional, Tuple, Dict
+from typing import Union, Optional, Tuple, Dict, List
 from uuid import uuid4
 
+from django.contrib.auth import get_user_model
 from django.core.exceptions import ValidationError, ObjectDoesNotExist
 from django.db import models, transaction, IntegrityError
-from django.db.models import Q, Sum, F
-from django.db.models.signals import post_delete
+from django.db.models import Q, Sum, F, Count
+from django.db.models.signals import post_delete, pre_save
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
 from django.utils.timezone import localdate
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.models.entity import EntityModel
-from django_ledger.models.items import ItemTransactionModelQuerySet
-from django_ledger.models.mixins import CreateUpdateMixIn, LedgerWrapperMixIn, MarkdownNotesMixIn, PaymentTermsMixIn
+from django_ledger.models.items import ItemTransactionModelQuerySet, ItemTransactionModel
+from django_ledger.models.mixins import CreateUpdateMixIn, AccrualMixIn, MarkdownNotesMixIn, PaymentTermsMixIn
 from django_ledger.models.utils import lazy_loader
 from django_ledger.settings import (DJANGO_LEDGER_DOCUMENT_NUMBER_PADDING, DJANGO_LEDGER_BILL_NUMBER_PREFIX)
 
+UserModel = get_user_model()
+
+
+class BillModelValidationError(ValidationError):
+    pass
+
 
 class BillModelQuerySet(models.QuerySet):
     """
     A custom defined QuerySet for the BillModel. This implements multiple methods or queries needed to get a filtered
     QuerySet based on the BillModel status. For example, we might want to have list of bills which are paid, unpaid,
     due ,overdue, approved or in draft stage. All these separate functions will assist in making such queries and
     building customized reports.
@@ -230,15 +237,15 @@
                 Q(ledger__entity__slug__exact=entity_slug) & (
                         Q(ledger__entity__admin=user_model) |
                         Q(ledger__entity__managers__in=[user_model])
                 )
             )
 
 
-class BillModelAbstract(LedgerWrapperMixIn,
+class BillModelAbstract(AccrualMixIn,
                         PaymentTermsMixIn,
                         MarkdownNotesMixIn,
                         CreateUpdateMixIn):
     """
     This is the main abstract class which the BillModel database will inherit from.
     The BillModel inherits functionality from the following MixIns:
 
@@ -386,80 +393,96 @@
             models.Index(fields=['vendor']),
             models.Index(fields=['bill_number']),
         ]
 
     def __str__(self):
         return f'Bill: {self.bill_number}'
 
+    def is_configured(self) -> bool:
+        return all([
+            super().is_configured(),
+            self.bill_status
+        ])
+
     # Configuration...
     def configure(self,
                   entity_slug: Union[str, EntityModel],
-                  user_model,
+                  user_model: Optional[UserModel] = None,
+                  date_draft: Optional[date] = None,
                   ledger_posted: bool = False,
-                  bill_desc: str = None,
-                  commit: bool = False):
+                  ledger_name: str = None,
+                  commit: bool = False,
+                  commit_ledger: bool = False):
         """
         A configuration hook which executes all initial BillModel setup on to the LedgerModel and all initial
         values of the BillModel. Can only call this method once in the lifetime of a BillModel.
 
         Parameters
-        __________
+        ----------
 
+        date_draft: date
+            Optional date to use as Draft Date. Defaults to localdate() if None.
         entity_slug: str or EntityModel
             The entity slug or EntityModel to associate the Bill with.
-
-        user_model:
+        user_model: UserModel
             The UserModel making the request to check for QuerySet permissions.
-
-        ledger_posted:
+        ledger_posted: bool
             An option to mark the BillModel Ledger as posted at the time of configuration. Defaults to False.
-
-        bill_desc: str
-            An optional description appended to the LedgerModel name.
-
+        ledger_name: str
+            Optional additional InvoiceModel ledger name or description.
         commit: bool
             Saves the current BillModel after being configured.
+        commit_ledger: bool
+            Saves the BillModel's LedgerModel while being configured.
 
         Returns
         -------
         A tuple of LedgerModel, BillModel
         """
 
         # todo: add raise_exception flag, check if this is consistent...
 
         if not self.is_configured():
-            if not self.ledger_id:
-                if isinstance(entity_slug, str):
-                    entity_qs = EntityModel.objects.for_user(
-                        user_model=user_model)
-                    entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
-                elif isinstance(entity_slug, EntityModel):
-                    entity_model = entity_slug
-                else:
-                    raise ValidationError('entity_slug must be an instance of str or EntityModel')
+            if isinstance(entity_slug, str):
+                if not user_model:
+                    raise BillModelValidationError(_('Must pass user_model when using entity_slug.'))
+                entity_qs = EntityModel.objects.for_user(user_model=user_model)
+                entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
+            elif isinstance(entity_slug, EntityModel):
+                entity_model = entity_slug
+            else:
+                raise BillModelValidationError('entity_slug must be an instance of str or EntityModel')
 
             if entity_model.is_accrual_method():
                 self.accrue = True
-                self.progress = 1
+                self.progress = Decimal.from_float(1.00)
             else:
                 self.accrue = False
 
+            self.bill_status = self.BILL_STATUS_DRAFT
+            self.date_draft = localdate() if not date_draft else date_draft
+
             LedgerModel = lazy_loader.get_ledger_model()
-            ledger_model: LedgerModel = LedgerModel(
-                entity=entity_model,
-                posted=ledger_posted
-            )
-            ledger_name = f'Bill {self.uuid}'
-            if bill_desc:
-                ledger_name += f' | {bill_desc}'
+            ledger_model: LedgerModel = LedgerModel(entity=entity_model, posted=ledger_posted)
+
+            if not ledger_name:
+                ledger_name = f'Bill {self.uuid}'
+            ledger_name += f' | {ledger_name}'
             ledger_model.name = ledger_name
+
             ledger_model.clean()
 
             self.ledger = ledger_model
-            self.ledger.save()
+
+            if commit_ledger:
+                self.ledger.save()
+
+            if self.can_generate_bill_number():
+                self.generate_bill_number(commit=commit)
+
             self.clean()
 
             if commit:
                 self.save()
 
         return self.ledger, self
 
@@ -471,48 +494,60 @@
         Returns
         _______
         str
             Description as a string.
         """
         return f'Bill {self.bill_number} account adjustment.'
 
-    def validate_item_transaction_qs(self, queryset: ItemTransactionModelQuerySet):
+    def validate_item_transaction_qs(self, queryset: Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]):
         """
         Validates that the entire ItemTransactionModelQuerySet is bound to the BillModel.
 
         Parameters
         ----------
-        queryset: ItemTransactionModelQuerySet
+        queryset: ItemTransactionModelQuerySet or list of ItemTransactionModel.
             ItemTransactionModelQuerySet to validate.
         """
         valid = all([
             i.bill_model_id == self.uuid for i in queryset
         ])
         if not valid:
-            raise ValidationError(f'Invalid queryset. All items must be assigned to Bill {self.uuid}')
+            raise BillModelValidationError(f'Invalid queryset. All items must be assigned to Bill {self.uuid}')
 
     def get_itemtxs_data(self,
-                         queryset: ItemTransactionModelQuerySet = None) -> Tuple[ItemTransactionModelQuerySet, Dict]:
+                         queryset: Optional[ItemTransactionModelQuerySet] = None,
+                         aggregate_on_db: bool = False,
+                         ) -> Tuple[ItemTransactionModelQuerySet, Dict]:
         """
         Fetches the BillModel Items and aggregates the QuerySet.
 
         Parameters
-        __________
+        ----------
         queryset:
             Optional pre-fetched ItemModelQueryset to use. Avoids additional DB query if provided.
-
+        aggregate_on_db: bool
+            If True, performs aggregation of ItemsTransactions in the DB resulting in one additional DB query.
         Returns
-        _______
+        -------
         A tuple: ItemTransactionModelQuerySet, dict
         """
         if not queryset:
-            queryset = self.itemtransactionmodel_set.select_related('item_model', 'po_model', 'bill_model').all()
+            queryset = self.itemtransactionmodel_set.all().select_related(
+                'item_model',
+                'entity_unit',
+                'po_model',
+                'bill_model')
         else:
             self.validate_item_transaction_qs(queryset)
 
+        if aggregate_on_db and isinstance(queryset, ItemTransactionModelQuerySet):
+            return queryset, queryset.aggregate(
+                total_amount__sum=Sum('total_amount'),
+                total_items=Count('uuid')
+            )
         return queryset, {
             'total_amount__sum': sum(i.total_amount for i in queryset),
             'total_items': len(queryset)
         }
 
     def get_migration_data(self,
                            queryset: Optional[ItemTransactionModelQuerySet] = None) -> ItemTransactionModelQuerySet:
@@ -540,22 +575,22 @@
             'entity_unit__slug',
             'entity_unit__uuid',
             'total_amount').annotate(
             account_unit_total=Sum('total_amount')
         )
 
     def update_amount_due(self,
-                          itemtxs_qs: Optional[ItemTransactionModelQuerySet] = None
+                          itemtxs_qs: Optional[Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]] = None
                           ) -> ItemTransactionModelQuerySet:
         """
         Updates the BillModel amount due.
 
         Parameters
         ----------
-        itemtxs_qs: ItemTransactionModelQuerySet
+        itemtxs_qs: ItemTransactionModelQuerySet or list of ItemTransactionModel
             Optional pre-fetched ItemTransactionModelQuerySet. Avoids additional DB if provided.
             Queryset is validated if provided.
 
         Returns
         -------
         ItemTransactionModelQuerySet
             Newly fetched of previously fetched ItemTransactionModelQuerySet if provided.
@@ -762,31 +797,31 @@
         Parameters
         __________
 
         estimate_model: EstimateModel
             EstimateModel to check against.
 
         raise_exception: bool
-            If True, raises ValidationError if unable to bind. Else, returns False.
+            If True, raises BillModelValidationError if unable to bind. Else, returns False.
 
         Returns
         _______
 
         bool
             True if can bind provided EstimateModel, else False.
         """
         if self.ce_model_id:
             if raise_exception:
-                raise ValidationError(f'Bill {self.bill_number} already bound to '
-                                      f'Estimate {self.ce_model.estimate_number}')
+                raise BillModelValidationError(f'Bill {self.bill_number} already bound to '
+                                               f'Estimate {self.ce_model.estimate_number}')
             return False
 
         is_approved = estimate_model.is_approved()
         if not is_approved and raise_exception:
-            raise ValidationError(f'Cannot bind estimate that is not approved.')
+            raise BillModelValidationError(f'Cannot bind estimate that is not approved.')
         return all([
             is_approved
         ])
 
     def can_bind_po(self, po_model, raise_exception: bool = False) -> bool:
         """
         Checks if the BillModel can be bound to a given PurchaseOrderModel.
@@ -794,30 +829,30 @@
         Parameters
         __________
 
         po_model: PurchaseOrderModel
             The PurchaseOrderModel to check against.
 
         raise_exception: bool
-            If True, raises ValidationError if unable to bind, else False.
+            If True, raises BillModelValidationError if unable to bind, else False.
 
         Returns
         _______
 
         bool
             True if can bind provided PurchaseOderModel, else False.
         """
         if not po_model.is_approved():
             if raise_exception:
-                raise ValidationError(f'Cannot bind an unapproved PO.')
+                raise BillModelValidationError(f'Cannot bind an unapproved PO.')
             return False
 
         if po_model.date_approved > self.date_draft:
             if raise_exception:
-                raise ValidationError(f'Approved PO date cannot be greater than Bill draft date.')
+                raise BillModelValidationError(f'Approved PO date cannot be greater than Bill draft date.')
             return False
 
         return True
 
     def can_generate_bill_number(self) -> bool:
         """
         Checks if BillModel can generate its Document Number.
@@ -826,29 +861,38 @@
         _______
 
         bool
             True if BillModel can generate its bill_number, else False.
         """
         return all([
             not self.bill_number,
-            self.date_draft
+            self.is_draft(),
+            self.is_configured()
         ])
 
+    # --> URLs <---
+    def get_absolute_url(self):
+        return reverse('django_ledger:bill-detail',
+                       kwargs={
+                           'entity_slug': self.ledger.entity.slug,
+                           'bill_pk': self.uuid
+                       })
+
     # --> ACTIONS <---
     def action_bind_estimate(self, estimate_model, commit: bool = False, raise_exception: bool = True):
         """
         Binds BillModel to a given EstimateModel. Raises ValueError if EstimateModel cannot be bound.
 
         Parameters
         __________
         estimate_model: EstimateModel
             EstimateModel to bind.
 
         raise_exception: bool
-            Raises ValidationError if unable to bind EstimateModel.
+            Raises BillModelValidationError if unable to bind EstimateModel.
 
         commit: bool
             Commits transaction into current BillModel.
         """
         try:
             self.can_bind_estimate(estimate_model, raise_exception=True)
         except ValueError as e:
@@ -873,15 +917,15 @@
         date_draft: date
             Draft date. If None, defaults to localdate().
 
         commit: bool
             Commits transaction into the Database. Defaults to False.
         """
         if not self.can_draft():
-            raise ValidationError(
+            raise BillModelValidationError(
                 f'Bill {self.bill_number} cannot be marked as draft. Must be In Review.'
             )
         self.bill_status = self.BILL_STATUS_DRAFT
         self.date_draft = localdate() if not date_draft else date_draft
         self.clean()
         if commit:
             self.save(
@@ -953,31 +997,31 @@
         date_in_review: date
             BillModel in review date. Defaults to localdate() if None.
         itemtxs_qs: ItemTransactionModelQuerySet
             Pre fetched ItemTransactionModelQuerySet to use. Avoids additional DB Query if previously fetched.
         commit: bool
             Commits transaction into the Database. Defaults to False.
         raise_exception: bool
-            Raises ValidationError if BillModel cannot be marked as in review. Defaults to True.
+            Raises BillModelValidationError if BillModel cannot be marked as in review. Defaults to True.
         """
         if not self.can_review():
             if raise_exception:
-                raise ValidationError(
+                raise BillModelValidationError(
                     f'Bill {self.bill_number} cannot be marked as in review. Must be Draft and Configured.'
                 )
 
         if not itemtxs_qs:
             itemtxs_qs = self.itemtransactionmodel_set.all()
         else:
             self.validate_item_transaction_qs(queryset=itemtxs_qs)
 
         if not itemtxs_qs.count():
-            raise ValidationError(message=f'Cannot review a {self.__class__.__name__} without items...')
+            raise BillModelValidationError(message=f'Cannot review a {self.__class__.__name__} without items...')
         if not self.amount_due:
-            raise ValidationError(
+            raise BillModelValidationError(
                 f'Bill {self.bill_number} cannot be marked as in review. Amount due must be greater than 0.'
             )
 
         self.bill_status = self.BILL_STATUS_REVIEW
         self.date_in_review = localdate() if not date_in_review else date_in_review
         self.date_in_review = date_in_review
         self.clean()
@@ -1062,15 +1106,15 @@
             Commits transaction into the Database. Defaults to False.
 
         force_migrate: bool
             Forces migration. True if Accounting Method is Accrual.
         """
 
         if not self.can_approve():
-            raise ValidationError(
+            raise BillModelValidationError(
                 f'Bill {self.bill_number} cannot be marked as in approved.'
             )
         self.bill_status = self.BILL_STATUS_APPROVED
         self.date_approved = localdate() if not date_approved else date_approved
         self.new_state(commit=True)
         self.clean()
         if commit:
@@ -1163,24 +1207,25 @@
         itemtxs_qs: ItemTransactionModelQuerySet
             Pre-fetched ItemTransactionModelQuerySet. Avoids additional DB query. Validated if passed.
 
         commit: bool
             Commits transaction into the Database. Defaults to False.
         """
         if not self.can_pay():
-            raise ValidationError(f'Cannot mark Bill {self.bill_number} as paid...')
+            raise BillModelValidationError(f'Cannot mark Bill {self.bill_number} as paid...')
 
         self.progress = Decimal.from_float(1.0)
         self.amount_paid = self.amount_due
         self.date_paid = localdate() if not date_paid else date_paid
 
         if self.date_paid > localdate():
-            raise ValidationError(f'Cannot pay {self.__class__.__name__} in the future.')
+            raise BillModelValidationError(f'Cannot pay {self.__class__.__name__} in the future.')
         if self.date_paid < self.date_approved:
-            raise ValidationError(f'Cannot pay {self.__class__.__name__} before approved date {self.date_approved}.')
+            raise BillModelValidationError(
+                f'Cannot pay {self.__class__.__name__} before approved date {self.date_approved}.')
 
         self.bill_status = self.BILL_STATUS_PAID
         self.new_state(commit=True)
         self.clean()
 
         if not itemtxs_qs:
             itemtxs_qs = self.itemtransactionmodel_set.all()
@@ -1281,15 +1326,15 @@
         date_void: date
             BillModel void date. Defaults to localdate() if None.
 
         commit: bool
             Commits transaction into DB. Defaults to False.
         """
         if not self.can_void():
-            raise ValidationError(f'Bill {self.bill_number} cannot be voided. Must be approved.')
+            raise BillModelValidationError(f'Bill {self.bill_number} cannot be voided. Must be approved.')
 
         self.date_void = date_void if date_void else localdate()
         self.bill_status = self.BILL_STATUS_VOID
         self.void_state(commit=True)
         self.clean()
 
         if commit:
@@ -1362,15 +1407,15 @@
         date_canceled: date
             BillModel canceled date. Defaults to localdate() if None.
 
         commit: bool
             Commits transaction into the Database. Defaults to False.
         """
         if not self.can_cancel():
-            raise ValidationError(f'Bill {self.bill_number} cannot be canceled. Must be draft or in review.')
+            raise BillModelValidationError(f'Bill {self.bill_number} cannot be canceled. Must be draft or in review.')
 
         self.date_canceled = localdate() if not date_canceled else date_canceled
         self.bill_status = self.BILL_STATUS_CANCELED
         self.clean()
         if commit:
             self.save(update_fields=[
                 'bill_status',
@@ -1426,15 +1471,15 @@
 
     # DELETE ACTIONS...
     def mark_as_delete(self, **kwargs):
         """
         Deletes BillModel from DB if possible. Raises exception if can_delete() is False.
         """
         if not self.can_delete():
-            raise ValidationError(f'Bill {self.bill_number} cannot be deleted. Must be void after Approved.')
+            raise BillModelValidationError(f'Bill {self.bill_number} cannot be deleted. Must be void after Approved.')
         self.delete(**kwargs)
 
     def get_mark_as_delete_html_id(self) -> str:
         """
         BillModel Mark as Delete HTML ID Tag.
 
         Returns
@@ -1648,45 +1693,41 @@
         Parameters
         __________
 
         commit: bool
             If True, commits into DB the generated BillModel number if generated.
         """
 
-        if self.can_generate_bill_number():
-            self.generate_bill_number(commit=commit)
-
-        super(LedgerWrapperMixIn, self).clean()
+        super(AccrualMixIn, self).clean()
         super(PaymentTermsMixIn, self).clean()
 
         if self.accrue:
-            self.progress = Decimal('1.00')
+            self.progress = Decimal.from_float(1.00)
 
         if self.is_draft():
-            self.amount_paid = Decimal('0.00')
+            self.amount_paid = Decimal.from_float(0.00)
             self.paid = False
             self.date_paid = None
 
         if not self.additional_info:
             self.additional_info = dict()
 
-    def save(self, **kwargs):
-        """
-        Save method for BillModel. Results in a DB query if bill number has not been generated and the BillModel is
-        eligible to generate a bill_number.
-        """
-        if self.can_generate_bill_number():
-            self.generate_bill_number(commit=False)
-        super(BillModelAbstract, self).save(**kwargs)
-
 
 class BillModel(BillModelAbstract):
     """
     Base BillModel from Abstract.
     """
 
 
+def billmodel_presave(instance: BillModel, **kwargs):
+    if instance.can_generate_bill_number():
+        instance.generate_bill_number(commit=False)
+
+
+pre_save.connect(receiver=billmodel_presave, sender=BillModel)
+
+
 def billmodel_predelete(instance: BillModel, **kwargs):
     instance.ledger.delete()
 
 
 post_delete.connect(receiver=billmodel_predelete, sender=BillModel)
```

## django_ledger/models/coa.py

```diff
@@ -18,47 +18,57 @@
 Statements.
 
 All EntityModel must have a default CoA to be able to create any type of transaction. Throughout the application,
 when no explicit CoA is specified, the default behavior is to use the EntityModel default CoA. **Only ONE Chart of
 Accounts can be used when creating Journal Entries**. No commingling between CoAs is allowed in order to preserve the
 integrity of the Journal Entry.
 """
-
+from typing import Optional, Union
 from uuid import uuid4
 
 from django.contrib.auth import get_user_model
+from django.core.exceptions import ValidationError
 from django.db import models
 from django.db.models import Q
 from django.utils.translation import gettext_lazy as _
 
+from django_ledger.io import (ROOT_COA, ROOT_GROUP_LEVEL_2, ROOT_GROUP_META, ROOT_ASSETS,
+                              ROOT_LIABILITIES, ROOT_CAPITAL,
+                              ROOT_INCOME, ROOT_COGS, ROOT_EXPENSES)
 from django_ledger.models import lazy_loader
+from django_ledger.models.accounts import AccountModel, AccountModelQuerySet
 from django_ledger.models.mixins import CreateUpdateMixIn, SlugNameMixIn
+from django_ledger.settings import logger
 
 UserModel = get_user_model()
 
 
-class ChartOfAccountQuerySet(models.QuerySet):
+class ChartOfAccountsModelValidationError(ValidationError):
+    pass
+
+
+class ChartOfAccountModelQuerySet(models.QuerySet):
     pass
 
 
 class ChartOfAccountModelManager(models.Manager):
     """
     A custom defined ChartOfAccountModelManager that will act as an interface to handling the initial DB queries
     to the ChartOfAccountModel.
     """
 
-    def for_user(self, user_model) -> ChartOfAccountQuerySet:
+    def for_user(self, user_model) -> ChartOfAccountModelQuerySet:
         """
         Fetches a QuerySet of ChartOfAccountModel that the UserModel as access to. May include ChartOfAccountModel from
         multiple Entities. The user has access to bills if:
-            1. Is listed as Manager of Entity.
-            2. Is the Admin of the Entity.
+        1. Is listed as Manager of Entity.
+        2. Is the Admin of the Entity.
 
         Parameters
-        __________
+        ----------
         user_model
             Logged in and authenticated django UserModel instance.
 
         Examples
         ________
             >>> request_user = self.request.user
             >>> coa_model_qs = ChartOfAccountModel.objects.for_user(user_model=request_user)
@@ -72,15 +82,15 @@
         return qs.filter(
             (
                     Q(entity__admin=user_model) |
                     Q(entity__managers__in=[user_model])
             )
         )
 
-    def for_entity(self, entity_slug, user_model) -> ChartOfAccountQuerySet:
+    def for_entity(self, entity_slug, user_model) -> ChartOfAccountModelQuerySet:
         """
         Fetches a QuerySet of ChartOfAccountsModel associated with a specific EntityModel & UserModel.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
         Parameters
         __________
 
@@ -147,26 +157,152 @@
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
     entity = models.ForeignKey('django_ledger.EntityModel',
                                editable=False,
                                verbose_name=_('Entity'),
                                on_delete=models.CASCADE)
     locked = models.BooleanField(default=False, verbose_name=_('Locked'))
     description = models.TextField(verbose_name=_('CoA Description'), null=True, blank=True)
-    objects = ChartOfAccountModelManager.from_queryset(queryset_class=ChartOfAccountQuerySet)()
+    objects = ChartOfAccountModelManager.from_queryset(queryset_class=ChartOfAccountModelQuerySet)()
 
     class Meta:
         abstract = True
         ordering = ['-created']
         verbose_name = _('Chart of Account')
         verbose_name_plural = _('Chart of Accounts')
         indexes = [
             models.Index(fields=['entity'])
         ]
 
     def __str__(self):
         return f'{self.slug}: {self.name}'
 
+    # def is_configured(self, account_model_qs: Optional[AccountModelQuerySet]):
+    #     pass
+
+    def get_coa_root_accounts_qs(self) -> AccountModelQuerySet:
+        return self.accountmodel_set.all().is_coa_root()
+
+    def get_coa_root_account(self) -> AccountModel:
+        qs = self.get_coa_root_accounts_qs()
+        return qs.get(role__exact=ROOT_COA)
+
+    def get_coa_l2_root(self,
+                        account_model: AccountModel,
+                        root_account_qs: Optional[AccountModelQuerySet] = None,
+                        as_queryset: bool = False) -> Union[AccountModelQuerySet, AccountModel]:
+
+        if not account_model.is_coa_root():
+
+            if not root_account_qs:
+                root_account_qs = self.get_coa_root_accounts_qs()
+
+            if account_model.is_asset():
+                qs = root_account_qs.filter(code__exact=ROOT_GROUP_META[ROOT_ASSETS]['code'])
+            elif account_model.is_liability():
+                qs = root_account_qs.filter(code__exact=ROOT_GROUP_META[ROOT_LIABILITIES]['code'])
+            elif account_model.is_capital():
+                qs = root_account_qs.filter(code__exact=ROOT_GROUP_META[ROOT_CAPITAL]['code'])
+            elif account_model.is_income():
+                qs = root_account_qs.filter(code__exact=ROOT_GROUP_META[ROOT_INCOME]['code'])
+            elif account_model.is_cogs():
+                qs = root_account_qs.filter(code__exact=ROOT_GROUP_META[ROOT_COGS]['code'])
+            elif account_model.is_expense():
+                qs = root_account_qs.filter(code__exact=ROOT_GROUP_META[ROOT_EXPENSES]['code'])
+            else:
+                raise ChartOfAccountsModelValidationError(message=f'Unable to locate Balance Sheet'
+                                                                  ' root node for account code: '
+                                                                  f'{account_model.code} {account_model.name}')
+            if as_queryset:
+                return qs
+            return qs.get()
+
+    def get_non_root_coa_accounts_qs(self) -> AccountModelQuerySet:
+        return self.accountmodel_set.all().not_coa_root()
+
+    def get_coa_account_tree(self):
+        root_account = self.get_coa_root_account()
+        return AccountModel.dump_bulk(parent=root_account)
+
+    def configure(self, raise_exception: bool = True):
+        root_accounts_qs = self.get_coa_root_accounts_qs()
+        existing_root_roles = list(set(acc.role for acc in root_accounts_qs))
+
+        if len(existing_root_roles) > 0:
+            raise ChartOfAccountsModelValidationError(message=f'Root Nodes already Exist in CoA {self.uuid}...')
+
+        if ROOT_COA not in existing_root_roles:
+            # add coa root...
+            role_meta = ROOT_GROUP_META[ROOT_COA]
+            account_pk = uuid4()
+            coa_root_account_model = AccountModel.add_root(
+                instance=AccountModel(
+                    uuid=account_pk,
+                    code=role_meta['code'],
+                    name=role_meta['title'],
+                    coa_model=self,
+                    role=ROOT_COA,
+                    active=False,
+                    locked=True,
+                    balance_type=role_meta['balance_type']
+                ))
+
+            coa_root_account_model = AccountModel.objects.get(uuid__exact=account_pk)
+
+            for root_role in ROOT_GROUP_LEVEL_2:
+                if root_role not in existing_root_roles:
+                    account_pk = uuid4()
+                    role_meta = ROOT_GROUP_META[root_role]
+                    coa_root_account_model.add_child(
+                        instance=AccountModel(
+                            uuid=account_pk,
+                            code=role_meta['code'],
+                            name=role_meta['title'],
+                            coa_model=self,
+                            role=root_role,
+                            active=False,
+                            locked=True,
+                            balance_type=role_meta['balance_type']
+                        ))
+
+    def validate_account_model_qs(self, account_model_qs: AccountModelQuerySet):
+        if not isinstance(account_model_qs, AccountModelQuerySet):
+            raise ChartOfAccountsModelValidationError(
+                message='Must pass an instance of AccountModelQuerySet'
+            )
+        for acc_model in account_model_qs:
+            if not acc_model.coa_model_id == self.uuid:
+                raise ChartOfAccountsModelValidationError(
+                    message=f'Invalid root queryset for CoA {self.name}'
+                )
+
+    def create_account(self, account_model: AccountModel, root_account_qs: Optional[AccountModelQuerySet] = None):
+        if not account_model.coa_model_id:
+
+            if not root_account_qs:
+                root_account_qs = self.get_coa_root_accounts_qs()
+            else:
+                self.validate_account_model_qs(root_account_qs)
+
+            l2_root_node: AccountModel = self.get_coa_l2_root(account_model, root_account_qs=root_account_qs)
+
+            account_model.coa_model = self
+            account_model = l2_root_node.add_child(instance=account_model)
+        return account_model
+
+    # ACTIONS -----
+
+    # todo: use these methods once multi CoA fetures are enabled...
+    def lock_all_accounts(self) -> AccountModelQuerySet:
+        non_root_accounts_qs = self.get_non_root_coa_accounts_qs()
+        non_root_accounts_qs.update(locked=True)
+        return non_root_accounts_qs
+
+    def unlock_all_accounts(self) -> AccountModelQuerySet:
+        non_root_accounts_qs = self.get_non_root_coa_accounts_qs()
+        non_root_accounts_qs.update(locked=False)
+        return non_root_accounts_qs
+
 
 class ChartOfAccountModel(ChartOfAccountModelAbstract):
     """
     Base ChartOfAccounts Model
     """
```

## django_ledger/models/coa_default.py

```diff
@@ -1,159 +1,368 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
-Miguel Sanda <msanda@arrobalytics.com>
-Pranav P Tulshyan <ptulshyan77@gmail.com>
-"""
-
-"""
-This is the base Chart of Accounts that has all the possible accounts that are useful for the prepeartion of the Financial Statements.
+    * Miguel Sanda <msanda@arrobalytics.com>
+    * Pranav P Tulshyan <ptulshyan77@gmail.com>
 
-The Chart of Accounts is Braodly Bifurcted into 5 different Sections:
-
-1. Assets:
-2. Liabilities
-3. Shareholder's Equity
-4. Expenses 
-5. Revenue
+This is the base Chart of Accounts that has all the possible accounts that are useful for the preparation of the
+Financial Statements. A user may choose to use the default CoA at the creation of each EntityModel but it is not
+required. The default CoA is intended to provide a QuickStart solution for most use cases.
+
+The Chart of Accounts is broadly bifurcated into 5 different Sections:
+    1. Assets:
+    2. Liabilities
+    3. Shareholder's Equity
+    4. Expenses
+    5. Revenue
+
+The Django Ledger Default Chart of Accounts must include the following fields:
+    * Code - String
+    * Role - A choice from any of the possible account roles (see django_ledger.roles module).
+    * Balance Type - A CREDIT or DEBIT balance account setting.
+    * Name - A human readable name.
+    * Parent - The parent account of the AccountModel instance.
+
+If the DEFAULT_CHART_OF_ACCOUNTS setting is present, the default CoA will be replace by such setting.
+
+Default Chart of Accounts Table
+===============================
+
+======  ==========================  ==============  ===================================================  ========  ================
+  code  role                        balance_type    name                                                   parent  root_group
+======  ==========================  ==============  ===================================================  ========  ================
+  1910  asset_adjustment            debit           Securities Unrealized Gains/Losses                             root_assets
+  1920  asset_adjustment            debit           PPE Unrealized Gains/Losses                                    root_assets
+  1010  asset_ca_cash               debit           Cash                                                           root_assets
+  1200  asset_ca_inv                debit           Inventory                                                      root_assets
+  1050  asset_ca_mkt_sec            debit           Short Term Investments                                         root_assets
+  1300  asset_ca_prepaid            debit           Prepaid Expenses                                               root_assets
+  1100  asset_ca_recv               debit           Accounts Receivable                                            root_assets
+  1110  asset_ca_uncoll             credit          Uncollectibles                                                 root_assets
+  1810  asset_ia                    debit           Goodwill                                                       root_assets
+  1820  asset_ia                    debit           Intellectual Property                                          root_assets
+  1830  asset_ia_accum_amort        credit          Less: Intangible Assets Accumulated Amortization               root_assets
+  1520  asset_lti_land              debit           Land                                                           root_assets
+  1510  asset_lti_notes             debit           Notes Receivable                                               root_assets
+  1530  asset_lti_sec               debit           Securities                                                     root_assets
+  1610  asset_ppe_build             debit           Buildings                                                      root_assets
+  1611  asset_ppe_build_accum_depr  credit          Less: Buildings Accumulated Depreciation                       root_assets
+  1630  asset_ppe_equip             debit           Equipment                                                      root_assets
+  1631  asset_ppe_equip_accum_depr  credit          Less: Equipment Accumulated Depreciation                       root_assets
+  1620  asset_ppe_plant             debit           Plant                                                          root_assets
+  1640  asset_ppe_plant             debit           Vehicles                                                       root_assets
+  1650  asset_ppe_plant             debit           Furniture & Fixtures                                           root_assets
+  1621  asset_ppe_plant_depr        credit          Less: Plant Accumulated Depreciation                           root_assets
+  1641  asset_ppe_plant_depr        credit          Less: Vehicles Accumulated Depreciation                        root_assets
+  1651  asset_ppe_plant_depr        credit          Less: Furniture & Fixtures Accumulated Depreciation            root_assets
+  3910  eq_adjustment               credit          Available for Sale                                             root_capital
+  3920  eq_adjustment               credit          PPE Unrealized Gains/Losses                                    root_capital
+  3010  eq_capital                  credit          Capital Account 1                                              root_capital
+  3020  eq_capital                  credit          Capital Account 2                                              root_capital
+  3030  eq_capital                  credit          Capital Account 3                                              root_capital
+  3930  eq_dividends                debit           Dividends & Distributions                                      root_capital
+  3110  eq_stock_common             credit          Common Stock                                                   root_capital
+  3120  eq_stock_preferred          credit          Preferred Stock                                                root_capital
+  5010  cogs_regular                debit           Cost of Goods Sold                                             root_cogs
+  6075  ex_amortization             debit           Amortization Expense                                           root_expenses
+  6070  ex_depreciation             debit           Depreciation Expense                                           root_expenses
+  6130  ex_interest                 debit           Interest Expense                                               root_expenses
+  6500  ex_other                    debit           Misc. Expense                                                  root_expenses
+  6010  ex_regular                  debit           Advertising                                                    root_expenses
+  6020  ex_regular                  debit           Amortization                                                   root_expenses
+  6030  ex_regular                  debit           Auto Expense                                                   root_expenses
+  6040  ex_regular                  debit           Bad Debt                                                       root_expenses
+  6050  ex_regular                  debit           Bank Charges                                                   root_expenses
+  6060  ex_regular                  debit           Commission Expense                                             root_expenses
+  6080  ex_regular                  debit           Employee Benefits                                               root_expenses
+  6090  ex_regular                  debit           Freight                                                        root_expenses
+  6110  ex_regular                  debit           Gifts                                                          root_expenses
+  6120  ex_regular                  debit           Insurance                                                      root_expenses
+  6140  ex_regular                  debit           Professional Fees                                              root_expenses
+  6150  ex_regular                  debit           License Expense                                                root_expenses
+  6170  ex_regular                  debit           Maintenance Expense                                            root_expenses
+  6180  ex_regular                  debit           Meals & Entertainment                                          root_expenses
+  6190  ex_regular                  debit           Office Expense                                                  root_expenses
+  6220  ex_regular                  debit           Printing                                                       root_expenses
+  6230  ex_regular                  debit           Postage                                                        root_expenses
+  6240  ex_regular                  debit           Rent                                                           root_expenses
+  6250  ex_regular                  debit           Maintenance & Repairs                                          root_expenses
+  6251  ex_regular                  debit           Maintenance                                                    root_expenses
+  6252  ex_regular                  debit           Repairs                                                        root_expenses
+  6253  ex_regular                  debit           HOA                                                            root_expenses
+  6254  ex_regular                  debit           Snow Removal                                                   root_expenses
+  6255  ex_regular                  debit           Lawn Care                                                      root_expenses
+  6260  ex_regular                  debit           Salaries                                                       root_expenses
+  6270  ex_regular                  debit           Supplies                                                       root_expenses
+  6290  ex_regular                  debit           Utilities                                                      root_expenses
+  6292  ex_regular                  debit           Sewer                                                          root_expenses
+  6293  ex_regular                  debit           Gas                                                            root_expenses
+  6294  ex_regular                  debit           Garbage                                                        root_expenses
+  6295  ex_regular                  debit           Electricity                                                    root_expenses
+  6300  ex_regular                  debit           Property Management                                            root_expenses
+  6400  ex_regular                  debit           Vacancy                                                        root_expenses
+  6210  ex_taxes                    debit           Payroll Taxes                                                  root_expenses
+  6280  ex_taxes                    debit           Taxes                                                          root_expenses
+  4040  in_gain_loss                credit          Capital Gain/Loss Income                                       root_income
+  4030  in_interest                 credit          Interest Income                                                root_income
+  4010  in_operational              credit          Sales Income                                                   root_income
+  4050  in_other                    credit          Other Income                                                   root_income
+  4020  in_passive                  credit          Investing Income                                               root_income
+  2010  lia_cl_acc_payable          credit          Accounts Payable                                               root_liabilities
+  2060  lia_cl_def_rev              credit          Deferred Revenues                                              root_liabilities
+  2030  lia_cl_int_payable          credit          Interest Payable                                               root_liabilities
+  2050  lia_cl_ltd_mat              credit          Current Maturities LT Debt                                     root_liabilities
+  2070  lia_cl_other                credit          Other Payables                                                 root_liabilities
+  2040  lia_cl_st_notes_payable     credit          Short-Term Notes Payable                                       root_liabilities
+  2020  lia_cl_wages_payable        credit          Wages Payable                                                  root_liabilities
+  2120  lia_ltl_bonds               credit          Bonds Payable                                                  root_liabilities
+  2130  lia_ltl_mortgage            credit          Mortgage Payable                                               root_liabilities
+  2110  lia_ltl_notes               credit          Long Term Notes Payable                                        root_liabilities
+======  ==========================  ==============  ===================================================  ========  ================
 """
 
-
 from itertools import groupby
+from typing import Optional, Dict, List
+
+from django_ledger.exceptions import DjangoLedgerConfigurationError
+from django_ledger.io import roles, ROOT_ASSETS, ROOT_INCOME, ROOT_EXPENSES, ROOT_LIABILITIES, ROOT_CAPITAL, ROOT_COGS
+from django_ledger.settings import DJANGO_LEDGER_DEFAULT_COA
 
-from django_ledger.io import roles
+# todo: include a function to use a user-defined CHART_OF_ACCOUNTS option.
 
-CHART_OF_ACCOUNTS = [
+DEFAULT_CHART_OF_ACCOUNTS = [
 
     # ---------# ASSETS START #---------#
     # CURRENT ASSETS  ------
     {'code': '1010', 'role': roles.ASSET_CA_CASH, 'balance_type': 'debit', 'name': 'Cash', 'parent': None},
-    {'code': '1050', 'role': roles.ASSET_CA_MKT_SECURITIES, 'balance_type': 'debit', 'name': 'Short Term Investments', 'parent': None},
-    {'code': '1100', 'role': roles.ASSET_CA_RECEIVABLES, 'balance_type': 'debit', 'name': 'Accounts Receivable', 'parent': None},
-    {'code': '1110', 'role': roles.ASSET_CA_UNCOLLECTIBLES, 'balance_type': 'credit', 'name': 'Uncollectibles', 'parent': None},
+    {'code': '1050', 'role': roles.ASSET_CA_MKT_SECURITIES, 'balance_type': 'debit', 'name': 'Short Term Investments',
+     'parent': None},
+    {'code': '1100', 'role': roles.ASSET_CA_RECEIVABLES, 'balance_type': 'debit', 'name': 'Accounts Receivable',
+     'parent': None},
+    {'code': '1110', 'role': roles.ASSET_CA_UNCOLLECTIBLES, 'balance_type': 'credit', 'name': 'Uncollectibles',
+     'parent': None},
     {'code': '1200', 'role': roles.ASSET_CA_INVENTORY, 'balance_type': 'debit', 'name': 'Inventory', 'parent': None},
-    {'code': '1300', 'role': roles.ASSET_CA_PREPAID, 'balance_type': 'debit', 'name': 'Prepaid Expenses', 'parent': None},
+    {'code': '1300', 'role': roles.ASSET_CA_PREPAID, 'balance_type': 'debit', 'name': 'Prepaid Expenses',
+     'parent': None},
 
     # LONG TERM INVESTMENTS ------
-    {'code': '1510', 'role': roles.ASSET_LTI_NOTES_RECEIVABLE, 'balance_type': 'debit', 'name': 'Notes Receivable', 'parent': None},
+    {'code': '1510', 'role': roles.ASSET_LTI_NOTES_RECEIVABLE, 'balance_type': 'debit', 'name': 'Notes Receivable',
+     'parent': None},
     {'code': '1520', 'role': roles.ASSET_LTI_LAND, 'balance_type': 'debit', 'name': 'Land', 'parent': None},
     {'code': '1530', 'role': roles.ASSET_LTI_SECURITIES, 'balance_type': 'debit', 'name': 'Securities', 'parent': None},
 
     # PPE ------
     {'code': '1610', 'role': roles.ASSET_PPE_BUILDINGS, 'balance_type': 'debit', 'name': 'Buildings', 'parent': None},
-    {'code': '1611', 'role': roles.ASSET_PPE_BUILDINGS_ACCUM_DEPRECIATION, 'balance_type': 'credit', 'name': 'Less: Buildings Accumulated Depreciation', 'parent': None},
+    {'code': '1611', 'role': roles.ASSET_PPE_BUILDINGS_ACCUM_DEPRECIATION, 'balance_type': 'credit',
+     'name': 'Less: Buildings Accumulated Depreciation', 'parent': None},
     {'code': '1620', 'role': roles.ASSET_PPE_PLANT, 'balance_type': 'debit', 'name': 'Plant', 'parent': None},
-    {'code': '1621', 'role': roles.ASSET_PPE_PLANT_ACCUM_DEPRECIATION, 'balance_type': 'credit', 'name': 'Less: Plant Accumulated Depreciation', 'parent': None},
+    {'code': '1621', 'role': roles.ASSET_PPE_PLANT_ACCUM_DEPRECIATION, 'balance_type': 'credit',
+     'name': 'Less: Plant Accumulated Depreciation', 'parent': None},
     {'code': '1630', 'role': roles.ASSET_PPE_EQUIPMENT, 'balance_type': 'debit', 'name': 'Equipment', 'parent': None},
-    {'code': '1631', 'role': roles.ASSET_PPE_EQUIPMENT_ACCUM_DEPRECIATION, 'balance_type': 'credit', 'name': 'Less: Equipment Accumulated Depreciation', 'parent': None},
+    {'code': '1631', 'role': roles.ASSET_PPE_EQUIPMENT_ACCUM_DEPRECIATION, 'balance_type': 'credit',
+     'name': 'Less: Equipment Accumulated Depreciation', 'parent': None},
     {'code': '1640', 'role': roles.ASSET_PPE_PLANT, 'balance_type': 'debit', 'name': 'Vehicles', 'parent': None},
-    {'code': '1641', 'role': roles.ASSET_PPE_PLANT_ACCUM_DEPRECIATION, 'balance_type': 'credit', 'name': 'Less: Vehicles Accumulated Depreciation', 'parent': None},
-    {'code': '1650', 'role': roles.ASSET_PPE_PLANT, 'balance_type': 'debit', 'name': 'Furniture & Fixtures', 'parent': None},
-    {'code': '1651', 'role': roles.ASSET_PPE_PLANT_ACCUM_DEPRECIATION, 'balance_type': 'credit', 'name': 'Less: Furniture & Fixtures Accumulated Depreciation', 'parent': None},
+    {'code': '1641', 'role': roles.ASSET_PPE_PLANT_ACCUM_DEPRECIATION, 'balance_type': 'credit',
+     'name': 'Less: Vehicles Accumulated Depreciation', 'parent': None},
+    {'code': '1650', 'role': roles.ASSET_PPE_PLANT, 'balance_type': 'debit', 'name': 'Furniture & Fixtures',
+     'parent': None},
+    {'code': '1651', 'role': roles.ASSET_PPE_PLANT_ACCUM_DEPRECIATION, 'balance_type': 'credit',
+     'name': 'Less: Furniture & Fixtures Accumulated Depreciation', 'parent': None},
 
     # INTANGIBLE ASSETS ------
-    {'code': '1810', 'role': roles.ASSET_INTANGIBLE_ASSETS, 'balance_type': 'debit', 'name': 'Goodwill', 'parent': None},
-    {'code': '1820', 'role': roles.ASSET_INTANGIBLE_ASSETS, 'balance_type': 'debit', 'name': 'Intellectual Property', 'parent': None},
-    {'code': '1830', 'role': roles.ASSET_INTANGIBLE_ASSETS_ACCUM_AMORTIZATION, 'balance_type': 'credit', 'name': 'Less: Intangible Assets Accumulated Amortization', 'parent': '1820'},
+    {'code': '1810', 'role': roles.ASSET_INTANGIBLE_ASSETS, 'balance_type': 'debit', 'name': 'Goodwill',
+     'parent': None},
+    {'code': '1820', 'role': roles.ASSET_INTANGIBLE_ASSETS, 'balance_type': 'debit', 'name': 'Intellectual Property',
+     'parent': None},
+    {'code': '1830', 'role': roles.ASSET_INTANGIBLE_ASSETS_ACCUM_AMORTIZATION, 'balance_type': 'credit',
+     'name': 'Less: Intangible Assets Accumulated Amortization', 'parent': '1820'},
 
     # ADJUSTMENTS ------
-    {'code': '1910', 'role': roles.ASSET_ADJUSTMENTS, 'balance_type': 'debit', 'name': 'Securities Unrealized Gains/Losses', 'parent': None},
-    {'code': '1920', 'role': roles.ASSET_ADJUSTMENTS, 'balance_type': 'debit', 'name': 'PPE Unrealized Gains/Losses', 'parent': None},
+    {'code': '1910', 'role': roles.ASSET_ADJUSTMENTS, 'balance_type': 'debit',
+     'name': 'Securities Unrealized Gains/Losses', 'parent': None},
+    {'code': '1920', 'role': roles.ASSET_ADJUSTMENTS, 'balance_type': 'debit', 'name': 'PPE Unrealized Gains/Losses',
+     'parent': None},
 
     # ---------# ASSETS END #---------#
 
     # ---------# LIABILITIES START #---------#
     # CURRENT LIABILITIES ------
-    {'code': '2010', 'role': roles.LIABILITY_CL_ACC_PAYABLE, 'balance_type': 'credit', 'name': 'Accounts Payable', 'parent': None},
-    {'code': '2020', 'role': roles.LIABILITY_CL_WAGES_PAYABLE, 'balance_type': 'credit', 'name': 'Wages Payable', 'parent': None},
-    {'code': '2030', 'role': roles.LIABILITY_CL_INTEREST_PAYABLE, 'balance_type': 'credit', 'name': 'Interest Payable', 'parent': None},
-    {'code': '2040', 'role': roles.LIABILITY_CL_ST_NOTES_PAYABLE, 'balance_type': 'credit', 'name': 'Short-Term Notes Payable', 'parent': None},
-    {'code': '2050', 'role': roles.LIABILITY_CL_LTD_MATURITIES, 'balance_type': 'credit', 'name': 'Current Maturities LT Debt', 'parent': None},
-    {'code': '2060', 'role': roles.LIABILITY_CL_DEFERRED_REVENUE, 'balance_type': 'credit', 'name': 'Deferred Revenues', 'parent': None},
-    {'code': '2070', 'role': roles.LIABILITY_CL_OTHER, 'balance_type': 'credit', 'name': 'Other Payables', 'parent': None},
+    {'code': '2010', 'role': roles.LIABILITY_CL_ACC_PAYABLE, 'balance_type': 'credit', 'name': 'Accounts Payable',
+     'parent': None},
+    {'code': '2020', 'role': roles.LIABILITY_CL_WAGES_PAYABLE, 'balance_type': 'credit', 'name': 'Wages Payable',
+     'parent': None},
+    {'code': '2030', 'role': roles.LIABILITY_CL_INTEREST_PAYABLE, 'balance_type': 'credit', 'name': 'Interest Payable',
+     'parent': None},
+    {'code': '2040', 'role': roles.LIABILITY_CL_ST_NOTES_PAYABLE, 'balance_type': 'credit',
+     'name': 'Short-Term Notes Payable', 'parent': None},
+    {'code': '2050', 'role': roles.LIABILITY_CL_LTD_MATURITIES, 'balance_type': 'credit',
+     'name': 'Current Maturities LT Debt', 'parent': None},
+    {'code': '2060', 'role': roles.LIABILITY_CL_DEFERRED_REVENUE, 'balance_type': 'credit', 'name': 'Deferred Revenues',
+     'parent': None},
+    {'code': '2070', 'role': roles.LIABILITY_CL_OTHER, 'balance_type': 'credit', 'name': 'Other Payables',
+     'parent': None},
 
     # LIABILITIES ACCOUNTS ------
-    {'code': '2110', 'role': roles.LIABILITY_LTL_NOTES_PAYABLE, 'balance_type': 'credit', 'name': 'Long Term Notes Payable', 'parent': None},
-    {'code': '2120', 'role': roles.LIABILITY_LTL_BONDS_PAYABLE, 'balance_type': 'credit', 'name': 'Bonds Payable', 'parent': None},
-    {'code': '2130', 'role': roles.LIABILITY_LTL_MORTGAGE_PAYABLE, 'balance_type': 'credit', 'name': 'Mortgage Payable', 'parent': None},
+    {'code': '2110', 'role': roles.LIABILITY_LTL_NOTES_PAYABLE, 'balance_type': 'credit',
+     'name': 'Long Term Notes Payable', 'parent': None},
+    {'code': '2120', 'role': roles.LIABILITY_LTL_BONDS_PAYABLE, 'balance_type': 'credit', 'name': 'Bonds Payable',
+     'parent': None},
+    {'code': '2130', 'role': roles.LIABILITY_LTL_MORTGAGE_PAYABLE, 'balance_type': 'credit', 'name': 'Mortgage Payable',
+     'parent': None},
 
     # ---------# LIABILITIES END #---------#
 
     # ---------# SHEREHOLDERS EQUITY START #---------#
     # CAPITAL ACCOUNTS ------
-    {'code': '3010', 'role': roles.EQUITY_CAPITAL, 'balance_type': 'credit', 'name': 'Capital Account 1', 'parent': None},
-    {'code': '3020', 'role': roles.EQUITY_CAPITAL, 'balance_type': 'credit', 'name': 'Capital Account 2', 'parent': None},
-    {'code': '3030', 'role': roles.EQUITY_CAPITAL, 'balance_type': 'credit', 'name': 'Capital Account 3', 'parent': None},
+    {'code': '3010', 'role': roles.EQUITY_CAPITAL, 'balance_type': 'credit', 'name': 'Capital Account 1',
+     'parent': None},
+    {'code': '3020', 'role': roles.EQUITY_CAPITAL, 'balance_type': 'credit', 'name': 'Capital Account 2',
+     'parent': None},
+    {'code': '3030', 'role': roles.EQUITY_CAPITAL, 'balance_type': 'credit', 'name': 'Capital Account 3',
+     'parent': None},
+
+    {'code': '3110', 'role': roles.EQUITY_COMMON_STOCK, 'balance_type': 'credit', 'name': 'Common Stock',
+     'parent': None},
+    {'code': '3120', 'role': roles.EQUITY_PREFERRED_STOCK, 'balance_type': 'credit', 'name': 'Preferred Stock',
+     'parent': None},
+
+    {'code': '3910', 'role': roles.EQUITY_ADJUSTMENT, 'balance_type': 'credit', 'name': 'Available for Sale',
+     'parent': None},
+    {'code': '3920', 'role': roles.EQUITY_ADJUSTMENT, 'balance_type': 'credit', 'name': 'PPE Unrealized Gains/Losses',
+     'parent': None},
 
-    {'code': '3110', 'role': roles.EQUITY_COMMON_STOCK, 'balance_type': 'credit', 'name': 'Common Stock', 'parent': None},
-    {'code': '3120', 'role': roles.EQUITY_PREFERRED_STOCK, 'balance_type': 'credit', 'name': 'Preferred Stock', 'parent': None},
-
-    {'code': '3910', 'role': roles.EQUITY_ADJUSTMENT, 'balance_type': 'credit', 'name': 'Available for Sale', 'parent': None},
-    {'code': '3920', 'role': roles.EQUITY_ADJUSTMENT, 'balance_type': 'credit', 'name': 'PPE Unrealized Gains/Losses', 'parent': None},
-
-    {'code': '3930', 'role': roles.EQUITY_DIVIDENDS, 'balance_type': 'debit', 'name': 'Dividends & Distributions', 'parent': None},
+    {'code': '3930', 'role': roles.EQUITY_DIVIDENDS, 'balance_type': 'debit', 'name': 'Dividends & Distributions',
+     'parent': None},
 
     # REVENUE ACCOUNTS ------
-    {'code': '4010', 'role': roles.INCOME_OPERATIONAL, 'balance_type': 'credit', 'name': 'Sales Income', 'parent': None},
-    {'code': '4020', 'role': roles.INCOME_INVESTING, 'balance_type': 'credit', 'name': 'Investing Income', 'parent': None},
-    {'code': '4030', 'role': roles.INCOME_INTEREST, 'balance_type': 'credit', 'name': 'Interest Income', 'parent': None},
-    {'code': '4040', 'role': roles.INCOME_CAPITAL_GAIN_LOSS, 'balance_type': 'credit', 'name': 'Capital Gain/Loss Income', 'parent': None},
+    {'code': '4010', 'role': roles.INCOME_OPERATIONAL, 'balance_type': 'credit', 'name': 'Sales Income',
+     'parent': None},
+    {'code': '4020', 'role': roles.INCOME_INVESTING, 'balance_type': 'credit', 'name': 'Investing Income',
+     'parent': None},
+    {'code': '4030', 'role': roles.INCOME_INTEREST, 'balance_type': 'credit', 'name': 'Interest Income',
+     'parent': None},
+    {'code': '4040', 'role': roles.INCOME_CAPITAL_GAIN_LOSS, 'balance_type': 'credit',
+     'name': 'Capital Gain/Loss Income', 'parent': None},
     {'code': '4050', 'role': roles.INCOME_OTHER, 'balance_type': 'credit', 'name': 'Other Income', 'parent': None},
 
     # COGS ACCOUNTS ------
     {'code': '5010', 'role': roles.COGS, 'balance_type': 'debit', 'name': 'Cost of Goods Sold', 'parent': None},
 
     # EXPENSE ACCOUNTS ------
-    {'code': '6010', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Advertising', 'parent': None},
-    {'code': '6020', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Amortization', 'parent': None},
-    {'code': '6030', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Auto Expense', 'parent': None},
-    {'code': '6040', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Bad Debt', 'parent': None},
-    {'code': '6050', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Bank Charges', 'parent': None},
-    {'code': '6060', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Commission Expense', 'parent': None},
-    {'code': '6080', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Employee Benefits', 'parent': None},
-    {'code': '6090', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Freight', 'parent': None},
-    {'code': '6110', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Gifts', 'parent': None},
-    {'code': '6120', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Insurance', 'parent': None},
-    {'code': '6140', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Professional Fees', 'parent': None},
-    {'code': '6150', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'License Expense', 'parent': None},
-    {'code': '6170', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Maintenance Expense', 'parent': None},
-    {'code': '6180', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Meals & Entertainment', 'parent': None},
-    {'code': '6190', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Office Expense', 'parent': None},
-    {'code': '6220', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Printing', 'parent': None},
-    {'code': '6230', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Postage', 'parent': None},
-    {'code': '6240', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Rent', 'parent': None},
-    {'code': '6250', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Maintenance & Repairs', 'parent': None},
-    {'code': '6251', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Maintenance', 'parent': None},
-    {'code': '6252', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Repairs', 'parent': None},
-    {'code': '6253', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'HOA', 'parent': None},
-    {'code': '6254', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Snow Removal', 'parent': None},
-    {'code': '6255', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Lawn Care', 'parent': None},
-    {'code': '6260', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Salaries', 'parent': None},
-    {'code': '6270', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Supplies', 'parent': None},
-    {'code': '6290', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Utilities', 'parent': None},
-    {'code': '6292', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Sewer', 'parent': None},
-    {'code': '6293', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Gas', 'parent': None},
-    {'code': '6294', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Garbage', 'parent': None},
-    {'code': '6295', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Electricity', 'parent': None},
-    {'code': '6300', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Property Management', 'parent': None},
-    {'code': '6400', 'role': roles.EXPENSE_REGULAR, 'balance_type': 'debit', 'name': 'Vacancy', 'parent': None},
-
-
-    {'code': '6070', 'role': roles.EXPENSE_DEPRECIATION, 'balance_type': 'debit', 'name': 'Depreciation Expense', 'parent': None},
-    {'code': '6075', 'role': roles.EXPENSE_AMORTIZATION, 'balance_type': 'debit', 'name': 'Amortization Expense', 'parent': None},
-    {'code': '6130', 'role': roles.EXPENSE_INTEREST, 'balance_type': 'debit', 'name': 'Interest Expense', 'parent': None},
+    {'code': '6010', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Advertising', 'parent': None},
+    {'code': '6020', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Amortization',
+     'parent': None},
+    {'code': '6030', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Auto Expense',
+     'parent': None},
+    {'code': '6040', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Bad Debt', 'parent': None},
+    {'code': '6050', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Bank Charges',
+     'parent': None},
+    {'code': '6060', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Commission Expense',
+     'parent': None},
+    {'code': '6080', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Employee Benefits',
+     'parent': None},
+    {'code': '6090', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Freight', 'parent': None},
+    {'code': '6110', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Gifts', 'parent': None},
+    {'code': '6120', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Insurance', 'parent': None},
+    {'code': '6140', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Professional Fees',
+     'parent': None},
+    {'code': '6150', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'License Expense',
+     'parent': None},
+    {'code': '6170', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Maintenance Expense',
+     'parent': None},
+    {'code': '6180', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Meals & Entertainment',
+     'parent': None},
+    {'code': '6190', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Office Expense',
+     'parent': None},
+    {'code': '6220', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Printing', 'parent': None},
+    {'code': '6230', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Postage', 'parent': None},
+    {'code': '6240', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Rent', 'parent': None},
+    {'code': '6250', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Maintenance & Repairs',
+     'parent': None},
+    {'code': '6251', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Maintenance', 'parent': None},
+    {'code': '6252', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Repairs', 'parent': None},
+    {'code': '6253', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'HOA', 'parent': None},
+    {'code': '6254', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Snow Removal',
+     'parent': None},
+    {'code': '6255', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Lawn Care', 'parent': None},
+    {'code': '6260', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Salaries', 'parent': None},
+    {'code': '6270', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Supplies', 'parent': None},
+    {'code': '6290', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Utilities', 'parent': None},
+    {'code': '6292', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Sewer', 'parent': None},
+    {'code': '6293', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Gas', 'parent': None},
+    {'code': '6294', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Garbage', 'parent': None},
+    {'code': '6295', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Electricity', 'parent': None},
+    {'code': '6300', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Property Management',
+     'parent': None},
+    {'code': '6400', 'role': roles.EXPENSE_OPERATIONAL, 'balance_type': 'debit', 'name': 'Vacancy', 'parent': None},
+
+    {'code': '6070', 'role': roles.EXPENSE_DEPRECIATION, 'balance_type': 'debit', 'name': 'Depreciation Expense',
+     'parent': None},
+    {'code': '6075', 'role': roles.EXPENSE_AMORTIZATION, 'balance_type': 'debit', 'name': 'Amortization Expense',
+     'parent': None},
+    {'code': '6130', 'role': roles.EXPENSE_INTEREST, 'balance_type': 'debit', 'name': 'Interest Expense',
+     'parent': None},
     {'code': '6210', 'role': roles.EXPENSE_TAXES, 'balance_type': 'debit', 'name': 'Payroll Taxes', 'parent': None},
     {'code': '6280', 'role': roles.EXPENSE_TAXES, 'balance_type': 'debit', 'name': 'Taxes', 'parent': None},
     {'code': '6500', 'role': roles.EXPENSE_OTHER, 'balance_type': 'debit', 'name': 'Misc. Expense', 'parent': None}
 
 ]
 
+PREFIX_MAP = {
+    'in': ROOT_INCOME,
+    'ex': ROOT_EXPENSES,
+    'lia': ROOT_LIABILITIES,
+    'eq': ROOT_CAPITAL,
+    'asset': ROOT_ASSETS,
+    'cogs': ROOT_COGS
+}
+
+for i in DEFAULT_CHART_OF_ACCOUNTS:
+    i['root_group'] = PREFIX_MAP[i['role'].split('_')[0]]
+
+DEFAULT_CHART_OF_ACCOUNTS.sort(key=lambda x: (x['root_group'], x['role'], x['code']))
+CHART_OF_ACCOUNTS_ROOT_MAP = {
+    k: list(v) for k, v in groupby(DEFAULT_CHART_OF_ACCOUNTS, key=lambda x: x['root_group'])
+}
+
 
 def verify_unique_code():
-    code_list = list(i['code'] for i in CHART_OF_ACCOUNTS)
-    code_list.sort()
-    code_gb = groupby(code_list)
-    return {
-        code: sum([bool(v) for v in l]) for code, l in code_gb
-    }
+    """
+    A function that verifies that there are no duplicate code in the Default CoA during the development and launch.
+    """
+    code_list = [i['code'] for i in DEFAULT_CHART_OF_ACCOUNTS]
+    code_set = set(code_list)
+    if not len(code_list) == len(code_set):
+        raise DjangoLedgerConfigurationError('Default CoA is not unique.')
+
+
+def get_default_coa() -> List[Dict]:
+    if DJANGO_LEDGER_DEFAULT_COA is not None and isinstance(DJANGO_LEDGER_DEFAULT_COA, list):
+        return DJANGO_LEDGER_DEFAULT_COA
+    return DEFAULT_CHART_OF_ACCOUNTS
+
+
+def get_default_coa_rst(default_coa: Optional[Dict] = None) -> str:
+    """
+    Converts the provided Chart of Account into restructuredText format.
+    Parameters
+    ----------
+    default_coa:
+        A dictionary of chart of accounts. Must follow the same keys as CHART_OF_ACCOUNTS.
+
+    Returns
+    -------
+    str:
+        The table in RestructuredText format.
+    """
+    try:
+        from tabulate import tabulate
+    except ModuleNotFoundError as e:
+        raise DjangoLedgerConfigurationError(e.msg)
+    if default_coa:
+        return tabulate(default_coa, headers='keys', tablefmt='rst')
+    return tabulate(get_default_coa(), headers='keys', tablefmt='rst')
+
+
+verify_unique_code()
```

## django_ledger/models/customer.py

```diff
@@ -136,23 +136,21 @@
             A filtered CustomerModel QuerySet.
         """
         qs = self.get_queryset()
 
         if isinstance(entity_slug, lazy_loader.get_entity_model()):
             return qs.filter(
                 Q(entity_model=entity_slug) &
-                Q(active=True) &
                 (
                         Q(entity_model__admin=user_model) |
                         Q(entity_model__managers__in=[user_model])
                 )
             )
         return qs.filter(
             Q(entity_model__slug__exact=entity_slug) &
-            Q(active=True) &
             (
                     Q(entity_model__admin=user_model) |
                     Q(entity_model__managers__in=[user_model])
             )
         )
 
 
@@ -206,26 +204,28 @@
 
     objects = CustomerModelManager.from_queryset(queryset_class=CustomerModelQueryset)()
 
     class Meta:
         abstract = True
         verbose_name = _('Customer')
         indexes = [
+            models.Index(fields=['entity_model', 'customer_number']),
             models.Index(fields=['created']),
             models.Index(fields=['updated']),
             models.Index(fields=['active']),
             models.Index(fields=['hidden']),
-            models.Index(fields=['customer_number']),
         ]
         unique_together = [
             ('entity_model', 'customer_number')
         ]
 
     def __str__(self):
-        return f'Customer: {self.customer_name}'
+        if not self.customer_number:
+            f'Unknown Customer: {self.customer_name}'
+        return f'{self.customer_number}: {self.customer_name}'
 
     def can_generate_customer_number(self) -> bool:
         """
         Determines if the CustomerModel can be issued a Customer Number.
         CustomerModels have a unique sequential number, which is unique for each EntityMode/CustomerModel.
 
         Returns
```

## django_ledger/models/entity.py

```diff
@@ -23,42 +23,51 @@
 """
 from calendar import monthrange
 from collections import defaultdict
 from datetime import date, datetime
 from decimal import Decimal
 from random import choices
 from string import ascii_lowercase, digits
-from typing import Tuple, Union, Optional
-from uuid import uuid4
+from typing import Tuple, Union, Optional, List, Dict
+from uuid import uuid4, UUID
 
 from django.contrib.auth import get_user_model
 from django.core.exceptions import ValidationError
 from django.core.validators import MinValueValidator
 from django.db import models
-from django.db.models import Q
+from django.db.models import Q, QuerySet
 from django.db.models.signals import pre_save
 from django.urls import reverse
 from django.utils.text import slugify
 from django.utils.translation import gettext_lazy as _
 from treebeard.mp_tree import MP_Node, MP_NodeManager, MP_NodeQuerySet
 
-from django_ledger.io import IOMixIn
-from django_ledger.io.roles import ASSET_CA_CASH, EQUITY_CAPITAL, EQUITY_COMMON_STOCK, EQUITY_PREFERRED_STOCK
-from django_ledger.models.accounts import AccountModel
-from django_ledger.models.coa import ChartOfAccountModel
-from django_ledger.models.coa_default import CHART_OF_ACCOUNTS
+from django_ledger.io import roles as roles_module
+from django_ledger.io.io_mixin import IOMixIn
+from django_ledger.models.accounts import AccountModel, AccountModelQuerySet
+from django_ledger.models.bank_account import BankAccountModelQuerySet, BankAccountModel
+from django_ledger.models.coa import ChartOfAccountModel, ChartOfAccountModelQuerySet
+from django_ledger.models.coa_default import CHART_OF_ACCOUNTS_ROOT_MAP
+from django_ledger.models.customer import CustomerModelQueryset, CustomerModel
 from django_ledger.models.items import ItemModelQuerySet, ItemTransactionModelQuerySet
+from django_ledger.models.ledger import LedgerModel
 from django_ledger.models.mixins import CreateUpdateMixIn, SlugNameMixIn, ContactInfoMixIn, LoggingMixIn
+from django_ledger.models.unit import EntityUnitModel
 from django_ledger.models.utils import lazy_loader
+from django_ledger.models.vendor import VendorModelQuerySet, VendorModel
 
 UserModel = get_user_model()
 
 ENTITY_RANDOM_SLUG_SUFFIX = ascii_lowercase + digits
 
 
+class EntityModelValidationError(ValidationError):
+    pass
+
+
 class EntityModelQuerySet(MP_NodeQuerySet):
     """
     A custom defined EntityModel QuerySet.
     Inherits from the Materialized Path Node QuerySet Class from Django Treebeard.
     """
 
     def hidden(self):
@@ -96,15 +105,15 @@
     >>> user = request.user
     >>> entity_model_qs = EntityModel.objects.for_user(user_model=user)
 
     """
 
     def get_queryset(self):
         """Sets the custom queryset as the default."""
-        return EntityModelQuerySet(self.model).order_by('path')
+        return EntityModelQuerySet(self.model).order_by('path').select_related('admin', 'default_coa')
 
     def for_user(self, user_model):
         """
         This QuerySet guarantees that Users do not access or operate on EntityModels that don't have access to.
         This is the recommended initial QuerySet.
 
         Parameters
@@ -147,15 +156,34 @@
 
         Examples
         ________
             * 1 -> January.
             * 4 -> April.
             * 9 -> September.
         """
-        fy: int = getattr(self, 'fy_start_month')
+        # fy: int = getattr(self, 'fy_start_month')
+
+        try:
+            fy: int = getattr(self, 'fy_start_month')
+        except AttributeError:
+            # current object is not an entity, get current entity and fetch its fy_start_month value
+
+            # if current object is a detail view with an object...
+            obj = getattr(self, 'object')
+            if isinstance(obj, EntityModel):
+                entity = obj
+            elif isinstance(obj, LedgerModel):
+                entity = obj.entity
+            elif isinstance(obj, EntityUnitModel):
+                entity = obj.entity
+            elif isinstance(obj, AccountModel):
+                entity = obj.coa_model.entity
+
+            fy: int = getattr(entity, 'fy_start_month')
+
         return fy
 
     def validate_quarter(self, quarter: int):
         """
         Validates the quarter as a valid parameter for other functions.
         Makes sure that only integers 1,2,3, or 4 are used to refer to a particular Quarter.
         Prevents injection of invalid values from views into the IOMixIn.
@@ -471,16 +499,15 @@
                               verbose_name=_('Admin'))
     managers = models.ManyToManyField(UserModel,
                                       through='EntityManagementModel',
                                       related_name='managed_by',
                                       verbose_name=_('Managers'))
 
     hidden = models.BooleanField(default=False)
-    accrual_method = models.BooleanField(default=False,
-                                         verbose_name=_('Use Accrual Method'))
+    accrual_method = models.BooleanField(default=False, verbose_name=_('Use Accrual Method'))
     fy_start_month = models.IntegerField(choices=FY_MONTHS, default=1, verbose_name=_('Fiscal Year Start'))
     picture = models.ImageField(blank=True, null=True)
     objects = EntityModelManager.from_queryset(queryset_class=EntityModelQuerySet)()
 
     node_order_by = ['uuid']
 
     class Meta:
@@ -489,19 +516,36 @@
         verbose_name = _('Entity')
         verbose_name_plural = _('Entities')
         indexes = [
             models.Index(fields=['admin'])
         ]
 
     def __str__(self):
-        return f'EntityModel: {self.name}'
+        return f'EntityModel {self.slug}: {self.name}'
+
+    # ## Logging ###
+    def get_logger_name(self):
+        return f'EntityModel {self.uuid}'
+
+    # ### ACCRUAL METHODS ######
+    def get_accrual_method(self) -> str:
+        if self.is_cash_method():
+            return self.CASH_METHOD
+        return self.ACCRUAL_METHOD
+
+    def is_cash_method(self) -> bool:
+        return self.accrual_method is False
+
+    def is_accrual_method(self) -> bool:
+        return self.accrual_method is True
 
     def is_admin_user(self, user_model):
         return user_model.id == self.admin_id
 
+    # #### SLUG GENERATION ###
     @staticmethod
     def generate_slug_from_name(name: str) -> str:
         """
         Uses Django's slugify function to create a valid slug from any given string.
 
         Parameters
         ----------
@@ -546,54 +590,663 @@
         if commit:
             self.save(update_fields=[
                 'slug',
                 'updated'
             ])
         return self.slug
 
-    def recorded_inventory(self,
-                           user_model,
-                           item_qs: Optional[ItemModelQuerySet] = None,
-                           as_values: bool = True) -> ItemModelQuerySet:
+    # #### CHART OF ACCOUNTS ####
+    def has_default_coa(self) -> bool:
         """
-        Recorded inventory on the books marked as received. PurchaseOrderModel drives the ordering and receiving of
-        inventory. Once inventory is marked as "received" recorded inventory of each item is updated by calling
-        :func:`update_inventory <django_ledger.models.entity.EntityModelAbstract.update_inventory>`.
-        This function returns relevant values of the recoded inventory, including Unit of Measures.
+        Determines if the EntityModel instance has a Default CoA.
+
+        Returns
+        -------
+        bool
+            True if EntityModel instance has a Default CoA.
+        """
+        return self.default_coa_id is not None
+
+    def get_default_coa(self, raise_exception: bool = True) -> Optional[ChartOfAccountModel]:
+        if not self.default_coa_id:
+            if raise_exception:
+                raise EntityModelValidationError(f'EntityModel {self.slug} does not have a default CoA')
+        return self.default_coa
+
+    def create_chart_of_accounts(self,
+                                 assign_as_default: bool = False,
+                                 coa_name: Optional[str] = None,
+                                 commit: bool = False) -> ChartOfAccountModel:
+        """
+        Creates a Chart of Accounts for the Entity Model and optionally assign it as the default Chart of Accounts.
+        EntityModel must have a default Chart of Accounts before being able to transact.
 
         Parameters
         ----------
-        user_model: UserModel
-            The Django UserModel making the request.
+        coa_name: str
+            The new CoA name. If not provided will be auto generated based on the EntityModel name.
 
-        item_qs: ItemModelQuerySet
-            Pre fetched ItemModelQuerySet. Avoids additional DB Query.
+        commit: bool
+            Commits the transaction into the DB. A ChartOfAccountModel will
 
-        as_values: bool
-            Returns a list of dictionaries by calling the Django values() QuerySet function.
+        assign_as_default: bool
+            Assigns the newly created ChartOfAccountModel as the EntityModel default_coa.
 
+        Returns
+        -------
+        ChartOfAccountModel
+            The newly created chart of accounts model.
+        """
+        # todo: this logic will generate always the same slug...
+        if not coa_name:
+            coa_name = 'Default CoA'
+
+        chart_of_accounts = ChartOfAccountModel(
+            slug=self.slug + ''.join(choices(ENTITY_RANDOM_SLUG_SUFFIX, k=6)) + '-coa',
+            name=coa_name,
+            entity=self
+        )
+        chart_of_accounts.clean()
+        chart_of_accounts.save()
+        chart_of_accounts.configure()
+
+        if assign_as_default:
+            self.default_coa = chart_of_accounts
+            if commit:
+                self.save(update_fields=[
+                    'default_coa',
+                    'updated'
+                ])
+        return chart_of_accounts
+
+    def populate_default_coa(self,
+                             activate_accounts: bool = False,
+                             force: bool = False,
+                             ignore_if_default_coa: bool = True,
+                             chart_of_accounts: Optional[ChartOfAccountModel] = None,
+                             commit: bool = True):
+
+        if not chart_of_accounts:
+            if not self.has_default_coa():
+                self.create_chart_of_accounts(assign_as_default=True, commit=commit)
+            chart_of_accounts: ChartOfAccountModel = self.default_coa
+
+        coa_accounts_qs = chart_of_accounts.accountmodel_set.all()
+
+        # forces evaluation
+        len(coa_accounts_qs)
+
+        coa_has_accounts = coa_accounts_qs.not_coa_root().exists()
+
+        if not coa_has_accounts or force:
+            root_accounts = coa_accounts_qs.is_coa_root()
+
+            root_maps = {
+                root_accounts.get(role__exact=k): [
+                    AccountModel(
+                        code=a['code'],
+                        name=a['name'],
+                        role=a['role'],
+                        balance_type=a['balance_type'],
+                        active=activate_accounts,
+                        # coa_model=chart_of_accounts,
+                    ) for a in v] for k, v in CHART_OF_ACCOUNTS_ROOT_MAP.items()
+            }
+
+            for root_acc, acc_model_list in root_maps.items():
+                roles_set = set(account_model.role for account_model in acc_model_list)
+                for i, account_model in enumerate(acc_model_list):
+                    account_model.role_default = True if account_model.role in roles_set else False
+
+                    try:
+                        roles_set.remove(account_model.role)
+                    except KeyError:
+                        pass
+
+                    account_model.clean()
+                    chart_of_accounts.create_account(account_model)
+
+        else:
+            if not ignore_if_default_coa:
+                raise ValidationError(f'Entity {self.name} already has existing accounts. '
+                                      'Use force=True to bypass this check')
+
+    def validate_chart_of_accounts_for_entity(self,
+                                              coa_model: ChartOfAccountModel,
+                                              raise_exception: bool = True) -> bool:
+        if coa_model.entity_id == self.uuid:
+            return True
+        if raise_exception:
+            raise EntityModelValidationError(
+                f'Invalid ChartOfAccounts model {coa_model.slug} for EntityModel {self.slug}')
+        return False
+
+    def validate_account_model_for_coa(self,
+                                       account_model: AccountModel,
+                                       coa_model: ChartOfAccountModel,
+                                       raise_exception: bool = True) -> bool:
+        valid = self.validate_chart_of_accounts_for_entity(coa_model, raise_exception=raise_exception)
+        if valid and account_model.coa_model_id == coa_model.uuid:
+            return True
+        if raise_exception:
+            raise EntityModelValidationError(
+                f'Invalid AccountModel model {account_model.uuid} for EntityModel {self.slug}'
+            )
+        return False
+
+    def get_all_coa_accounts(self,
+                             order_by: Optional[Tuple[str]] = ('code',),
+                             active: bool = True) -> Tuple[
+        ChartOfAccountModelQuerySet, Dict[ChartOfAccountModel, AccountModelQuerySet]]:
+
+        """
+        Fetches all the AccountModels associated with the EntityModel grouped by ChartOfAccountModel.
+
+        Parameters
+        ----------
+        active: bool
+            Selects only active accounts.
+        order_by: list of strings.
+            Optional list of fields passed to the order_by QuerySet method.
 
         Returns
         -------
-        ItemModelQuerySet
-            The ItemModelQuerySet containing inventory ItemModels with additional Unit of Measure information.
+        Tuple: Tuple[ChartOfAccountModelQuerySet, Dict[ChartOfAccountModel, AccountModelQuerySet]
+            The ChartOfAccountModelQuerySet and a grouping of AccountModels by ChartOfAccountModel as keys.
+        """
 
+        account_model_qs = ChartOfAccountModel.objects.filter(
+            entity_id=self.uuid
+        ).select_related('entity').prefetch_related('accountmodel_set')
+
+        return account_model_qs, {
+            coa_model: coa_model.accountmodel_set.filter(active=active).order_by(*order_by) for coa_model in
+            account_model_qs
+        }
+
+    # ##### ACCOUNT MANAGEMENT ######
+
+    def get_all_accounts(self, active: bool = True, order_by: Optional[Tuple[str]] = ('code',)) -> AccountModelQuerySet:
         """
-        if not item_qs:
-            recorded_qs = self.itemmodel_set.inventory(
-                entity_slug=self.slug,
-                user_model=user_model
-            )
+        Fetches all AccountModelQuerySet associated with the EntityModel.
+
+        Parameters
+        ----------
+        active: bool
+            Selects only active accounts.
+        order_by: list of strings.
+            Optional list of fields passed to the order_by QuerySet method.
+        Returns
+        -------
+        AccountModelQuerySet
+            The AccountModelQuerySet of the assigned default CoA.
+        """
+
+        account_model_qs = AccountModel.objects.filter(
+            coa_model__entity__uuid__exact=self.uuid
+        ).select_related('coa_model', 'coa_model__entity')
+
+        if active:
+            account_model_qs = account_model_qs.active()
+        if order_by:
+            account_model_qs = account_model_qs.order_by(*order_by)
+        return account_model_qs
+
+    def get_coa_accounts(self,
+                         coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                         active: bool = True,
+                         order_by: Optional[Tuple[str]] = ('code',)) -> AccountModelQuerySet:
+        """
+        Fetches the AccountModelQuerySet for a specific ChartOfAccountModel.
+
+        Parameters
+        ----------
+        coa_model: ChartOfAccountModel, UUID, str
+            The ChartOfAccountsModel UUID, model instance or slug to pull accounts from. If None, will use default CoA.
+        active: bool
+            Selects only active accounts.
+        order_by: list of strings.
+            Optional list of fields passed to the order_by QuerySet method.
+
+        Returns
+        -------
+        AccountModelQuerySet
+            The AccountModelQuerySet of the assigned default CoA.
+        """
+
+        if not coa_model:
+            account_model_qs = self.default_coa.accountmodel_set.all().select_related('coa_model', 'coa_model__entity')
         else:
-            recorded_qs = item_qs
-        if as_values:
-            return recorded_qs.values(
-                'uuid', 'name', 'uom__name', 'inventory_received', 'inventory_received_value')
-        return recorded_qs
+            account_model_qs = AccountModel.objects.filter(
+                coa_model__entity__uuid__exact=self.uuid
+            ).select_related('coa_model', 'coa_model__entity')
+
+            if isinstance(coa_model, ChartOfAccountModel):
+                self.validate_chart_of_accounts_for_entity(coa_model=coa_model, raise_exception=True)
+                account_model_qs = account_model_qs.filter(coa_model=coa_model)
+            if isinstance(coa_model, str):
+                account_model_qs = account_model_qs.filter(coa_model__slug__exact=coa_model)
+            elif isinstance(coa_model, UUID):
+                account_model_qs = account_model_qs.filter(coa_model__uuid__exact=coa_model)
+
+        if active:
+            account_model_qs = account_model_qs.active()
+
+        if order_by:
+            account_model_qs = account_model_qs.order_by(*order_by)
+
+        return account_model_qs
+
+    def get_default_coa_accounts(self,
+                                 active: bool = True,
+                                 order_by: Optional[Tuple[str]] = ('code',),
+                                 raise_exception: bool = True) -> Optional[AccountModelQuerySet]:
+        """
+        Fetches the default AccountModelQuerySet.
+
+        Parameters
+        ----------
+        active: bool
+            Selects only active accounts.
+        order_by: list of strings.
+            Optional list of fields passed to the order_by QuerySet method.
+        raise_exception: bool
+            Raises EntityModelValidationError if no default_coa found.
+
+        Returns
+        -------
+        AccountModelQuerySet
+            The AccountModelQuerySet of the assigned default CoA.
+        """
+        if not self.default_coa_id:
+            if raise_exception:
+                raise EntityModelValidationError(message=_('No default_coa found.'))
+            return
+
+        return self.get_coa_accounts(active=active, order_by=order_by)
+
+    def get_accounts_with_codes(self,
+                                code_list: Union[str, List[str]],
+                                coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None
+                                ) -> AccountModelQuerySet:
+        """
+        Fetches the AccountModelQuerySet with provided code list.
+
+        Parameters
+        ----------
+        coa_model: ChartOfAccountModel, UUID, str
+            The ChartOfAccountsModel UUID, model instance or slug to pull accounts from. Uses default Coa if not
+            provided.
+        code_list: list or str
+            Code or list of codes to fetch.
+
+        Returns
+        -------
+        AccountModelQuerySet
+            The requested AccountModelQuerySet with applied code filter.
+        """
+
+        if not coa_model:
+            account_model_qs = self.get_default_coa_accounts()
+        else:
+            account_model_qs = self.get_coa_accounts(coa_model=coa_model)
+
+        if isinstance(code_list, str):
+            return account_model_qs.filter(code__exact=code_list)
+        return account_model_qs.filter(code__in=code_list)
+
+    def get_default_account_for_role(self,
+                                     role: str,
+                                     coa_model: Optional[ChartOfAccountModel] = None,
+                                     account_model_qs: Optional[AccountModelQuerySet] = None) -> AccountModel:
+        if not coa_model:
+            coa_model = self.default_coa
+        else:
+            self.validate_chart_of_accounts_for_entity(coa_model)
+
+        if not account_model_qs:
+            return coa_model.accountmodel_set.get(role__exact=role, role_default=True)
+        return account_model_qs.get(coa_model=coa_model, role__exact=role, role_default=True)
+
+    def create_account(self,
+                       account_model_kwargs: Dict,
+                       coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                       raise_exception: bool = True) -> Tuple[ChartOfAccountModel, AccountModel]:
+        """
+        Creates a new AccountModel for the EntityModel.
+
+        Parameters
+        ----------
+        coa_model: ChartOfAccountModel, UUID, str
+            The ChartOfAccountsModel UUID, model instance or slug to pull accounts from. Uses default Coa if not
+            provided.
+        account_model_kwargs: dict
+            A dictionary of kwargs to be used to create the new AccountModel instance.
+        raise_exception: bool
+            Raises EntityModelValidationError if ChartOfAccountsModel is not valid for the EntityModel instance.
+
+        Returns
+        -------
+        A tuple of ChartOfAccountModel, AccountModel
+            The ChartOfAccountModel and AccountModel instance just created.
+        """
+        if coa_model:
+            if isinstance(coa_model, UUID):
+                coa_model = self.chartofaccountsmodel_set.get(uuid__exact=coa_model)
+            elif isinstance(coa_model, str):
+                coa_model = self.chartofaccountsmodel_set.get(slug__exact=coa_model)
+            elif isinstance(coa_model, ChartOfAccountModel):
+                self.validate_chart_of_accounts_for_entity(coa_model=coa_model, raise_exception=raise_exception)
+        else:
+            coa_model = self.default_coa
+
+        account_model = AccountModel(**account_model_kwargs)
+        account_model.clean()
+        return coa_model, coa_model.create_account(account_model=account_model)
+
+    # ### VENDOR MANAGEMENT ####
+    def get_vendors(self, active: bool = True) -> VendorModelQuerySet:
+        """
+        Fetches the VendorModels associated with the EntityModel instance.
+
+        Parameters
+        ----------
+        active: bool
+            Active VendorModels only. Defaults to True.
+
+        Returns
+        -------
+        VendorModelQuerySet
+            The EntityModel instance VendorModelQuerySet with applied filters.
+        """
+        vendor_qs = self.vendormodel_set.all().select_related('entity_model')
+        if active:
+            vendor_qs = vendor_qs.active()
+        return vendor_qs
+
+    def get_vendor_by_number(self, vendor_number: str):
+        vendor_model_qs = self.get_vendors()
+        return vendor_model_qs.get(vendor_number__exact=vendor_number)
+
+    def get_vendor_by_uuid(self, vendor_uuid: Union[str, UUID]):
+        vendor_model_qs = self.get_vendors()
+        return vendor_model_qs.get(uuid__exact=vendor_uuid)
+
+    def create_vendor(self, vendor_model_kwargs: Dict, commit: bool = True) -> VendorModel:
+        """
+        Creates a new VendorModel associated with the EntityModel instance.
+
+        Parameters
+        ----------
+        vendor_model_kwargs: dict
+            The kwargs to be used for the new VendorModel.
+        commit: bool
+            Saves the VendorModel instance in the Database.
+
+        Returns
+        -------
+        VendorModel
+        """
+        vendor_model = VendorModel(entity_model=self, **vendor_model_kwargs)
+        vendor_model.clean()
+        if commit:
+            vendor_model.save()
+        return vendor_model
+
+    # ### CUSTOMER MANAGEMENT ####
+
+    def get_customers(self, active: bool = True) -> CustomerModelQueryset:
+        """
+        Fetches the CustomerModel associated with the EntityModel instance.
+
+        Parameters
+        ----------
+        active: bool
+            Active CustomerModel only. Defaults to True.
+
+        Returns
+        -------
+        CustomerModelQueryset
+            The EntityModel instance CustomerModelQueryset with applied filters.
+        """
+        customer_model_qs = self.customermodel_set.all().select_related('entity_model')
+        if active:
+            customer_model_qs = customer_model_qs.active()
+        return customer_model_qs
+
+    def get_customer_by_number(self, customer_number: str):
+        customer_model_qs = self.get_customers()
+        return customer_model_qs.get(customer_number__exact=customer_number)
+
+    def get_customer_by_uuid(self, customer_uuid: Union[str, UUID]):
+        customer_model_qs = self.get_customers()
+        return customer_model_qs.get(uuid__exact=customer_uuid)
+
+    def validate_customer(self, customer_model: CustomerModel):
+        if customer_model.entity_model_id != self.uuid:
+            raise EntityModelValidationError(f'Invalid CustomerModel {self.uuid} for EntityModel {self.uuid}...')
+
+    def create_customer(self, customer_model_kwargs: Dict, commit: bool = True) -> CustomerModel:
+        """
+        Creates a new CustomerModel associated with the EntityModel instance.
+
+        Parameters
+        ----------
+        customer_model_kwargs: dict
+            The kwargs to be used for the new CustomerModel.
+        commit: bool
+            Saves the CustomerModel instance in the Database.
+
+        Returns
+        -------
+        CustomerModel
+        """
+        customer_model = CustomerModel(entity_model=self, **customer_model_kwargs)
+        customer_model.clean()
+        if commit:
+            customer_model.save()
+        return customer_model
+
+    # ### BILL MANAGEMENT ####
+    def get_bills(self):
+        BillModel = lazy_loader.get_bill_model()
+        return BillModel.objects.filter(
+            ledger__entity__uuid__exact=self.uuid
+        ).select_related('ledger', 'ledger__entity', 'vendor')
+
+    def create_bill(self,
+                    vendor_model: Union[VendorModel, UUID, str],
+                    xref: Optional[str] = None,
+                    cash_account: Optional[AccountModel] = None,
+                    prepaid_account: Optional[AccountModel] = None,
+                    payable_account: Optional[AccountModel] = None,
+                    additional_info: Optional[Dict] = None,
+                    ledger_name: Optional[str] = None,
+                    coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                    commit: bool = True):
+
+        BillModel = lazy_loader.get_bill_model()
+
+        if isinstance(vendor_model, VendorModel):
+            if not vendor_model.entity_model_id == self.uuid:
+                raise EntityModelValidationError(f'VendorModel {vendor_model.uuid} belongs to a different EntityModel.')
+        elif isinstance(vendor_model, UUID):
+            vendor_model = self.get_vendor_by_uuid(vendor_uuid=vendor_model)
+        elif isinstance(vendor_model, str):
+            vendor_model = self.get_vendor_by_number(vendor_number=vendor_model)
+        else:
+            raise EntityModelValidationError('VendorModel must be an instance of VendorModel, UUID or str.')
+
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+
+        account_model_qs = account_model_qs.with_roles(roles=[
+            roles_module.ASSET_CA_CASH,
+            roles_module.ASSET_CA_PREPAID,
+            roles_module.LIABILITY_CL_ACC_PAYABLE
+        ]).is_role_default()
+        # evaluates the queryset...
+        len(account_model_qs)
+
+        bill_model = BillModel(
+            vendor=vendor_model,
+            xref=xref,
+            additional_info=additional_info,
+            cash_account=account_model_qs.get(role=roles_module.ASSET_CA_CASH) if not cash_account else cash_account,
+            prepaid_account=account_model_qs.get(
+                role=roles_module.ASSET_CA_PREPAID) if not prepaid_account else prepaid_account,
+            unearned_account=account_model_qs.get(
+                role=roles_module.LIABILITY_CL_ACC_PAYABLE) if not payable_account else payable_account
+        )
+
+        _, bill_model = bill_model.configure(entity_slug=self,
+                                             ledger_name=ledger_name,
+                                             commit=commit,
+                                             commit_ledger=commit)
+
+        return bill_model
+
+    # ### INVOICE MANAGEMENT ####
+    def get_invoices(self):
+        InvoiceModel = lazy_loader.get_invoice_model()
+        return InvoiceModel.objects.filter(
+            ledger__entity__uuid__exact=self.uuid
+        ).select_related('ledger', 'ledger__entity', 'customer')
+
+    def create_invoice(self,
+                       customer_model: Union[VendorModel, UUID, str],
+                       cash_account: Optional[AccountModel] = None,
+                       prepaid_account: Optional[AccountModel] = None,
+                       payable_account: Optional[AccountModel] = None,
+                       additional_info: Optional[Dict] = None,
+                       ledger_name: Optional[str] = None,
+                       coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                       commit: bool = True):
+
+        InvoiceModel = lazy_loader.get_invoice_model()
+
+        if isinstance(customer_model, CustomerModel):
+            if not customer_model.entity_model_id == self.uuid:
+                raise EntityModelValidationError(
+                    f'CustomerModel {customer_model.uuid} belongs to a different EntityModel.')
+        elif isinstance(customer_model, UUID):
+            customer_model = self.get_customer_by_uuid(customer_uuid=customer_model)
+        elif isinstance(customer_model, str):
+            customer_model = self.get_customer_by_number(customer_number=customer_model)
+        else:
+            raise EntityModelValidationError('CustomerModel must be an instance of CustomerModel, UUID or str.')
 
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+        account_model_qs = account_model_qs.with_roles(roles=[
+            roles_module.ASSET_CA_CASH,
+            roles_module.ASSET_CA_PREPAID,
+            roles_module.LIABILITY_CL_ACC_PAYABLE
+        ]).is_role_default()
+
+        # evaluates the queryset...
+        len(account_model_qs)
+
+        invoice_model = InvoiceModel(
+            customer=customer_model,
+            additional_info=additional_info,
+            cash_account=account_model_qs.get(role=roles_module.ASSET_CA_CASH) if not cash_account else cash_account,
+            prepaid_account=account_model_qs.get(
+                role=roles_module.ASSET_CA_PREPAID) if not prepaid_account else prepaid_account,
+            unearned_account=account_model_qs.get(
+                role=roles_module.LIABILITY_CL_ACC_PAYABLE) if not payable_account else payable_account
+        )
+
+        _, invoice_model = invoice_model.configure(entity_slug=self,
+                                                   ledger_name=ledger_name,
+                                                   commit=commit,
+                                                   commit_ledger=commit)
+
+        return invoice_model
+
+    # ### PURCHASE ORDER MANAGEMENT ####
+    def get_purchase_orders(self):
+        return self.purchaseordermodel_set.all().select_related('entity')
+
+    def create_purchase_order(self,
+                              draft_date: Optional[date] = None,
+                              estimate_model=None,
+                              commit: bool = True):
+        PurchaseOrderModel = lazy_loader.get_purchase_order_model()
+        po_model = PurchaseOrderModel()
+        return po_model.configure(
+            entity_slug=self,
+            draft_date=draft_date,
+            estimate_model=estimate_model,
+            commit=commit
+        )
+
+    # ### ESTIMATE/CONTRACT MANAGEMENT ####
+    def get_estimates(self):
+        return self.estimatemodel_set.all().select_related('entity')
+
+    def create_estimate(self,
+                        estimate_title: str,
+                        customer_model: Union[CustomerModel, UUID, str],
+                        draft_date: Optional[date] = None,
+                        commit: bool = True):
+
+        if isinstance(customer_model, CustomerModel):
+            self.validate_customer(customer_model)
+        elif isinstance(customer_model, str):
+            customer_model = self.get_customer_by_number(customer_number=customer_model)
+        elif isinstance(customer_model, UUID):
+            customer_model = self.get_customer_by_uuid(customer_uuid=customer_model)
+        else:
+            raise EntityModelValidationError('CustomerModel must be an instance of CustomerModel, UUID or str.')
+
+        EstimateModel = lazy_loader.get_estimate_model()
+        estimate_model = EstimateModel()
+        return estimate_model.configure(
+            entity_slug=self,
+            date_draft=draft_date,
+            customer_model=customer_model,
+            estimate_title=estimate_title,
+            commit=commit
+        )
+
+    # ### BANK ACCOUNT MANAGEMENT ####
+    def get_bank_accounts(self, active: bool = True) -> BankAccountModelQuerySet:
+        bank_account_qs = self.bankaccountmodel_set.all().select_related('entity_model')
+        if active:
+            bank_account_qs = bank_account_qs.active()
+        return bank_account_qs
+
+    def create_bank_account(self,
+                            name: str,
+                            account_type: str,
+                            active=False,
+                            cash_account: Optional[AccountModel] = None,
+                            coa_model: Optional[Union[ChartOfAccountModel, UUID, str]] = None,
+                            bank_account_model_kwargs: Optional[Dict] = None,
+                            commit: bool = True):
+        if bank_account_model_kwargs is None:
+            bank_account_model_kwargs = dict()
+        if account_type not in BankAccountModel.VALID_ACCOUNT_TYPES:
+            raise EntityModelValidationError(
+                _(f'Invalid Account Type: choices are {BankAccountModel.VALID_ACCOUNT_TYPES}'))
+        account_model_qs = self.get_coa_accounts(coa_model=coa_model, active=True)
+        account_model_qs = account_model_qs.with_roles(roles=roles_module.ASSET_CA_CASH).is_role_default()
+        bank_account_model = BankAccountModel(
+            name=name,
+            entity_model=self,
+            account_type=account_type,
+            active=active,
+            cash_account=account_model_qs.get() if not cash_account else cash_account,
+            **bank_account_model_kwargs
+        )
+        bank_account_model.clean()
+        if commit:
+            bank_account_model.save()
+        return bank_account_model
+
+    # ##### INVENTORY MANAGEMENT ####
     @staticmethod
     def inventory_adjustment(counted_qs, recorded_qs) -> defaultdict:
         """
         Computes the necessary inventory adjustment to update balance sheet.
 
         Parameters
         ----------
@@ -733,112 +1386,53 @@
                                               'inventory_received',
                                               'inventory_received_value',
                                               'updated'
                                           ])
 
         return adj, counted_qs, recorded_qs
 
-    def has_default_coa(self):
-        return self.default_coa_id is not None
-
-    def create_chart_of_accounts(self,
-                                 assign_as_default: bool = False,
-                                 coa_name: Optional[str] = None,
-                                 commit: bool = False) -> ChartOfAccountModel:
+    def recorded_inventory(self,
+                           user_model,
+                           item_qs: Optional[ItemModelQuerySet] = None,
+                           as_values: bool = True) -> ItemModelQuerySet:
         """
-        Creates a Chart of Accounts for the Entity Model and optionally assign it as the default Chart of Accounts.
-        EntityModel must have a default Chart of Accounts before being able to transact.
+        Recorded inventory on the books marked as received. PurchaseOrderModel drives the ordering and receiving of
+        inventory. Once inventory is marked as "received" recorded inventory of each item is updated by calling
+        :func:`update_inventory <django_ledger.models.entity.EntityModelAbstract.update_inventory>`.
+        This function returns relevant values of the recoded inventory, including Unit of Measures.
 
         Parameters
         ----------
-        coa_name: str
-            The new CoA name. If not provided will be auto generated based on the EntityModel name.
+        user_model: UserModel
+            The Django UserModel making the request.
 
-        commit: bool
-            Commits the transaction into the DB. A ChartOfAccountModel will
+        item_qs: ItemModelQuerySet
+            Pre fetched ItemModelQuerySet. Avoids additional DB Query.
+
+        as_values: bool
+            Returns a list of dictionaries by calling the Django values() QuerySet function.
 
-        assign_as_default: bool
-            Assigns the newly created ChartOfAccountModel as the EntityModel default_coa.
 
         Returns
         -------
-        ChartOfAccountModel
-            The newly created chart of accounts model.
-        """
-        # todo: this logic will generate always the same slug...
-        if not coa_name:
-            coa_name = self.name + ' Default CoA'
-
-        chart_of_accounts = ChartOfAccountModel(
-            slug=self.slug + '-coa',
-            name=coa_name,
-            entity=self
-        )
-        chart_of_accounts.clean()
-        chart_of_accounts.save()
-
-        if assign_as_default:
-            self.default_coa = chart_of_accounts
-            if commit:
-                self.save(update_fields=[
-                    'default_coa',
-                    'updated'
-                ])
-        return chart_of_accounts
-
-    def populate_default_coa(self,
-                             activate_accounts: bool = False,
-                             force: bool = False,
-                             ignore_if_default_coa: bool = True,
-                             chart_of_accounts: Optional[ChartOfAccountModel] = None,
-                             commit: bool = True):
-
-        if not chart_of_accounts:
-            if not self.has_default_coa():
-                self.create_chart_of_accounts(assign_as_default=True, coa_name='Default', commit=commit)
-            chart_of_accounts: ChartOfAccountModel = self.default_coa
-
-        coa_has_accounts = chart_of_accounts.accountmodel_set.all().exists()
-
-        if not coa_has_accounts or force:
-            logger = self.get_logger()
-            acc_objs = [
-                AccountModel(
-                    code=a['code'],
-                    name=a['name'],
-                    role=a['role'],
-                    balance_type=a['balance_type'],
-                    active=activate_accounts,
-                    coa_model=chart_of_accounts,
-                ) for a in CHART_OF_ACCOUNTS
-            ]
-
-            for account_model in acc_objs:
-                account_model.clean()
-                logger.info(msg=f'Adding Account {account_model.code}: {account_model.name}...')
-                AccountModel.add_root(instance=account_model)
-        else:
-            if not ignore_if_default_coa:
-                raise ValidationError(f'Entity {self.name} already has existing accounts. '
-                                      'Use force=True to bypass this check')
+        ItemModelQuerySet
+            The ItemModelQuerySet containing inventory ItemModels with additional Unit of Measure information.
 
-    def get_accounts(self, user_model, active_only: bool = True):
-        """
-        This func does...
-        @param user_model: Request User Model
-        @param active_only: Active accounts only
-        @return: A queryset.
         """
-        accounts_qs = AccountModel.objects.for_entity(
-            entity_slug=self.slug,
-            user_model=user_model
-        )
-        if active_only:
-            accounts_qs = accounts_qs.active()
-        return accounts_qs
+        if not item_qs:
+            recorded_qs = self.itemmodel_set.inventory_all(
+                entity_slug=self.slug,
+                user_model=user_model
+            )
+        else:
+            recorded_qs = item_qs
+        if as_values:
+            return recorded_qs.values(
+                'uuid', 'name', 'uom__name', 'inventory_received', 'inventory_received_value')
+        return recorded_qs
 
     def add_equity(self,
                    user_model,
                    cash_account: Union[str, AccountModel],
                    equity_account: Union[str, AccountModel],
                    txs_date: Union[date, str],
                    amount: Decimal,
@@ -846,18 +1440,18 @@
                    ledger_posted: bool = False,
                    je_posted: bool = False):
 
         if not isinstance(cash_account, AccountModel) and not isinstance(equity_account, AccountModel):
 
             account_qs = AccountModel.objects.with_roles(
                 roles=[
-                    EQUITY_CAPITAL,
-                    EQUITY_COMMON_STOCK,
-                    EQUITY_PREFERRED_STOCK,
-                    ASSET_CA_CASH
+                    roles_module.EQUITY_CAPITAL,
+                    roles_module.EQUITY_COMMON_STOCK,
+                    roles_module.EQUITY_PREFERRED_STOCK,
+                    roles_module.ASSET_CA_CASH
                 ],
                 entity_slug=self.slug,
                 user_model=user_model
             )
 
             cash_account_model = account_qs.get(code__exact=cash_account)
             equity_account_model = account_qs.get(code__exact=equity_account)
@@ -898,24 +1492,89 @@
             je_date=txs_date,
             je_txs=txs,
             je_posted=je_posted,
             je_ledger=ledger
         )
         return ledger
 
-    def is_cash_method(self) -> bool:
-        return self.accrual_method is False
+    # #### FINANCIAL STATEMENTS ####
 
-    def is_accrual_method(self) -> bool:
-        return self.accrual_method is True
+    def get_balance_sheet(self,
+                          to_date: Union[date, datetime],
+                          user_model: UserModel,
+                          txs_queryset: Optional[QuerySet] = None,
+                          **kwargs: Dict) -> Tuple[QuerySet, Dict]:
+        return self.digest(
+            user_model=user_model,
+            to_date=to_date,
+            balance_sheet_statement=True,
+            txs_queryset=txs_queryset,
+            **kwargs
+        )
 
-    def get_accrual_method(self) -> str:
-        if self.is_cash_method():
-            return self.CASH_METHOD
-        return self.ACCRUAL_METHOD
+    def get_income_statement(self,
+                             from_date: Union[date, datetime],
+                             to_date: Union[date, datetime],
+                             user_model: UserModel,
+                             txs_queryset: Optional[QuerySet] = None,
+                             **kwargs) -> Tuple[QuerySet, Dict]:
+        return self.digest(
+            user_model=user_model,
+            from_date=from_date,
+            to_date=to_date,
+            income_statement=True,
+            txs_queryset=txs_queryset,
+            **kwargs
+        )
+
+    def get_cash_flow_statement(self,
+                                from_date: Union[date, datetime],
+                                to_date: Union[date, datetime],
+                                user_model: UserModel,
+                                txs_queryset: Optional[QuerySet] = None,
+                                **kwargs) -> Tuple[QuerySet, Dict]:
+
+        return self.digest(
+            user_model=user_model,
+            from_date=from_date,
+            to_date=to_date,
+            cash_flow_statement=True,
+            txs_queryset=txs_queryset,
+            **kwargs
+        )
+
+    def get_financial_statements(self,
+                                 from_date: Union[date, datetime],
+                                 to_date: Union[date, datetime],
+                                 user_model: UserModel,
+                                 txs_queryset: Optional[QuerySet] = None,
+                                 **kwargs) -> Tuple[QuerySet, Dict]:
+        return self.digest(
+            user_model=user_model,
+            from_date=from_date,
+            to_date=to_date,
+            balance_sheet_statement=True,
+            income_statement=True,
+            cash_flow_statement=True,
+            txs_queryset=txs_queryset,
+            **kwargs
+        )
+
+    # ### RANDOM DATA GENERATION ####
+
+    def populate_random_data(self, start_date: date):
+        EntityDataGenerator = lazy_loader.get_entity_data_generator()
+        data_generator = EntityDataGenerator(
+            user_model=self.admin,
+            days_forward=30,
+            start_date=start_date,
+            entity_model=self,
+            capital_contribution=Decimal.from_float(50000.00)
+        )
+        data_generator.populate_entity()
 
     # URLS ----
     def get_dashboard_url(self) -> str:
         """
         The EntityModel Dashboard URL.
 
         Returns
@@ -1212,30 +1871,19 @@
 
 class EntityModel(EntityModelAbstract):
     """
     Entity Model Base Class From Abstract
     """
 
 
+class EntityManagementModel(EntityManagementModelAbstract):
+    """
+    EntityManagement Model Base Class From Abstract
+    """
+
+
 def entitymodel_presave(instance: EntityModel, **kwargs):
     if not instance.slug:
         instance.generate_slug(commit=False)
 
 
-
-
-pre_save.connect(entitymodel_presave, EntityModel)
-
-
-# instance.ledgermodel_set.create(
-#     name=_(f'{instance.name} First Ledger'),
-#     posted=True
-# )
-
-
-# post_init.connect(entitymodel_postinit, EntityModel)
-
-
-class EntityManagementModel(EntityManagementModelAbstract):
-    """
-    EntityManagement Model Base Class From Abstract
-    """
+pre_save.connect(receiver=entitymodel_presave, sender=EntityModel)
```

## django_ledger/models/estimate.py

```diff
@@ -1,20 +1,29 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
     * Miguel Sanda <msanda@arrobalytics.com>
+
+The EstimateModel provides the means to estimate customer requests, jobs or quotes that may ultimately be considered
+contracts, if approved. The EstimateModels will estimate revenues and costs associated with a specific scope of work
+which is documented using ItemTransactionModels.
+
+Once approved, the user may initiate purchase orders, bills and invoices that will be associated with the EstimateModel
+for tracking purposes. It is however not required to always have an EstimateModel, but recommended in order to be able
+to produce more specific financial reports associated with a specific scope of work.
 """
 from datetime import date
 from decimal import Decimal
 from string import ascii_uppercase, digits
 from typing import Union, Optional, List
 from uuid import uuid4, UUID
 
+from django.contrib.auth import get_user_model
 from django.core.exceptions import ValidationError, ObjectDoesNotExist
 from django.core.validators import MinValueValidator, MinLengthValidator
 from django.db import models, transaction, IntegrityError
 from django.db.models import Q, Sum, ExpressionWrapper, FloatField, F
 from django.db.models.functions import Coalesce
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
@@ -27,22 +36,24 @@
 from django_ledger.models.items import ItemTransactionModelQuerySet, ItemTransactionModel
 from django_ledger.models.mixins import CreateUpdateMixIn, MarkdownNotesMixIn
 from django_ledger.models.purchase_order import PurchaseOrderModelQuerySet
 from django_ledger.settings import DJANGO_LEDGER_DOCUMENT_NUMBER_PADDING, DJANGO_LEDGER_ESTIMATE_NUMBER_PREFIX
 
 ESTIMATE_NUMBER_CHARS = ascii_uppercase + digits
 
+UserModel = get_user_model()
+
 
 class EstimateModelValidationError(ValidationError):
     pass
 
 
 class EstimateModelQuerySet(models.QuerySet):
     """
-    A custom defined QuerySet for the EstimateModel.
+    A custom-defined LedgerModelManager that implements custom QuerySet methods related to the EstimateModel.
     """
 
     def approved(self):
         """
         Approved Estimates or Sales Orders are those that have been approved or completed.
 
         Returns
@@ -90,16 +101,15 @@
             A EstimateModelQuerySet with applied filters. Equivalent to not approved.
         """
         return self.not_approved()
 
 
 class EstimateModelManager(models.Manager):
     """
-    A custom defined EstimateModelManager that will act as an interface to handling the initial DB queries
-    to the EstimateModel.
+    A custom defined EstimateModelManager that that implements custom QuerySet methods related to the EstimateModel.
     """
 
     def for_entity(self, entity_slug: Union[EntityModel, str], user_model):
         """
         Fetches a QuerySet of EstimateModels associated with a specific EntityModel & UserModel.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
@@ -145,75 +155,58 @@
         1. :func:`MarkdownNotesMixIn <django_ledger.models.mixins.MarkdownNotesMixIn>`
         2. :func:`CreateUpdateMixIn <django_ledger.models.mixins.CreateUpdateMixIn>`
 
     Attributes
     ----------
     uuid : UUID
         This is a unique primary key generated for the table. The default value of this field is uuid4().
-
     estimate_number: str
         Auto assigned number at creation by generate_estimate_number() function.
         Prefix be customized with DJANGO_LEDGER_ESTIMATE_NUMBER_PREFIX setting.
         Includes a reference to the Fiscal Year and a sequence number. Max Length is 20.
-
     entity: EntityModel
         The EntityModel associated with te EntityModel instance.
-
     customer: CustomerModel
         The CustomerModel associated with the EstimateModel instance.
-
     title: str
         A string representing the name or title of the EstimateModel instance.
-
     status: str
         The status of the EstimateModel instance. Must be one of Draft, In Review, Approved, Completed Void or Canceled.
-
     terms: str
         The contract terms that will be associated with this EstimateModel instance.
         Choices are Fixed Price, Target Price, Time & Materials and Other.
-
     date_draft: date
         The draft date represents the date when the EstimateModel was first created. Defaults to
         :func:`localdate <django.utils.timezone.localdate>`.
-
     date_in_review: date
         The in review date represents the date when the EstimateModel was marked as In Review status.
         Will be null if EstimateModel is canceled during draft status. Defaults to
         :func:`localdate <django.utils.timezone.localdate>`.
-
     date_approved: date
         The approved date represents the date when the EstimateModel was approved.
         Will be null if EstimateModel is canceled.
         Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     date_completed: date
         The paid date represents the date when the EstimateModel was completed and fulfilled.
         Will be null if EstimateModel is canceled. Defaults to
         :func:`localdate <django.utils.timezone.localdate>`.
-
     date_void: date
         The void date represents the date when the EstimateModel was void, if applicable.
         Will be null unless EstimateModel is void. Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     date_canceled: date
         The canceled date represents the date when the EstimateModel was canceled, if applicable.
         Will be null unless EstimateModel is canceled. Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     revenue_estimate: Decimal
         The total estimated revenue of the EstimateModel instance.
-
     labor_estimate: Decimal
         The total labor costs estimate of the EstimateModel instance.
-
     material_estimate: Decimal
         The total material costs estimate of the EstimateModel instance.
-
     equipment_estimate: Decimal
         The total equipment costs estimate of the EstimateModel instance.
-
     other_estimate: Decimal
         the total miscellaneous costs estimate of the EstimateModel instance.
     """
     CJ_STATUS_DRAFT = 'draft'
     CJ_STATUS_REVIEW = 'in_review'
     CJ_STATUS_APPROVED = 'approved'
     CJ_STATUS_COMPLETED = 'completed'
@@ -331,70 +324,77 @@
             return f'Contract {self.estimate_number} | {self.title}'
         return f'Estimate {self.estimate_number} | {self.title}'
 
     # Configuration...
 
     def configure(self,
                   entity_slug: Union[EntityModel, UUID, str],
-                  user_model,
                   customer_model: CustomerModel,
+                  user_model: Optional[UserModel] = None,
                   date_draft: Optional[date] = None,
-                  raise_exception: bool = True,
-                  commit: bool = False):
+                  estimate_title: Optional[str] = None,
+                  commit: bool = False,
+                  raise_exception: bool = True):
         """
         A configuration hook which executes all initial EstimateModel setup.
         Can only call this method once in the lifetime of a EstimateModel.
 
         Parameters
         ----------
         entity_slug: str or EntityModel
             The entity slug or EntityModel to associate the Bill with.
-
         user_model:
             The UserModel making the request to check for QuerySet permissions.
-
         date_draft: date
             The draft date to use. If None defaults to localdate().
-
         customer_model: CustomerModel
             The CustomerModel to be associated with this EstimateModel instance.
-
         commit: bool
             Saves the current EstimateModel after being configured.
-
+        estimate_title: str
+            Optional EstimateModel title.
         raise_exception: bool
             If True, raises EstimateModelValidationError when model is already configured.
 
         Returns
         -------
         EstimateModel
             The configured EstimateModel instance.
         """
-        if self.is_configured():
-            if raise_exception:
-                raise EstimateModelValidationError(
-                    message=f'{self.__class__.__name__} already configured...'
-                )
-            return
+        if not self.is_configured():
+            if isinstance(entity_slug, (str, UUID)):
+                if not user_model:
+                    if raise_exception:
+                        raise EstimateModelValidationError(_('Must pass user_model when using entity_slug.'))
+                    return
+                entity_qs = EntityModel.objects.for_user(user_model=user_model)
+                if isinstance(entity_slug, str):
+                    entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
+                elif isinstance(entity_slug, UUID):
+                    entity_model: EntityModel = get_object_or_404(entity_qs, uuid__exact=entity_slug)
+            elif isinstance(entity_slug, EntityModel):
+                entity_model = entity_slug
+            else:
+                if raise_exception:
+                    raise EstimateModelValidationError('entity_slug must be an instance of str or EntityModel')
+                return
+
+            if estimate_title:
+                self.title = estimate_title
+
+            self.entity = entity_model
+
+            self.customer = customer_model
+            if not date_draft:
+                self.date_draft = localdate()
 
-        if isinstance(entity_slug, str):
-            entity_qs = EntityModel.objects.for_user(user_model=user_model)
-            entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
-        elif isinstance(entity_slug, EntityModel):
-            entity_model = entity_slug
-        else:
-            raise ValidationError('entity_slug must be an instance of str or EntityModel')
-
-        self.entity = entity_model
-        self.customer = customer_model
-        if not date_draft:
-            self.date_draft = localdate()
+            self.clean()
 
-        if commit:
-            self.save()
+            if commit:
+                self.save()
         return self
 
     # State....
 
     def is_draft(self) -> bool:
         """
         Determines if the EstimateModel is in Draft status.
@@ -995,15 +995,17 @@
 
     # HTML Tags...
     def get_html_id(self):
         return f'djl-customer-estimate-id-{self.uuid}'
 
     # ItemThroughModels...
     def get_itemtxs_data(self,
-                         itemtxs_qs: Optional[ItemTransactionModelQuerySet] = None) -> ItemTransactionModelQuerySet:
+                         itemtxs_qs: Optional[Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]] = None
+                         ) -> ItemTransactionModelQuerySet:
+        # todo: this needs to return an aggregate for consistency...
         """
         Returns all ItemTransactionModels associated with the EstimateModel and a total aggregate.
 
         Parameters
         ----------
         itemtxs_qs: ItemTransactionModelQuerySet
             ItemTransactionModelQuerySet to use. Avoids additional DB query if provided.
@@ -1108,15 +1110,16 @@
                 'labor_estimate',
                 'material_estimate',
                 'equipment_estimate',
                 'other_estimate',
                 'updated'
             ])
 
-    def update_state(self, itemtxs_qs: Optional[ItemTransactionModelQuerySet] = None):
+    def update_state(self,
+                     itemtxs_qs: Optional[Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]] = None):
         itemtxs_qs = self.get_itemtxs_data(itemtxs_qs=itemtxs_qs)
         self.update_cost_estimate(itemtxs_qs)
         self.update_revenue_estimate(itemtxs_qs)
 
     # Features...
     def get_cost_estimate(self, as_float: bool = False) -> Union[float, Decimal]:
         """
```

## django_ledger/models/invoice.py

```diff
@@ -25,28 +25,32 @@
 from typing import Union, Optional, Tuple, Dict
 from uuid import uuid4
 
 from django.contrib.auth import get_user_model
 from django.core.exceptions import ValidationError, ObjectDoesNotExist
 from django.db import models, transaction, IntegrityError
 from django.db.models import Q, Sum, F
-from django.db.models.signals import post_delete
+from django.db.models.signals import post_delete, pre_save
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
 from django.utils.timezone import localdate
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.models import lazy_loader, ItemTransactionModelQuerySet
 from django_ledger.models.entity import EntityModel
-from django_ledger.models.mixins import CreateUpdateMixIn, LedgerWrapperMixIn, MarkdownNotesMixIn, PaymentTermsMixIn
+from django_ledger.models.mixins import CreateUpdateMixIn, AccrualMixIn, MarkdownNotesMixIn, PaymentTermsMixIn
 from django_ledger.settings import DJANGO_LEDGER_DOCUMENT_NUMBER_PADDING, DJANGO_LEDGER_INVOICE_NUMBER_PREFIX
 
 UserModel = get_user_model()
 
 
+class InvoiceModelValidationError(ValidationError):
+    pass
+
+
 class InvoiceModelQuerySet(models.QuerySet):
     """
    A custom defined QuerySet for the InvoiceModel.
    This implements multiple methods or queries that we need to run to get a status of Invoices raised by the entity.
    For example, We might want to have list of invoices which are paid, unpaid, due , overDue, approved or in draft stage.
    All these separate functions will assist in making such queries and building customized reports.
    """
@@ -168,24 +172,22 @@
 
     def for_entity(self, entity_slug, user_model) -> InvoiceModelQuerySet:
         """
         Returns a QuerySet of InvoiceModels associated with a specific EntityModel & UserModel.
         May pass an instance of EntityModel or a String representing the EntityModel slug.
 
         Parameters
-        __________
-
+        ----------
         entity_slug: str or EntityModel
             The entity slug or EntityModel used for filtering the QuerySet.
-
         user_model
             The request UserModel to check for privileges.
 
         Returns
-        _______
+        -------
         InvoiceModelQuerySet
             A Filtered InvoiceModelQuerySet.
         """
         qs = self.get_queryset().filter(
             Q(ledger__entity__admin=user_model) |
             Q(ledger__entity__managers__in=[user_model])
         )
@@ -195,88 +197,68 @@
             return qs.filter(ledger__entity__slug__exact=entity_slug)
 
     def for_entity_unpaid(self, entity_slug, user_model):
         qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
         return qs.approved()
 
 
-class InvoiceModelAbstract(LedgerWrapperMixIn,
+class InvoiceModelAbstract(AccrualMixIn,
                            PaymentTermsMixIn,
                            MarkdownNotesMixIn,
                            CreateUpdateMixIn):
     """
     This is the main abstract class which the InvoiceModel database will inherit from.
     The InvoiceModel inherits functionality from the following MixIns:
     
         1. :func:`LedgerWrapperMixIn <django_ledger.models.mixins.LedgerWrapperMixIn>`
         2. :func:`PaymentTermsMixIn <django_ledger.models.mixins.PaymentTermsMixIn>`
         3. :func:`MarkdownNotesMixIn <django_ledger.models.mixins.MarkdownNotesMixIn>`
         4. :func:`CreateUpdateMixIn <django_ledger.models.mixins.CreateUpdateMixIn>`
 
 
     Attributes
-    __________
-
+    ----------
     uuid: UUID
         This is a unique primary key generated for the table. The default value of this field is uuid4().
-
     invoice_number: str
         Auto assigned number at creation by generate_invoice_number() function.
         Prefix be customized with DJANGO_LEDGER_INVOICE_NUMBER_PREFIX setting.
         Includes a reference to the Fiscal Year, Entity Unit and a sequence number. Max Length is 20.
-
     invoice_status: str
         Current status of the InvoiceModel. Must be one of the choices as mentioned under "INVOICE_STATUS".
-        By default, the status will be "Draft"
-
-    xref: str
-        This is the field for capturing of any external reference number like the PO number of the buyer.
-        Any other reference number like the Vendor code in buyer books may also be captured.
-
+        By default, the status will be "Draft".
     customer: :obj:`CustomerModel`
         This is the foreign key reference to the CustomerModel from whom the purchase has been made.
-
     additional_info: dict
         Any additional metadata about the InvoiceModel may be stored here as a dictionary object.
         The data is serialized and stored as a JSON document in the Database.
-
     invoice_items:
         A foreign key reference to the list of ItemTransactionModel that make the invoice amount.
-
     ce_model: EstimateModel
         A foreign key to the InvoiceModel associated EstimateModel for overall Job/Contract tracking.
-
     date_draft: date
         The draft date represents the date when the InvoiceModel was first created.
         Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     date_in_review: date
         The in review date represents the date when the InvoiceModel was marked as In Review status.
         Will be null if InvoiceModel is canceled during draft status. Defaults to
         :func:`localdate <django.utils.timezone.localdate>`.
-
     date_approved: date
         The approved date represents the date when the InvoiceModel was approved.
         Will be null if InvoiceModel is canceled.
         Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     date_paid: date
         The paid date represents the date when the InvoiceModel was paid and amount_due equals amount_paid.
         Will be null if InvoiceModel is canceled. Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     date_void: date
         The void date represents the date when the InvoiceModel was void, if applicable.
         Will be null unless InvoiceModel is void. Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
     date_canceled: date
         The canceled date represents the date when the InvoiceModel was canceled, if applicable.
         Will be null unless InvoiceModel is canceled. Defaults to :func:`localdate <django.utils.timezone.localdate>`.
-
-    objects: InvoiceModelManager
-        Custom defined InvoiceModelManager.
     """
 
     IS_DEBIT_BALANCE = True
     REL_NAME_PREFIX = 'invoice'
 
     INVOICE_STATUS_DRAFT = 'draft'
     INVOICE_STATUS_REVIEW = 'in_review'
@@ -368,79 +350,95 @@
             models.Index(fields=['customer']),
             models.Index(fields=['invoice_number']),
         ]
 
     def __str__(self):
         return f'Invoice: {self.invoice_number}'
 
+    def is_configured(self) -> bool:
+        return all([
+            super().is_configured(),
+            self.invoice_status
+        ])
+
     def configure(self,
                   entity_slug: Union[EntityModel, str],
-                  user_model: UserModel,
+                  user_model: Optional[UserModel] = None,
+                  date_draft: Optional[date] = None,
                   ledger_posted: bool = False,
-                  invoice_desc: str = None,
-                  commit: bool = False):
+                  ledger_name: Optional[str] = None,
+                  commit: bool = False,
+                  commit_ledger: bool = False):
         """
         A configuration hook which executes all initial InvoiceModel setup on to the LedgerModel and all initial
         values of the InvoiceModel. Can only call this method once in the lifetime of a InvoiceModel.
 
         Parameters
         __________
 
         entity_slug: str or EntityModel
             The entity slug or EntityModel to associate the Invoice with.
-
-        user_model:
+        user_model: UserModel
             The UserModel making the request to check for QuerySet permissions.
-
-        ledger_posted:
+        ledger_posted: bool
             An option to mark the InvoiceModel Ledger as posted at the time of configuration. Defaults to False.
-
+        ledger_name: str
+            Optional additional InvoiceModel ledger name or description.
         invoice_desc: str
             An optional description appended to the LedgerModel name.
-
         commit: bool
             Saves the current InvoiceModel after being configured.
-
+        commit_ledger: bool
+            Saves the InvoiceModel's LedgerModel while being configured.
         Returns
         -------
         A tuple of LedgerModel, InvoiceModel
         """
 
-        if isinstance(entity_slug, str):
-            entity_qs = EntityModel.objects.for_user(
-                user_model=user_model)
-            entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
-        elif isinstance(entity_slug, EntityModel):
-            entity_model = entity_slug
-        else:
-            raise ValidationError('entity_slug must be an instance of str or EntityModel')
+        if not self.is_configured():
+            if isinstance(entity_slug, str):
+                if not user_model:
+                    raise InvoiceModelValidationError(_('Must pass user_model when using entity_slug.'))
+                entity_qs = EntityModel.objects.for_user(user_model=user_model)
+                entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
+            elif isinstance(entity_slug, EntityModel):
+                entity_model = entity_slug
+            else:
+                raise InvoiceModelValidationError('entity_slug must be an instance of str or EntityModel')
+
+            if entity_model.is_accrual_method():
+                self.accrue = True
+                self.progress = Decimal.from_float(1.00)
+            else:
+                self.accrue = False
+
+            self.invoice_status = self.INVOICE_STATUS_DRAFT
+            self.date_draft = localdate() if not date_draft else date_draft
+
+            LedgerModel = lazy_loader.get_ledger_model()
+            ledger_model: LedgerModel = LedgerModel(entity=entity_model, posted=ledger_posted)
+
+            if not ledger_name:
+                ledger_name = f'Invoice {self.uuid}'
+            ledger_name += f' | {ledger_name}'
+            ledger_model.name = ledger_name
+            ledger_model.clean()
+
+            self.ledger = ledger_model
+
+            if commit_ledger:
+                self.ledger.save()
 
-        if entity_model.is_accrual_method():
-            self.accrue = True
-            self.progress = Decimal('1.00')
-        else:
-            self.accrue = False
+            if self.can_generate_invoice_number():
+                self.generate_invoice_number(commit=commit)
 
-        LedgerModel = lazy_loader.get_ledger_model()
-        ledger_model: LedgerModel = LedgerModel(
-            entity=entity_model,
-            posted=ledger_posted
-        )
-        ledger_name = f'Invoice {self.uuid}'
-        if invoice_desc:
-            ledger_name += f' | {invoice_desc}'
-        ledger_model.name = ledger_name
-        ledger_model.clean()
+            self.clean()
 
-        self.ledger = ledger_model
-        self.ledger.save()
-        self.clean()
-
-        if commit:
-            self.save()
+            if commit:
+                self.save()
         return self.ledger, self
 
     def get_migrate_state_desc(self):
         """
         Description used when migrating transactions into the LedgerModel.
 
         Returns
@@ -459,15 +457,15 @@
         queryset: ItemTransactionModelQuerySet
             ItemTransactionModelQuerySet to validate.
         """
         valid = all([
             i.invoice_model_id == self.uuid for i in queryset
         ])
         if not valid:
-            raise ValidationError(f'Invalid queryset. All items must be assigned to Invoice {self.uuid}')
+            raise InvoiceModelValidationError(f'Invalid queryset. All items must be assigned to Invoice {self.uuid}')
 
     def get_itemtxs_data(self,
                          queryset: ItemTransactionModelQuerySet = None) -> Tuple[ItemTransactionModelQuerySet, Dict]:
         """
         Fetches the InvoiceModel Items and aggregates the QuerySet.
 
         Parameters
@@ -477,15 +475,20 @@
 
         Returns
         _______
         A tuple: ItemTransactionModelQuerySet, dict
         """
 
         if not queryset:
-            queryset = self.itemtransactionmodel_set.all().select_related('item_model')
+            queryset = self.itemtransactionmodel_set.all().select_related(
+                'item_model',
+                'entity_unit',
+                'po_model',
+                'invoice_model'
+            )
         else:
             self.validate_item_transaction_qs(queryset)
 
         return queryset, {
             'total_amount__sum': sum(i.total_amount for i in queryset),
             'total_items': len(queryset)
         }
@@ -741,32 +744,32 @@
         Parameters
         __________
 
         estimate_model: EstimateModel
             EstimateModel to check against.
 
         raise_exception: bool
-            If True, raises ValidationError if unable to bind. Else, returns False.
+            If True, raises InvoiceModelValidationError if unable to bind. Else, returns False.
 
         Returns
         _______
 
         bool
             True if can bind provided EstimateModel, else False.
         """
 
         if self.ce_model_id:
             if raise_exception:
-                raise ValidationError(f'Invoice {self.invoice_number} already bound to '
-                                      f'Estimate {self.ce_model.estimate_number}')
+                raise InvoiceModelValidationError(f'Invoice {self.invoice_number} already bound to '
+                                                  f'Estimate {self.ce_model.estimate_number}')
             return False
 
         is_approved = estimate_model.is_approved()
         if not is_approved and raise_exception:
-            raise ValidationError(f'Cannot bind estimate that is not approved.')
+            raise InvoiceModelValidationError(f'Cannot bind estimate that is not approved.')
         return all([
             is_approved
         ])
 
     def can_generate_invoice_number(self):
         """
         Checks if InvoiceModel can generate its Document Number.
@@ -775,29 +778,30 @@
         _______
 
         bool
             True if InvoiceModel can generate its invoice_number, else False.
         """
         return all([
             self.date_draft,
-            not self.invoice_number
+            not self.invoice_number,
+            self.is_configured()
         ])
 
     # ACTIONS...
     def action_bind_estimate(self, estimate_model, commit: bool = False):
         """
         Binds InvoiceModel to a given EstimateModel. Raises ValueError if EstimateModel cannot be bound.
 
         Parameters
         __________
         estimate_model: EstimateModel
             EstimateModel to bind.
 
         raise_exception: bool
-            Raises ValidationError if unable to bind EstimateModel.
+            Raises InvoiceModelValidationError if unable to bind EstimateModel.
 
         commit: bool
             Commits transaction into current InvoiceModel.
         """
 
         try:
             self.can_bind_estimate(estimate_model, raise_exception=True)
@@ -825,15 +829,15 @@
         date_draft: date
             Draft date. If None, defaults to localdate().
 
         commit: bool
             Commits transaction into the Database. Defaults to False.
         """
         if not self.can_draft():
-            raise ValidationError(f'Cannot mark PO {self.uuid} as draft...')
+            raise InvoiceModelValidationError(f'Cannot mark PO {self.uuid} as draft...')
         self.invoice_status = self.INVOICE_STATUS_DRAFT
         self.clean()
         if commit:
             self.save(update_fields=[
                 'invoice_status',
                 'updated'
             ])
@@ -895,27 +899,27 @@
         date_in_review: date
             InvoiceModel in review date. Defaults to localdate() if None.
         itemtxs_qs: ItemTransactionModelQuerySet
             Pre fetched ItemTransactionModelQuerySet to use. Avoids additional DB Query if previously fetched.
         commit: bool
             Commits transaction into the Database. Defaults to False.
         raise_exception: bool
-            Raises ValidationError if InvoiceModel cannot be marked as in review. Defaults to True.
+            Raises InvoiceModelValidationError if InvoiceModel cannot be marked as in review. Defaults to True.
         """
         if not self.can_review():
-            raise ValidationError(f'Cannot mark PO {self.uuid} as In Review...')
+            raise InvoiceModelValidationError(f'Cannot mark PO {self.uuid} as In Review...')
 
         self.date_in_review = localdate() if not date_in_review else date_in_review
 
         if not itemtxs_qs:
             itemtxs_qs = self.itemtransactionmodel_set.all()
         if not itemtxs_qs.count():
-            raise ValidationError(message='Cannot review an Invoice without items...')
+            raise InvoiceModelValidationError(message='Cannot review an Invoice without items...')
         if not self.amount_due:
-            raise ValidationError(
+            raise InvoiceModelValidationError(
                 f'PO {self.invoice_number} cannot be marked as in review. Amount due must be greater than 0.'
             )
 
         self.invoice_status = self.INVOICE_STATUS_REVIEW
         self.clean()
         if commit:
             self.save(update_fields=[
@@ -993,15 +997,15 @@
         commit: bool
             Commits transaction into the Database. Defaults to False.
 
         force_migrate: bool
             Forces migration. True if Accounting Method is Accrual.
         """
         if not self.can_approve():
-            raise ValidationError(f'Cannot mark PO {self.uuid} as Approved...')
+            raise InvoiceModelValidationError(f'Cannot mark PO {self.uuid} as Approved...')
 
         self.invoice_status = self.INVOICE_STATUS_APPROVED
         self.date_approved = localdate() if not date_approved else date_approved
         self.clean()
         if commit:
             self.save(update_fields=[
                 'invoice_status',
@@ -1088,22 +1092,22 @@
             Pre-fetched ItemTransactionModelQuerySet. Avoids additional DB query. Validated if passed.
 
         commit: bool
             Commits transaction into the Database. Defaults to False.
         """
 
         if not self.can_pay():
-            raise ValidationError(f'Cannot mark PO {self.uuid} as Paid...')
+            raise InvoiceModelValidationError(f'Cannot mark PO {self.uuid} as Paid...')
 
         self.progress = Decimal.from_float(1.0)
         self.amount_paid = self.amount_due
         self.date_paid = localdate() if not date_paid else date_paid
 
         if self.date_paid > localdate():
-            raise ValidationError(f'Cannot pay {self.__class__.__name__} in the future.')
+            raise InvoiceModelValidationError(f'Cannot pay {self.__class__.__name__} in the future.')
 
         self.new_state(commit=True)
         self.invoice_status = self.INVOICE_STATUS_PAID
         self.clean()
 
         if commit:
             self.save()
@@ -1181,23 +1185,24 @@
         date_void: date
             InvoiceModel void date. Defaults to localdate() if None.
 
         commit: bool
             Commits transaction into DB. Defaults to False.
         """
         if not self.can_void():
-            raise ValidationError(f'Cannot mark Invoice {self.uuid} as Void...')
+            raise InvoiceModelValidationError(f'Cannot mark Invoice {self.uuid} as Void...')
 
         self.date_void = localdate() if not date_void else date_void
 
         if self.date_void > localdate():
-            raise ValidationError(f'Cannot void {self.__class__.__name__} in the future.')
+            raise InvoiceModelValidationError(f'Cannot void {self.__class__.__name__} in the future.')
         if self.date_void < self.date_approved:
-            raise ValidationError(f'Cannot void {self.__class__.__name__} at {self.date_void} before approved '
-                                  f'{self.date_approved}')
+            raise InvoiceModelValidationError(
+                f'Cannot void {self.__class__.__name__} at {self.date_void} before approved '
+                f'{self.date_approved}')
 
         self.void_state(commit=True)
         self.invoice_status = self.INVOICE_STATUS_VOID
         self.clean()
 
         if commit:
             self.unlock_ledger(commit=True, raise_exception=False)
@@ -1265,15 +1270,15 @@
         date_canceled: date
             InvoiceModel canceled date. Defaults to localdate() if None.
 
         commit: bool
             Commits transaction into the Database. Defaults to False.
         """
         if not self.can_cancel():
-            raise ValidationError(f'Cannot cancel Invoice {self.invoice_number}.')
+            raise InvoiceModelValidationError(f'Cannot cancel Invoice {self.invoice_number}.')
 
         self.date_canceled = localdate() if not date_canceled else date_canceled
         self.invoice_status = self.INVOICE_STATUS_CANCELED
         self.clean()
         if commit:
             self.save(update_fields=[
                 'invoice_status',
@@ -1328,26 +1333,27 @@
 
     # DELETE ACTIONS...
     def mark_as_delete(self, **kwargs):
         """
         Deletes InvoiceModel from DB if possible. Raises exception if can_delete() is False.
         """
         if not self.can_delete():
-            raise ValidationError(f'Invoice {self.invoice_number} cannot be deleted. Must be void after Approved.')
+            raise InvoiceModelValidationError(
+                f'Invoice {self.invoice_number} cannot be deleted. Must be void after Approved.')
         self.delete(**kwargs)
 
     def get_mark_as_delete_html_id(self) -> str:
         """
-        InvoiceModel Mark as Delete HTML ID Tag.
+        InvoiceModel Mark as Delete URL.
 
         Returns
         _______
 
         str
-            HTML ID as a String.
+            URL as a String.
         """
         return f'djl-invoice-model-{self.uuid}-mark-as-delete'
 
     def get_mark_as_delete_url(self, entity_slug: Optional[str] = None) -> str:
         """
         InvoiceModel Mark-as-Delete action URL.
 
@@ -1546,18 +1552,16 @@
 
         Parameters
         __________
 
         commit: bool
             If True, commits into DB the generated InvoiceModel number if generated.
         """
-        if self.can_generate_invoice_number():
-            self.generate_invoice_number(commit=commit)
 
-        super(LedgerWrapperMixIn, self).clean()
+        super(AccrualMixIn, self).clean()
         super(PaymentTermsMixIn, self).clean()
 
         if self.accrue:
             self.progress = Decimal('1.00')
 
         if self.is_draft():
             self.amount_paid = Decimal('0.00')
@@ -1576,12 +1580,20 @@
 
 class InvoiceModel(InvoiceModelAbstract):
     """
     Base Invoice Model from Abstract.
     """
 
 
+def invoicemodel_presave(instance: InvoiceModel, **kwargs):
+    if instance.can_generate_invoice_number():
+        instance.generate_invoice_number(commit=False)
+
+
+pre_save.connect(receiver=invoicemodel_presave, sender=InvoiceModel)
+
+
 def invoicemodel_predelete(instance: InvoiceModel, **kwargs):
     instance.ledger.delete()
 
 
 post_delete.connect(receiver=invoicemodel_predelete, sender=InvoiceModel)
```

## django_ledger/models/items.py

```diff
@@ -1,66 +1,137 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
-Miguel Sanda <msanda@arrobalytics.com>
-Pranav P Tulshyan <ptulshyan77@gmail.com>
+    * Miguel Sanda <msanda@arrobalytics.com>
+    * Pranav P Tulshyan <ptulshyan77@gmail.com>
 
+The Items refer to the additional detail provided to Bills, Invoices, Purchase Orders and Estimates for the purposes of
+documenting a breakdown of materials, labor, equipment, and other resources used for the purposes of the business
+operations.
+
+The items associated with any of the aforementioned models are responsible for calculating the different amounts
+that ultimately drive the behavior of Journal Entries onto the company books.
+
+Each item must be assigned a UnitOfMeasureModel which is the way or method used to quantify such resource. Examples
+are Pounds, Gallons, Man Hours, etc used to measure how resources are quantified when associated with a specific
+ItemTransactionModel. If many unit of measures are used for the same item, it would constitute a different item hence a
+new record must be created.
+
+ItemsTransactionModels constitute the way multiple items and used resources are associated with Bills, Invoices,
+Purchase Orders and Estimates. Each transaction will record the unit of measure and quantity of each resource.
+Totals will be calculated and associated with the containing model at the time of update.
 """
 from decimal import Decimal
 from string import ascii_lowercase, digits
-from uuid import uuid4
+from uuid import uuid4, UUID
 
 from django.core.exceptions import ValidationError, ObjectDoesNotExist
 from django.core.validators import MinValueValidator
 from django.db import models, transaction, IntegrityError
-from django.db.models import Q, Sum, F, ExpressionWrapper, DecimalField, Value, Case, When
+from django.db.models import Q, Sum, F, ExpressionWrapper, DecimalField, Value, Case, When, QuerySet
 from django.db.models.functions import Coalesce
 from django.utils.translation import gettext_lazy as _
-from treebeard.mp_tree import MP_Node, MP_NodeManager
 
-from django_ledger.models import lazy_loader
 from django_ledger.models.mixins import CreateUpdateMixIn
+from django_ledger.models.utils import lazy_loader
 from django_ledger.settings import (DJANGO_LEDGER_TRANSACTION_MAX_TOLERANCE, DJANGO_LEDGER_DOCUMENT_NUMBER_PADDING,
                                     DJANGO_LEDGER_EXPENSE_NUMBER_PREFIX, DJANGO_LEDGER_INVENTORY_NUMBER_PREFIX,
                                     DJANGO_LEDGER_PRODUCT_NUMBER_PREFIX)
 
 ITEM_LIST_RANDOM_SLUG_SUFFIX = ascii_lowercase + digits
 
-"""
-The Item list is a collection of all the products that are sold by any organization.
-The tems may include Products or even services.
 
-"""
+class ItemModelValidationError(ValidationError):
+    pass
 
 
 # UNIT OF MEASURES MODEL....
 class UnitOfMeasureModelManager(models.Manager):
+    """
+    A custom defined QuerySet Manager for the UnitOfMeasureModel.
+    """
+
+    def for_entity(self, entity_slug: str, user_model) -> QuerySet:
+        """
+        Fetches the UnitOfMeasureModels associated with the provided EntityModel and UserModel.
 
-    def for_entity(self, entity_slug: str, user_model):
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The EntityModel slug or EntityModel used to filter the QuerySet.
+        user_model: UserModel
+            The Django UserModel to check permissions.
+
+        Returns
+        -------
+        QuerySet
+            A QuerySet with applied filters.
+        """
         qs = self.get_queryset()
+        if isinstance(entity_slug, lazy_loader.get_entity_model()):
+            return qs.filter(
+                Q(entity=entity_slug) &
+                (
+                        Q(entity__admin=user_model) |
+                        Q(entity__managers__in=[user_model])
+                )
+            )
         return qs.filter(
             Q(entity__slug__exact=entity_slug) &
             (
                     Q(entity__admin=user_model) |
                     Q(entity__managers__in=[user_model])
             )
         )
 
     def for_entity_active(self, entity_slug: str, user_model):
+        """
+        Fetches the Active UnitOfMeasureModels associated with the provided EntityModel and UserModel.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The EntityModel slug or EntityModel used to filter the QuerySet.
+        user_model: UserModel
+            The Django UserModel to check permissions.
+
+        Returns
+        -------
+        QuerySet
+            A QuerySet with applied filters.
+        """
         qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(is_active=True)
 
 
 class UnitOfMeasureModelAbstract(CreateUpdateMixIn):
+    """
+    Base implementation of a Unit of Measure assigned to each Item Transaction.
+
+    Attributes
+    ----------
+    uuid: UUID
+        This is a unique primary key generated for the table. The default value of this field is uuid4().
+    name: str
+        The name of the unit of measure. Maximum of 50 characters.
+    unit_abbr: str
+        An abbreviation of the unit of measure used as an identifier or slug for URLs and queries.
+    is_active: bool
+        A boolean representing of the UnitOfMeasureModel instance is active to be used on new transactions.
+    entity: EntityModel
+        The EntityModel associated with the UnitOfMeasureModel instance.
+    """
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
     name = models.CharField(max_length=50, verbose_name=_('Unit of Measure Name'))
     unit_abbr = models.SlugField(max_length=10, verbose_name=_('UoM Abbreviation'))
     is_active = models.BooleanField(default=True, verbose_name=_('Is Active'))
+
+    # todo: rename to entity_model
     entity = models.ForeignKey('django_ledger.EntityModel',
                                editable=False,
                                on_delete=models.CASCADE,
                                verbose_name=_('UoM Entity'))
 
     objects = UnitOfMeasureModelManager()
 
@@ -75,108 +146,392 @@
 
     def __str__(self):
         return f'{self.name} ({self.unit_abbr})'
 
 
 # ITEM MODEL....
 class ItemModelQuerySet(models.QuerySet):
+    """
+    A custom-defined ItemModelQuerySet that implements custom QuerySet methods related to the ItemModel.
+    """
 
     def active(self):
+        """
+        Filters the QuerySet to only active Item Models.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A QuerySet with applied filters.
+        """
         return self.filter(active=True)
 
 
-class ItemModelManager(MP_NodeManager):
+class ItemModelManager(models.Manager):
+    """
+    A custom defined ItemModelManager that implement custom QuerySet methods related to the ItemModel
+    """
 
-    def get_queryset(self):
-        return ItemModelQuerySet(self.model).order_by('path')
+    def for_entity(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModel associated with a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
 
-    def for_entity(self, entity_slug: str, user_model):
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
         qs = self.get_queryset()
+        if isinstance(entity_slug, lazy_loader.get_entity_model()):
+            return qs.filter(
+                Q(entity=entity_slug) &
+                (
+                        Q(entity__managers__in=[user_model]) |
+                        Q(entity__admin=user_model)
+                )
+            ).select_related('uom')
         return qs.filter(
             Q(entity__slug__exact=entity_slug) &
             (
                     Q(entity__managers__in=[user_model]) |
                     Q(entity__admin=user_model)
             )
         ).select_related('uom')
 
-    def for_entity_active(self, entity_slug: str, user_model):
+    def for_entity_active(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of Active ItemModel associated with a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
         qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(is_active=True)
 
-    def products_and_services(self, entity_slug: str, user_model):
+    def products(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that only qualify as products for a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
         qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(
-            Q(is_product_or_service=True) &
-            Q(for_inventory=False)
+            (
+                    Q(is_product_or_service=True) &
+                    Q(for_inventory=True)
+            ) |
+            Q(item_role=ItemModel.ITEM_ROLE_PRODUCT)
         )
 
-    def expenses(self, entity_slug: str, user_model):
+    def services(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that only qualify as active services for a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
         qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(
-            is_product_or_service=False,
-            for_inventory=False
+            (
+                    Q(is_product_or_service=True) &
+                    Q(for_inventory=False)
+            ) |
+            Q(item_role=ItemModel.ITEM_ROLE_SERVICE)
         )
 
-    def inventory(self, entity_slug: str, user_model):
+    def expenses(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that only qualify as active products for a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
         qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
-        return qs.filter(for_inventory=True).select_related('uom')
+        return qs.filter(
+            (
+                    Q(is_product_or_service=False) &
+                    Q(for_inventory=False)
+            ) | Q(item_role=ItemModel.ITEM_ROLE_EXPENSE)
+        )
+
+    def inventory_wip(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that only qualify as inventory in progress for a specific EntityModel &
+        UserModel. These types of items cannot be sold as they are not considered a finished product.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
+        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
+        return qs.filter(
+            (
+                    Q(is_product_or_service=False) &
+                    Q(for_inventory=True)
+            ) | Q(item_role=ItemModel.ITEM_ROLE_INVENTORY)
+        )
+
+    def inventory_all(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that qualify as inventory for a specific EntityModel &
+        UserModel. These types of items may be finished or unfinished.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
+        qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
+        return qs.filter(
+            (
+                    (
+                            Q(is_product_or_service=False) &
+                            Q(for_inventory=True)
+                    ) | Q(item_role=ItemModel.ITEM_ROLE_INVENTORY)
+            ) |
+            (
+                    (
+                            Q(is_product_or_service=True) &
+                            Q(for_inventory=True)
+                    ) |
+                    Q(item_role=ItemModel.ITEM_ROLE_PRODUCT)
 
-    def for_bill(self, entity_slug: str, user_model):
+            )
+        )
+
+    def for_bill(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that can only be used for BillModels for a specific EntityModel &
+        UserModel. These types of items qualify as expenses or inventory purchases.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
         qs = self.for_entity_active(entity_slug=entity_slug, user_model=user_model)
         return qs.filter(
             (
                     Q(is_product_or_service=False) &
                     Q(for_inventory=False)
             ) |
             Q(for_inventory=True)
         )
 
-    def for_po(self, entity_slug: str, user_model):
-        return self.inventory(entity_slug=entity_slug, user_model=user_model)
+    def for_po(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of ItemModels that can only be used for PurchaseOrders for a specific EntityModel &
+        UserModel. These types of items qualify as inventory purchases.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
+        return self.inventory_all(entity_slug=entity_slug, user_model=user_model)
 
     def for_estimate(self, entity_slug: str, user_model):
-        return self.products_and_services(entity_slug=entity_slug, user_model=user_model)
+        """
+        Returns a QuerySet of ItemModels that can only be used for EstimateModels for a specific EntityModel &
+        UserModel. These types of items qualify as products.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        ItemModelQuerySet
+            A Filtered ItemModelQuerySet.
+        """
+        return self.products(entity_slug=entity_slug, user_model=user_model)
 
-    def for_contract(self, entity_slug: str, user_model, ce_model_uuid):
-        qs = self.for_estimate(
-            entity_slug=entity_slug,
-            user_model=user_model
-        )
-        qs = qs.filter(itemtransactionmodel__ce_model_id=ce_model_uuid)
-        return qs.distinct('uuid')
 
+class ItemModelAbstract(CreateUpdateMixIn):
+    """
+    Base implementation of the ItemModel.
 
-class ItemModelAbstract(MP_Node, CreateUpdateMixIn):
+    Attributes
+    ----------
+    uuid: UUID
+        This is a unique primary key generated for the table. The default value of this field is uuid4().
+    name: str
+        Human readable name of the ItemModel instance. Maximum of 100 characters.
+    item_role: str
+        A choice of ITEM_ROLE_CHOICES that determines whether the ItemModel should be treated as an expense, inventory,
+        service or product.
+    item_type: str
+        A choice of ITEM_TYPE_CHOICES that determines whether the ItemModel should be treated as labor, material,
+        equipment, lump sum or other.
+    uom: UnitOfMeasureModel
+        The assigned UnitOfMeasureModel of the ItemModel instance. Mandatory.
+    sku: str
+        The SKU number associated with the ItemModel instance. Maximum 50 characters.
+    upc: str
+        The UPC number associated with the ItemModel instance. Maximum 50 characters.
+    item_id: str
+        EntityModel specific id associated with the ItemModel instance. Maximum 50 characters.
+    item_number: str
+        Auto generated human-readable item number.
+    is_active: bool
+        Determines if the ItemModel instance is considered active. Defaults to True.
+    default_amount: Decimal
+        The default, prepopulated monetary amount of the ItemModel instance .
+    for_inventory: bool
+        Legacy field used to determine if the ItemModel instance is considered an inventory item. Mandatory.
+        Superseded by item_role field. Will be deprecated.
+    is_product_or_service: bool
+        Legacy field used to determine if the ItemModel instance is considered a product or service item. Mandatory.
+        Superseded by item_role field. Will be deprecated.
+    sold_as_unit: bool
+        Determines if only whole numbers can be used when specifying the quantity on ItemTransactionModels.
+    inventory_account: AccountModel
+        Inventory account associated with the ItemModel instance. Enforced if ItemModel instance is_inventory() is True.
+    inventory_received: Decimal
+        Holds the total quantity of the inventory received for the whole EntityModel instance.
+    inventory_received_value: Decimal
+        Holds the total monetary value of the inventory received for the whole EntityModel instance.
+    cogs_account: AccountModel
+        COGS account associated with the ItemModel instance. Enforced if ItemModel instance is_inventory() is True.
+    earnings_account: AccountModel
+        Earnings account associated with the ItemModel instance. Enforced if ItemModel instance is_product() or
+         is_service() is True.
+    expense_account: AccountModel
+        Expense account associated with the ItemModel instance. Enforced if ItemModel instance is_expense() is True.
+    additional_info: dict
+        Additional user defined information stored as JSON document in the Database.
+    entity: EntityModel
+        The EntityModel associated with the ItemModel instance.
+    """
     REL_NAME_PREFIX = 'item'
 
-    LABOR_TYPE = 'L'
-    MATERIAL_TYPE = 'M'
-    EQUIPMENT_TYPE = 'E'
-    LUMP_SUM = 'S'
-    OTHER_TYPE = 'O'
-
-    ITEM_CHOICES = [
-        (LABOR_TYPE, _('Labor')),
-        (MATERIAL_TYPE, _('Material')),
-        (EQUIPMENT_TYPE, _('Equipment')),
-        (LUMP_SUM, _('Lump Sum')),
-        (OTHER_TYPE, _('Other')),
+    ITEM_TYPE_LABOR = 'L'
+    ITEM_TYPE_MATERIAL = 'M'
+    ITEM_TYPE_EQUIPMENT = 'E'
+    ITEM_TYPE_LUMP_SUM = 'S'
+    ITEM_TYPE_OTHER = 'O'
+    ITEM_TYPE_CHOICES = [
+        (ITEM_TYPE_LABOR, _('Labor')),
+        (ITEM_TYPE_MATERIAL, _('Material')),
+        (ITEM_TYPE_EQUIPMENT, _('Equipment')),
+        (ITEM_TYPE_LUMP_SUM, _('Lump Sum')),
+        (ITEM_TYPE_OTHER, _('Other')),
+    ]
+
+    ITEM_ROLE_EXPENSE = 'expense'
+    ITEM_ROLE_INVENTORY = 'inventory'
+    ITEM_ROLE_SERVICE = 'service'
+    ITEM_ROLE_PRODUCT = 'product'
+    ITEM_ROLE_CHOICES = [
+        ('expense', _('Expense')),
+        ('inventory', _('Inventory')),
+        ('service', _('Service')),
+        ('product', _('Product')),
     ]
 
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
     name = models.CharField(max_length=100, verbose_name=_('Item Name'))
-    item_type = models.CharField(max_length=1, choices=ITEM_CHOICES, null=True, blank=True)
+
+    item_role = models.CharField(max_length=10, choices=ITEM_ROLE_CHOICES, null=True, blank=True)
+    item_type = models.CharField(max_length=1, choices=ITEM_TYPE_CHOICES, null=True, blank=True)
 
     uom = models.ForeignKey('django_ledger.UnitOfMeasureModel',
                             verbose_name=_('Unit of Measure'),
                             on_delete=models.RESTRICT)
 
     sku = models.CharField(max_length=50, blank=True, null=True, verbose_name=_('SKU Code'))
     upc = models.CharField(max_length=50, blank=True, null=True, verbose_name=_('UPC Code'))
+
+    # todo: rename this and remove 'id' from it.
     item_id = models.CharField(max_length=50, blank=True, null=True, verbose_name=_('Internal ID'))
     item_number = models.CharField(max_length=30, editable=False, verbose_name=_('Item Number'))
     is_active = models.BooleanField(default=True, verbose_name=_('Is Active'))
 
     default_amount = models.DecimalField(max_digits=20,
                                          decimal_places=2,
                                          default=0,
@@ -238,94 +593,139 @@
         help_text=_('Expense account where cost will be recognized on Income Statement.'),
         on_delete=models.RESTRICT)
 
     additional_info = models.JSONField(blank=True,
                                        null=True,
                                        default=dict,
                                        verbose_name=_('Item Additional Info'))
+
+    # todo: rename to entity_model...
     entity = models.ForeignKey('django_ledger.EntityModel',
                                editable=False,
                                on_delete=models.CASCADE,
                                verbose_name=_('Item Entity'))
 
-    objects = ItemModelManager()
-    node_order_by = ['uuid']
+    objects = ItemModelManager.from_queryset(queryset_class=ItemModelQuerySet)()
 
     class Meta:
         abstract = True
         unique_together = [
             ('entity', 'item_number')
         ]
         indexes = [
-            models.Index(fields=['inventory_account']),
-            models.Index(fields=['cogs_account']),
-            models.Index(fields=['earnings_account']),
-            models.Index(fields=['expense_account']),
-            models.Index(fields=['for_inventory']),
-            models.Index(fields=['is_product_or_service']),
-            models.Index(fields=['is_active']),
+            models.Index(fields=['item_number']),
             models.Index(fields=['item_type']),
-            models.Index(fields=['sku']),
+            models.Index(fields=['item_role']),
             models.Index(fields=['upc']),
-            models.Index(fields=['item_id']),
-            models.Index(fields=['item_number']),
+            models.Index(fields=['sku']),
+            models.Index(fields=['for_inventory']),
+            models.Index(fields=['is_product_or_service']),
+            models.Index(fields=['is_active'])
         ]
 
     def __str__(self):
         if self.is_expense():
-            return f'Expense Item: {self.name} | {self.get_item_type_display()}'
+            return f'Expense: {self.name} | {self.get_item_type_display()}'
         elif self.is_inventory():
             return f'Inventory: {self.name} | {self.get_item_type_display()}'
-        elif self.is_product_or_service:
-            return f'Product/Service: {self.name} | {self.get_item_type_display()}'
+        elif self.is_service():
+            return f'Service: {self.name} | {self.get_item_type_display()}'
+        elif self.is_product():
+            return f'Product: {self.name}'
         return f'Item Model: {self.name} - {self.sku} | {self.get_item_type_display()}'
 
     def is_expense(self):
-        return self.is_product_or_service is False and self.for_inventory is False
+        if self.item_role:
+            return self.item_role == self.ITEM_ROLE_EXPENSE
+        if all([
+            not self.is_product_or_service,
+            not self.for_inventory
+        ]):
+            self.item_role = self.ITEM_ROLE_EXPENSE
+            return True
+        return False
 
     def is_inventory(self):
-        return self.for_inventory is True
+        if self.item_role:
+            return self.item_role == self.ITEM_ROLE_INVENTORY
+
+        if all([
+            not self.is_product_or_service,
+            self.for_inventory,
+        ]):
+            self.item_role = self.ITEM_ROLE_INVENTORY
+            return True
+        return False
 
     def is_product(self):
-        return all([
+        if self.item_role:
+            return self.item_role == self.ITEM_ROLE_PRODUCT
+
+        if all([
             self.is_product_or_service,
-            not self.for_inventory
-        ])
+            self.for_inventory,
+            not self.is_labor()
+        ]):
+            self.item_role = self.ITEM_ROLE_PRODUCT
+            return True
+        return False
+
+    def is_service(self):
+        if self.item_role:
+            return self.item_role == self.ITEM_ROLE_SERVICE
+        if all([
+            self.is_product_or_service,
+            not self.for_inventory,
+            self.is_labor()
+        ]):
+            self.item_role = self.ITEM_ROLE_SERVICE
+            return True
+        return False
+
+    def product_or_service_display(self):
+        if self.is_product():
+            return 'product'
+        elif self.is_service():
+            return 'service'
 
     def is_labor(self):
-        return self.item_type == self.LABOR_TYPE
+        return self.item_type == self.ITEM_TYPE_LABOR
 
     def is_material(self):
-        return self.item_type == self.MATERIAL_TYPE
+        return self.item_type == self.ITEM_TYPE_MATERIAL
 
     def is_equipment(self):
-        return self.item_type == self.EQUIPMENT_TYPE
+        return self.item_type == self.ITEM_TYPE_EQUIPMENT
 
     def is_lump_sum(self):
-        return self.item_type == self.LUMP_SUM
+        return self.item_type == self.ITEM_TYPE_LUMP_SUM
 
     def is_other(self):
-        return self.item_type == self.OTHER_TYPE
+        return self.item_type == self.ITEM_TYPE_OTHER
 
     def get_average_cost(self) -> Decimal:
         if self.inventory_received:
             try:
                 return self.inventory_received_value / self.inventory_received
             except ZeroDivisionError:
                 pass
         return Decimal('0.00')
 
     def get_item_number_prefix(self):
         if self.is_expense():
             return DJANGO_LEDGER_EXPENSE_NUMBER_PREFIX
         elif self.is_inventory():
             return DJANGO_LEDGER_INVENTORY_NUMBER_PREFIX
-        elif self.is_product():
+        elif self.is_product() or self.is_service():
             return DJANGO_LEDGER_PRODUCT_NUMBER_PREFIX
-        raise ValidationError('Cannot determine Item Number prefix for ItemModel')
+        raise ItemModelValidationError('Cannot determine Item Number prefix for ItemModel. '
+                                       f'For Inventory: {self.for_inventory}, '
+                                       f'IsProductOrService: {self.is_product_or_service}, '
+                                       f'Type: {self.item_type} '
+                                       f'IsLabor: {self.is_labor()} ')
 
     def can_generate_item_number(self) -> bool:
         return all([
             self.entity_id,
             not self.item_number
         ])
 
@@ -378,66 +778,70 @@
 
             if commit:
                 self.save(update_fields=['item_number'])
 
         return self.item_number
 
     def save(self, **kwargs):
-        self.clean()
         if self.can_generate_item_number():
             self.generate_item_number(commit=False)
         super(ItemModelAbstract, self).save(**kwargs)
 
     def clean(self):
 
         if self.can_generate_item_number():
             self.generate_item_number(commit=False)
 
-        if all([
-            self.for_inventory is False,
-            self.is_product_or_service is False
-        ]):
+        if self.is_expense():
             if not self.expense_account_id:
-                raise ValidationError(_('Items must have an associated expense accounts.'))
+                raise ItemModelValidationError(_('Items must have an associated expense accounts.'))
+            if not self.item_type:
+                raise ItemModelValidationError(_('Expenses must have a type.'))
             self.inventory_account = None
             self.earnings_account = None
             self.cogs_account = None
+            self.for_inventory = False
+            self.is_product_or_service = False
 
-        elif all([
-            self.for_inventory is True,
-            self.is_product_or_service is True
-        ]):
+        elif self.is_product():
             if not all([
                 self.inventory_account_id,
                 self.cogs_account_id,
                 self.earnings_account_id
             ]):
-                raise ValidationError(_('Items for resale must have Inventory, COGS & Earnings accounts.'))
+                raise ItemModelValidationError(_('Products must have Inventory, COGS & Earnings accounts.'))
+            if self.is_labor():
+                raise ItemModelValidationError(_(f'Product must not be labor...'))
+            self.expense_account = None
+            self.for_inventory = True
+            self.is_product_or_service = True
 
-        elif all([
-            self.for_inventory is True,
-            self.is_product_or_service is False
-        ]):
+        elif self.is_service():
             if not all([
-                self.inventory_account_id,
-                self.cogs_account_id
+                self.cogs_account_id,
+                self.earnings_account_id
             ]):
-                raise ValidationError(_('Items for inventory must have Inventory & COGS accounts.'))
+                raise ItemModelValidationError(_('Services must have COGS & Earnings accounts.'))
+            self.inventory_account = None
             self.expense_account = None
-            self.earnings_account = None
+            self.for_inventory = False
+            self.is_product_or_service = True
+            self.item_type = self.ITEM_TYPE_LABOR
 
-        elif all([
-            self.for_inventory is False,
-            self.is_product_or_service is True
-        ]):
-            if not self.earnings_account_id:
-                raise ValidationError(_('Products & Services must have an Earnings Account'))
+        elif self.is_inventory():
+            if not all([
+                self.inventory_account_id,
+            ]):
+                raise ItemModelValidationError(_('Items for inventory must have Inventory & COGS accounts.'))
+            if not self.item_type:
+                raise ItemModelValidationError(_('Inventory items must have a type.'))
             self.expense_account = None
-            self.inventory_account = None
-            self.cogs_account = None
+            self.earnings_account = None
+            self.for_inventory = True
+            self.is_product_or_service = False
 
 
 # ITEM TRANSACTION MODELS...
 class ItemTransactionModelQuerySet(models.QuerySet):
 
     def is_received(self):
         return self.filter(po_item_status=ItemTransactionModel.STATUS_RECEIVED)
@@ -542,21 +946,22 @@
         return qs.filter(
             Q(item_model__for_inventory=True) &
             Q(invoice_model__isnull=False)
         )
 
     def inventory_count(self, entity_slug, user_model):
         qs = self.for_entity(entity_slug=entity_slug, user_model=user_model)
+        PurchaseOrderModel = lazy_loader.get_purchase_order_model()
         qs = qs.filter(
             Q(item_model__for_inventory=True) &
             (
                 # received inventory...
                     (
                             Q(bill_model__isnull=False) &
-                            Q(po_model__po_status='approved') &
+                            Q(po_model__po_status=PurchaseOrderModel.PO_STATUS_APPROVED) &
                             Q(po_item_status__exact=ItemTransactionModel.STATUS_RECEIVED)
                     ) |
 
                     # invoiced inventory...
                     (
                         Q(invoice_model__isnull=False)
                     )
@@ -740,67 +1145,115 @@
             return f'Bill Model: {self.bill_model_id} | {self.total_amount}'
         elif self.invoice_model_id:
             return f'Invoice Model: {self.invoice_model_id} | {self.total_amount}'
         elif self.ce_model_id:
             return f'Estimate/Contract Model: {self.ce_model_id} | {self.ce_cost_estimate}'
         return f'Orphan {self.__class__.__name__}: {self.uuid}'
 
-    def is_received(self):
+    def is_received(self) -> bool:
+        """
+        Determines if the ItemModel instance is received.
+        ItemModel status is only relevant for ItemModels associated with PurchaseOrderModels.
+
+        Returns
+        -------
+        bool
+            True if received, else False.
+        """
+        return self.po_item_status == self.STATUS_RECEIVED
+
+    def is_ordered(self) -> bool:
+        """
+        Determines if the ItemModel instance is ordered.
+        ItemModel status is only relevant for ItemModels associated with PurchaseOrderModels.
+
+        Returns
+        -------
+        bool
+            True if received, else False.
+        """
         return self.po_item_status == self.STATUS_RECEIVED
 
     def is_canceled(self):
+        """
+        Determines if the ItemModel instance is canceled.
+        ItemModel status is only relevant for ItemModels associated with PurchaseOrderModels.
+
+        Returns
+        -------
+        bool
+            True if canceled, else False.
+        """
         return self.po_item_status == self.STATUS_CANCELED
 
     # ItemTransactionModel Associations...
-    def for_estimate(self) -> bool:
+    def has_estimate(self) -> bool:
         """
-        True if ItemTransactionModel is associated with an EstimateModel, else False.
-        @return: True/False
+        Determines if the ItemModel instance is associated with an EstimateModel.
+
+        Returns
+        -------
+        bool
+            True if associated with an EstimateModel, else False.
         """
         return self.ce_model_id is not None
 
-    def for_po(self):
+    def has_po(self) -> bool:
         """
-        True if ItemTransactionModel is associated with a PurchaseOrderModel, else False.
-        @return:  True/False
+        Determines if the ItemModel instance is associated with a PurchaseOrderModel.
+
+        Returns
+        -------
+        bool
+            True if associated with an PurchaseOrderModel, else False.
         """
         return self.po_model_id is not None
 
-    def for_invoice(self):
+    def has_invoice(self):
         """
-        True if ItemTransactionModel is associated with an InvoiceModel, else False.
-        @return:  True/False
+        Determines if the ItemModel instance is associated with a InvoiceModel.
+
+        Returns
+        -------
+        bool
+            True if associated with an InvoiceModel, else False.
         """
         return self.invoice_model_id is not None
 
-    def for_bill(self):
+    def has_bill(self):
         """
-        True if ItemTransactionModel is associated with a BillModel, else False.
-        @return:  True/False
+        Determines if the ItemModel instance is associated with a BillModel.
+
+        Returns
+        -------
+        bool
+            True if associated with an BillModel, else False.
         """
         return self.bill_model_id is not None
 
     # TRANSACTIONS...
     def update_total_amount(self):
+        """
+        Hook that updates and checks the ItemModel instance fields according to its associations.
+        Calculates and updates total_amount accordingly. Called on every clean() call.
+        """
         if any([
-            self.for_bill(),
-            self.for_invoice(),
-            self.for_po()
+            self.has_bill(),
+            self.has_invoice(),
+            self.has_po()
         ]):
             if self.quantity is None:
                 self.quantity = 0.0
 
             if self.unit_cost is None:
                 self.unit_cost = 0.0
 
-            self.total_amount = round(
-                Decimal.from_float(self.quantity * self.unit_cost), self.DECIMAL_PLACES
-            )
+            self.total_amount = round(Decimal.from_float(self.quantity * self.unit_cost), self.DECIMAL_PLACES)
 
-            if self.for_po():
+            if self.has_po():
 
                 if self.quantity > self.po_quantity:
                     raise ValidationError(f'Billed quantity {self.quantity} cannot be greater than '
                                           f'PO quantity {self.po_quantity}')
                 if self.total_amount > self.po_total_amount:
                     raise ValidationError(f'Item amount {self.total_amount} cannot exceed authorized '
                                           f'PO amount {self.po_total_amount}')
@@ -813,89 +1266,138 @@
                             f'Difference between PO Amount {self.po_total_amount} and Bill {self.total_amount} '
                             f'exceeds tolerance of {DJANGO_LEDGER_TRANSACTION_MAX_TOLERANCE}')
                     self.total_amount = self.po_total_amount
                     return
 
     # PURCHASE ORDER...
     def update_po_total_amount(self):
-        if self.for_po():
+        """
+        Hook that updates and checks the ItemModel instance purchase order fields according to its associations.
+        Calculates and updates po_total_amount accordingly. Called on every clean() call.
+        """
+        if self.has_po():
             if self.po_quantity is None:
                 self.po_quantity = 0.0
             if self.po_unit_cost is None:
                 self.po_unit_cost = 0.0
 
-            self.po_total_amount = round(Decimal.from_float(self.po_quantity * self.po_unit_cost),
-                                         self.DECIMAL_PLACES)
+            self.po_total_amount = round(Decimal.from_float(self.po_quantity * self.po_unit_cost), self.DECIMAL_PLACES)
 
     # ESTIMATE/CONTRACTS...
     def update_cost_estimate(self):
-        if self.for_estimate():
+        """
+        Hook that updates and checks the ItemModel instance cost estimate fields according to its associations.
+        Calculates and updates ce_cost_estimate accordingly. Called on every clean() call.
+        """
+        if self.has_estimate():
             if self.ce_quantity is None:
                 self.ce_quantity = 0.00
             if self.ce_unit_cost_estimate is None:
                 self.ce_unit_cost_estimate = 0.00
             self.ce_cost_estimate = round(Decimal.from_float(self.ce_quantity * self.ce_unit_cost_estimate),
                                           self.DECIMAL_PLACES)
 
     def update_revenue_estimate(self):
-        if self.for_estimate():
+        """
+        Hook that updates and checks the ItemModel instance revenue estimate fields according to its associations.
+        Calculates and updates ce_revenue_estimate accordingly. Called on every clean() call.
+        """
+        if self.has_estimate():
             if self.ce_quantity is None:
                 self.ce_quantity = 0.00
             if self.ce_unit_revenue_estimate is None:
                 self.ce_unit_revenue_estimate = 0.00
             self.ce_revenue_estimate = Decimal.from_float(self.ce_quantity * self.ce_unit_revenue_estimate)
 
     # HTML TAGS...
-    def html_id(self):
+    def html_id(self) -> str:
+        """
+        Unique ItemModel instance HTML ID.
+
+        Returns
+        _______
+        str
+            HTML ID as a String.
+        """
         return f'djl-item-{self.uuid}'
 
-    def html_id_unit_cost(self):
+    def html_id_unit_cost(self) -> str:
+        """
+        Unique ItemModel instance unit cost field HTML ID.
+
+        Returns
+        _______
+        str
+            HTML ID as a String.
+        """
         return f'djl-item-unit-cost-id-{self.uuid}'
 
-    def html_id_quantity(self):
-        return f'djl-item-quantity-id-{self.uuid}'
+    def html_id_quantity(self) -> str:
+        """
+        Unique ItemModel instance quantity field HTML ID.
 
-    def is_cancelled(self):
-        return self.po_item_status == self.STATUS_CANCELED
+        Returns
+        _______
+        str
+            HTML ID as a String.
+        """
+        return f'djl-item-quantity-id-{self.uuid}'
 
-    def can_create_bill(self):
-        # pylint: disable=no-member
+    def can_create_bill(self) -> bool:
+        """
+        Determines if the ItemModel instance can be associated with a BillModel.
+        Returns
+        -------
+        bool
+            True, if instance can be associated with a BillModel, else False.
+        """
         return self.bill_model_id is None and self.po_item_status in [
-            self.STATUS_ORDERED, self.STATUS_IN_TRANSIT, self.STATUS_RECEIVED
+            self.STATUS_ORDERED,
+            self.STATUS_IN_TRANSIT,
+            self.STATUS_RECEIVED
         ]
 
-    def get_status_css_class(self):
-        if self.po_item_status == self.STATUS_RECEIVED:
+    def get_status_css_class(self) -> str:
+        """
+        Determines the CSS Class used to represent the ItemModel instance in the UI based on its status.
+
+        Returns
+        -------
+        str
+            The CSS class as a String.
+        """
+        if self.is_received():
             return ' is-success'
-        elif self.po_item_status == self.STATUS_CANCELED:
+        elif self.is_canceled():
             return ' is-danger'
-        elif self.po_item_status == self.STATUS_ORDERED:
+        elif self.is_ordered():
             return ' is-info'
         return ' is-warning'
 
     def clean(self):
+        if self.has_po() and not self.po_item_status:
+            self.po_item_status = self.STATUS_NOT_ORDERED
 
         self.update_po_total_amount()
         self.update_cost_estimate()
         self.update_revenue_estimate()
-
         self.update_total_amount()
 
 
 # FINAL MODEL CLASSES....
 
 class UnitOfMeasureModel(UnitOfMeasureModelAbstract):
     """
-    Base Unit of Measure Model from Abstract.
+    Base UnitOfMeasureModel from Abstract.
     """
 
 
 class ItemTransactionModel(ItemTransactionModelAbstract):
     """
-    Base Item Transaction Model.
+    Base ItemTransactionModel from Abstract.
     """
 
 
 class ItemModel(ItemModelAbstract):
     """
-    Base Item Model from Abstract.
+    Base ItemModel from Abstract.
     """
```

## django_ledger/models/journal_entry.py

```diff
@@ -36,14 +36,15 @@
 
 from django.core.exceptions import FieldError, ObjectDoesNotExist
 from django.core.exceptions import ValidationError
 from django.db import models, transaction, IntegrityError
 from django.db.models import Q, Sum, QuerySet, F
 from django.db.models.functions import Coalesce
 from django.urls import reverse
+from django.utils.timezone import localtime
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.io.roles import (ASSET_CA_CASH, GROUP_CFS_FIN_DIVIDENDS, GROUP_CFS_FIN_ISSUING_EQUITY,
                                     GROUP_CFS_FIN_LT_DEBT_PAYMENTS, GROUP_CFS_FIN_ST_DEBT_PAYMENTS,
                                     GROUP_CFS_INVESTING_AND_FINANCING, GROUP_CFS_INV_PURCHASE_OR_SALE_OF_PPE,
                                     GROUP_CFS_INV_LTD_OF_PPE, GROUP_CFS_INV_PURCHASE_OF_SECURITIES,
                                     GROUP_CFS_INV_LTD_OF_SECURITIES, GROUP_CFS_INVESTING_PPE,
@@ -225,50 +226,41 @@
 
 
 class JournalEntryModelAbstract(CreateUpdateMixIn):
     """
     The base implementation of the JournalEntryModel.
 
     Attributes
-    __________
-    uuid : UUID
+    ----------
+    uuid: UUID
         This is a unique primary key generated for the table. The default value of this field is uuid4().
-
     je_number: str
         A unique, sequential, human-readable alphanumeric Journal Entry Number (a.k.a Voucher or Document Number in
         other commercial bookkeeping software). Contains the fiscal year under which the JE takes place within the
         EntityModel as a prefix.
-
     timestamp: datetime
         The date of the JournalEntryModel. This date is applied to all TransactionModels contained within the JE, and
         drives the financial statements of the EntityModel.
-
     description: str
         A user defined description for the JournalEntryModel.
-
     entity_unit: EntityUnitModel
         A logical, self-contained, user defined class or structure defined withing the EntityModel.
         See EntityUnitModel documentation for more details.
-
     activity: str
         Programmatically determined based on the JE transactions and must be a value from ACTIVITIES. Gives
         additional insight of the nature of the JournalEntryModel in order to produce the Statement of Cash Flows for the
         EntityModel.
-
     origin: str
         A string giving additional information behind the origin or trigger of the JournalEntryModel.
         For example: reconciliations, migrations, auto-generated, etc. Any string value is valid. Max 30 characters.
-
     posted: bool
         Determines if the JournalLedgerModel is posted, which means is affecting the books. Defaults to False.
-
     locked: bool
         Determines  if the JournalEntryModel is locked, which the creation or updates of new transactions are not
         allowed.
-
     ledger: LedgerModel
         The LedgerModel associated with this JournalEntryModel. Cannot be null.
     """
     OPERATING_ACTIVITY = ActivityEnum.OPERATING.value
     FINANCING_OTHER = ActivityEnum.FINANCING.value
     INVESTING_OTHER = ActivityEnum.INVESTING.value
 
@@ -298,16 +290,16 @@
         )),
     ]
 
     VALID_ACTIVITIES = list(chain.from_iterable([[a[0] for a in cat[1]] for cat in ACTIVITIES]))
     NON_OPERATIONAL_ACTIVITIES = [a for a in VALID_ACTIVITIES if ActivityEnum.OPERATING.value not in a]
 
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
-    je_number = models.SlugField(max_length=20, editable=False, verbose_name=_('Journal Entry Number'))
-    timestamp = models.DateTimeField(verbose_name=_('Date'))
+    je_number = models.SlugField(max_length=25, editable=False, verbose_name=_('Journal Entry Number'))
+    timestamp = models.DateTimeField(verbose_name=_('Timestamp'), default=localtime)
     description = models.CharField(max_length=70, blank=True, null=True, verbose_name=_('Description'))
     entity_unit = models.ForeignKey('django_ledger.EntityUnitModel',
                                     on_delete=models.RESTRICT,
                                     blank=True,
                                     null=True,
                                     verbose_name=_('Associated Entity Unit'))
     activity = models.CharField(choices=ACTIVITIES,
@@ -895,16 +887,16 @@
             if raise_exception:
                 raise e
 
     def can_generate_je_number(self) -> bool:
         """
         Checks if the JournalEntryModel instance can generate its own JE number.
         Conditions are:
-            * The JournalEntryModel must have a LedgerModel instance assigned.
-            * The JournalEntryModel instance must not have a pre-existing JE number.
+        * The JournalEntryModel must have a LedgerModel instance assigned.
+        * The JournalEntryModel instance must not have a pre-existing JE number.
 
         Returns
         -------
         bool
             True if JournalEntryModel needs a JE number, otherwise False.
         """
         return all([
@@ -994,14 +986,16 @@
                     is_txs_qs_valid = self.is_txs_qs_valid(raise_exception=raise_exception, txs_qs=txs_qs)
                 except JournalEntryValidationError as e:
                     raise e
 
             # CREDIT/DEBIT Balance validation...
             try:
                 is_balance_valid = self.is_balance_valid(txs_qs=txs_qs, raise_exception=raise_exception)
+                if not is_balance_valid:
+                    raise JournalEntryValidationError('Transaction balances are not valid!')
             except JournalEntryValidationError as e:
                 raise e
 
             # if not len(txs_qs):
             #     if raise_exception:
             #         raise JournalEntryValidationError('Journal entry has no transactions.')
 
@@ -1014,40 +1008,52 @@
                 self.generate_activity(txs_qs=txs_qs, raise_exception=raise_exception)
                 self._verified = True
                 return txs_qs, self.is_verified()
         return TransactionModel.objects.none(), self.is_verified()
 
     def clean(self,
               verify: bool = False,
+              raise_exception: bool = True,
               txs_qs: Optional[TransactionModelQuerySet] = None) -> Tuple[TransactionModelQuerySet, bool]:
         """
         Customized JournalEntryModel clean method. Generates a JE number if needed. Optional verification hook on clean.
 
         Parameters
         ----------
+        raise_exception: bool
+            Raises exception if JE could not be verified. Defaults to True.
         verify: bool
             Attempts to verify the JournalEntryModel during cleaning.
         txs_qs: TransactionModelQuerySet
             Prefetched TransactionModelQuerySet. If provided avoids additional DB query. Will be verified against
             JournalEntryModel instance.
 
         Returns
         -------
         tuple: TransactionModelQuerySet, bool
             The TransactionModelQuerySet of the JournalEntryModel instance, verification result as True/False.
         """
         if txs_qs:
             self.is_txs_qs_valid(txs_qs=txs_qs)
+
+        if not self.timestamp:
+            self.timestamp = localtime()
+        elif self.timestamp and self.timestamp > localtime():
+            raise JournalEntryValidationError(message='Cannot create JE Models with timestamp in the future.')
+
         self.generate_je_number(commit=True)
         if verify:
             txs_qs, verified = self.verify()
             return txs_qs, self.is_verified()
         return TransactionModel.objects.none(), self.is_verified()
 
-    def save(self, verify: bool = True, post_on_verify: bool = False, *args, **kwargs):
+    def save(self,
+             verify: bool = True,
+             post_on_verify: bool = False,
+             *args, **kwargs):
         # todo this does not show up on docs...
         """
         Custom JournalEntryModel instance save method. Additional options are added to attempt to verify JournalEntryModel
         before saving into database.
 
         Parameters
         ----------
@@ -1060,15 +1066,15 @@
         -------
         JournalEntryModel
             The saved instance.
         """
         try:
             self.generate_je_number(commit=False)
             if verify:
-                self.clean(verify=True)
+                txs_qs, is_verified = self.clean(verify=True)
                 if self.is_verified() and post_on_verify:
                     # commit is False since the super call takes place at the end of save()
                     self.mark_as_posted(commit=False, verify=False, raise_exception=True)
         except ValidationError as e:
             if self.can_unpost():
                 self.mark_as_unposted(raise_exception=True)
             raise JournalEntryValidationError(
```

## django_ledger/models/ledger.py

```diff
@@ -1,40 +1,95 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
-Miguel Sanda <msanda@arrobalytics.com>
+    * Miguel Sanda <msanda@arrobalytics.com>
+
+The LedgerModel is the heart of Django Ledger. It is a self-contained unit of accounting that implements a
+double-entry accounting system capable of creating and managing transactions into the ledger and producing any financial
+statements. In essence, an EntityModel is made of a collection of LedgerModels that drive the whole bookkeeping process.
+Each LedgerModel is independent and they can operate as an individual or as a group.
+
+Each LedgerModel encapsulates a collection of JournalEntryModels, which in turn hold a collection of TransactionModels.
+LedgerModels can be used to represent any part of the EntityModel and can be extended to add additional functionality
+and custom logic that drives how transactions are recorded into the books. One example of this is the LedgerWrapperMixIn
+(see django_ledger.models.mixins.LedgerWrapperMixIn), which is the foundation of LedgerModel abstractions such as the
+BillModel, InvoiceModel, PurchaseOrderModel and EstimateModel. Extending the LedgerModel can add additional
+functionality necessary to implement industry-specific functionality to almost anything you can think of. Examples:
+Farming Equipment, Real Estate, Investment Portfolio, etc.
+
+Also, the LedgerModel inherits functionality from the all mighty IOMixIn (see django_ledger.io.io_mixin.IOMixIn),
+which is the class responsible for making accounting queries to the Database in an efficient and performing way.
+The digest() method executes all necessary aggregations and optimizations in order to push as much work to the Database
+layer as possible in order to minimize the amount of data being pulled for analysis into the Python memory.
+
+The Django Ledger core model follows the following structure: \n
+EntityModel -< LedgerModel -< JournalEntryModel -< TransactionModel
 """
 
-from random import choice
 from string import ascii_lowercase, digits
 from uuid import uuid4
 
+from django.core.exceptions import ValidationError
 from django.db import models
 from django.db.models import Q
 from django.urls import reverse
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.io import IOMixIn
 from django_ledger.models import lazy_loader
 from django_ledger.models.mixins import CreateUpdateMixIn
 
 LEDGER_ID_CHARS = ascii_lowercase + digits
 
 
+class LedgerModelValidationError(ValidationError):
+    pass
+
+
 class LedgerModelQuerySet(models.QuerySet):
     """
     Custom defined LedgerModel QuerySet.
     """
 
+    def posted(self):
+        """
+        Filters the QuerySet to only posted LedgerModel.
+
+        Returns
+        -------
+        LedgerModelQuerySet
+            A QuerySet with applied filters.
+        """
+        return self.filter(posted=True)
+
 
 class LedgerModelManager(models.Manager):
+    """
+    A custom-defined LedgerModelManager that implements custom QuerySet methods related to the LedgerModel.
+    """
 
     def for_entity(self, entity_slug, user_model):
+        """
+        Returns a QuerySet of LedgerModels associated with a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
+
+        Parameters
+        ----------
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel used for filtering the QuerySet.
+        user_model
+            The request UserModel to check for privileges.
+
+        Returns
+        -------
+        LedgerModelQuerySet
+            A Filtered LedgerModelQuerySet.
+        """
         qs = self.get_queryset()
         if isinstance(entity_slug, lazy_loader.get_entity_model()):
             return qs.filter(
                 Q(entity=entity_slug) &
                 (
                         Q(entity__admin=user_model) |
                         Q(entity__managers__in=[user_model])
@@ -44,21 +99,38 @@
             Q(entity__slug__exact=entity_slug) &
             (
                     Q(entity__admin=user_model) |
                     Q(entity__managers__in=[user_model])
             )
         )
 
-    def posted(self):
-        return self.get_queryset().filter(posted=True)
-
 
 class LedgerModelAbstract(CreateUpdateMixIn, IOMixIn):
+    """
+    Base implmentation of the LedgerModel.
+
+    Attributes
+    ----------
+    uuid: UUID
+        This is a unique primary key generated for the table. The default value of this field is uuid4().
+    name: str
+        Human-readable name of the LedgerModel. Maximum 150 characters.
+    entity: EntityModel
+        The EntityModel associated with the LedgerModel instance.
+    posted: bool
+        Determines if the LedgerModel is posted. Defaults to False. Mandatory.
+    locked: bool
+        Determines if the LedgerModel is locked. Defaults to False. Mandatory.
+    hidden: bool
+        Determines if the LedgerModel is hidden. Defaults to False. Mandatory.
+    """
     uuid = models.UUIDField(default=uuid4, editable=False, primary_key=True)
     name = models.CharField(max_length=150, null=True, blank=True, verbose_name=_('Ledger Name'))
+
+    # todo: rename to entity_model...
     entity = models.ForeignKey('django_ledger.EntityModel',
                                editable=False,
                                on_delete=models.CASCADE,
                                verbose_name=_('Ledger Entity'))
     posted = models.BooleanField(default=False, verbose_name=_('Posted Ledger'))
     locked = models.BooleanField(default=False, verbose_name=_('Locked Ledger'))
     hidden = models.BooleanField(default=False, verbose_name=_('Hidden Ledger'))
@@ -75,71 +147,190 @@
             models.Index(fields=['entity', 'posted']),
             models.Index(fields=['entity', 'locked']),
         ]
 
     def __str__(self):
         return self.name
 
-    def is_posted(self):
+    def is_posted(self) -> bool:
+        """
+        Determines if the LedgerModel instance is posted.
+
+        Returns
+        -------
+        bool
+            True if posted, else False.
+        """
         return self.posted is True
 
-    def is_locked(self):
+    def is_locked(self) -> bool:
+        """
+        Determines if the LedgerModel instance is locked.
+
+        Returns
+        -------
+        bool
+            True if locked, else False.
+        """
         return self.locked is True
 
-    def is_hidden(self):
+    def is_hidden(self) -> bool:
+        """
+        Determines if the LedgerModel instance is hidden.
+
+        Returns
+        -------
+        bool
+            True if hidden, else False.
+        """
         return self.hidden is True
 
-    def get_absolute_url(self):
-        return reverse('django_ledger:ledger-detail',
-                       kwargs={
-                           # pylint: disable=no-member
-                           'entity_slug': self.entity.slug,
-                           'ledger_pk': self.uuid
-                       })
+    def can_post(self) -> bool:
+        """
+        Determines if the LedgerModel can be marked as posted.
+
+        Returns
+        -------
+        bool
+            True if can be posted, else False.
+        """
+        return self.posted is False
+
+    def can_unpost(self) -> bool:
+        """
+        Determines if the LedgerModel can be un-posted.
+
+        Returns
+        -------
+        bool
+            True if can be un-posted, else False.
+        """
+        return self.posted is True
 
-    def get_update_url(self):
-        return reverse('django_ledger:ledger-update',
-                       kwargs={
-                           # pylint: disable=no-member
-                           'entity_slug': self.entity.slug,
-                           'ledger_pk': self.uuid
-                       })
+    def can_lock(self) -> bool:
+        """
+        Determines if the LedgerModel can be locked.
+
+        Returns
+        -------
+        bool
+            True if can be locked, else False.
+        """
+        return self.locked is False
+
+    def can_unlock(self) -> bool:
+        """
+        Determines if the LedgerModel can be un-locked.
+
+        Returns
+        -------
+        bool
+            True if can be un-locked, else False.
+        """
+        return self.locked is True
 
     def post(self, commit: bool = False):
-        if not self.posted:
+        """
+        Posts the LedgerModel.
+
+        Parameters
+        ----------
+        commit: bool
+            If True, saves the LedgerModel instance instantly. Defaults to False.
+        """
+        if self.can_post():
             self.posted = True
             if commit:
                 self.save(update_fields=[
                     'posted',
                     'updated'
                 ])
 
     def unpost(self, commit: bool = False):
-        if self.posted:
+        """
+        Un-posts the LedgerModel.
+
+        Parameters
+        ----------
+        commit: bool
+            If True, saves the LedgerModel instance instantly. Defaults to False.
+        """
+        if self.can_unpost():
             self.posted = False
             if commit:
                 self.save(update_fields=[
                     'posted',
                     'updated'
                 ])
 
     def lock(self, commit: bool = False):
-        self.locked = True
-        if commit:
-            self.save(update_fields=[
-                'locked',
-                'updated'
-            ])
+        """
+        Locks the LedgerModel.
+
+        Parameters
+        ----------
+        commit: bool
+            If True, saves the LedgerModel instance instantly. Defaults to False.
+        """
+        if self.can_lock():
+            self.locked = True
+            if commit:
+                self.save(update_fields=[
+                    'locked',
+                    'updated'
+                ])
 
     def unlock(self, commit: bool = False):
-        self.locked = False
-        if commit:
-            self.save(update_fields=[
-                'locked',
-                'updated'
-            ])
+        """
+        Un-locks the LedgerModel.
+
+        Parameters
+        ----------
+        commit: bool
+            If True, saves the LedgerModel instance instantly. Defaults to False.
+        """
+        if self.can_unlock():
+            self.locked = False
+            if commit:
+                self.save(update_fields=[
+                    'locked',
+                    'updated'
+                ])
+
+    def get_absolute_url(self) -> str:
+        """
+        Determines the absolute URL of the LedgerModel instance.
+        Results in additional Database query if entity field is not selected in QuerySet.
+
+        Returns
+        -------
+        str
+            URL as a string.
+        """
+        return reverse('django_ledger:ledger-detail',
+                       kwargs={
+                           # pylint: disable=no-member
+                           'entity_slug': self.entity.slug,
+                           'ledger_pk': self.uuid
+                       })
+
+    def get_update_url(self) -> str:
+        """
+        Determines the update URL of the LedgerModel instance.
+        Results in additional Database query if entity field is not selected in QuerySet.
+
+        Returns
+        -------
+        str
+            URL as a string.
+        """
+        return reverse('django_ledger:ledger-update',
+                       kwargs={
+                           'entity_slug': self.entity.slug,
+                           'ledger_pk': self.uuid
+                       })
 
 
 class LedgerModel(LedgerModelAbstract):
     """
-    Ledger Model from Abstract
+    Base LedgerModel from Abstract.
     """
```

## django_ledger/models/mixins.py

```diff
@@ -1,66 +1,110 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
-Miguel Sanda <msanda@arrobalytics.com>
+    * Miguel Sanda <msanda@arrobalytics.com>
+
+This module implements the different model MixIns used on different Django Ledger Models to implement common
+functionality.
 """
 import logging
 from collections import defaultdict
 from datetime import timedelta, date, datetime
 from decimal import Decimal
 from itertools import groupby
-from typing import Optional, Union
+from typing import Optional, Union, Dict
+from uuid import UUID
 
+from django.conf import settings
 from django.core.exceptions import ValidationError
 from django.core.validators import MinValueValidator, MaxValueValidator, MinLengthValidator
 from django.core.validators import int_list_validator
 from django.db import models
 from django.db.models import QuerySet
 from django.utils.encoding import force_str
 from django.utils.timezone import localdate, localtime
 from django.utils.translation import gettext_lazy as _
 from markdown import markdown
 
-from django_ledger.io import balance_tx_data, ASSET_CA_CASH, ASSET_CA_PREPAID, LIABILITY_CL_DEFERRED_REVENUE, \
-    validate_io_date
+from django_ledger.io import (balance_tx_data, ASSET_CA_CASH, ASSET_CA_PREPAID, LIABILITY_CL_DEFERRED_REVENUE,
+                              validate_io_date)
 from django_ledger.models.utils import lazy_loader
 
+logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
+
 
 class SlugNameMixIn(models.Model):
+    """
+    Implements a slug field and a name field to a base Django Model.
+
+    Attributes
+    ----------
+    slug: str
+        A unique slug field to use as an index. Validates that the slug is at least 10 characters long.
+    name: str
+        A human-readable name for display purposes. Maximum 150 characters.
+    """
     slug = models.SlugField(max_length=50,
                             editable=False,
                             unique=True,
                             validators=[
                                 MinLengthValidator(limit_value=10,
                                                    message=_('Slug field must contain at least 10 characters.'))
                             ])
     name = models.CharField(max_length=150, null=True, blank=True)
 
     class Meta:
         abstract = True
 
-    def __str__(self):
-        # pylint: disable=invalid-str-returned
-        return self.slug
-
 
 class CreateUpdateMixIn(models.Model):
     """
-    The create and update mixin!
+    Implements a created and an updated field to a base Django Model.
+
+    Attributes
+    ----------
+    created: datetime
+        A created timestamp. Defaults to now().
+    updated: str
+        An updated timestamp used to identify when models are updated.
     """
     created = models.DateTimeField(auto_now_add=True)
     updated = models.DateTimeField(auto_now=True, null=True, blank=True)
 
     class Meta:
         abstract = True
 
 
 class ContactInfoMixIn(models.Model):
+    """
+    Implements a common set of fields used to document contact information.
+
+    Attributes
+    ----------
+    address_1: str
+        A string used to document the first line of an address. Mandatory. Max length is 70.
+    address_2: str
+        A string used to document the first line of an address. Optional.
+    city: str
+        A string used to document the city. Optional.
+    state: str
+        A string used to document the State of Province. Optional.
+    zip_code: str
+        A string used to document the ZIP code. Optional
+    country: str
+       A string used to document the country. Optional.
+    email: str
+        A string used to document the contact email. Uses django's EmailField for validation.
+    website: str
+        A string used to document the contact website. Uses django's URLField for validation.
+    phone: str
+        A string used to document the contact phone.
+    """
     address_1 = models.CharField(max_length=70, verbose_name=_('Address Line 1'))
     address_2 = models.CharField(null=True, blank=True, max_length=70, verbose_name=_('Address Line 2'))
     city = models.CharField(null=True, blank=True, max_length=70, verbose_name=_('City'))
     state = models.CharField(null=True, blank=True, max_length=70, verbose_name=_('State/Province'))
     zip_code = models.CharField(null=True, blank=True, max_length=20, verbose_name=_('Zip Code'))
     country = models.CharField(null=True, blank=True, max_length=70, verbose_name=_('Country'))
     email = models.EmailField(null=True, blank=True, verbose_name=_('Email'))
@@ -76,18 +120,46 @@
             self.state,
             self.zip_code,
             self.country,
         ]):
             return f'{self.city}, {self.state}. {self.zip_code}. {self.country}'
 
 
-class LedgerWrapperMixIn(models.Model):
+class AccrualMixIn(models.Model):
     """
-    The Ledger wrapper!
-
+    Implements functionality used to track accruable financial instruments to a base Django Model.
+    Examples of this include bills and invoices expenses/income, that depending on the Entity's accrual method, may
+    be recognized on the Income Statement differently.
+
+    Attributes
+    ----------
+    amount_due: Decimal
+        The total amount due of the financial instrument.
+    amount_paid: Decimal
+        The total amount paid or settled.
+    amount_receivable: Decimal
+        The total amount allocated to Accounts Receivable based on the progress.
+    amount_unearned: Decimal
+        The total amount allocated to Accounts Payable based on the progress.
+    amount_earned:
+        The total amount that is recognized on the earnings based on progress.
+    accrue: bool
+        If True, the financial instrument will follow the Accrual Method of Accounting, otherwise it will follow the
+        Cash Method of Accounting. Defaults to the EntityModel preferred method of accounting.
+    progress: Decimal
+        A decimal number representing the amount of progress of the financial instrument. Value is between 0.00 and 1.00.
+    ledger: LedgerModel
+        The LedgerModel associated with the Accruable financial instrument.
+    cash_account: AccountModel
+        The AccountModel used to track cash payments to the financial instrument. Must be of role ASSET_CA_CASH.
+    prepaid_account: AccountModel
+        The AccountModel used to track receivables to the financial instrument. Must be of role ASSET_CA_PREPAID.
+    unearned_account: AccountModel
+        The AccountModel used to track receivables to the financial instrument. Must be of role
+        LIABILITY_CL_DEFERRED_REVENUE.
     """
     IS_DEBIT_BALANCE = None
     REL_NAME_PREFIX = None
     ALLOW_MIGRATE = True
     TX_TYPE_MAPPING = {
         'ci': 'credit',
         'dd': 'credit',
@@ -120,24 +192,25 @@
                                         max_digits=20,
                                         decimal_places=2,
                                         verbose_name=_('Amount Earned'),
                                         validators=[MinValueValidator(limit_value=0)])
 
     accrue = models.BooleanField(default=False, verbose_name=_('Accrue'))
 
-    # todo: change progress method from percent to currency amount...
+    # todo: change progress method from percent to currency amount and FloatField??...
     progress = models.DecimalField(default=0,
                                    verbose_name=_('Progress Amount'),
                                    decimal_places=2,
                                    max_digits=3,
                                    validators=[
                                        MinValueValidator(limit_value=0),
                                        MaxValueValidator(limit_value=1)
                                    ])
 
+    # todo: rename to ledger_model...
     ledger = models.OneToOneField('django_ledger.LedgerModel',
                                   editable=False,
                                   verbose_name=_('Ledger'),
                                   on_delete=models.CASCADE)
     cash_account = models.ForeignKey('django_ledger.AccountModel',
                                      on_delete=models.RESTRICT,
                                      blank=True,
@@ -146,175 +219,367 @@
                                      related_name=f'{REL_NAME_PREFIX}_cash_account')
     prepaid_account = models.ForeignKey('django_ledger.AccountModel',
                                         on_delete=models.RESTRICT,
                                         blank=True,
                                         null=True,
                                         verbose_name=_('Prepaid Account'),
                                         related_name=f'{REL_NAME_PREFIX}_prepaid_account')
+
+    # todo: rename to payable account...
     unearned_account = models.ForeignKey('django_ledger.AccountModel',
                                          on_delete=models.RESTRICT,
                                          blank=True,
                                          null=True,
                                          verbose_name=_('Unearned Account'),
                                          related_name=f'{REL_NAME_PREFIX}_unearned_account')
 
     class Meta:
         abstract = True
 
     # STATES..
-    def is_configured(self):
+    def is_configured(self) -> bool:
+        """
+        Determines if the accruable financial instrument is properly configured.
+
+        Returns
+        -------
+        bool
+            True if configured, else False.
+        """
         return all([
             self.ledger_id is not None,
             self.cash_account_id is not None,
             self.unearned_account_id is not None,
             self.prepaid_account_id is not None
         ])
 
     def is_posted(self):
+        """
+        Determines if the accruable financial instrument is posted.
+        Results in additional Database query if 'ledger' field is not pre-fetch on QuerySet.
+
+        Returns
+        -------
+        bool
+            True if posted, else False.
+        """
         return self.ledger.posted
 
     # OTHERS...
-    def get_progress(self):
+    def get_progress(self) -> Union[Decimal, float]:
+        """
+        Determines the progress amount based on amount due, amount paid and accrue field.
+
+        Returns
+        -------
+        Decimal
+            Financial instrument progress as a Decimal.
+        """
         if self.accrue:
             return self.progress
         if not self.amount_due:
-            return 0
-        return (self.amount_paid or 0) / self.amount_due
+            return Decimal.from_float(0.00)
+        return (self.amount_paid or Decimal.from_float(0.00)) / self.amount_due
 
-    def get_progress_percent(self):
+    def get_progress_percent(self) -> float:
+        """
+        Determines the progress amount as percent based on amount due, amount paid and accrue field.
+
+        Returns
+        -------
+        float
+            Financial instrument progress as a percent.
+        """
         return round(self.get_progress() * 100, 2)
 
-    def get_amount_cash(self):
+    def get_amount_cash(self) -> Union[Decimal, float]:
+        """
+        Determines the impact to the EntityModel cash balance based on the financial instrument debit or credit
+        configuration. i.e, Invoices are debit financial instrument because payments to invoices increase cash.
+
+        Returns
+        -------
+        float
+            Financial instrument progress as a percent.
+        """
         if self.IS_DEBIT_BALANCE:
             return self.amount_paid
         elif not self.IS_DEBIT_BALANCE:
             return -self.amount_paid
 
-    def get_amount_earned(self):
+    def get_amount_earned(self) -> Union[Decimal, float]:
+        """
+        Determines the impact to the EntityModel earnings based on financial instrument progress.
+
+        Returns
+        -------
+        float or Decimal
+            Financial instrument amount earned.
+        """
         if self.accrue:
-            amount_due = self.amount_due or 0
+            amount_due = self.amount_due or Decimal.from_float(0.00)
             return self.get_progress() * amount_due
         else:
-            return self.amount_paid or 0
+            return self.amount_paid or Decimal.from_float(0.00)
+
+    def get_amount_prepaid(self) -> Union[Decimal, float]:
+        """
+        Determines the impact to the EntityModel Accounts Receivable based on financial instrument progress.
 
-    def get_amount_prepaid(self):
-        payments = self.amount_paid or 0
+        Returns
+        -------
+        float or Decimal
+            Financial instrument amount prepaid.
+        """
+        payments = self.amount_paid or Decimal.from_float(0.00)
         if self.accrue:
             amt_earned = self.get_amount_earned()
-            if all([self.IS_DEBIT_BALANCE,
-                    amt_earned >= payments]):
+            if all([
+                self.IS_DEBIT_BALANCE,
+                amt_earned >= payments
+            ]):
                 return self.get_amount_earned() - payments
-            elif all([not self.IS_DEBIT_BALANCE,
-                      amt_earned <= payments]):
+            elif all([
+                not self.IS_DEBIT_BALANCE,
+                amt_earned <= payments
+            ]):
                 return payments - self.get_amount_earned()
-        return 0
+        return Decimal.from_float(0.00)
 
-    def get_amount_unearned(self):
+    def get_amount_unearned(self) -> Union[Decimal, float]:
+        """
+        Determines the impact to the EntityModel Accounts Payable based on financial instrument progress.
+
+        Returns
+        -------
+        float or Decimal
+            Financial instrument amount unearned.
+        """
         if self.accrue:
             amt_earned = self.get_amount_earned()
-            if all([self.IS_DEBIT_BALANCE,
-                    amt_earned <= self.amount_paid]):
+            if all([
+                self.IS_DEBIT_BALANCE,
+                amt_earned <= self.amount_paid
+            ]):
                 return self.amount_paid - amt_earned
-            elif all([not self.IS_DEBIT_BALANCE,
-                      amt_earned >= self.amount_paid]):
+            elif all([
+                not self.IS_DEBIT_BALANCE,
+                amt_earned >= self.amount_paid
+            ]):
                 return amt_earned - self.amount_paid
-        return 0
+        return Decimal.from_float(0.00)
+
+    def get_amount_open(self) -> Union[Decimal, float]:
+        """
+        Determines the open amount left to be progressed.
 
-    def get_amount_open(self):
+        Returns
+        -------
+        float or Decimal
+            Financial instrument amount open.
+        """
         if self.accrue:
-            amount_due = self.amount_due or 0
+            amount_due = self.amount_due or Decimal.from_float(0.00)
             return amount_due - self.get_amount_earned()
-        else:
-            amount_due = self.amount_due or 0
-            payments = self.amount_paid or 0
-            return amount_due - payments
+        amount_due = self.amount_due or Decimal.from_float(0.00)
+        payments = self.amount_paid or Decimal.from_float(0.00)
+        return amount_due - payments
 
-    def get_migration_data(self, queryset=None):
-        raise NotImplementedError('Must implement get_account_balance_data method.')
+    def get_migration_data(self, queryset: QuerySet = None):
+        raise NotImplementedError('Must implement get_migration_data method.')
 
     def get_migrate_state_desc(self, *args, **kwargs):
-        """
-        Must be implemented.
-        :return:
-        """
+        raise NotImplementedError('Must implement get_migrate_state_desc method.')
 
     def can_migrate(self) -> bool:
         """
-        Function returning if model state can be migrated to related accounts.
-        :return:
+        Determines if the Accruable financial instrument can be migrated to the books.
+        Results in additional Database query if 'ledger' field is not pre-fetch on QuerySet.
+
+        Returns
+        -------
+        bool
+            True if can migrate, else False.
         """
         if not self.ledger_id:
             return False
         return not self.ledger.locked
 
     def get_tx_type(self,
                     acc_bal_type: dict,
                     adjustment_amount: Decimal):
+        """
+        Determines the transaction type associated with an increase/decrease of an account balance of the financial
+        instrument.
 
-        if adjustment_amount:
-            acc_bal_type = acc_bal_type[0]
-            d_or_i = 'd' if adjustment_amount < 0 else 'i'
-            return self.TX_TYPE_MAPPING[acc_bal_type + d_or_i]
-        return 'debit'
+        Parameters
+        ----------
+        acc_bal_type:
+            The balance type of the account to be adjusted.
+        adjustment_amount: Decimal
+            The adjustment, whether positive or negative.
+
+        Returns
+        -------
+        str
+            The transaction type of the account adjustment.
+        """
+        acc_bal_type = acc_bal_type[0]
+        d_or_i = 'd' if adjustment_amount < 0.00 else 'i'
+        return self.TX_TYPE_MAPPING[acc_bal_type + d_or_i]
+
+    @classmethod
+    def split_amount(cls, amount: Union[Decimal, float],
+                     unit_split: Dict,
+                     account_uuid: UUID,
+                     account_balance_type: str) -> Dict:
+        """
+        Splits an amount into different proportions representing the unit splits.
+        Makes sure that 100% of the amount is numerically allocated taking into consideration decimal points.
 
-    def split_amount(self, amount: float, unit_split: dict, account_uuid, account_balance_type) -> dict:
+        Parameters
+        ----------
+        amount: Decimal or float
+            The amount to be split.
+        unit_split: dict
+            A dictionary with information related to each unit split and proportions.
+        account_uuid: UUID
+            The AccountModel UUID associated with the splits.
+        account_balance_type: str
+            The AccountModel balance type to determine whether to perform a credit or a debit.
+
+        Returns
+        -------
+        dict
+            A dictionary with the split information.
+        """
         running_alloc = 0
         SPLIT_LEN = len(unit_split) - 1
         split_results = dict()
         for i, (u, p) in enumerate(unit_split.items()):
             if i == SPLIT_LEN:
                 split_results[(account_uuid, u, account_balance_type)] = amount - running_alloc
             else:
                 alloc = round(p * amount, 2)
                 split_results[(account_uuid, u, account_balance_type)] = alloc
                 running_alloc += alloc
         return split_results
 
     # LOCK/UNLOCK Ledger...
     def lock_ledger(self, commit: bool = False, raise_exception: bool = True, **kwargs):
+        """
+        Convenience method to lock the LedgerModel associated with the Accruable financial instrument.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits the transaction in the database. Defaults to False.
+        raise_exception: bool
+            If True, raises ValidationError if LedgerModel already locked.
+        """
         ledger_model = self.ledger
         if ledger_model.locked:
             if raise_exception:
                 raise ValidationError(f'Bill ledger {ledger_model.name} is already locked...')
         ledger_model.lock(commit)
 
     def unlock_ledger(self, commit: bool = False, raise_exception: bool = True, **kwargs):
+        """
+        Convenience method to un-lock the LedgerModel associated with the Accruable financial instrument.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits the transaction in the database. Defaults to False.
+        raise_exception: bool
+            If True, raises ValidationError if LedgerModel already locked.
+        """
         ledger_model = self.ledger
         if not ledger_model.locked:
             if raise_exception:
                 raise ValidationError(f'Bill ledger {ledger_model.name} is already unlocked...')
         ledger_model.unlock(commit)
 
     # POST/UNPOST Ledger...
     def post_ledger(self, commit: bool = False, raise_exception: bool = True, **kwargs):
+        """
+        Convenience method to post the LedgerModel associated with the Accruable financial instrument.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits the transaction in the database. Defaults to False.
+        raise_exception: bool
+            If True, raises ValidationError if LedgerModel already locked.
+        """
         ledger_model = self.ledger
         if ledger_model.posted:
             if raise_exception:
                 raise ValidationError(f'Bill ledger {ledger_model.name} is already posted...')
         ledger_model.post(commit)
 
     def unpost_ledger(self, commit: bool = False, raise_exception: bool = True, **kwargs):
+        """
+        Convenience method to un-lock the LedgerModel associated with the Accruable financial instrument.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits the transaction in the database. Defaults to False.
+        raise_exception: bool
+            If True, raises ValidationError if LedgerModel already locked.
+        """
         ledger_model = self.ledger
         if not ledger_model.posted:
             if raise_exception:
                 raise ValidationError(f'Bill ledger {ledger_model.name} is not posted...')
         ledger_model.post(commit)
 
     def migrate_state(self,
                       user_model,
                       entity_slug: str,
-                      itemtxs_qs: QuerySet = None,
+                      itemtxs_qs: Optional[QuerySet] = None,
                       force_migrate: bool = False,
                       commit: bool = True,
                       void: bool = False,
-                      je_date: Union[str, date, datetime] = None,
-                      verify_journal_entries: bool = True,
+                      je_date: Optional[Union[str, date, datetime]] = None,
                       raise_exception: bool = True,
                       **kwargs):
 
+        """
+        Migrates the current Accruable financial instrument into the books. The main objective of the migrate_state
+        method is to determine the JournalEntry and TransactionModels necessary to accurately reflect the financial
+        instrument state in the books.
+
+        Parameters
+        ----------
+        user_model
+            The Django User Model.
+        entity_slug: str
+            The EntityModel slug.
+        itemtxs_qs: ItemTransactionModelQuerySet
+            The pre-fetched ItemTransactionModelQuerySet containing the item information associated with the financial
+            element migration. If provided, will avoid additional database query.
+        force_migrate: bool
+            Forces migration of the financial instrument bypassing the can_migrate() check.
+        commit: bool
+            If True the migration will be committed in the database. Defaults to True.
+        void: bool
+            If True, the migration will perform a VOID actions of the financial instrument.
+        je_date: date
+            The JournalEntryModel date to be used for this migration.
+        raise_exception: bool
+            Raises ValidationError if migration is not allowed. Defaults to True.
+
+        Returns
+        -------
+        tuple
+            A tuple of the ItemTransactionModel and the Digest Result from IOMixIn.
+        """
+
         if self.can_migrate() or force_migrate:
 
             # getting current ledger state
             txs_qs, txs_digest = self.ledger.digest(
                 user_model=user_model,
                 entity_slug=entity_slug,
                 process_groups=True,
@@ -506,57 +771,90 @@
                     balance_tx_data(tx_data=[tx for ui, tx in txs_list if uid == ui], perform_correction=True)
 
                 # validates all txs as a whole (for safety)...
                 txs = [tx for ui, tx in txs_list]
                 balance_tx_data(tx_data=txs, perform_correction=True)
                 TransactionModel.objects.bulk_create(txs)
 
-                if verify_journal_entries:
-                    for _, je in je_list.items():
-                        # will independently verify and populate appropriate activity for JE.
-                        je.clean(verify=True)
-                        if je.is_verified():
-                            je.mark_as_posted(commit=False, verify=False, raise_exception=True)
-                            je.mark_as_locked(commit=False, raise_exception=True)
-
-                    if all([je.is_verified() for _, je in je_list.items()]):
-                        # only if all JEs have been verified will be posted and locked...
-                        JournalEntryModel.objects.bulk_update(
-                            objs=[je for _, je in je_list.items()],
-                            fields=['posted', 'locked', 'activity']
-                        )
+                for _, je in je_list.items():
+                    # will independently verify and populate appropriate activity for JE.
+                    je.clean(verify=True)
+                    if je.is_verified():
+                        je.mark_as_posted(commit=False, verify=False, raise_exception=True)
+                        je.mark_as_locked(commit=False, raise_exception=True)
+
+                if all([je.is_verified() for _, je in je_list.items()]):
+                    # only if all JEs have been verified will be posted and locked...
+                    JournalEntryModel.objects.bulk_update(
+                        objs=[je for _, je in je_list.items()],
+                        fields=['posted', 'locked', 'activity']
+                    )
 
-            return item_data, digest_data
+            return item_data, txs_digest
         else:
             if raise_exception:
                 raise ValidationError(f'{self.REL_NAME_PREFIX.upper()} state migration not allowed')
 
-    def void_state(self, commit: bool = False):
+    def void_state(self, commit: bool = False) -> Dict:
+        """
+        Determines the VOID state of the financial instrument.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits the new financial instrument state into the model.
+
+        Returns
+        -------
+        dict
+            A dictionary with new amount_paid, amount_receivable, amount_unearned and amount_earned as keys.
+        """
         void_state = {
-            'amount_paid': Decimal.from_float(0.0),
-            'amount_receivable': Decimal.from_float(0.0),
-            'amount_unearned': Decimal.from_float(0.0),
-            'amount_earned': Decimal.from_float(0.0),
+            'amount_paid': Decimal.from_float(0.00),
+            'amount_receivable': Decimal.from_float(0.00),
+            'amount_unearned': Decimal.from_float(0.00),
+            'amount_earned': Decimal.from_float(0.00),
         }
         if commit:
             self.update_state(void_state)
         return void_state
 
     def new_state(self, commit: bool = False):
+        """
+        Determines the new state of the financial instrument based on progress.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits the new financial instrument state into the model.
+
+        Returns
+        -------
+        dict
+            A dictionary with new amount_paid, amount_receivable, amount_unearned and amount_earned as keys.
+        """
         new_state = {
             'amount_paid': self.get_amount_cash(),
             'amount_receivable': self.get_amount_prepaid(),
             'amount_unearned': self.get_amount_unearned(),
             'amount_earned': self.get_amount_earned()
         }
         if commit:
             self.update_state(new_state)
         return new_state
 
-    def update_state(self, state: dict = None):
+    def update_state(self, state: Optional[Dict] = None):
+        """
+        Updates the state on the financial instrument.
+
+        Parameters
+        ----------
+        state: dict
+            Optional user provided state to use.
+        """
         if not state:
             state = self.new_state()
         self.amount_paid = abs(state['amount_paid'])
         self.amount_receivable = state['amount_receivable']
         self.amount_unearned = state['amount_unearned']
         self.amount_earned = state['amount_earned']
 
@@ -592,21 +890,21 @@
             if self.prepaid_account.role != ASSET_CA_PREPAID:
                 raise ValidationError(f'Prepaid account must be of role {ASSET_CA_PREPAID}.')
             # pylint: disable=no-member
             if self.unearned_account.role != LIABILITY_CL_DEFERRED_REVENUE:
                 raise ValidationError(f'Unearned account must be of role {LIABILITY_CL_DEFERRED_REVENUE}.')
 
         if self.accrue and self.progress is None:
-            self.progress = 0
+            self.progress = Decimal.from_float(0.00)
 
         if self.amount_paid > self.amount_due:
             raise ValidationError(f'Amount paid {self.amount_paid} cannot exceed amount due {self.amount_due}')
 
         if self.is_paid():
-            self.progress = Decimal(1.0)
+            self.progress = Decimal.from_float(1.0)
             self.amount_paid = self.amount_due
             today = localdate()
 
             if not self.date_paid:
                 self.date_paid = today
             if self.date_paid > today:
                 raise ValidationError(f'Cannot pay {self.__class__.__name__} in the future.')
@@ -618,59 +916,135 @@
                 self.amount_paid,
                 self.amount_earned,
                 self.amount_unearned,
                 self.amount_receivable
             ]):
                 raise ValidationError('Voided element cannot have any balance.')
 
-            self.progress = 0
+            self.progress = Decimal.from_float(0.00)
 
         if self.can_migrate():
             self.update_state()
 
 
 class PaymentTermsMixIn(models.Model):
     """
-    Payment Terms MixIn!
+    Implements functionality used to track dates relate to various payment terms.
+    Examples of this include tracking bills and invoices that are due on receipt, 30, 60 or 90 days after they are
+    approved.
+
+    Attributes
+    ----------
+    terms: str
+        A choice of TERM_CHOICES that determines the payment terms.
+
     """
     TERMS_ON_RECEIPT = 'on_receipt'
     TERMS_NET_30 = 'net_30'
     TERMS_NET_60 = 'net_60'
     TERMS_NET_90 = 'net_90'
     TERMS_NET_90_PLUS = 'net_90+'
 
-    TERMS = [
+    TERM_CHOICES = [
         (TERMS_ON_RECEIPT, 'Due On Receipt'),
         (TERMS_NET_30, 'Net 30 Days'),
         (TERMS_NET_60, 'Net 60 Days'),
         (TERMS_NET_90, 'Net 90 Days'),
     ]
 
+    TERM_DAYS_MAPPING = {
+        TERMS_ON_RECEIPT: 0,
+        TERMS_NET_30: 30,
+        TERMS_NET_60: 60,
+        TERMS_NET_90: 90,
+        TERMS_NET_90_PLUS: 120
+    }
+
     terms = models.CharField(max_length=10,
                              default='on_receipt',
-                             choices=TERMS,
+                             choices=TERM_CHOICES,
                              verbose_name=_('Terms'))
     date_due = models.DateField(verbose_name=_('Due Date'), null=True, blank=True)
 
     class Meta:
         abstract = True
 
-    def get_terms_start_date(self) -> Optional[date]:
+    def get_terms_start_date(self) -> date:
+        """
+        Determines the start date for the terms of payment.
+
+        Returns
+        -------
+        date
+            The date when terms of payment starts.
+        """
         raise NotImplementedError(
             f'Must implement get_terms_start_date() for {self.__class__.__name__}'
         )
 
+    def get_terms_net_90_plus(self) -> int:
+        """
+        Determines the number of days for 90+ days terms of payment.
+
+        Returns
+        -------
+        date
+            The date when terms of payment starts.
+        """
+        return 120
+
+    def get_terms_timedelta_days(self) -> int:
+        """
+        Determines the number of days from the terms start date.
+
+        Returns
+        -------
+        int
+            The number of days as integer.
+        """
+        if self.terms == self.TERMS_NET_90_PLUS:
+            return self.get_terms_net_90_plus()
+        return self.TERM_DAYS_MAPPING[self.terms]
+
+    def get_terms_timedelta(self) -> timedelta:
+        """
+        Calculates a timedelta relative to the terms start date.
+
+        Returns
+        -------
+        timedelta
+            Timedelta relative to terms start date.
+        """
+        return timedelta(days=self.get_terms_timedelta_days())
+
     def due_in_days(self) -> Optional[int]:
+        """
+        Determines how many days until the due date.
+
+        Returns
+        -------
+        int
+            Days as integer.
+        """
         if self.date_due:
             td = self.date_due - localdate()
             if td.days < 0:
                 return 0
             return td.days
 
+    # todo: is this necessary?...
     def net_due_group(self):
+        """
+        Determines the group where the financial instrument falls based on the number of days until the due date.
+
+        Returns
+        -------
+        str
+            The terms group as a string.
+        """
         due_in = self.due_in_days()
         if due_in == 0:
             return self.TERMS_ON_RECEIPT
         elif due_in <= 30:
             return self.TERMS_NET_30
         elif due_in <= 60:
             return self.TERMS_NET_60
@@ -678,64 +1052,84 @@
             return self.TERMS_NET_90
         return self.TERMS_NET_90_PLUS
 
     def clean(self):
         terms_start_date = self.get_terms_start_date()
         if terms_start_date:
             if self.terms != self.TERMS_ON_RECEIPT:
-                # pylint: disable=no-member
-                self.date_due = terms_start_date + timedelta(days=int(self.terms.split('_')[-1]))
+                self.date_due = terms_start_date + self.get_terms_timedelta()
             else:
                 self.date_due = terms_start_date
 
 
 class MarkdownNotesMixIn(models.Model):
     """
-    MarkDown Notes MixIn!
+    Implements functionality used to add a Mark-Down notes to a base Django Model.
+
+    Attributes
+    ----------
+    markdown_notes: str
+        A string of text representing the mark-down document.
     """
     markdown_notes = models.TextField(blank=True, null=True, verbose_name=_('Markdown Notes'))
 
     class Meta:
         abstract = True
 
     def notes_html(self):
+        """
+        Compiles the markdown_notes field into html.
+
+        Returns
+        -------
+        str
+            Compiled HTML document as a string.
+        """
         if not self.markdown_notes:
             return ''
         return markdown(force_str(self.markdown_notes))
 
 
 class BankAccountInfoMixIn(models.Model):
     """
-    MixIn to add universal bank routing information to DjangoLedger Models.
+    Implements functionality used to add bank account details to base Django Models.
 
-    @account_number: This is the Bank Account number . Only Digits are allowed.
-    @routing_number: User defined routing number for the concerned bank account. Also called as 'Routing Transit Number (RTN)'
-    @aba_number: The American Bankers Association Number assigned to each bank.
-    @account_type: Each account will have to select from the available choices Checking, Savings or Money Market.
-    @swift_number: SWIFT electronic communications network number of the bank institution.
+    Attributes
+    ----------
+    account_number: str
+        The Bank Account number. Only Digits are allowed. Max 30 digists.
+    routing_number: str
+        Routing number for the concerned bank account. Also called as 'Routing Transit Number (RTN)'. Max 30 digists.
+    aba_number: str
+        The American Bankers Association Number assigned to each bank.
+    account_type: str
+        A choice of ACCOUNT_TYPES. Each account will have to select from the available choices Checking, Savings.
+    swift_number: str
+        SWIFT electronic communications network number of the bank institution.
     """
 
     ACCOUNT_CHECKING = 'checking'
     ACCOUNT_SAVINGS = 'savings'
-    ACCOUNT_TYPES = [
+    ACCOUNT_TYPE_CHOICES = [
         (ACCOUNT_CHECKING, _('Checking')),
         (ACCOUNT_SAVINGS, _('Savings'))
     ]
+    VALID_ACCOUNT_TYPES = tuple(atc[0] for atc in ACCOUNT_TYPE_CHOICES)
 
     account_number = models.CharField(max_length=30, null=True, blank=True,
                                       validators=[
                                           int_list_validator(sep='', message=_('Only digits allowed'))
                                       ], verbose_name=_('Account Number'))
     routing_number = models.CharField(max_length=30, null=True, blank=True,
                                       validators=[
                                           int_list_validator(sep='', message=_('Only digits allowed'))
                                       ], verbose_name=_('Routing Number'))
     aba_number = models.CharField(max_length=30, null=True, blank=True, verbose_name=_('ABA Number'))
     swift_number = models.CharField(max_length=30, null=True, blank=True, verbose_name=_('SWIFT Number'))
-    account_type = models.CharField(choices=ACCOUNT_TYPES,
+    account_type = models.CharField(choices=ACCOUNT_TYPE_CHOICES,
                                     max_length=10,
                                     default=ACCOUNT_CHECKING,
                                     verbose_name=_('Account Type'))
 
     class Meta:
         abstract = True
 
@@ -747,32 +1141,51 @@
                                      verbose_name=_('Tax Registration Number'))
 
     class Meta:
         abstract = True
 
 
 class TaxCollectionMixIn(models.Model):
+    """
+    Implements functionality used to add tax collection rates and or withholding to a base Django Model.
+    This field may be used to set a pre-defined withholding rate to a financial instrument, customer, vendor, etc.
+
+    Attributes
+    ----------
+    sales_tax_rate: float
+        The tax rate as a float. A Number between 0.00 and 1.00.
+    """
     sales_tax_rate = models.FloatField(default=0.00000,
                                        verbose_name=_('Sales Tax Rate'),
                                        null=True,
                                        blank=True,
                                        validators=[
                                            MinValueValidator(limit_value=0.00000),
                                            MaxValueValidator(limit_value=1.00000)
                                        ])
 
     class Meta:
         abstract = True
 
 
 class LoggingMixIn:
+    """
+    Implements functionality used to add logging capabilities to any python class.
+    Useful for production and or testing environments.
+    """
     LOGGER_NAME_ATTRIBUTE = None
+    LOGGER_BYPASS_DEBUG = False
 
     def get_logger_name(self):
         if self.LOGGER_NAME_ATTRIBUTE is None:
             raise NotImplementedError(f'{self.__class__.__name__} must define LOGGER_NAME_ATTRIBUTE of implement '
                                       'get_logger_name() function.')
         return getattr(self, self.LOGGER_NAME_ATTRIBUTE)
 
     def get_logger(self) -> logging.Logger:
         name = self.get_logger_name()
         return logging.getLogger(name)
+
+    def send_log(self, msg, level, force):
+        if self.LOGGER_BYPASS_DEBUG or settings.DEBUG or force:
+            logger = self.get_logger()
+            logger.log(msg=msg, level=level)
```

## django_ledger/models/purchase_order.py

```diff
@@ -1,78 +1,184 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
     * Miguel Sanda <msanda@arrobalytics.com>
     * Pranav P Tulshyan <Ptulshyan77@gmail.com>
+
+A purchase order is a commercial source document that is issued by a business purchasing department when placing an
+order with its vendors or suppliers. The document indicates the details on the items that are to be purchased, such as
+the types of goods, quantity, and price. In simple terms, it is the contract drafted by the buyer when purchasing goods
+from the seller.
+
+The PurchaseOrderModel is designed to track the status of a Purchase Order and all its items. The PurchaseOrderModel
+starts in draft model by default and goes through different states including InReview, Approved, Fulfilled, Canceled and
+Void. The PurchaseOrderModel also keeps track of when these states take place.
+
 """
 from datetime import date
 from string import ascii_uppercase, digits
-from typing import Tuple, List, Union
+from typing import Tuple, List, Union, Optional
 from uuid import uuid4
 
+from django.contrib.auth import get_user_model
 from django.core.exceptions import ValidationError, ObjectDoesNotExist
 from django.core.validators import MinLengthValidator
 from django.db import models, transaction, IntegrityError
-from django.db.models import Q, Sum, Count, QuerySet, F
+from django.db.models import Q, Sum, Count, F
 from django.db.models.functions import Coalesce
+from django.db.models.signals import pre_save
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
 from django.utils.timezone import localdate
 from django.utils.translation import gettext_lazy as _
 
-from django_ledger.models import EntityModel, ItemTransactionModel, lazy_loader, BillModel
+from django_ledger.models.bill import BillModel, BillModelQuerySet
+from django_ledger.models.entity import EntityModel
+from django_ledger.models.items import ItemTransactionModel, ItemTransactionModelQuerySet
 from django_ledger.models.mixins import CreateUpdateMixIn, MarkdownNotesMixIn
+from django_ledger.models.utils import lazy_loader
 from django_ledger.settings import DJANGO_LEDGER_DOCUMENT_NUMBER_PADDING, DJANGO_LEDGER_PO_NUMBER_PREFIX
 
 PO_NUMBER_CHARS = ascii_uppercase + digits
 
+UserModel = get_user_model()
+
 
 class PurchaseOrderModelValidationError(ValidationError):
     pass
 
 
 class PurchaseOrderModelQuerySet(models.QuerySet):
+    """
+    A custom defined PurchaseOrderModel QuerySet.
+    """
 
     def approved(self):
+        """
+        Filters the QuerySet to include Approved PurchaseOrderModels only.
+
+        Returns
+        -------
+        PurchaseOrderModelQuerySet
+            A PurchaseOrderModelQuerySet with applied filters.
+        """
         return self.filter(po_status__exact=PurchaseOrderModel.PO_STATUS_APPROVED)
 
     def fulfilled(self):
+        """
+        Filters the QuerySet to include Fulfilled PurchaseOrderModels only.
+
+        Returns
+        -------
+        PurchaseOrderModelQuerySet
+            A PurchaseOrderModelQuerySet with applied filters.
+        """
         return self.filter(po_status__exact=PurchaseOrderModel.PO_STATUS_FULFILLED)
 
     def active(self):
+        """
+        Filters the QuerySet to include Active PurchaseOrderModels only.
+        Active PurchaseOrderModels are either approved or fulfilled, which are those that may contain associated
+        transactions on the Ledger.
+
+        Returns
+        -------
+        PurchaseOrderModelQuerySet
+            A PurchaseOrderModelQuerySet with applied filters.
+        """
         return self.filter(
             Q(po_status__exact=PurchaseOrderModel.PO_STATUS_APPROVED) |
             Q(po_status__exact=PurchaseOrderModel.PO_STATUS_FULFILLED)
         )
 
 
 class PurchaseOrderModelManager(models.Manager):
+    """
+    A custom defined PurchaseOrderModel Manager.
+    """
+
+    def for_entity(self, entity_slug, user_model) -> PurchaseOrderModelQuerySet:
+        """
+        Fetches a QuerySet of PurchaseOrderModel associated with a specific EntityModel & UserModel.
+        May pass an instance of EntityModel or a String representing the EntityModel slug.
 
-    def for_entity(self, entity_slug, user_model):
+        Returns
+        -------
+        PurchaseOrderModelQuerySet
+            A PurchaseOrderModelQuerySet with applied filters.
+        """
         qs = self.get_queryset()
         if isinstance(entity_slug, EntityModel):
             qs = qs.filter(entity=entity_slug)
         elif isinstance(entity_slug, str):
             qs = qs.filter(entity__slug__exact=entity_slug)
         return qs.filter(
             Q(entity__admin=user_model) |
             Q(entity__managers__in=[user_model])
         )
 
 
 class PurchaseOrderModelAbstract(CreateUpdateMixIn, MarkdownNotesMixIn):
+    """
+    The base implementation of the PurchaseOrderModel.
+
+    Attributes
+    ----------
+    uuid: UUID
+        This is a unique primary key generated for the table. The default value of this field is uuid4().
+    po_number: str
+        A unique human-readable and sequential PO Number identifier. Automatically generated.
+    po_title: str
+        The PurchaseOrderModel instance title.
+    po_status: str
+        One of PO_STATUS values representing the current status of the PurchaseOrderModel instance.
+    po_amount: Decimal
+        The total value of the PurchaseOrderModel instance.
+    po_amount_received: Decimal
+        The PurchaseOrderModel instance total value received to date. Cannot be greater than PO amount.
+    entity: EntityModel
+        The EntityModel associated with the PurchaseOrderModel instance.
+    date_draft: date
+        The draft date represents the date when the PurchaseOrderModel was first created. Defaults to
+        :func:`localdate <django.utils.timezone.localdate>`.
+    date_in_review: date
+        The in review date represents the date when the PurchaseOrderModel was marked as In Review status.
+        Will be null if PurchaseOrderModel is canceled during draft status. Defaults to
+        :func:`localdate <django.utils.timezone.localdate>`.
+    date_approved: date
+        The approved date represents the date when the PurchaseOrderModel was approved. Will be null if
+        PurchaseOrderModel is canceled.
+        Defaults to :func:`localdate <django.utils.timezone.localdate>`.
+    date_fulfilled: date
+        The paid date represents the date when the PurchaseOrderModel was fulfilled and po_amount_received equals
+        po_amount. Will be null if PurchaseOrderModel is canceled.
+        Defaults to :func:`localdate <django.utils.timezone.localdate>`.
+    date_void: date
+        The void date represents the date when the PurchaseOrderModel was void, if applicable.
+        Will be null unless PurchaseOrderModel is void.
+        Defaults to :func:`localdate <django.utils.timezone.localdate>`.
+    date_canceled: date
+        The canceled date represents the date when the PurchaseOrderModel was canceled, if applicable.
+        Will be null unless PurchaseOrderModel is canceled.
+        Defaults to :func:`localdate <django.utils.timezone.localdate>`.
+    po_items:
+        A foreign key reference to the list of ItemTransactionModel that make the PurchaseOrderModel amount.
+    ce_model: EstimateModel
+        A foreign key reference to the EstimateModel associated with the PurchaseOrderModel, if any.
+    """
     PO_STATUS_DRAFT = 'draft'
     PO_STATUS_REVIEW = 'in_review'
     PO_STATUS_APPROVED = 'approved'
     PO_STATUS_FULFILLED = 'fulfilled'
     PO_STATUS_VOID = 'void'
     PO_STATUS_CANCELED = 'canceled'
 
+    """The different valid PO Status and their representation in the Database"""
     PO_STATUS = [
         (PO_STATUS_DRAFT, _('Draft')),
         (PO_STATUS_REVIEW, _('In Review')),
         (PO_STATUS_APPROVED, _('Approved')),
         (PO_STATUS_FULFILLED, _('Fulfilled')),
         (PO_STATUS_CANCELED, _('Canceled')),
         (PO_STATUS_VOID, _('Void')),
@@ -111,15 +217,15 @@
 
     ce_model = models.ForeignKey('django_ledger.EstimateModel',
                                  on_delete=models.RESTRICT,
                                  null=True,
                                  blank=True,
                                  verbose_name=_('Associated Customer Job/Estimate'))
 
-    objects = PurchaseOrderModelManager.from_queryset(queryset_class=PurchaseOrderModelQuerySet)
+    objects = PurchaseOrderModelManager.from_queryset(queryset_class=PurchaseOrderModelQuerySet)()
 
     class Meta:
         abstract = True
         indexes = [
             models.Index(fields=['entity']),
             models.Index(fields=['po_number']),
             models.Index(fields=['po_status']),
@@ -137,280 +243,677 @@
         ]
 
     def __str__(self):
         # pylint: disable=no-member
         return f'PO Model: {self.po_number} | {self.get_po_status_display()}'
 
     # Configuration...
+
+    def is_configured(self) -> bool:
+        return all([
+            self.entity_id is not None,
+            self.date_draft,
+            self.po_status
+        ])
+
     def configure(self,
-                  entity_slug: str or EntityModel,
-                  user_model,
-                  draft_date: date = None,
+                  entity_slug: Union[str, EntityModel],
+                  user_model: Optional[UserModel] = None,
+                  draft_date: Optional[date] = None,
+                  estimate_model=None,
                   commit: bool = False):
+        """
+        A configuration hook which executes all initial PurchaseOrderModel setup on to the EntityModel and all initial
+        values of the EntityModel. Can only call this method once in the lifetime of a PurchaseOrderModel.
 
-        if isinstance(entity_slug, str):
-            entity_qs = EntityModel.objects.for_user(
-                user_model=user_model)
-            entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
-        elif isinstance(entity_slug, EntityModel):
-            entity_model = entity_slug
-        else:
-            raise PurchaseOrderModelValidationError('entity_slug must be an instance of str or EntityModel')
+        Parameters
+        __________
 
-        if draft_date:
-            self.date_draft = draft_date
-        if not self.date_draft:
-            self.date_draft = localdate()
-        self.entity = entity_model
-        self.clean()
-        if commit:
-            self.save()
+        entity_slug: str or EntityModel
+            The entity slug or EntityModel to associate the Bill with.
+
+        user_model:
+            The UserModel making the request to check for QuerySet permissions.
+
+        ledger_posted:
+            An option to mark the BillModel Ledger as posted at the time of configuration. Defaults to False.
+
+        bill_desc: str
+            An optional description appended to the LedgerModel name.
+
+        commit: bool
+            Saves the current BillModel after being configured.
+
+        Returns
+        -------
+        PurchaseOrderModel
+            The configured PurchaseOrderModel instance.
+        """
+        if not self.is_configured():
+            if isinstance(entity_slug, str):
+                if not user_model:
+                    raise PurchaseOrderModelValidationError(_('Must pass user_model when using entity_slug.'))
+                entity_qs = EntityModel.objects.for_user(user_model=user_model)
+                entity_model: EntityModel = get_object_or_404(entity_qs, slug__exact=entity_slug)
+            elif isinstance(entity_slug, EntityModel):
+                entity_model = entity_slug
+            else:
+                raise PurchaseOrderModelValidationError('entity_slug must be an instance of str or EntityModel')
+
+            self.date_draft = localdate() if not draft_date else draft_date
+            self.po_status = PurchaseOrderModel.PO_STATUS_DRAFT
+
+            if estimate_model:
+                self.action_bind_estimate(estimate_model=estimate_model, commit=False)
+
+            self.entity = entity_model
+
+            self.clean()
+            if commit:
+                self.save()
         return self
 
+    def validate_item_transaction_qs(self, queryset: Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]):
+        """
+        Validates that the entire ItemTransactionModelQuerySet is bound to the PurchaseOrderModel.
+
+        Parameters
+        ----------
+        queryset: ItemTransactionModelQuerySet or list of ItemTransactionModel.
+            ItemTransactionModelQuerySet to validate.
+        """
+        valid = all([
+            i.po_model_id == self.uuid for i in queryset
+        ])
+        if not valid:
+            raise PurchaseOrderModelValidationError(f'Invalid queryset. All items must be assigned to PO {self.uuid}')
+
     # State Update...
-    def get_itemtxs_data(self, queryset: QuerySet = None) -> Tuple:
+    def get_itemtxs_data(self,
+                         queryset: Optional[Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]] = None,
+                         aggregate_on_db: bool = False) -> Tuple:
+        """
+        Fetches the PurchaseOrderModel Items and aggregates the QuerySet.
+
+        Parameters
+        ----------
+        queryset: ItemTransactionModelQuerySet
+            Optional pre-fetched ItemModelQueryset to use. Avoids additional DB query if provided.
+            Validated if provided.
+        aggregate_on_db: bool
+            If True, performs aggregation of ItemsTransactions in the DB resulting in one additional DB query.
+
+        Returns
+        -------
+        A tuple: ItemTransactionModelQuerySet, dict
+        """
         if not queryset:
-            # pylint: disable=no-member
             queryset = self.itemtransactionmodel_set.all().select_related('bill_model', 'item_model')
+        else:
+            self.validate_item_transaction_qs(queryset)
 
-        return queryset, queryset.aggregate(
-            po_total_amount__sum=Coalesce(Sum('po_total_amount'), 0.0, output_field=models.FloatField()),
-            bill_amount_paid__sum=Coalesce(Sum('bill_model__amount_paid'), 0.0, output_field=models.FloatField()),
-            total_items=Count('uuid')
-        )
+        if aggregate_on_db and isinstance(queryset, ItemTransactionModelQuerySet):
+            return queryset, queryset.aggregate(
+                po_total_amount__sum=Coalesce(Sum('po_total_amount'), 0.0, output_field=models.FloatField()),
+                bill_amount_paid__sum=Coalesce(Sum('bill_model__amount_paid'), 0.0, output_field=models.FloatField()),
+                total_items=Count('uuid')
+            )
+        return queryset, {
+            'po_total_amount__sum': sum(i.total_amount for i in queryset),
+            'bill_amount_paid__sum': sum(i.bill_model.amount_paid for i in queryset if i.bill_model_id),
+            'total_items': len(queryset)
+        }
 
     def update_state(self,
-                     itemtxs_qs: QuerySet = None,
-                     itemtxs_list: List[ItemTransactionModel] = None) -> Union[Tuple, None]:
-        if itemtxs_qs and itemtxs_list:
-            raise PurchaseOrderModelValidationError('Either queryset or list can be used.')
-
-        if itemtxs_list:
-            self.po_amount = round(sum(a.po_total_amount for a in itemtxs_list if not a.is_canceled()), 2)
-            self.po_amount_received = round(sum(a.po_total_amount for a in itemtxs_list if a.is_received()), 2)
-        else:
-            itemtxs_qs, itemtxs_agg = self.get_itemtxs_data(queryset=itemtxs_qs)
+                     itemtxs_qs: Optional[Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]]] = None
+                     ) -> Tuple:
+
+        """
+        Updates the state of the PurchaseOrderModel.
+
+        Parameters
+        ----------
+        itemtxs_qs: ItemTransactionModelQuerySet or list of ItemTransactionModel
+
+        Returns
+        -------
+        tuple
+            A tuple of ItemTransactionModels and Aggregation
+        """
+        itemtxs_qs, itemtxs_agg = self.get_itemtxs_data(queryset=itemtxs_qs)
+
+        if isinstance(itemtxs_qs, list):
+            self.po_amount = round(sum(a.po_total_amount for a in itemtxs_qs if not a.is_canceled()), 2)
+            self.po_amount_received = round(sum(a.po_total_amount for a in itemtxs_qs if a.is_received()), 2)
+        elif isinstance(itemtxs_qs, ItemTransactionModelQuerySet):
             total_po_amount = round(sum(i.po_total_amount for i in itemtxs_qs if not i.is_canceled()), 2)
             total_received = round(sum(i.po_total_amount for i in itemtxs_qs if i.is_received()), 2)
             self.po_amount = total_po_amount
             self.po_amount_received = total_received
-            return itemtxs_qs, itemtxs_agg
+
+        return itemtxs_qs, itemtxs_agg
 
     # State...
     def is_draft(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel is in Draft status.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is Draft, else False.
+        """
         return self.po_status == self.PO_STATUS_DRAFT
 
     def is_review(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel is in Review status.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is Review, else False.
+        """
         return self.po_status == self.PO_STATUS_REVIEW
 
     def is_approved(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel is in Approved status.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is Approved, else False.
+        """
         return self.po_status == self.PO_STATUS_APPROVED
 
     def is_fulfilled(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel is in Fulfilled status.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is in Fulfilled status, else False.
+        """
         return self.po_status == self.PO_STATUS_FULFILLED
 
     def is_canceled(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel is in Canceled status.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is in Canceled, else False.
+        """
         return self.po_status == self.PO_STATUS_CANCELED
 
     def is_void(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel is in Void status.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is Void, else False.
+        """
         return self.po_status == self.PO_STATUS_VOID
 
     # Permissions...
     def can_draft(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be marked as Draft.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be marked as Draft, else False.
+        """
         return self.is_review()
 
     def can_review(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be marked as In Review.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be marked as In Review, else False.
+        """
         return self.is_draft()
 
     def can_approve(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be marked as Approved.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be marked as Approved, else False.
+        """
         return self.is_review()
 
     def can_fulfill(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be marked as Fulfilled.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be marked as Fulfilled, else False.
+        """
         return self.is_approved()
 
     def can_cancel(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be marked as Canceled.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be marked as Canceled, else False.
+        """
         return any([
             self.is_draft(),
             self.is_review()
         ])
 
     def can_void(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be marked as Void.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be marked as Void, else False.
+        """
         return self.is_approved()
 
     def can_delete(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel can be deleted.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be deleted, else False.
+        """
         return any([
             self.is_draft(),
             self.is_review()
         ])
 
     def can_edit_items(self) -> bool:
+        """
+        Checks if the PurchaseOrderModel items can be edited.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel items can be edited, else False.
+        """
         return self.is_draft()
 
     def is_contract_bound(self):
+        """
+        Checks if the PurchaseOrderModel is bound to an EstimateModel.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel is bound to an EstimateModel, else False.
+        """
         return self.ce_model_id is not None
 
     def can_bind_estimate(self, estimate_model, raise_exception: bool = False) -> bool:
+        """
+        Checks if the PurchaseOrderModel ican be bound to an EstimateModel.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can be bound to an EstimateModel, else False.
+        """
         if self.is_contract_bound():
             if raise_exception:
-                raise PurchaseOrderModelValidationError(f'PO {self.po_number} already bound to Estimate {self.ce_model.estimate_number}')
+                raise PurchaseOrderModelValidationError(
+                    f'PO {self.po_number} already bound to Estimate {self.ce_model.estimate_number}')
             return False
         # check if estimate_model is passed and raise exception if needed...
         is_approved = estimate_model.is_approved()
         if not is_approved and raise_exception:
             raise PurchaseOrderModelValidationError(f'Cannot bind estimate that is not approved.')
         return all([
             is_approved
         ])
 
-    def can_generate_po_number(self):
-        return all([
-            self.date_draft,
-            not self.po_number
-        ])
-
-    # Actions...
     def action_bind_estimate(self, estimate_model, commit: bool = False):
+        """
+        Binds a specific EstimateModel to the PurchaseOrderModel instance.
+
+        Parameters
+        ----------
+        estimate_model: EstimateModel
+            The EstimateModel to bind.
+        commit: bool
+            Commits the changes in the Database, if True. Defaults to False.
+        """
         try:
             self.can_bind_estimate(estimate_model, raise_exception=True)
         except ValueError as e:
             raise e
         self.ce_model = estimate_model
         self.clean()
         if commit:
             self.save(update_fields=[
                 'ce_model',
                 'updated'
             ])
 
+    def can_generate_po_number(self):
+        """
+        Checks if PurchaseOrderModel can generate its Document Number.
+
+        Returns
+        -------
+        bool
+            True if PurchaseOrderModel can generate its po_number, else False.
+        """
+        return all([
+            self.date_draft,
+            not self.po_number
+        ])
+
+    # Actions...
+
     # DRAFT...
-    def mark_as_draft(self, commit: bool = False, **kwargs):
+    def mark_as_draft(self, date_draft: Optional[date] = None, commit: bool = False, **kwargs):
+        """
+        Marks PurchaseOrderModel as Draft.
+
+        Parameters
+        ----------
+        date_draft: date
+            Draft date. If None, defaults to localdate().
+        commit: bool
+            Commits transaction into the Database. Defaults to False.
+        """
         if not self.can_draft():
-            raise PurchaseOrderModelValidationError(message=f'Purchase Order {self.po_number} cannot be marked as draft.')
+            raise PurchaseOrderModelValidationError(
+                message=f'Purchase Order {self.po_number} cannot be marked as draft.')
         self.po_status = self.PO_STATUS_DRAFT
+        self.date_draft = localdate() if not date_draft else date_draft
         self.clean()
         if commit:
             self.save(update_fields=[
                 'po_status',
                 'updated'
             ])
 
     def get_mark_as_draft_html_id(self):
+        """
+        PurchaseOrderModel Mark as Draft HTML ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return f'djl-{self.uuid}-po-mark-as-draft'
 
     def get_mark_as_draft_url(self):
+        """
+        PurchaseOrderModel Mark as Draft URL ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return reverse('django_ledger:po-action-mark-as-draft',
                        kwargs={
                            'entity_slug': self.entity.slug,
                            'po_pk': self.uuid
                        })
 
     def get_mark_as_draft_message(self):
+        """
+        PurchaseOrderModel Mark as Draft Message.
+
+        Returns
+        -------
+        str
+            Message as a String.
+        """
         return _('Do you want to mark Purchase Order %s as Draft?') % self.po_number
 
     # REVIEW...
-    def mark_as_review(self, date_review: date = None, commit: bool = False, **kwargs):
+    def mark_as_review(self, date_in_review: Optional[date] = None, commit: bool = False, **kwargs):
+        """
+        Marks PurchaseOrderModel as In Review.
+
+        Parameters
+        ----------
+        date_in_review: date
+            Draft date. If None, defaults to localdate().
+        commit: bool
+            Commits transaction into the Database. Defaults to False.
+        """
         if not self.can_review():
-            raise PurchaseOrderModelValidationError(message=f'Purchase Order {self.po_number} cannot be marked as in review.')
-        itemthrough_qs = self.itemtransactionmodel_set.all()
-        if not itemthrough_qs.count():
+            raise PurchaseOrderModelValidationError(
+                message=f'Purchase Order {self.po_number} cannot be marked as in review.')
+
+        itemtxs_qs, itemtxs_agg = self.get_itemtxs_data()
+        if not itemtxs_qs.count():
             raise PurchaseOrderModelValidationError(message='Cannot review a PO without items...')
         if not self.po_amount:
             raise PurchaseOrderModelValidationError(message='PO amount is zero.')
 
-        self.date_in_review = localdate() if not date_review else date_review
+        self.date_in_review = localdate() if not date_in_review else date_in_review
         self.po_status = self.PO_STATUS_REVIEW
         self.clean()
         if commit:
             self.save(update_fields=[
                 'po_status',
                 'date_in_review',
                 'updated'
             ])
 
     def get_mark_as_review_html_id(self):
+        """
+        PurchaseOrderModel Mark as In Review HTML ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return f'djl-{self.uuid}-po-mark-as-review'
 
     def get_mark_as_review_url(self):
+        """
+        PurchaseOrderModel Mark as In Review URL ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return reverse('django_ledger:po-action-mark-as-review',
                        kwargs={
                            'entity_slug': self.entity.slug,
                            'po_pk': self.uuid
                        })
 
     def get_mark_as_review_message(self):
+        """
+        PurchaseOrderModel Mark as Review Message.
+
+        Returns
+        -------
+        str
+            Message as a String.
+        """
         return _('Do you want to mark Purchase Order %s as In Review?') % self.po_number
 
     # APPROVED...
-    def mark_as_approved(self, commit: bool = False, date_approved: date = None, **kwargs):
+    def mark_as_approved(self, date_approved: Optional[date] = None, commit: bool = False, **kwargs):
+        """
+        Marks PurchaseOrderModel as Approved.
+
+        Parameters
+        ----------
+        date_approved: date
+            Approved date. If None, defaults to localdate().
+        commit: bool
+            Commits transaction into the Database. Defaults to False.
+        """
         if not self.can_approve():
-            raise PurchaseOrderModelValidationError(message=f'Purchase Order {self.po_number} cannot be marked as approved.')
+            raise PurchaseOrderModelValidationError(
+                message=f'Purchase Order {self.po_number} cannot be marked as approved.')
         self.date_approved = localdate() if not date_approved else date_approved
         self.po_status = self.PO_STATUS_APPROVED
         self.clean()
         if commit:
             self.itemtransactionmodel_set.all().update(po_item_status=ItemTransactionModel.STATUS_NOT_ORDERED)
             self.save(update_fields=[
                 'date_approved',
                 'po_status',
                 'updated'
             ])
 
     def get_mark_as_approved_html_id(self):
+        """
+        PurchaseOrderModel Mark as Approved HTML ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return f'djl-{self.uuid}-po-mark-as-approved'
 
     def get_mark_as_approved_url(self):
+        """
+        PurchaseOrderModel Mark as Approved URL ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return reverse('django_ledger:po-action-mark-as-approved',
                        kwargs={
                            'entity_slug': self.entity.slug,
                            'po_pk': self.uuid
                        })
 
     def get_mark_as_approved_message(self):
+        """
+        PurchaseOrderModel Mark as Approved Message.
+
+        Returns
+        -------
+        str
+            Message as a String.
+        """
         return _('Do you want to mark Purchase Order %s as Approved?') % self.po_number
 
     # CANCEL...
-    def mark_as_canceled(self, commit: bool = False, date_canceled: date = None, **kwargs):
+    def mark_as_canceled(self, date_canceled: Optional[date] = None, commit: bool = False, **kwargs):
+        """
+        Marks PurchaseOrderModel as Canceled.
+
+        Parameters
+        ----------
+        date_canceled: date
+            Canceled date. If None, defaults to localdate().
+        commit: bool
+            Commits transaction into the Database. Defaults to False.
+        """
         if not self.can_cancel():
-            raise PurchaseOrderModelValidationError(message=f'Purchase Order {self.po_number} cannot be marked as canceled.')
+            raise PurchaseOrderModelValidationError(
+                message=f'Purchase Order {self.po_number} cannot be marked as canceled.')
         self.date_canceled = localdate() if not date_canceled else date_canceled
         self.po_status = self.PO_STATUS_CANCELED
         self.clean()
         if commit:
             self.save(update_fields=[
                 'po_status',
                 'date_canceled',
                 'updated'
             ])
 
     def get_mark_as_canceled_html_id(self):
+        """
+        PurchaseOrderModel Mark as Canceled HTML ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return f'djl-{self.uuid}-po-mark-as-canceled'
 
     def get_mark_as_canceled_url(self):
+        """
+        PurchaseOrderModel Mark as Canceled URL ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return reverse('django_ledger:po-action-mark-as-canceled',
                        kwargs={
                            'entity_slug': self.entity.slug,
                            'po_pk': self.uuid
                        })
 
     def get_mark_as_canceled_message(self):
+        """
+        PurchaseOrderModel Mark as Canceled Message.
+
+        Returns
+        -------
+        str
+            Message as a String.
+        """
         return _('Do you want to mark Purchase Order %s as Canceled?') % self.po_number
 
     # FULFILL...
     def mark_as_fulfilled(self,
                           date_fulfilled: date = None,
-                          po_items: Union[QuerySet, List[ItemTransactionModel]] = None,
-                          commit=False,
+                          po_items: Union[ItemTransactionModelQuerySet, List[ItemTransactionModel]] = None,
+                          commit: bool = False,
                           **kwargs):
+        """
+        Marks PurchaseOrderModel as Fulfilled.
+
+        Parameters
+        ----------
+        date_fulfilled: date
+            Fulfilled date. If None, defaults to localdate().
+        po_items: ItemTransactionModelQuerySet or list of ItemTransactionModel.
+            Pre-fetched ItemTransactionModelQuerySet or list of  ItemTransactionModel.
+            Validated if provided.
+        commit: bool
+            Commits transaction into the Database. Defaults to False.
+        """
+
         if not self.can_fulfill():
-            raise PurchaseOrderModelValidationError(message=f'Purchase Order {self.po_number} cannot be marked as fulfilled.')
-        self.date_fulfilled = localdate() if not date_fulfilled else date_fulfilled
-        self.po_amount_received = self.po_amount
+            raise PurchaseOrderModelValidationError(
+                message=f'Purchase Order {self.po_number} cannot be marked as fulfilled.')
 
         if not po_items:
-            po_items = self.itemtransactionmodel_set.all().select_related('bill_model')
+            po_items, po_items_agg = self.get_itemtxs_data(queryset=po_items)
+
+        self.date_fulfilled = localdate() if not date_fulfilled else date_fulfilled
+        self.po_amount_received = self.po_amount
 
         bill_models = [i.bill_model for i in po_items]
         all_items_billed = all(bill_models)
         if not all_items_billed:
             raise PurchaseOrderModelValidationError('All items must be billed before PO can be fulfilled.')
 
         all_bills_paid = all(b.is_paid() for b in bill_models)
@@ -422,49 +925,80 @@
             raise PurchaseOrderModelValidationError('All items must be received before PO is fulfilled.')
 
         self.date_fulfilled = date_fulfilled
         self.po_status = self.PO_STATUS_FULFILLED
         self.clean()
 
         if commit:
+            # todo: what if PO items is list???...
             po_items.update(po_item_status=ItemTransactionModel.STATUS_RECEIVED)
             self.save(update_fields=[
                 'date_fulfilled',
                 'po_status',
                 'updated'
             ])
 
     def get_mark_as_fulfilled_html_id(self):
+        """
+        PurchaseOrderModel Mark as Fulfilled HTML ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return f'djl-{self.uuid}-po-mark-as-fulfilled'
 
     def get_mark_as_fulfilled_url(self):
+        """
+        PurchaseOrderModel Mark as Fulfilled URL ID Tag.
+
+        Returns
+        -------
+        str
+            URL as a String.
+        """
         return reverse('django_ledger:po-action-mark-as-fulfilled',
                        kwargs={
                            'entity_slug': self.entity.slug,
                            'po_pk': self.uuid
                        })
 
     def get_mark_as_fulfilled_message(self):
+        """
+        PurchaseOrderModel Mark as Fulfilled Message.
+
+        Returns
+        -------
+        str
+            Message as a String.
+        """
         return _('Do you want to mark Purchase Order %s as Fulfilled?') % self.po_number
 
     # VOID...
     def mark_as_void(self,
-                     entity_slug: str,
-                     user_model,
-                     void_date: date = None,
-                     commit=False,
+                     void_date: Optional[date] = None,
+                     commit: bool = False,
                      **kwargs):
+        """
+        Marks PurchaseOrderModel as Fulfilled.
+
+        Parameters
+        ----------
+        void_date: date
+            Void date. If None, defaults to localdate().
+        commit: bool
+            Commits transaction into the Database. Defaults to False.
+        """
         if not self.can_void():
-            raise PurchaseOrderModelValidationError(message=f'Purchase Order {self.po_number} cannot be marked as void.')
+            raise PurchaseOrderModelValidationError(
+                message=f'Purchase Order {self.po_number} cannot be marked as void.')
 
         # all bills associated with this PO...
-        bill_model_qs = self.get_po_bill_queryset(
-            entity_slug=entity_slug,
-            user_model=user_model
-        )
+        bill_model_qs = self.get_po_bill_queryset()
         bill_model_qs = bill_model_qs.only('bill_status')
 
         if not all(b.is_void() for b in bill_model_qs):
             raise PurchaseOrderModelValidationError('Must void all PO bills before PO can be voided.')
 
         self.date_void = localdate() if not void_date else void_date
         self.po_status = self.PO_STATUS_VOID
@@ -474,40 +1008,85 @@
             self.save(update_fields=[
                 'void_date',
                 'po_status',
                 'updated'
             ])
 
     def get_mark_as_void_html_id(self):
+        """
+        PurchaseOrderModel Mark as Void HTML ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return f'djl-{self.uuid}-po-mark-as-void'
 
     def get_mark_as_void_url(self):
+        """
+        PurchaseOrderModel Mark as Void URL ID Tag.
+
+        Returns
+        -------
+        str
+            HTML ID as a String.
+        """
         return reverse('django_ledger:po-action-mark-as-void',
                        kwargs={
                            'entity_slug': self.entity.slug,
                            'po_pk': self.uuid
                        })
 
     def get_mark_as_void_message(self):
+        """
+        PurchaseOrderModel Mark as Void Message.
+
+        Returns
+        -------
+        str
+            Message as a String.
+        """
         return _('Do you want to mark Purchase Order %s as Void?') % self.po_number
 
-    # Conevience Methods...
+    def get_po_bill_queryset(self) -> BillModelQuerySet:
+        """
+        Fetches a BillModelQuerySet of all BillModels associated with the PurchaseOrderModel instance.
 
-    def get_po_bill_queryset(self, user_model, entity_slug):
-        return BillModel.objects.for_entity(
-            user_model=user_model,
-            entity_slug=entity_slug
-        ).filter(bill_items__purchaseordermodel__uuid__exact=self.uuid)
+        Returns
+        -------
+        BillModelQuerySet
+        """
+        return BillModel.objects.filter(bill_items__purchaseordermodel__uuid__exact=self.uuid)
 
     def get_status_action_date(self):
-        if self.is_fulfilled():
-            return self.date_fulfilled
+        """
+        Current status action date.
+
+        Returns
+        -------
+        date
+            A date. i.e. If status is Approved, return date_approved. If In Review, return date_in_review.
+        """
         return getattr(self, f'date_{self.po_status}')
 
     def _get_next_state_model(self, raise_exception: bool = True):
+        """
+        Fetches the next sequenced state model associated with the PurchaseOrderModel number.
+
+        Parameters
+        ----------
+        raise_exception: bool
+            Raises IntegrityError if unable to secure transaction from DB.
+
+        Returns
+        -------
+        EntityStateModel
+            An instance of EntityStateModel
+        """
         EntityStateModel = lazy_loader.get_entity_state_model()
         EntityModel = lazy_loader.get_entity_model()
         entity_model = EntityModel.objects.get(uuid__exact=self.entity_id)
         fy_key = entity_model.get_fy_for_date(dt=self.date_draft)
         try:
             LOOKUP = {
                 'entity_model_id__exact': self.entity_id,
@@ -540,16 +1119,24 @@
         except IntegrityError as e:
             if raise_exception:
                 raise e
 
     def generate_po_number(self, commit: bool = False) -> str:
         """
         Atomic Transaction. Generates the next PurchaseOrder document number available.
-        @param commit: Commit transaction into InvoiceModel.
-        @return: A String, representing the current InvoiceModel instance Document Number.
+
+        Parameters
+        ----------
+        commit: bool
+            Commits transaction into PurchaseOrderModel.
+
+        Returns
+        -------
+        str
+            A String, representing the generated or current PurchaseOrderModel instance Document Number.
         """
         if self.can_generate_po_number():
             with transaction.atomic(durable=True):
 
                 state_model = None
                 while not state_model:
                     state_model = self._get_next_state_model(raise_exception=False)
@@ -562,17 +1149,20 @@
 
         return self.po_number
 
     def clean(self):
         if self.can_generate_po_number():
             self.generate_po_number(commit=True)
 
-    def save(self, **kwargs):
-        if self.can_generate_po_number():
-            self.generate_po_number(commit=True)
-        super(PurchaseOrderModelAbstract, self).save(**kwargs)
-
 
 class PurchaseOrderModel(PurchaseOrderModelAbstract):
     """
     Purchase Order Base Model
     """
+
+
+def purchaseordermodel_presave(instance: PurchaseOrderModel, **kwargs):
+    if instance.can_generate_po_number():
+        instance.generate_po_number(commit=False)
+
+
+pre_save.connect(receiver=purchaseordermodel_presave, sender=PurchaseOrderModel)
```

## django_ledger/models/transactions.py

```diff
@@ -1,48 +1,52 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
     * Miguel Sanda <msanda@arrobalytics.com>
+
+The TransactionModel is the lowest accounting level where the financial information is recorded on the books.
+Every transaction which has an financial implication must be recorded as part of a JournalEntryModel, which in turn
+encapsulates a collection of TransactionModels. Transaction models cannot exist without being part of a validated
+JournalEntryModel. Orphan TransactionModels are not allowed, and this is enforced by the database.
+
+A transaction by definition must perform a CREDIT or a DEBIT to the underlying AccountModel. The IOMixIn plays a crucial
+role in the production of financial statements and sets its foundation in the TransactionModel API to effective query
+amd aggregate transactions at the Database layer without the need of pulling all TransactionModels into memory for the
+production of financial statements.
 """
 from datetime import datetime, date
 from typing import List, Union
 from uuid import uuid4, UUID
 
+from django.core.exceptions import ValidationError
 from django.core.validators import MinValueValidator
 from django.db import models
 from django.db.models import Q, QuerySet
 from django.utils.translation import gettext_lazy as _
 
-from django_ledger.io import validate_io_date, lazy_importer
+from django_ledger.io import validate_io_date
 from django_ledger.models.accounts import AccountModel
-from django_ledger.models.entity import EntityModel
-from django_ledger.models.ledger import LedgerModel
 from django_ledger.models.bill import BillModel
+from django_ledger.models.entity import EntityModel
 from django_ledger.models.invoice import InvoiceModel
+from django_ledger.models.ledger import LedgerModel
 from django_ledger.models.mixins import CreateUpdateMixIn
 from django_ledger.models.unit import EntityUnitModel
+from django_ledger.models.utils import lazy_loader
 
-"""
-The TransactionModel is the lowest accounting level where the financial information is recorded on the books.
-Every transaction which has an financial implication must be recorded as part of a JournalEntryModel, which in turn
-encapsulates a collection of TransactionModels. Transaction models cannot exist without being part of a validated
-JournalEntryModel. Orphan TransactionModels are not allowed, and this is enforced by the database.
 
-A transaction by definition must perform a CREDIT or a DEBIT to the underlying AccountModel. The IOMixIn plays a crucial
-role in the production of financial statements and sets its foundation in the TransactionModel API to effective query
-amd aggregate transactions at the Database layer without the need of pulling all TransactionModels into memory for the
-production of financial statements.
-"""
+class TransactionModelValidationError(ValidationError):
+    pass
 
 
 class TransactionModelQuerySet(QuerySet):
     """
-    A custom defined QuerySet for the TransactionModel.
+    A custom defined EntityUnitModel Queryset.
     """
 
     def posted(self) -> QuerySet:
         """
         Fetches a QuerySet of posted transactions only.
         Posted transactions are must meet the following criteria:
             * Be bart of a *posted* JournalEntryModel.
@@ -320,15 +324,15 @@
         TransactionModelQuerySet
             Returns a TransactionModelQuerySet with applied filters.
         """
         qs = self.for_ledger(user_model=user_model,
                              entity_slug=entity_slug,
                              ledger_model=ledger_model)
 
-        if isinstance(je_model, lazy_importer.get_journal_entry_model()):
+        if isinstance(je_model, lazy_loader.get_journal_entry_model()):
             return qs.filter(journal_entry=je_model)
         return qs.filter(journal_entry__uuid__exact=je_model)
 
     def for_bill(self,
                  user_model,
                  entity_slug: str,
                  bill_model: Union[BillModel, str, UUID]):
@@ -459,15 +463,20 @@
 
     def __str__(self):
         # pylint: disable=no-member
         return '{x1}-{x2}/{x5}: {x3}/{x4}'.format(x1=self.account.code,
                                                   x2=self.account.name,
                                                   x3=self.amount,
                                                   x4=self.tx_type,
-                                                  # pylint: disable=no-member
                                                   x5=self.account.balance_type)
 
+    def clean(self):
+        if self.account.is_root_account():
+            raise TransactionModelValidationError(
+                message=_('Cannot transact on root accounts')
+            )
+
 
 class TransactionModel(TransactionModelAbstract):
     """
     Base Transaction Model From Abstract.
     """
```

## django_ledger/models/unit.py

```diff
@@ -22,28 +22,33 @@
 """
 
 from random import choices
 from string import ascii_lowercase, digits, ascii_uppercase
 from typing import Optional
 from uuid import uuid4
 
+from django.core.exceptions import ValidationError
 from django.db import models
 from django.db.models import Q
 from django.urls import reverse
 from django.utils.text import slugify
 from django.utils.translation import gettext_lazy as _
 from treebeard.mp_tree import MP_Node, MP_NodeManager, MP_NodeQuerySet
 
 from django_ledger.io.io_mixin import IOMixIn
 from django_ledger.models import lazy_loader
 from django_ledger.models.mixins import CreateUpdateMixIn, SlugNameMixIn
 
 ENTITY_UNIT_RANDOM_SLUG_SUFFIX = ascii_lowercase + digits
 
 
+class EntityUnitModelValidationError(ValidationError):
+    pass
+
+
 class EntityUnitModelQuerySet(MP_NodeQuerySet):
     """
     A custom defined EntityUnitModel Queryset.
     """
 
 
 class EntityUnitModelManager(MP_NodeManager):
```

## django_ledger/models/utils.py

```diff
@@ -25,14 +25,17 @@
     INVOICE_MODEL = None
     BILL_MODEL = None
     UOM_MODEL = None
     VENDOR_MODEL = None
     TRANSACTION_MODEL = None
     ENTITY_UNIT_MODEL = None
     PURCHASE_ORDER_MODEL = None
+    ESTIMATE_MODEL = None
+
+    ENTITY_DATA_GENERATOR = None
 
     def get_entity_model(self):
         if not self.ENTITY_MODEL:
             from django_ledger.models import EntityModel
             self.ENTITY_MODEL = EntityModel
         return self.ENTITY_MODEL
 
@@ -134,9 +137,21 @@
 
     def get_entity_unit_model(self):
         if not self.ENTITY_UNIT_MODEL:
             from django_ledger.models import EntityUnitModel
             self.ENTITY_UNIT_MODEL = EntityUnitModel
         return self.ENTITY_UNIT_MODEL
 
+    def get_estimate_model(self):
+        if not self.ESTIMATE_MODEL:
+            from django_ledger.models import EstimateModel
+            self.ESTIMATE_MODEL = EstimateModel
+        return self.ESTIMATE_MODEL
+
+    def get_entity_data_generator(self):
+        if not self.ENTITY_DATA_GENERATOR:
+            from django_ledger.io.data_generator import EntityDataGenerator
+            self.ENTITY_DATA_GENERATOR = EntityDataGenerator
+        return self.ENTITY_DATA_GENERATOR
+
 
 lazy_loader = LazyLoader()
```

## django_ledger/models/vendor.py

```diff
@@ -12,29 +12,83 @@
 Vendors can be flagged as active/inactive or hidden. Vendors who no longer conduct business with the EntityModel,
 whether temporarily or indefinitely may be flagged as inactive (i.e. active is False). Hidden Vendors will not show up
 as an option in the UI, but can still be used programmatically (via API).
 """
 
 from uuid import uuid4
 
-from django.core.exceptions import ObjectDoesNotExist
+from django.core.exceptions import ObjectDoesNotExist, ValidationError
 from django.db import models, transaction, IntegrityError
-from django.db.models import Q, F
+from django.db.models import Q, F, QuerySet
 from django.utils.translation import gettext_lazy as _
 
 from django_ledger.models.mixins import ContactInfoMixIn, CreateUpdateMixIn, BankAccountInfoMixIn, TaxInfoMixIn
 from django_ledger.models.utils import lazy_loader
 from django_ledger.settings import DJANGO_LEDGER_DOCUMENT_NUMBER_PADDING, DJANGO_LEDGER_VENDOR_NUMBER_PREFIX
 
 
-class VendorModelQuerySet(models.QuerySet):
+class VendorModelValidationError(ValidationError):
+    pass
+
+
+class VendorModelQuerySet(QuerySet):
     """
     Custom defined VendorModel QuerySet.
     """
 
+    def active(self) -> QuerySet:
+        """
+        Active vendors can be assigned to new bills and show on dropdown menus and views.
+
+        Returns
+        -------
+        VendorModelQuerySet
+            A QuerySet of active Vendors.
+        """
+        return self.filter(active=True)
+
+    def inactive(self) -> QuerySet:
+        """
+        Active vendors can be assigned to new bills and show on dropdown menus and views.
+        Marking VendorModels as inactive can help reduce Database load to populate select inputs and also inactivate
+        VendorModels that are not relevant to the Entity anymore. Also, it makes de UI cleaner by not populating
+        unnecessary choices.
+
+        Returns
+        -------
+        VendorModelQuerySet
+            A QuerySet of inactive Vendors.
+        """
+        return self.filter(active=False)
+
+    def hidden(self) -> QuerySet:
+        """
+        Hidden vendors do not show on dropdown menus, but may be used via APIs or any other method that does not
+        involve the UI.
+
+        Returns
+        -------
+        VendorModelQuerySet
+            A QuerySet of hidden Vendors.
+        """
+        return self.filter(hidden=True)
+
+    def visible(self) -> QuerySet:
+        """
+        Visible vendors show on dropdown menus and views. Visible vendors are active and not hidden.
+
+        Returns
+        -------
+        VendorModelQuerySet
+            A QuerySet of visible Vendors.
+        """
+        return self.filter(
+            Q(hidden=False) & Q(active=True)
+        )
+
 
 class VendorModelManager(models.Manager):
     """
     Custom defined VendorModel Manager, which defines many methods for initial query of the Database.
     """
 
     def for_entity(self, entity_slug, user_model) -> VendorModelQuerySet:
@@ -60,35 +114,32 @@
         VendorModelQuerySet
             A filtered VendorModel QuerySet.
         """
         qs = self.get_queryset()
         if isinstance(entity_slug, lazy_loader.get_entity_model()):
             return qs.filter(
                 Q(entity_model=entity_slug) &
-                Q(active=True) &
                 (
                         Q(entity_model__admin=user_model) |
                         Q(entity_model__managers__in=[user_model])
                 )
             )
         return qs.filter(
             Q(entity_model__slug__exact=entity_slug) &
-            Q(active=True) &
             (
                     Q(entity_model__admin=user_model) |
                     Q(entity_model__managers__in=[user_model])
             )
         )
 
 
 class VendorModelAbstract(ContactInfoMixIn,
                           BankAccountInfoMixIn,
                           TaxInfoMixIn,
                           CreateUpdateMixIn):
-
     """
     This is the main abstract class which the VendorModel database will inherit from.
     The VendorModel inherits functionality from the following MixIns:
 
         1. :func:`ContactInfoMixIn <django_ledger.models.mixins.ContactInfoMixIn>`
         2. :func:`BankAccountInfoMixIn <django_ledger.models.mixins.BankAccountInfoMixIn>`
         3. :func:`TaxInfoMixIn <django_ledger.models.mixins.TaxInfoMixIn>`
@@ -109,15 +160,15 @@
     vendor_number: str
         A unique, auto-generated human-readable number which identifies the vendor within the EntityModel.
 
     description: str
         A text field to capture the description about the vendor.
 
     active: bool
-        We can set any customer code to be active or inactive. Defaults to True.
+        We can set any vendor to be active or inactive. Defaults to True.
 
     hidden: bool
         Hidden VendorModel don't show on the UI. Defaults to False.
 
     additional_info: dict
         Any additional information about the vendor, stored as a JSON object using a JSONField.
 
@@ -137,36 +188,40 @@
     additional_info = models.JSONField(null=True, blank=True, default=dict)
 
     objects = VendorModelManager.from_queryset(queryset_class=VendorModelQuerySet)()
 
     class Meta:
         verbose_name = _('Vendor')
         indexes = [
+            models.Index(fields=['entity_model', 'vendor_number']),
+            models.Index(fields=['vendor_number']),
             models.Index(fields=['created']),
             models.Index(fields=['updated']),
             models.Index(fields=['active']),
             models.Index(fields=['hidden']),
         ]
         unique_together = [
             ('entity_model', 'vendor_number')
         ]
         abstract = True
 
     def __str__(self):
-        return f'Vendor: {self.vendor_name}'
+        if not self.vendor_number:
+            f'Unknown Vendor: {self.vendor_name}'
+        return f'{self.vendor_number}: {self.vendor_name}'
 
     def can_generate_vendor_number(self) -> bool:
         """
         Determines if the VendorModel can be issued a Vendor Number.
         VendorModel have a unique sequential number, which is unique for each EntityModel/VendorModel.
 
         Returns
         -------
         bool
-            True if customer model can be generated, else False.
+            True if vendor number can be generated, else False.
         """
         return all([
             self.entity_model_id,
             not self.vendor_number
         ])
 
     def _get_next_state_model(self, raise_exception: bool = True):
```

## django_ledger/templatetags/django_ledger.py

```diff
@@ -3,25 +3,27 @@
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
 Miguel Sanda <msanda@arrobalytics.com>
 """
 
 from calendar import month_abbr
+from itertools import groupby
 from random import randint
 
 from django import template
 from django.db.models import Sum
 from django.urls import reverse
 from django.utils.formats import number_format
 from django.utils.timezone import localdate
 
 from django_ledger import __version__
 from django_ledger.forms.app_filters import EntityFilterForm, ActivityFilterForm
 from django_ledger.forms.feedback import BugReportForm, RequestNewFeatureForm
+from django_ledger.io import BS_BUCKETS_ORDER, ACCOUNT_LIST_ROLE_ORDER
 from django_ledger.io.io_mixin import validate_activity
 from django_ledger.models import TransactionModel, BillModel, InvoiceModel, EntityUnitModel
 from django_ledger.settings import (
     DJANGO_LEDGER_FINANCIAL_ANALYSIS, DJANGO_LEDGER_CURRENCY_SYMBOL,
     DJANGO_LEDGER_SPACED_CURRENCY_SYMBOL)
 from django_ledger.utils import get_default_entity_session_key, get_end_date_from_session, prepare_context_by_unit
 
@@ -83,36 +85,40 @@
     }
 
 
 @register.inclusion_tag('django_ledger/financial_statements/tags/balance_sheet_statement.html', takes_context=True)
 def balance_sheet_statement(context, io_model, to_date=None):
     user_model = context['user']
     activity = context['request'].GET.get('activity')
-    activity = validate_activity(activity, raise_404=True)
     entity_slug = context['view'].kwargs.get('entity_slug')
 
     if not to_date:
         to_date = context['to_date']
 
+    # todo: clean this up!...
     prepare_context_by_unit(context)
 
     txs_qs, digest = io_model.digest(
         activity=activity,
         user_model=user_model,
         equity_only=False,
         entity_slug=entity_slug,
         unit_slug=context['unit_slug'],
         by_unit=context['by_unit'],
         to_date=to_date,
         signs=True,
-        process_groups=True)
+        process_groups=True,
+        balance_sheet_statement=True)
 
+    # todo: this can be moved to the digest function...
     digest['by_unit'] = context['by_unit']
     digest['unit_model'] = context['unit_model']
     digest['unit_slug'] = context['unit_slug']
+    digest['entity_slug'] = entity_slug
+
     return digest
 
 
 @register.inclusion_tag('django_ledger/financial_statements/tags/cash_flow_statement.html', takes_context=True)
 def cash_flow_statement(context, io_model):
     user_model = context['user']
     entity_slug = context['view'].kwargs.get('entity_slug')
@@ -159,15 +165,18 @@
         user_model=user_model,
         entity_slug=entity_slug,
         unit_slug=context['unit_slug'],
         by_unit=context['by_unit'],
         from_date=from_date,
         to_date=to_date,
         equity_only=True,
-        process_groups=True)
+        process_groups=True,
+        income_statement=True,
+        signs=True
+    )
 
     digest['by_unit'] = context['by_unit']
     digest['unit_model'] = context['unit_model']
     digest['unit_slug'] = context['unit_slug']
     return digest
 
 
@@ -191,15 +200,15 @@
 
 
 @register.inclusion_tag('django_ledger/data_import/tags/data_import_job_txs_imported.html', takes_context=True)
 def data_import_job_txs_imported(context):
     return context
 
 
-@register.inclusion_tag('django_ledger/journal_entry/tags/jes_table.html', takes_context=True)
+@register.inclusion_tag('django_ledger/journal_entry/tags/je_table.html', takes_context=True)
 def jes_table(context, next_url=None):
     entity_slug = context['view'].kwargs['entity_slug']
     ledger_pk = context['view'].kwargs['ledger_pk']
     if not next_url:
         next_url = reverse('django_ledger:je-list',
                            kwargs={
                                'entity_slug': entity_slug,
@@ -209,47 +218,48 @@
         'jes': context['journal_entries'],
         'entity_slug': context['view'].kwargs['entity_slug'],
         'ledger_pk': context['view'].kwargs['ledger_pk'],
         'next_url': next_url
     }
 
 
-@register.inclusion_tag('django_ledger/transaction/tags/txs_table.html')
+@register.inclusion_tag('django_ledger/journal_entry/tags/je_txs_table.html')
 def journal_entry_txs_table(journal_entry_model, style='detail'):
-    txs_queryset = journal_entry_model.transactionmodel_set.all().select_related('account')
+    txs_queryset = journal_entry_model.transactionmodel_set.all().select_related('account').order_by('account__code')
     total_credits = sum(tx.amount for tx in txs_queryset if tx.tx_type == 'credit')
     total_debits = sum(tx.amount for tx in txs_queryset if tx.tx_type == 'debit')
     return {
         'txs': txs_queryset,
         'total_debits': total_debits,
         'total_credits': total_credits,
         'style': style
     }
 
 
-@register.inclusion_tag('django_ledger/transaction/tags/txs_table.html', takes_context=True)
+@register.inclusion_tag('django_ledger/journal_entry/tags/je_txs_table.html', takes_context=True)
 def bill_txs_table(context, bill_model: BillModel):
+    # todo: move this to bill model...
     txs_queryset = TransactionModel.objects.for_bill(
         bill_model=bill_model.uuid,
         user_model=context['request'].user,
         entity_slug=context['view'].kwargs['entity_slug']
-    ).select_related('journal_entry').order_by('-journal_entry__date')
+    ).select_related('journal_entry').order_by('-journal_entry__timestamp')
     total_credits = sum(tx.amount for tx in txs_queryset if tx.tx_type == 'credit')
     total_debits = sum(tx.amount for tx in txs_queryset if tx.tx_type == 'debit')
     return {
         'txs': txs_queryset,
         'total_debits': total_debits,
         'total_credits': total_credits
     }
 
 
-@register.inclusion_tag('django_ledger/transaction/tags/txs_table.html', takes_context=True)
+@register.inclusion_tag('django_ledger/journal_entry/tags/je_txs_table.html', takes_context=True)
 def invoice_txs_table(context, invoice_model: InvoiceModel):
     txs_queryset = TransactionModel.objects.for_invoice(
-        invoice_pk=invoice_model.uuid,
+        invoice_model=invoice_model,
         user_model=context['request'].user,
         entity_slug=context['view'].kwargs['entity_slug']
     ).select_related('journal_entry').order_by('-journal_entry__date')
     total_credits = sum(tx.amount for tx in txs_queryset if tx.tx_type == 'credit')
     total_debits = sum(tx.amount for tx in txs_queryset if tx.tx_type == 'debit')
     return {
         'txs': txs_queryset,
@@ -289,17 +299,17 @@
         'entity_slug': context['view'].kwargs['entity_slug']
     }
 
 
 @register.inclusion_tag('django_ledger/account/tags/accounts_table.html', takes_context=True)
 def accounts_table(context, accounts_qs, title=None):
     return {
-        'accounts': accounts_qs,
         'title': title,
         'entity_slug': context['view'].kwargs['entity_slug'],
+        'accounts_gb': accounts_qs.gb_bs_role(),
     }
 
 
 @register.inclusion_tag('django_ledger/customer/tags/customer_table.html', takes_context=True)
 def customer_table(context):
     return context
 
@@ -650,19 +660,24 @@
                     {
                         'type': 'link',
                         'title': 'Entity Units',
                         'url': reverse('django_ledger:unit-list', kwargs={'entity_slug': ENTITY_SLUG})
                     },
                     {
                         'type': 'link',
-                        'title': 'My Products & Services',
+                        'title': 'Products',
                         'url': reverse('django_ledger:product-list', kwargs={'entity_slug': ENTITY_SLUG})
                     },
                     {
                         'type': 'link',
+                        'title': 'Services',
+                        'url': reverse('django_ledger:service-list', kwargs={'entity_slug': ENTITY_SLUG})
+                    },
+                    {
+                        'type': 'link',
                         'title': 'Business Expenses',
                         'url': reverse('django_ledger:expense-list', kwargs={'entity_slug': ENTITY_SLUG})
                     },
                     {
                         'type': 'link',
                         'title': 'Inventory Items',
                         'url': reverse('django_ledger:inventory-item-list', kwargs={'entity_slug': ENTITY_SLUG})
@@ -734,20 +749,29 @@
             }
         ]
         ctx['links'] = nav_menu_links
         ctx['request'] = context['request']
     return ctx
 
 
-@register.inclusion_tag('django_ledger/product/tags/pns_table.html', takes_context=True)
-def pns_table(context, queryset):
+@register.inclusion_tag('django_ledger/product/tags/product_table.html', takes_context=True)
+def product_table(context, queryset):
+    entity_slug = context['view'].kwargs['entity_slug']
+    return {
+        'entity_slug': entity_slug,
+        'product_list': queryset
+    }
+
+
+@register.inclusion_tag('django_ledger/service/tags/services_table.html', takes_context=True)
+def service_table(context, queryset):
     entity_slug = context['view'].kwargs['entity_slug']
     return {
         'entity_slug': entity_slug,
-        'pns_list': queryset
+        'service_list': queryset
     }
 
 
 @register.inclusion_tag('django_ledger/expense/tags/expense_item_table.html', takes_context=True)
 def expense_item_table(context, queryset):
     entity_slug = context['view'].kwargs['entity_slug']
     return {
```

## django_ledger/tests/base.py

```diff
@@ -12,15 +12,14 @@
 from django_ledger.io.data_generator import EntityDataGenerator
 from django_ledger.models import EntityModel
 
 UserModel = get_user_model()
 
 
 class DjangoLedgerBaseTest(TestCase):
-
     FY_STARTS = None
     CAPITAL_CONTRIBUTION = None
     START_DATE = None
     user_model = None
     TEST_DATA = list()
     CLIENT = None
     TZ = None
@@ -52,15 +51,14 @@
         except ObjectDoesNotExist:
             cls.user_model = UserModel.objects.create_user(
                 username=cls.USERNAME,
                 password=cls.PASSWORD,
                 email=cls.USER_EMAIL,
             )
 
-        cls.TZ = get_default_timezone()
         cls.FY_STARTS = [
             '1',
             '2',
             '3',
             '4',
             '5',
             '6',
@@ -71,15 +69,14 @@
             '11',
             '12'
         ]
         cls.TEST_DATA = list()
         cls.CAPITAL_CONTRIBUTION = Decimal('50000.00')
         cls.ENTITY_MODEL_QUERYSET = None
 
-        cls.START_DATE = cls.get_random_date()
         cls.create_entity_models(n=cls.N)
         cls.populate_entity_models()
 
     @classmethod
     def get_random_date(cls) -> date:
         return date(
             year=choice(range(1990, 2020)),
@@ -104,38 +101,43 @@
     def refresh_test_data(cls, n: int = None):
         N = n if n else cls.N
         cls.TEST_DATA = [cls.get_random_entity_data() for _ in range(N)]
 
     @classmethod
     def get_random_entity_data(cls) -> dict:
         return {
-            'slug': f'a-cool-slug-{randint(10000,99999)}',
+            'slug': f'a-cool-slug-{randint(10000, 99999)}',
             'name': f'Testing Inc-{randint(100000, 999999)}',
             'address_1': f'{randint(100000, 999999)} Main St',
             'address_2': f'Suite {randint(1000, 9999)}',
             'city': 'Charlotte',
             'state': 'NC',
             'zip_code': '28202',
             'country': 'US',
             'email': 'mytest@testinginc.com',
             'website': 'http://www.mytestingco.com',
             'fy_start_month': choice(cls.FY_STARTS),
             'admin': cls.user_model
         }
 
+    def get_random_entity_model(self) -> EntityModel:
+        if self.ENTITY_MODEL_QUERYSET:
+            return choice(self.ENTITY_MODEL_QUERYSET)
+        raise ValueError('EntityModels have not been populated.')
+
     @classmethod
     def create_entity_models(cls, save=True, n: int = 5):
         cls.refresh_test_data(n)
         for ent_data in cls.TEST_DATA:
             entity_model = EntityModel.add_root(**ent_data)
             entity_model.admin = cls.user_model
             entity_model.clean()
             if save:
                 entity_model.save()
-    
+
     @classmethod
     def populate_entity_models(cls):
         entities_qs = EntityModel.objects.all()
         for entity_model in entities_qs:
             data_generator = EntityDataGenerator(
                 user_model=cls.user_model,
                 entity_model=entity_model,
```

## django_ledger/tests/test_bill.py

```diff
@@ -4,16 +4,17 @@
 from urllib.parse import urlparse
 from uuid import uuid4
 
 from django.contrib.auth import get_user_model
 from django.urls import reverse
 from django.utils.timezone import localdate
 
-from django_ledger.io.roles import ASSET_CA_CASH, ASSET_CA_PREPAID, LIABILITY_CL_DEFERRED_REVENUE
-from django_ledger.models import EntityModel, BillModel, VendorModel
+from django_ledger.io.roles import ASSET_CA_CASH, ASSET_CA_PREPAID, LIABILITY_CL_DEFERRED_REVENUE, \
+    LIABILITY_CL_ACC_PAYABLE
+from django_ledger.models import EntityModel, BillModel, VendorModel, AccountModel
 from django_ledger.settings import DJANGO_LEDGER_LOGIN_URL
 from django_ledger.tests.base import DjangoLedgerBaseTest
 from django_ledger.urls.bill import urlpatterns as bill_urls
 
 UserModel = get_user_model()
 
 
@@ -23,18 +24,16 @@
         self.URL_PATTERNS = {
             p.name: set(p.pattern.converters.keys()) for p in bill_urls
         }
 
     def create_bill(self, amount: Decimal, draft_date: date = None, is_accrued: bool = False) -> tuple[
         EntityModel, BillModel]:
         entity_model: EntityModel = choice(self.ENTITY_MODEL_QUERYSET)
-        vendor_model: VendorModel = entity_model.vendors.first()
-        account_qs = entity_model.get_accounts(
-            user_model=self.user_model
-        )
+        vendor_model: VendorModel = choice(entity_model.get_vendors())
+        account_qs = entity_model.get_default_coa_accounts()
 
         len(account_qs)  # force evaluation
 
         cash_account = account_qs.filter(role__in=[ASSET_CA_CASH]).first()
         prepaid_account = account_qs.filter(role__in=[ASSET_CA_PREPAID]).first()
         unearned_account = account_qs.filter(role__in=[LIABILITY_CL_DEFERRED_REVENUE]).first()
         dt = self.get_random_date() if not draft_date else draft_date
@@ -61,16 +60,16 @@
     def test_protected_views(self):
         """
         All Bill Model views must have user authenticated.
         If not, user must be redirected to login page.
         """
 
         self.logout_client()
-
-        entity_model, bill_model = self.create_bill(amount=Decimal('500.00'))
+        entity_model = self.get_random_entity_model()
+        bill_model = choice(entity_model.get_bills())
 
         for path, kwargs in self.URL_PATTERNS.items():
             url_kwargs = dict()
             url_kwargs['entity_slug'] = entity_model.slug
             if 'bill_pk' in kwargs:
                 url_kwargs['bill_pk'] = bill_model.uuid
             if 'year' in kwargs:
@@ -96,24 +95,23 @@
         self.login_client()
         entity_model = choice(self.ENTITY_MODEL_QUERYSET)
         bill_list_url = reverse('django_ledger:bill-list',
                                 kwargs={
                                     'entity_slug': entity_model.slug
                                 })
 
-        with self.assertNumQueries(5):
+        with self.assertNumQueries(6):
             response = self.CLIENT.get(bill_list_url)
 
             # bill-list view is rendered...
             self.assertEqual(response.status_code, 200)
 
         bill_model_qs = response.context['bills']
 
         for bill_model in bill_model_qs:
-
             bill_detail_url = reverse('django_ledger:bill-detail',
                                       kwargs={
                                           'entity_slug': entity_model.slug,
                                           'bill_pk': bill_model.uuid
                                       })
             bill_update_url = reverse('django_ledger:bill-update',
                                       kwargs={
@@ -259,31 +257,29 @@
         # user can navigate to bill list
         bill_list_url = reverse('django_ledger:bill-list',
                                 kwargs={
                                     'entity_slug': entity_model.slug
                                 })
         self.assertContains(response, bill_list_url)
 
-        account_qs = entity_model.get_accounts(
-            user_model=self.user_model
-        )
+        account_qs = entity_model.get_default_coa_accounts()
+        len(account_qs)
 
-        # account_queryset = entity_model.
-        a_vendor_model = VendorModel.objects.for_entity(
-            entity_slug=entity_model.slug,
-            user_model=self.user_model
-        ).first()
+        a_vendor_model = choice(entity_model.get_vendors())
 
         bill_data = {
             'vendor': a_vendor_model.uuid,
             'date_draft': localdate(),
-            'terms': BillModel.TERMS_NET_30
+            'terms': BillModel.TERMS_NET_30,
+            'cash_account_id': account_qs.filter(role__exact=ASSET_CA_CASH),
+            'prepaid_account_id': account_qs.filter(role__exact=ASSET_CA_PREPAID),
+            'unearned_account_id': account_qs.filter(role__exact=LIABILITY_CL_ACC_PAYABLE),
         }
 
-        create_response = self.CLIENT.post(bill_create_url, data=bill_data, follow=True)
+        # create_response = self.CLIENT.post(bill_create_url, data=bill_data, follow=True)
         # self.assert
         # self.assertFormError(create_response, form='form', field=None,
         #                      errors=['Must provide a cash account.'])
         #
         # bill_data['cash_account'] = account_qs.with_roles(roles=ASSET_CA_CASH).first().uuid
         # create_response = self.CLIENT.post(bill_create_url, data=bill_data, follow=True)
         # self.assertFormError(create_response, form='form', field=None,
@@ -307,29 +303,26 @@
         # self.assertTrue(create_response.resolver_match.view_name, 'django_ledger:bill-detail')
 
     def test_bill_detail(self):
         self.login_client()
         today = localdate()
 
         for i in range(5):
-            entity_model, bill_model = self.create_bill(amount=Decimal('0.00'), draft_date=today)
-            vendor_model: VendorModel = bill_model.vendor
-            bill_detail_url = reverse('django_ledger:bill-detail',
-                                      kwargs={
-                                          'entity_slug': entity_model.slug,
-                                          'bill_pk': bill_model.uuid
-                                      })
+            entity_model: EntityModel = self.get_random_entity_model()
+            bill_model: BillModel = choice(entity_model.get_bills())
+            vendor_model = bill_model.vendor
+            bill_detail_url = bill_model.get_absolute_url()
 
-            with self.assertNumQueries(8):
+            with self.assertNumQueries(5):
                 bill_detail_response = self.CLIENT.get(bill_detail_url)
             self.assertTrue(bill_detail_response.status_code, 200)
 
-            self.assertTrue(bill_model.is_draft())
+            # self.assertTrue(bill_model.is_draft())
             # 'Not Approved' is displayed to the user...
-            self.assertFalse(bill_model.is_approved())
+            # self.assertFalse(bill_model.is_approved())
 
             # bill card is displayed to the user...
             self.assertContains(bill_detail_response, 'id="djl-bill-card-widget"')
 
             # vendor card is displayed to the user...
             self.assertContains(bill_detail_response, 'id="djl-vendor-card-widget"')
 
@@ -383,13 +376,13 @@
 
             else:
                 # amount prepaid is shown
                 self.assertContains(bill_detail_response, ' id="djl-bill-detail-amount-prepaid"')
                 # amount unearned is shown
                 self.assertContains(bill_detail_response, ' id="djl-bill-detail-amount-unearned"')
 
-            # amounts are zero...
-            self.assertEqual(bill_model.get_amount_cash(), Decimal('0.00'))
-            self.assertEqual(bill_model.get_amount_earned(), Decimal('0.00'))
-            self.assertEqual(bill_model.get_amount_open(), Decimal('0.00'))
-            self.assertEqual(bill_model.get_amount_prepaid(), Decimal('0.00'))
-            self.assertEqual(bill_model.get_amount_unearned(), Decimal('0.00'))
+            # # amounts are zero...
+            # self.assertEqual(bill_model.get_amount_cash(), Decimal('0.00'))
+            # self.assertEqual(bill_model.get_amount_earned(), Decimal('0.00'))
+            # self.assertEqual(bill_model.get_amount_open(), Decimal('0.00'))
+            # self.assertEqual(bill_model.get_amount_prepaid(), Decimal('0.00'))
+            # self.assertEqual(bill_model.get_amount_unearned(), Decimal('0.00'))
```

## django_ledger/tests/test_entity.py

```diff
@@ -166,15 +166,15 @@
         with self.assertNumQueries(3):
             entity_update_url = reverse('django_ledger:entity-update',
                                         kwargs={
                                             'entity_slug': an_entity.slug
                                         })
             response = self.CLIENT.get(entity_update_url)
 
-        with self.assertNumQueries(5):
+        with self.assertNumQueries(4):          # previously 5
             ent_data = response.context['form'].initial
             ent_data['name'] = 'New Cool Name LLC'
             ent_data = {k: v for k, v in ent_data.items() if v}
             response = self.CLIENT.post(entity_update_url, data=ent_data)
 
         with self.assertNumQueries(3):
             # redirects to entity list
@@ -195,15 +195,15 @@
             # this will redirect to entity-detail-month...
             entity_detail_url = reverse('django_ledger:entity-dashboard',
                                         kwargs={
                                             'entity_slug': entity_model.slug
                                         })
             response = self.CLIENT.get(entity_detail_url)
 
-        with self.assertNumQueries(10):
+        with self.assertNumQueries(7):         # previously 10
             local_dt = localdate()
             entity_month_detail_url = reverse('django_ledger:entity-dashboard-month',
                                               kwargs={
                                                   'entity_slug': entity_model.slug,
                                                   'year': local_dt.year,
                                                   'month': local_dt.month
                                               })
```

## django_ledger/urls/account.py

```diff
@@ -5,17 +5,14 @@
 urlpatterns = [
     path('<slug:entity_slug>/list/',
          views.AccountModelListView.as_view(),
          name='account-list'),
     path('<slug:entity_slug>/create/',
          views.AccountModelCreateView.as_view(),
          name='account-create'),
-    path('<slug:entity_slug>/create-child-account/<uuid:parent_account_pk>/',
-         views.AccountModelCreateChildView.as_view(),
-         name='account-create-child'),
     path('<slug:entity_slug>/update/<uuid:account_pk>/',
          views.AccountModelUpdateView.as_view(),
          name='account-update'),
     path('<slug:entity_slug>/detail/<uuid:account_pk>/',
          views.AccountModelDetailView.as_view(),
          name='account-detail'),
     path('<slug:entity_slug>/detail/<uuid:account_pk>/year/<int:year>/',
```

## django_ledger/urls/financial_statement.py

```diff
@@ -104,43 +104,60 @@
     path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/month/<int:year>/<str:month>/',
          views.MonthlyEntityUnitModelIncomeStatementView.as_view(),
          name='unit-ic-month'),
     path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/date/<int:year>/<str:month>/<int:day>/',
          views.MonthlyEntityUnitModelIncomeStatementView.as_view(),
          name='unit-ic-date'),
 
-
     # CASH FLOW STATEMENTS...
+    # Entities...
     path('entity/<slug:entity_slug>/cash-flow-statement/',
          views.EntityModelCashFlowStatementRedirectView.as_view(),
          name='entity-cf'),
     path('entity/<slug:entity_slug>/cash-flow-statement/year/<int:year>/',
          views.FiscalYearEntityModelCashFlowStatementView.as_view(),
          name='entity-cf-year'),
     path('entity/<slug:entity_slug>/cash-flow-statement/quarter/<int:year>/<int:quarter>/',
          views.QuarterlyEntityModelCashFlowStatementView.as_view(),
          name='entity-cf-quarter'),
     path('entity/<slug:entity_slug>/cash-flow-statement/month/<int:year>/<int:month>/',
          views.MonthlyEntityModelCashFlowStatementView.as_view(),
          name='entity-cf-month'),
     path('entity/<slug:entity_slug>/cash-flow-statement/date/<int:year>/<int:month>/<int:day>/',
-         views.DateModelCashFlowStatementView.as_view(),
+         views.DateEntityModelCashFlowStatementView.as_view(),
          name='entity-cf-date'),
 
+    # Ledgers...
+    path('entity/<slug:entity_slug>/<uuid:ledger_pk>/cash-flow-statement/',
+         views.LedgerModelCashFlowStatementRedirectView.as_view(),
+         name='ledger-cf'),
+    path('entity/<slug:entity_slug>/<uuid:ledger_pk>/cash-flow-statement/year/<int:year>/',
+         views.FiscalYearLedgerModelCashFlowStatementView.as_view(),
+         name='ledger-cf-year'),
+    path('entity/<slug:entity_slug>/<uuid:ledger_pk>/cash-flow-statement/quarter/<int:year>/<int:quarter>/',
+         views.QuarterlyLedgerModelCashFlowStatementView.as_view(),
+         name='ledger-cf-quarter'),
+    path('entity/<slug:entity_slug>/<uuid:ledger_pk>/cash-flow-statement/month/<int:year>/<int:month>/',
+         views.MonthlyLedgerModelCashFlowStatementView.as_view(),
+         name='ledger-cf-month'),
+    path('entity/<slug:entity_slug>/<uuid:ledger_pk>/cash-flow-statement/date/<int:year>/<int:month>/<int:day>/',
+         views.DateLedgerModelCashFlowStatementView.as_view(),
+         name='ledger-cf-date'),
+
     # Entity Units...
-    path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/',
-         views.EntityUnitModelIncomeStatementView.as_view(),
+    path('unit/<slug:entity_slug>/<slug:unit_slug>/cash-flow-statement/',
+         views.EntityUnitModelCashFlowStatementView.as_view(),
          name='unit-cf'),
-    path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/year/<int:year>/',
-         views.FiscalYearEntityUnitModelIncomeStatementView.as_view(),
+    path('unit/<slug:entity_slug>/<slug:unit_slug>/cash-flow-statement/year/<int:year>/',
+         views.FiscalYearEntityUnitModelCashFlowStatementView.as_view(),
          name='unit-cf-year'),
-    path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/quarter/<int:year>/<int:quarter>/',
-         views.QuarterlyEntityUnitModelIncomeStatementView.as_view(),
+    path('unit/<slug:entity_slug>/<slug:unit_slug>/cash-flow-statement/quarter/<int:year>/<int:quarter>/',
+         views.QuarterlyEntityUnitModelCashFlowStatementView.as_view(),
          name='unit-cf-quarter'),
-    path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/month/<int:year>/<str:month>/',
-         views.MonthlyEntityUnitModelIncomeStatementView.as_view(),
+    path('unit/<slug:entity_slug>/<slug:unit_slug>/cash-flow-statement/month/<int:year>/<str:month>/',
+         views.MonthlyEntityUnitModelCashFlowStatementView.as_view(),
          name='unit-cf-month'),
-    path('unit/<slug:entity_slug>/<slug:unit_slug>/income-statement/date/<int:year>/<str:month>/<int:day>/',
-         views.MonthlyEntityUnitModelIncomeStatementView.as_view(),
+    path('unit/<slug:entity_slug>/<slug:unit_slug>/cash-flow-statement/date/<int:year>/<str:month>/<int:day>/',
+         views.DateEntityUnitModelCashFlowStatementView.as_view(),
          name='unit-cf-date'),
 
 ]
```

## django_ledger/urls/item.py

```diff
@@ -1,34 +1,42 @@
 from django.urls import path
 
 from django_ledger.views import (
-    ProductsAndServicesListView, ProductOrServiceCreateView, UnitOfMeasureModelCreateView,
-    UnitOfMeasureModelListView, UnitOfMeasureModelUpdateView, ProductOrServiceUpdateView,
+    ProductListView, ProductCreateView, UnitOfMeasureModelCreateView,
+    UnitOfMeasureModelListView, UnitOfMeasureModelUpdateView, ProductUpdateView,
     ExpenseItemCreateView, ExpenseItemModelListView, ExpenseItemUpdateView, InventoryItemModelListView,
-    InventoryItemCreateView, InventoryItemUpdateView, UnitOfMeasureModelDeleteView, ProductOrServiceDeleteView)
+    InventoryItemCreateView, InventoryItemUpdateView, UnitOfMeasureModelDeleteView, ProductDeleteView,
+    ServiceListView, ServiceCreateView, ServiceUpdateView, ServiceDeleteView
+)
 
 urlpatterns = [
-    path('<str:entity_slug>/list/uom/', UnitOfMeasureModelListView.as_view(), name='uom-list'),
-    path('<str:entity_slug>/create/uom/', UnitOfMeasureModelCreateView.as_view(), name='uom-create'),
-    path('<str:entity_slug>/update/uom/<uuid:uom_pk>/', UnitOfMeasureModelUpdateView.as_view(), name='uom-update'),
-    path('<str:entity_slug>/delete/uom/<uuid:uom_pk>/', UnitOfMeasureModelDeleteView.as_view(), name='uom-delete'),
-
-    path('<str:entity_slug>/list/product/', ProductsAndServicesListView.as_view(), name='product-list'),
-    path('<str:entity_slug>/create/product/', ProductOrServiceCreateView.as_view(), name='product-create'),
-    path('<str:entity_slug>/update/product/<uuid:item_pk>/', ProductOrServiceUpdateView.as_view(),
-         name='product-update'),
-    path('<str:entity_slug>/delete/product/<uuid:item_pk>/', ProductOrServiceDeleteView.as_view(),
-         name='product-delete'),
-
-    path('<str:entity_slug>/list/expense/', ExpenseItemModelListView.as_view(), name='expense-list'),
-    path('<str:entity_slug>/create/expense/', ExpenseItemCreateView.as_view(), name='expense-create'),
-    path('<str:entity_slug>/update/expense/<uuid:item_pk>/',
-         ExpenseItemUpdateView.as_view(),
-         name='expense-update'),
 
+    # Unit of Measure Views...
+    path('<str:entity_slug>/uom/list/', UnitOfMeasureModelListView.as_view(), name='uom-list'),
+    path('<str:entity_slug>/uom/create/', UnitOfMeasureModelCreateView.as_view(), name='uom-create'),
+    path('<str:entity_slug>/uom/update/<uuid:uom_pk>/', UnitOfMeasureModelUpdateView.as_view(), name='uom-update'),
+    path('<str:entity_slug>/uom/delete/<uuid:uom_pk>/', UnitOfMeasureModelDeleteView.as_view(), name='uom-delete'),
+
+    # Product Views....
+    path('<str:entity_slug>/product/list/', ProductListView.as_view(), name='product-list'),
+    path('<str:entity_slug>/product/create/', ProductCreateView.as_view(), name='product-create'),
+    path('<str:entity_slug>/product/update/<uuid:item_pk>/', ProductUpdateView.as_view(), name='product-update'),
+    path('<str:entity_slug>/product/delete/<uuid:item_pk>/', ProductDeleteView.as_view(), name='product-delete'),
+
+    # Service Views...
+    path('<str:entity_slug>/service/list', ServiceListView.as_view(), name='service-list'),
+    path('<str:entity_slug>/service/create/', ServiceCreateView.as_view(), name='service-create'),
+    path('<str:entity_slug>/service/update/<uuid:item_pk>/', ServiceUpdateView.as_view(), name='service-update'),
+    path('<str:entity_slug>/service/delete/<uuid:item_pk>/', ServiceDeleteView.as_view(), name='service-delete'),
+
+    # Expense Views...
+    path('<str:entity_slug>/expense/list/', ExpenseItemModelListView.as_view(), name='expense-list'),
+    path('<str:entity_slug>/expense/create/', ExpenseItemCreateView.as_view(), name='expense-create'),
+    path('<str:entity_slug>/expense/update/<uuid:item_pk>/', ExpenseItemUpdateView.as_view(), name='expense-update'),
+
+    # Inventory Views...
     path('<str:entity_slug>/list/inventory/', InventoryItemModelListView.as_view(), name='inventory-item-list'),
     path('<str:entity_slug>/create/inventory/', InventoryItemCreateView.as_view(), name='inventory-item-create'),
-    path('<str:entity_slug>/update/inventory/<uuid:item_pk>/',
-         InventoryItemUpdateView.as_view(),
+    path('<str:entity_slug>/update/inventory/<uuid:item_pk>/', InventoryItemUpdateView.as_view(),
          name='inventory-item-update'),
 
 ]
```

## django_ledger/urls/journal_entry.py

```diff
@@ -8,14 +8,17 @@
          name='je-list'),
     path('<slug:entity_slug>/<uuid:ledger_pk>/create/',
          views.JournalEntryCreateView.as_view(),
          name='je-create'),
     path('<slug:entity_slug>/<uuid:ledger_pk>/detail/<uuid:je_pk>/',
          views.JournalEntryDetailView.as_view(),
          name='je-detail'),
+    path('<slug:entity_slug>/<uuid:ledger_pk>/detail/<uuid:je_pk>/txs/',
+         views.JournalEntryModelTXSDetailView.as_view(),
+         name='je-detail-txs'),
     path('<slug:entity_slug>/<uuid:ledger_pk>/update/<uuid:je_pk>/',
          views.JournalEntryUpdateView.as_view(),
          name='je-update'),
 
     # actions...
     path('<slug:entity_slug>/<uuid:ledger_pk>/update/<uuid:je_pk>/mark-as-posted/',
          views.JournalEntryActionMarkAsPostedView.as_view(),
```

## django_ledger/urls/transactions.py

```diff
@@ -1,9 +1,5 @@
 from django.urls import path
 
 from django_ledger import views
 
-urlpatterns = [
-    path('txs/<slug:entity_slug>/<uuid:ledger_pk>/journal-entry/<uuid:je_pk>/',
-         views.TXSJournalEntryView.as_view(),
-         name='txs-journal-entry'),
-]
+urlpatterns = []
```

## django_ledger/views/account.py

```diff
@@ -9,170 +9,132 @@
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
 from django.utils.timezone import localdate
 from django.utils.translation import gettext as _
 from django.views.generic import ListView, UpdateView, CreateView, DetailView
 from django.views.generic import RedirectView
 
-from django_ledger.forms.account import AccountModelUpdateForm, AccountModelCreateForm, AccountModelCreateChildForm
+from django_ledger.forms.account import AccountModelUpdateForm, AccountModelCreateForm
 from django_ledger.models import lazy_loader
 from django_ledger.models.accounts import AccountModel
 from django_ledger.views.mixins import (
     YearlyReportMixIn, MonthlyReportMixIn, QuarterlyReportMixIn, DjangoLedgerSecurityMixIn,
     BaseDateNavigationUrlMixIn, EntityUnitMixIn, DateReportMixIn
 )
 
 
+class BaseAccountModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = AccountModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user,
+            ).select_related('coa_model', 'coa_model__entity').order_by(
+                'coa_model', 'role', 'code').not_coa_root()
+        return super().get_queryset()
+
+
 # Account Views ----
-class AccountModelListView(DjangoLedgerSecurityMixIn, ListView):
+class AccountModelListView(DjangoLedgerSecurityMixIn, BaseAccountModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/account/account_list.html'
     context_object_name = 'accounts'
     PAGE_TITLE = _('Entity Accounts')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
 
-    def get_context_data(self, *args, **kwargs):
-        context = super().get_context_data(**kwargs)
-        qs = self.get_queryset()
-        context['asset_accounts'] = (a for a in qs if a.role_bs == 'assets')
-        context['liability_accounts'] = (a for a in qs if a.role_bs == 'liabilities')
-        context['equity_accounts'] = (a for a in qs if a.role_bs == 'equity')
-        return context
-
-    def get_queryset(self):
-        return AccountModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user,
-        ).order_by('code')
 
-
-class AccountModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class AccountModelUpdateView(DjangoLedgerSecurityMixIn, BaseAccountModelViewQuerySetMixIn, UpdateView):
     context_object_name = 'account'
     template_name = 'django_ledger/account/account_update.html'
     slug_url_kwarg = 'account_pk'
     slug_field = 'uuid'
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
         context['page_title'] = _('Update Account')
         context['header_title'] = _(f'Update Account: {self.object.code} - {self.object.name}')
         context['header_subtitle_icon'] = 'ic:twotone-account-tree'
         return context
 
     def get_form(self, form_class=None):
+        account_model = self.object
+
+        # Set here because user_model is needed to instantiate an instance of MoveNodeForm (AccountModelUpdateForm)
+        account_model.USER_MODEL = self.request.user
         return AccountModelUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
     def get_success_url(self):
         entity_slug = self.kwargs['entity_slug']
         return reverse('django_ledger:account-list',
                        kwargs={
                            'entity_slug': entity_slug,
                        })
 
-    def get_queryset(self):
-        return AccountModel.objects.for_entity(
-            user_model=self.request.user,
-            entity_slug=self.kwargs['entity_slug'],
-        )
-
 
-class AccountModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class AccountModelCreateView(DjangoLedgerSecurityMixIn, BaseAccountModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/account/account_create.html'
     PAGE_TITLE = _('Create Account')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'ic:twotone-account-tree'
 
     }
 
-    def get_queryset(self):
-        return AccountModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_form(self, form_class=None):
         return AccountModelCreateForm(
             user_model=self.request.user,
             entity_slug=self.kwargs['entity_slug'],
             **self.get_form_kwargs()
         )
 
     def form_valid(self, form):
         EntityModel = lazy_loader.get_entity_model()
-        entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user)
+        entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user).select_related('default_coa')
         entity_model: EntityModel = get_object_or_404(entity_model_qs, slug__exact=self.kwargs['entity_slug'])
+        account_model: AccountModel = form.save(commit=False)
 
-        # parent_account_pk = self.kwargs.get('parent_account_pk')
-        # if parent_account_pk:
-        #     account_qs = self.get_queryset()
-        #     parent_account_model = get_object_or_404(account_qs, uuid__exact=parent_account_pk)
-        #     account.parent = parent_account_model
-        #     account.role = parent_account_model.role
-
-        # coa_qs = ChartOfAccountModel.objects.for_entity(user_model=self.request.user,
-        #                                                 entity_slug=entity_slug)
-        # coa_model = get_object_or_404(coa_qs, entity__slug__exact=entity_slug)
+        if not entity_model.has_default_coa():
+            entity_model.create_chart_of_accounts(assign_as_default=True, commit=True)
 
-        account_model = AccountModel.add_root(**form.cleaned_data, coa_id=entity_model.default_coa_id)
+        coa_model = entity_model.default_coa
+        coa_model.create_account(account_model=account_model)
         return HttpResponseRedirect(self.get_success_url())
 
     def get_success_url(self):
         entity_slug = self.kwargs.get('entity_slug')
         return reverse('django_ledger:account-list',
                        kwargs={
                            'entity_slug': entity_slug,
                        })
 
 
-class AccountModelCreateChildView(AccountModelCreateView):
-    template_name = 'django_ledger/account/account_create_child.html'
-    slug_url_kwarg = 'parent_account_pk'
-    slug_field = 'uuid'
-    PAGE_TITLE = _('Create Child Account')
-    context_object_name = 'account'
-
-    def get_context_data(self, **kwargs):
-        context = super(AccountModelCreateChildView, self).get_context_data()
-        obj: AccountModel = self.get_object()
-        context['page_title'] = _('Create Child Account')
-        context['header_title'] = _('Create Child Account - %s' % obj)
-        context['header_subtitle_icon'] = 'ic:twotone-account-tree'
-        context['account'] = obj
-        return context
-
-    def get_form(self, form_class=None):
-        return AccountModelCreateChildForm(
-            user_model=self.request.user,
-            entity_slug=self.kwargs['entity_slug'],
-            **self.get_form_kwargs()
-        )
-
-
-class AccountModelDetailView(DjangoLedgerSecurityMixIn, RedirectView):
+class AccountModelDetailView(DjangoLedgerSecurityMixIn, BaseAccountModelViewQuerySetMixIn, RedirectView):
 
     def get_redirect_url(self, *args, **kwargs):
         loc_date = localdate()
         return reverse('django_ledger:account-detail-month',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'account_pk': self.kwargs['account_pk'],
                            'year': loc_date.year,
                            'month': loc_date.month,
                        })
 
 
 class AccountModelYearDetailView(DjangoLedgerSecurityMixIn,
+                                 BaseAccountModelViewQuerySetMixIn,
                                  BaseDateNavigationUrlMixIn,
                                  EntityUnitMixIn,
                                  YearlyReportMixIn,
                                  DetailView):
     context_object_name = 'account'
     template_name = 'django_ledger/account/account_detail.html'
     slug_url_kwarg = 'account_pk'
@@ -184,25 +146,24 @@
     }
 
     def get_context_data(self, **kwargs):
         account = self.object
         context = super().get_context_data(**kwargs)
         context['header_title'] = f'Account {account.code} - {account.name}'
         context['page_title'] = f'Account {account.code} - {account.name}'
-        txs_qs = self.object.transactionmodel_set.order_by('-journal_entry__date')
+        account_model: AccountModel = self.object
+        txs_qs = account_model.transactionmodel_set.order_by('journal_entry__timestamp')
         txs_qs = txs_qs.from_date(self.get_from_date())
         txs_qs = txs_qs.to_date(self.get_to_date())
         context['transactions'] = txs_qs
         return context
 
     def get_queryset(self):
-        return AccountModel.objects.for_entity(
-            user_model=self.request.user,
-            entity_slug=self.kwargs['entity_slug'],
-        ).prefetch_related('transactionmodel_set')
+        qs = super().get_queryset()
+        return qs.prefetch_related('transactionmodel_set')
 
 
 class AccountModelQuarterDetailView(QuarterlyReportMixIn, AccountModelYearDetailView):
     """
     Account Model Quarter Detail View
     """
```

## django_ledger/views/bank_account.py

```diff
@@ -13,34 +13,39 @@
 from django.views.generic.detail import SingleObjectMixin
 
 from django_ledger.forms.bank_account import BankAccountCreateForm, BankAccountUpdateForm
 from django_ledger.models.bank_account import BankAccountModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
-class BankAccountModelListView(DjangoLedgerSecurityMixIn, ListView):
+class BankAccountModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = BankAccountModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('cash_account', 'entity_model')
+        return super().get_queryset()
+
+
+class BankAccountModelListView(DjangoLedgerSecurityMixIn, BankAccountModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/bank_account/bank_account_list.html'
     PAGE_TITLE = _('Bank Accounts')
     context_object_name = 'bank_accounts'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'clarity:bank-line'
     }
 
-    def get_queryset(self):
-        return BankAccountModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('cash_account', 'entity_model')
-
 
-class BankAccountModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class BankAccountModelCreateView(DjangoLedgerSecurityMixIn, BankAccountModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/bank_account/bank_account_create.html'
-    form_class = BankAccountCreateForm
     PAGE_TITLE = _('Create Bank Account')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'clarity:bank-line'
     }
 
@@ -62,15 +67,15 @@
         bank_account_model.configure(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             commit=False)
         return super(BankAccountModelCreateView, self).form_valid(form)
 
 
-class BankAccountModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class BankAccountModelUpdateView(DjangoLedgerSecurityMixIn, BankAccountModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/bank_account/bank_account_update.html'
     pk_url_kwarg = 'bank_account_pk'
     PAGE_TITLE = _('Update Bank Account')
     context_object_name = 'bank_account'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
@@ -79,41 +84,32 @@
 
     def get_success_url(self):
         return reverse('django_ledger:bank-account-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
-    def get_queryset(self):
-        return BankAccountModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity_model')
-
     def get_form(self, form_class=None):
         return BankAccountUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
 
 # ACTION VIEWS...
-class BaseBankAccountModelActionView(DjangoLedgerSecurityMixIn, RedirectView, SingleObjectMixin):
+class BaseBankAccountModelActionView(DjangoLedgerSecurityMixIn,
+                                     BankAccountModelModelViewQuerySetMixIn,
+                                     RedirectView,
+                                     SingleObjectMixin):
     http_method_names = ['get']
     pk_url_kwarg = 'bank_account_pk'
     action_name = None
     commit = True
 
-    def get_queryset(self):
-        return BankAccountModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_redirect_url(self, *args, **kwargs):
         return reverse('django_ledger:bank-account-list',
                        kwargs={
                            'entity_slug': kwargs['entity_slug']
                        })
 
     def get(self, request, *args, **kwargs):
```

## django_ledger/views/bill.py

```diff
@@ -24,55 +24,24 @@
                                       ApprovedBillModelUpdateForm, AccruedAndApprovedBillModelUpdateForm,
                                       PaidBillModelUpdateForm)
 from django_ledger.models import EntityModel, PurchaseOrderModel, EstimateModel
 from django_ledger.models.bill import BillModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
-class BillModelListView(DjangoLedgerSecurityMixIn, ArchiveIndexView):
-    template_name = 'django_ledger/bills/bill_list.html'
-    context_object_name = 'bills'
-    PAGE_TITLE = _('Bill List')
-    date_field = 'date_draft'
-    paginate_by = 20
-    paginate_orphans = 2
-    allow_empty = True
-    extra_context = {
-        'page_title': PAGE_TITLE,
-        'header_title': PAGE_TITLE,
-        'header_subtitle_icon': 'uil:bill'
-    }
+class BillModelModelViewQuerySetMixIn:
+    queryset = None
 
     def get_queryset(self):
-        return BillModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('vendor', 'ledger', 'ledger__entity').order_by('-updated')
-
-    def get_allow_future(self):
-        allow_future = self.request.GET.get('allow_future')
-        if allow_future:
-            try:
-                allow_future = int(allow_future)
-                if allow_future in (0, 1):
-                    return bool(allow_future)
-            except ValueError:
-                pass
-        return False
-
-
-class BillModelYearListView(YearArchiveView, BillModelListView):
-    paginate_by = 10
-    make_object_list = True
-
-
-class BillModelMonthListView(MonthArchiveView, BillModelListView):
-    paginate_by = 10
-    month_format = '%m'
-    date_list_period = 'year'
+        if not self.queryset:
+            self.queryset = BillModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('vendor', 'ledger', 'ledger__entity').order_by('-updated')
+        return super().get_queryset()
 
 
 class BillModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
     template_name = 'django_ledger/bills/bill_create.html'
     PAGE_TITLE = _('Create Bill')
     extra_context = {
         'page_title': PAGE_TITLE,
@@ -157,14 +126,15 @@
                                    user_model=self.request.user,
                                    **self.get_form_kwargs())
 
     def form_valid(self, form):
         bill_model: BillModel = form.save(commit=False)
         ledger_model, bill_model = bill_model.configure(
             entity_slug=self.kwargs['entity_slug'],
+            commit_ledger=True,
             ledger_posted=False,
             user_model=self.request.user)
 
         if self.for_estimate:
             ce_pk = self.kwargs['ce_pk']
             estimate_model_qs = EstimateModel.objects.for_entity(
                 entity_slug=self.kwargs['entity_slug'],
@@ -202,25 +172,14 @@
             bill_model.update_amount_due()
             bill_model.new_state(commit=True)
             bill_model.clean()
             bill_model.save()
             po_model_items_qs.update(bill_model=bill_model)
             return HttpResponseRedirect(self.get_success_url())
 
-        elif self.for_estimate:
-            estimate_qs = EstimateModel.objects.for_entity(
-                entity_slug=self.kwargs['entity_slug'],
-                user_model=self.request.user
-            )
-            estimate_model = get_object_or_404(estimate_qs, uuid__exact=self.kwargs['ce_pk'])
-            bill_model.ce_model_id = estimate_model.uuid
-            bill_model.clean()
-            bill_model.save()
-            return HttpResponseRedirect(self.get_success_url())
-
         return super(BillModelCreateView, self).form_valid(form)
 
     def get_success_url(self):
         entity_slug = self.kwargs['entity_slug']
         if self.for_purchase_order:
             po_pk = self.kwargs['po_pk']
             return reverse('django_ledger:po-update',
@@ -238,14 +197,40 @@
         return reverse('django_ledger:bill-detail',
                        kwargs={
                            'entity_slug': entity_slug,
                            'bill_pk': bill_model.uuid
                        })
 
 
+class BillModelListView(DjangoLedgerSecurityMixIn, BillModelModelViewQuerySetMixIn, ArchiveIndexView):
+    template_name = 'django_ledger/bills/bill_list.html'
+    context_object_name = 'bills'
+    PAGE_TITLE = _('Bill List')
+    date_field = 'date_draft'
+    paginate_by = 20
+    paginate_orphans = 2
+    allow_empty = True
+    extra_context = {
+        'page_title': PAGE_TITLE,
+        'header_title': PAGE_TITLE,
+        'header_subtitle_icon': 'uil:bill'
+    }
+
+
+class BillModelYearListView(YearArchiveView, BillModelListView):
+    paginate_by = 10
+    make_object_list = True
+
+
+class BillModelMonthListView(MonthArchiveView, BillModelListView):
+    paginate_by = 10
+    month_format = '%m'
+    date_list_period = 'year'
+
+
 class BillModelDetailView(DjangoLedgerSecurityMixIn, DetailView):
     slug_url_kwarg = 'bill_pk'
     slug_field = 'uuid'
     context_object_name = 'bill'
     template_name = 'django_ledger/bills/bill_detail.html'
     extra_context = {
         'header_subtitle_icon': 'uil:bill',
@@ -256,17 +241,15 @@
         context = super().get_context_data(object_list=object_list, **kwargs)
         bill_model: BillModel = self.object
         title = f'Bill {bill_model.bill_number}'
         context['page_title'] = title
         context['header_title'] = title
 
         bill_model: BillModel = self.object
-        bill_items_qs, item_data = bill_model.get_itemtxs_data(
-            queryset=bill_model.itemtransactionmodel_set.all()
-        )
+        bill_items_qs, item_data = bill_model.get_itemtxs_data()
         context['bill_items'] = bill_items_qs
         context['total_amount__sum'] = item_data['total_amount__sum']
 
         if not bill_model.is_configured():
             link = format_html(f"""
             <a href="{reverse("django_ledger:bill-update", kwargs={
                 'entity_slug': self.kwargs['entity_slug'],
@@ -281,18 +264,22 @@
                                  extra_tags='is-danger')
         return context
 
     def get_queryset(self):
         return BillModel.objects.for_entity(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user
-        ).prefetch_related(
-            'itemtransactionmodel_set',
-            'ledger__journal_entries__entity_unit'
-        ).select_related('ledger', 'ledger__entity', 'vendor', 'cash_account', 'prepaid_account', 'unearned_account')
+        ).select_related(
+            'ledger',
+            'ledger__entity',
+            'vendor',
+            'cash_account',
+            'prepaid_account',
+            'unearned_account'
+        )
 
 
 class BillModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
     slug_url_kwarg = 'bill_pk'
     slug_field = 'uuid'
     context_object_name = 'bill_model'
     template_name = 'django_ledger/bills/bill_update.html'
```

## django_ledger/views/coa.py

```diff
@@ -11,15 +11,27 @@
 from django.views.generic import UpdateView
 
 from django_ledger.forms.coa import ChartOfAccountsModelUpdateForm
 from django_ledger.models.coa import ChartOfAccountModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
-class ChartOfAccountsUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class ChartOfAccountsModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = ChartOfAccountModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user,
+            ).select_related('entity')
+        return super().get_queryset()
+
+
+class ChartOfAccountsUpdateView(DjangoLedgerSecurityMixIn, ChartOfAccountsModelModelViewQuerySetMixIn, UpdateView):
     context_object_name = 'coa'
     slug_url_kwarg = 'coa_slug'
     template_name = 'django_ledger/code_of_accounts/coa_update.html'
     form_class = ChartOfAccountsModelUpdateForm
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
@@ -29,13 +41,7 @@
 
     def get_success_url(self):
         entity_slug = self.kwargs.get('entity_slug')
         return reverse('django_ledger:entity-dashboard',
                        kwargs={
                            'entity_slug': entity_slug
                        })
-
-    def get_queryset(self):
-        return ChartOfAccountModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user,
-        )
```

## django_ledger/views/customer.py

```diff
@@ -12,50 +12,52 @@
 
 from django_ledger.forms.customer import CustomerModelForm
 from django_ledger.models.customer import CustomerModel
 from django_ledger.models.entity import EntityModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
+class CustomerModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = CustomerModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).order_by('-updated')
+        return super().get_queryset()
+
+
 class CustomerModelListView(DjangoLedgerSecurityMixIn,
+                            CustomerModelModelViewQuerySetMixIn,
                             ListView):
     template_name = 'django_ledger/customer/customer_list.html'
     PAGE_TITLE = _('Customer List')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'dashicons:businesswoman'
     }
     context_object_name = 'customers'
 
-    def get_queryset(self):
-        return CustomerModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).order_by('-updated')
-
 
 class CustomerModelCreateView(DjangoLedgerSecurityMixIn,
+                              CustomerModelModelViewQuerySetMixIn,
                               CreateView):
     template_name = 'django_ledger/customer/customer_create.html'
     PAGE_TITLE = _('Create New Customer')
     form_class = CustomerModelForm
     context_object_name = 'customer'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'dashicons:businesswoman'
     }
 
-    def get_queryset(self):
-        return CustomerModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:customer-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def form_valid(self, form):
@@ -65,14 +67,15 @@
         ).get(slug__exact=self.kwargs['entity_slug'])
         customer_model.entity_model = entity_model
         customer_model.save()
         return super().form_valid(form)
 
 
 class CustomerModelUpdateView(DjangoLedgerSecurityMixIn,
+                              CustomerModelModelViewQuerySetMixIn,
                               UpdateView):
     template_name = 'django_ledger/customer/customer_update.html'
     PAGE_TITLE = _('Customer Update')
     form_class = CustomerModelForm
     context_object_name = 'customer'
     slug_url_kwarg = 'customer_pk'
     slug_field = 'uuid'
@@ -82,20 +85,14 @@
         customer_model: CustomerModel = self.object
         context['page_title'] = self.PAGE_TITLE
         context['header_title'] = self.PAGE_TITLE
         context['header_subtitle'] = customer_model.customer_number
         context['header_subtitle_icon'] = 'dashicons:businesswoman'
         return context
 
-    def get_queryset(self):
-        return CustomerModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:customer-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def form_valid(self, form):
```

## django_ledger/views/entity.py

```diff
@@ -6,15 +6,14 @@
 Miguel Sanda <msanda@arrobalytics.com>
 """
 
 from datetime import timedelta
 from decimal import Decimal
 from random import randint
 
-from django.contrib.messages import add_message, ERROR
 from django.http import HttpResponseRedirect
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
 from django.utils.timezone import localdate
 from django.utils.translation import gettext_lazy as _
 from django.views.generic import ListView, DetailView, UpdateView, CreateView, RedirectView, DeleteView
 
@@ -24,30 +23,33 @@
 from django_ledger.views.mixins import (
     QuarterlyReportMixIn, YearlyReportMixIn,
     MonthlyReportMixIn, DateReportMixIn, DjangoLedgerSecurityMixIn, EntityUnitMixIn,
     EntityDigestMixIn, UnpaidElementsMixIn, BaseDateNavigationUrlMixIn
 )
 
 
+class EntityModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        return EntityModel.objects.for_user(user_model=self.request.user).select_related('default_coa')
+
+
 # Entity CRUD Views ----
-class EntityModelListView(DjangoLedgerSecurityMixIn, ListView):
+class EntityModelListView(DjangoLedgerSecurityMixIn, EntityModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/entity/entitiy_list.html'
     context_object_name = 'entities'
     PAGE_TITLE = _('My Entities')
     extra_context = {
         'header_title': PAGE_TITLE,
         'page_title': PAGE_TITLE
     }
 
-    def get_queryset(self):
-        return EntityModel.objects.for_user(
-            user_model=self.request.user)
-
 
-class EntityModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class EntityModelCreateView(DjangoLedgerSecurityMixIn, EntityModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/entity/entity_create.html'
     form_class = EntityModelCreateForm
     PAGE_TITLE = _('Create Entity')
     extra_context = {
         'header_title': PAGE_TITLE,
         'page_title': PAGE_TITLE
     }
@@ -98,49 +100,41 @@
             entity_generator.populate_entity()
 
         return HttpResponseRedirect(
             redirect_to=self.get_success_url()
         )
 
 
-class EntityModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class EntityModelUpdateView(DjangoLedgerSecurityMixIn, EntityModelModelViewQuerySetMixIn, UpdateView):
     context_object_name = 'entity'
     template_name = 'django_ledger/entity/entity_update.html'
     form_class = EntityModelUpdateForm
     slug_url_kwarg = 'entity_slug'
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
         context['page_title'] = self.object.name
         context['header_title'] = self.object.name
         return context
 
     def get_success_url(self):
         return reverse('django_ledger:entity-list')
 
-    def get_queryset(self):
-        return EntityModel.objects.for_user(user_model=self.request.user)
-
 
-class EntityDeleteView(DjangoLedgerSecurityMixIn, DeleteView):
+class EntityDeleteView(DjangoLedgerSecurityMixIn, EntityModelModelViewQuerySetMixIn, DeleteView):
     slug_url_kwarg = 'entity_slug'
     context_object_name = 'entity'
     template_name = 'django_ledger/entity/entity_delete.html'
 
     def get_context_data(self, *, object_list=None, **kwargs):
         context = super().get_context_data(object_list=object_list, **kwargs)
         context['page_title'] = _('Delete Entity ') + self.object.name
         context['header_title'] = context['page_title']
         return context
 
-    def get_queryset(self):
-        return EntityModel.objects.for_user(
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:home')
 
     def post(self, request, *args, **kwargs):
         return self.delete(request, *args, **kwargs)
 
     def delete(self, request, *args, **kwargs):
@@ -182,14 +176,15 @@
                            'entity_slug': self.kwargs['entity_slug'],
                            'year': loc_date.year,
                            'month': loc_date.month,
                        })
 
 
 class FiscalYearEntityModelDashboardView(DjangoLedgerSecurityMixIn,
+                                         EntityModelModelViewQuerySetMixIn,
                                          BaseDateNavigationUrlMixIn,
                                          UnpaidElementsMixIn,
                                          EntityUnitMixIn,
                                          EntityDigestMixIn,
                                          YearlyReportMixIn,
                                          DetailView):
     context_object_name = 'entity'
@@ -226,27 +221,14 @@
         context['receivables_chart_endpoint'] = reverse(f'django_ledger:{url_pointer}-json-net-receivables',
                                                         kwargs=KWARGS)
 
         context = self.get_entity_digest(context)
 
         return context
 
-    def get_fy_start_month(self) -> int:
-        entity_model: EntityModel = self.object
-        return entity_model.fy_start_month
-
-    def get_queryset(self):
-        """
-        Returns a queryset of all Entities owned or Managed by the User.
-        Queryset is annotated with user_role parameter (owned/managed).
-        :return: The View queryset.
-        """
-        return EntityModel.objects.for_user(
-            user_model=self.request.user).select_related('default_coa')
-
 
 class QuarterlyEntityDashboardView(FiscalYearEntityModelDashboardView, QuarterlyReportMixIn):
     """
     Entity Quarterly Dashboard View.
     """
 
 
@@ -271,14 +253,15 @@
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'year': year
                        })
 
 
 class FiscalYearEntityModelBalanceSheetView(DjangoLedgerSecurityMixIn,
+                                            EntityModelModelViewQuerySetMixIn,
                                             BaseDateNavigationUrlMixIn,
                                             EntityUnitMixIn,
                                             YearlyReportMixIn,
                                             DetailView):
     context_object_name = 'entity'
     slug_url_kwarg = 'entity_slug'
     template_name = 'django_ledger/financial_statements/balance_sheet.html'
@@ -290,27 +273,14 @@
         unit_slug = self.request.GET.get('unit')
         if unit_slug:
             context['unit_model'] = get_object_or_404(EntityUnitModel,
                                                       slug=unit_slug,
                                                       entity__slug__exact=self.kwargs['entity_slug'])
         return context
 
-    def get_queryset(self):
-        """
-        Returns a queryset of all Entities owned or Managed by the User.
-        Queryset is annotated with user_role parameter (owned/managed).
-        :return: The View queryset.
-        """
-        return EntityModel.objects.for_user(user_model=self.request.user)
-
-    # todo: this is odd, why override this method from YearlyReportMixIn?
-    def get_fy_start_month(self) -> int:
-        entity_model: EntityModel = self.object
-        return entity_model.fy_start_month
-
 
 class QuarterlyEntityModelBalanceSheetView(QuarterlyReportMixIn, FiscalYearEntityModelBalanceSheetView):
     """
     Quarter Balance Sheet View.
     """
 
 
@@ -334,14 +304,15 @@
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'year': year
                        })
 
 
 class FiscalYearEntityModelIncomeStatementView(DjangoLedgerSecurityMixIn,
+                                               EntityModelModelViewQuerySetMixIn,
                                                BaseDateNavigationUrlMixIn,
                                                EntityUnitMixIn,
                                                YearlyReportMixIn,
                                                DetailView):
     context_object_name = 'entity'
     slug_url_kwarg = 'entity_slug'
     template_name = 'django_ledger/financial_statements/income_statement.html'
@@ -355,22 +326,14 @@
         if unit_slug:
             entity_unit_qs = entity_model.entityunitmodel_set.all()
             context['unit_model'] = get_object_or_404(entity_unit_qs,
                                                       slug__exact=unit_slug,
                                                       entity__slug__exact=self.kwargs['entity_slug'])
         return context
 
-    def get_queryset(self):
-        return EntityModel.objects.for_user(user_model=self.request.user)
-
-    # todo: this is odd, why override this method from YearlyReportMixIn?
-    def get_fy_start_month(self) -> int:
-        entity_model: EntityModel = self.object
-        return entity_model.fy_start_month
-
 
 class QuarterlyEntityModelIncomeStatementView(QuarterlyReportMixIn, FiscalYearEntityModelIncomeStatementView):
     """
     Quarter Income Statement View.
     """
 
 
@@ -395,14 +358,15 @@
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'year': year
                        })
 
 
 class FiscalYearEntityModelCashFlowStatementView(DjangoLedgerSecurityMixIn,
+                                                 EntityModelModelViewQuerySetMixIn,
                                                  BaseDateNavigationUrlMixIn,
                                                  EntityUnitMixIn,
                                                  YearlyReportMixIn,
                                                  DetailView):
     """
     Fiscal Year Cash Flow Statement View.
     """
@@ -420,32 +384,24 @@
         if unit_slug:
             entity_unit_qs = entity_model.entityunitmodel_set.all()
             context['unit_model'] = get_object_or_404(entity_unit_qs,
                                                       slug__exact=unit_slug,
                                                       entity__slug__exact=self.kwargs['entity_slug'])
         return context
 
-    def get_queryset(self):
-        return EntityModel.objects.for_user(user_model=self.request.user)
-
-    # todo: this is odd, why override this method from YearlyReportMixIn?
-    def get_fy_start_month(self) -> int:
-        entity_model: EntityModel = self.object
-        return entity_model.fy_start_month
-
 
 class QuarterlyEntityModelCashFlowStatementView(QuarterlyReportMixIn, FiscalYearEntityModelCashFlowStatementView):
     """
     Quarter Cash Flow Statement View.
     """
 
 
 class MonthlyEntityModelCashFlowStatementView(MonthlyReportMixIn, FiscalYearEntityModelCashFlowStatementView):
     """
     Monthly Cash Flow Statement View.
     """
 
 
-class DateModelCashFlowStatementView(DateReportMixIn, FiscalYearEntityModelCashFlowStatementView):
+class DateEntityModelCashFlowStatementView(DateReportMixIn, FiscalYearEntityModelCashFlowStatementView):
     """
     Date Cash Flow Statement View.
     """
```

## django_ledger/views/estimate.py

```diff
@@ -11,39 +11,42 @@
                                           CanEditEstimateItemModelFormset, ReadOnlyEstimateItemModelFormset,
                                           DraftEstimateModelUpdateForm)
 from django_ledger.models import EntityModel, ItemTransactionModelQuerySet
 from django_ledger.models.estimate import EstimateModel
 from django_ledger.views import DjangoLedgerSecurityMixIn
 
 
-class EstimateModelListView(DjangoLedgerSecurityMixIn, ArchiveIndexView):
+class EstimateModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = EstimateModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('customer', 'entity')
+        return super().get_queryset()
+
+
+class EstimateModelListView(DjangoLedgerSecurityMixIn, EstimateModelModelViewQuerySetMixIn, ArchiveIndexView):
     template_name = 'django_ledger/estimate/estimate_list.html'
     context_object_name = 'estimate_list'
     PAGE_TITLE = _('Customer Estimates')
     date_field = 'created'
     paginate_by = 20
     paginate_orphans = 2
     allow_empty = True
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'eos-icons:job'
     }
 
-    def get_queryset(self):
-        return EstimateModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('customer')
-
-    def get_date_field(self):
-        return 'created'
-
 
-class EstimateModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class EstimateModelCreateView(DjangoLedgerSecurityMixIn, EstimateModelModelViewQuerySetMixIn, CreateView):
     PAGE_TITLE = _('Create Customer Estimate')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'eos-icons:job'
     }
     template_name = 'django_ledger/estimate/estimate_create.html'
@@ -69,28 +72,28 @@
         estimate_model: EstimateModel = form.save(commit=False)
         entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user).only('uuid')
         entity_model: EntityModel = get_object_or_404(entity_model_qs, slug=self.kwargs['entity_slug'])
         estimate_model.entity = entity_model
         return super(EstimateModelCreateView, self).form_valid(form)
 
 
-class EstimateModelDetailView(DjangoLedgerSecurityMixIn, DetailView):
+class EstimateModelDetailView(DjangoLedgerSecurityMixIn, EstimateModelModelViewQuerySetMixIn, DetailView):
     pk_url_kwarg = 'ce_pk'
     template_name = 'django_ledger/estimate/estimate_detail.html'
     PAGE_TITLE = _('Customer Estimate Detail')
     context_object_name = 'estimate_model'
     extra_context = {
         'hide_menu': True
     }
     http_method_names = ['get', 'post']
 
     def get_context_data(self, **kwargs):
         context = super(EstimateModelDetailView, self).get_context_data(**kwargs)
         ce_model: EstimateModel = self.object
-        context['page_title'] = self.PAGE_TITLE,
+        context['page_title'] = self.PAGE_TITLE
         context['header_title'] = self.PAGE_TITLE
         context['header_subtitle'] = ce_model.estimate_number
         context['header_subtitle_icon'] = 'eos-icons:job'
         context['estimate_item_list'] = ce_model.itemtransactionmodel_set.all()
 
         # PO Model Queryset...
         po_qs = ce_model.purchaseordermodel_set.for_entity(
@@ -107,32 +110,29 @@
 
         bill_qs = ce_model.billmodel_set.for_entity(
             user_model=self.request.user,
             entity_slug=self.kwargs['entity_slug']
         ) if ce_model.is_approved() else ce_model.billmodel_set.none()
         context['estimate_bill_model_queryset'] = bill_qs
 
-        # context['contract_items'] = ce_model.itemtransactionmodel_set.all()
-
-        context['contract_progress'] = ce_model.get_contract_summary(
-            po_qs=po_qs,
-            invoice_qs=invoice_qs,
-            bill_qs=bill_qs
-        )
+        if ce_model.is_contract():
+            context['contract_progress'] = ce_model.get_contract_summary(
+                po_qs=po_qs,
+                invoice_qs=invoice_qs,
+                bill_qs=bill_qs
+            )
 
         return context
 
     def get_queryset(self):
-        return EstimateModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('customer', 'entity').prefetch_related('itemtransactionmodel_set')
+        qs = super().get_queryset()
+        return qs.prefetch_related('itemtransactionmodel_set')
 
 
-class EstimateModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class EstimateModelUpdateView(DjangoLedgerSecurityMixIn, EstimateModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/estimate/estimate_update.html'
     pk_url_kwarg = 'ce_pk'
     context_object_name = 'estimate'
     PAGE_TITLE = _('Customer Estimate Update')
     http_method_names = ['get', 'post']
 
     action_update_items = False
@@ -150,15 +150,15 @@
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
     def get_context_data(self, itemtxs_formset=None, **kwargs):
         context = super(EstimateModelUpdateView, self).get_context_data(**kwargs)
         ce_model: EstimateModel = self.object
-        context['page_title'] = self.PAGE_TITLE,
+        context['page_title'] = self.PAGE_TITLE
         context['header_title'] = self.PAGE_TITLE
         context['header_subtitle'] = ce_model.title
         context['header_subtitle_icon'] = 'eos-icons:job'
         if not itemtxs_formset:
             itemtxs_qs: ItemTransactionModelQuerySet = ce_model.get_itemtxs_data()
             itemtxs_agg = itemtxs_qs.get_estimate_aggregate()
             if ce_model.can_update_items():
@@ -181,20 +181,14 @@
 
         context['ce_revenue_estimate__sum'] = itemtxs_agg['ce_revenue_estimate__sum']
         context['ce_cost_estimate__sum'] = itemtxs_agg['ce_cost_estimate__sum']
         context['itemtxs_qs'] = itemtxs_qs
         context['itemtxs_formset'] = itemtxs_formset
         return context
 
-    def get_queryset(self):
-        return EstimateModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('customer', 'entity')
-
     def get_success_url(self):
         return reverse('django_ledger:customer-estimate-detail',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'ce_pk': self.kwargs['ce_pk']
                        })
 
@@ -253,26 +247,23 @@
                     return self.render_to_response(context=self.get_context_data())
             context = self.get_context_data(itemtxs_formset=itemtxs_formset)
             return self.render_to_response(context=context)
         return super(EstimateModelUpdateView, self).post(request, *args, **kwargs)
 
 
 # ---- ACTION VIEWS ----
-class BaseEstimateActionView(DjangoLedgerSecurityMixIn, RedirectView, SingleObjectMixin):
+class BaseEstimateActionView(DjangoLedgerSecurityMixIn,
+                             EstimateModelModelViewQuerySetMixIn,
+                             RedirectView,
+                             SingleObjectMixin):
     http_method_names = ['get']
     pk_url_kwarg = 'ce_pk'
     action_name = None
     commit = True
 
-    def get_queryset(self):
-        return EstimateModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_redirect_url(self, entity_slug, ce_pk, *args, **kwargs):
         return reverse('django_ledger:customer-estimate-update',
                        kwargs={
                            'entity_slug': entity_slug,
                            'ce_pk': ce_pk
                        })
```

## django_ledger/views/inventory.py

```diff
@@ -36,29 +36,33 @@
         context['page_title'] = _('Inventory')
         context['header_title'] = _('Inventory Status')
         context['header_subtitle'] = _('Ordered/In Transit/On Hand')
         context['header_subtitle_icon'] = 'ic:round-inventory'
         return context
 
     def get_queryset(self):
-        return ItemTransactionModel.objects.inventory_pipeline_aggregate(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
+        if not self.queryset:
+            self.queryset = ItemTransactionModel.objects.inventory_pipeline_aggregate(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            )
+        return super().get_queryset()
 
 
 class InventoryRecountView(DjangoLedgerSecurityMixIn, DetailView):
     template_name = 'django_ledger/inventory/inventory_recount.html'
     http_method_names = ['get']
     slug_url_kwarg = 'entity_slug'
 
     def get_queryset(self):
-        return EntityModel.objects.for_user(
-            user_model=self.request.user
-        )
+        if not self.queryset:
+            self.queryset = EntityModel.objects.for_user(
+                user_model=self.request.user
+            )
+        return super().get_queryset()
 
     def counted_inventory(self):
         entity_slug = self.kwargs['entity_slug']
         user_model = self.request.user
         return ItemTransactionModel.objects.inventory_count(
             entity_slug=entity_slug,
             user_model=user_model
```

## django_ledger/views/invoice.py

```diff
@@ -23,45 +23,51 @@
                                          ApprovedInvoiceModelUpdateForm, PaidInvoiceModelUpdateForm,
                                          AccruedAndApprovedInvoiceModelUpdateForm, InvoiceModelCreateForm)
 from django_ledger.models import EntityModel, LedgerModel, EstimateModel
 from django_ledger.models.invoice import InvoiceModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
-class InvoiceModelListView(DjangoLedgerSecurityMixIn, ArchiveIndexView):
+class InvoiceModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = InvoiceModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('customer', 'ledger').order_by('-created')
+        return super().get_queryset()
+
+
+class InvoiceModelListView(DjangoLedgerSecurityMixIn, InvoiceModelModelViewQuerySetMixIn, ArchiveIndexView):
     template_name = 'django_ledger/invoice/invoice_list.html'
     context_object_name = 'invoice_list'
     PAGE_TITLE = _('Invoice List')
     date_field = 'created'
     paginate_by = 20
     paginate_orphans = 2
     allow_empty = True
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
 
-    def get_queryset(self):
-        return InvoiceModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('customer').order_by('-created')
-
 
 class InvoiceModelYearlyListView(YearArchiveView, InvoiceModelListView):
     paginate_by = 10
     make_object_list = True
 
 
 class InvoiceModelMonthlyListView(MonthArchiveView, InvoiceModelListView):
     paginate_by = 10
     month_format = '%m'
 
 
-class InvoiceModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class InvoiceModelCreateView(DjangoLedgerSecurityMixIn, InvoiceModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/invoice/invoice_create.html'
     PAGE_TITLE = _('Create Invoice')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
     for_estimate = False
@@ -152,15 +158,15 @@
         return reverse('django_ledger:invoice-detail',
                        kwargs={
                            'entity_slug': entity_slug,
                            'invoice_pk': invoice_model.uuid
                        })
 
 
-class InvoiceModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class InvoiceModelUpdateView(DjangoLedgerSecurityMixIn, InvoiceModelModelViewQuerySetMixIn, UpdateView):
     slug_url_kwarg = 'invoice_pk'
     slug_field = 'uuid'
     context_object_name = 'invoice'
     template_name = 'django_ledger/invoice/invoice_update.html'
     form_class = BaseInvoiceModelUpdateForm
     http_method_names = ['get', 'post']
 
@@ -254,19 +260,16 @@
         return reverse('django_ledger:invoice-update',
                        kwargs={
                            'entity_slug': entity_slug,
                            'invoice_pk': invoice_pk
                        })
 
     def get_queryset(self):
-        return InvoiceModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).prefetch_related('itemtransactionmodel_set').select_related(
-            'ledger', 'customer')
+        qs = super().get_queryset()
+        return qs.prefetch_related('itemtransactionmodel_set')
 
     def form_valid(self, form):
         invoice_model: InvoiceModel = form.save(commit=False)
         if invoice_model.can_migrate():
             invoice_model.migrate_state(
                 user_model=self.request.user,
                 entity_slug=self.kwargs['entity_slug']
@@ -354,15 +357,15 @@
                     )
 
                 # if not valid, return formset with errors...
                 return self.render_to_response(context=self.get_context_data(itemtxs_formset=itemtxs_formset))
         return super(InvoiceModelUpdateView, self).post(request, **kwargs)
 
 
-class InvoiceModelDetailView(DjangoLedgerSecurityMixIn, DetailView):
+class InvoiceModelDetailView(DjangoLedgerSecurityMixIn, InvoiceModelModelViewQuerySetMixIn, DetailView):
     slug_url_kwarg = 'invoice_pk'
     slug_field = 'uuid'
     context_object_name = 'invoice'
     template_name = 'django_ledger/invoice/invoice_detail.html'
     extra_context = {
         'hide_menu': True
     }
@@ -377,23 +380,21 @@
         invoice_model: InvoiceModel = self.object
         itemtxs_qs, itemtxs_agg = invoice_model.get_itemtxs_data()
         context['invoice_items'] = itemtxs_qs
         context['total_amount_due'] = itemtxs_agg['total_amount__sum']
         return context
 
     def get_queryset(self):
-        return InvoiceModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).prefetch_related(
+        qs = super().get_queryset()
+        return qs.prefetch_related(
             'itemtransactionmodel_set'
-        ).select_related('ledger', 'customer', 'cash_account', 'prepaid_account', 'unearned_account')
+        ).select_related('cash_account', 'prepaid_account', 'unearned_account')
 
 
-class InvoiceModelDeleteView(DjangoLedgerSecurityMixIn, DeleteView):
+class InvoiceModelDeleteView(DjangoLedgerSecurityMixIn, InvoiceModelModelViewQuerySetMixIn, DeleteView):
     slug_url_kwarg = 'invoice_pk'
     slug_field = 'uuid'
     template_name = 'django_ledger/invoice/invoice_delete.html'
     context_object_name = 'invoice'
     extra_context = {
         'hide_menu': True
     }
@@ -406,34 +407,25 @@
 
     def get_success_url(self):
         return reverse('django_ledger:entity-dashboard',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
-    def get_queryset(self):
-        return InvoiceModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
 
 # ACTION VIEWS...
-class BaseInvoiceActionView(DjangoLedgerSecurityMixIn, RedirectView, SingleObjectMixin):
+class BaseInvoiceActionView(DjangoLedgerSecurityMixIn,
+                            RedirectView,
+                            InvoiceModelModelViewQuerySetMixIn,
+                            SingleObjectMixin):
     http_method_names = ['get']
     pk_url_kwarg = 'invoice_pk'
     action_name = None
     commit = True
 
-    def get_queryset(self):
-        return InvoiceModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_redirect_url(self, *args, **kwargs):
         return reverse('django_ledger:invoice-update',
                        kwargs={
                            'entity_slug': kwargs['entity_slug'],
                            'invoice_pk': kwargs['invoice_pk']
                        })
```

## django_ledger/views/item.py

```diff
@@ -5,41 +5,49 @@
 from django.http import HttpResponseRedirect
 from django.shortcuts import get_object_or_404
 from django.urls import reverse
 from django.utils.translation import gettext_lazy as _
 from django.views.generic import ListView, CreateView, UpdateView, DeleteView
 
 from django_ledger.forms.item import (
-    ProductOrServiceCreateForm, UnitOfMeasureModelCreateForm, UnitOfMeasureModelUpdateForm, ProductOrServiceUpdateForm,
-    ExpenseItemCreateForm, ExpenseItemUpdateForm, InventoryItemCreateForm, InventoryItemUpdateForm
+    ProductCreateForm, UnitOfMeasureModelCreateForm, UnitOfMeasureModelUpdateForm, ProductUpdateForm,
+    ExpenseItemCreateForm, ExpenseItemUpdateForm, InventoryItemCreateForm, InventoryItemUpdateForm,
+    ServiceCreateForm, ServiceUpdateForm
 )
 from django_ledger.models import ItemModel, UnitOfMeasureModel, EntityModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
 # todo: Create delete views...
 
-class UnitOfMeasureModelListView(DjangoLedgerSecurityMixIn, ListView):
+# UNIT OF MEASURE VIEWS....
+class UnitOfMeasureModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = UnitOfMeasureModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            )
+        return super().get_queryset()
+
+
+class UnitOfMeasureModelListView(DjangoLedgerSecurityMixIn, UnitOfMeasureModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/uom/uom_list.html'
     PAGE_TITLE = _('Unit of Measures')
     context_object_name = 'uom_list'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'carbon:circle-measurement'
     }
 
-    def get_queryset(self):
-        return UnitOfMeasureModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
 
-class UnitOfMeasureModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class UnitOfMeasureModelCreateView(DjangoLedgerSecurityMixIn, UnitOfMeasureModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/uom/uom_create.html'
     PAGE_TITLE = _('Create Unit of Measure')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'carbon:circle-measurement'
     }
@@ -80,57 +88,45 @@
                             message=_(
                                 f'The Unit of Measure {unit_abbr} already created for Entity {entity_model.name}.'),
                             extra_tags='is-danger')
                 return self.render_to_response(self.get_context_data(form=form))
         return super().form_valid(form)
 
 
-class UnitOfMeasureModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class UnitOfMeasureModelUpdateView(DjangoLedgerSecurityMixIn, UnitOfMeasureModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/uom/uom_update.html'
     PAGE_TITLE = _('Update Unit of Measure')
     context_object_name = 'uom'
     slug_url_kwarg = 'uom_pk'
     slug_field = 'uuid'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'carbon:circle-measurement'
     }
 
-    def get_queryset(self):
-        return UnitOfMeasureModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:uom-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def get_form(self, form_class=None):
         return UnitOfMeasureModelUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
 
-class UnitOfMeasureModelDeleteView(DjangoLedgerSecurityMixIn, DeleteView):
+class UnitOfMeasureModelDeleteView(DjangoLedgerSecurityMixIn, UnitOfMeasureModelModelViewQuerySetMixIn, DeleteView):
     pk_url_kwarg = 'uom_pk'
     template_name = 'django_ledger/uom/uom_delete.html'
     context_object_name = 'uom_model'
 
-    def get_queryset(self):
-        return UnitOfMeasureModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def form_valid(self, form):
         try:
             return super(UnitOfMeasureModelDeleteView, self).form_valid(form)
         except RestrictedError:
 
             uom_model: UnitOfMeasureModel = self.object
             add_message(self.request,
@@ -149,154 +145,299 @@
     def get_success_url(self):
         return reverse('django_ledger:uom-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
 
-# PRODUCTS AND SERVICES VIEW...
-class ProductsAndServicesListView(DjangoLedgerSecurityMixIn, ListView):
+# PRODUCTS VIEWS...
+class ProductItemModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = ItemModel.objects.products(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related(
+                'earnings_account', 'cogs_account',
+                'inventory_account', 'uom').order_by('-updated')
+        return super().get_queryset()
+
+
+class ProductListView(DjangoLedgerSecurityMixIn,
+                      ProductItemModelModelViewQuerySetMixIn,
+                      ListView):
     template_name = 'django_ledger/product/product_list.html'
-    PAGE_TITLE = _('Products & Services')
-    context_object_name = 'pns_list'
+    PAGE_TITLE = _('Products')
+    context_object_name = 'product_list'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
-    def get_queryset(self, **kwargs):
-        return ItemModel.objects.products_and_services(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('earnings_account', 'uom').order_by('-updated')
-
 
-class ProductOrServiceCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class ProductCreateView(DjangoLedgerSecurityMixIn,
+                        ProductItemModelModelViewQuerySetMixIn,
+                        CreateView):
     template_name = 'django_ledger/product/product_create.html'
     model = ItemModel
-    PAGE_TITLE = _('Create New Product or Service')
+    PAGE_TITLE = _('Create New Product')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
     def get_success_url(self):
         return reverse('django_ledger:product-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def get_form(self, form_class=None):
-        return ProductOrServiceCreateForm(
+        return ProductCreateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
     def form_valid(self, form):
         entity_slug = self.kwargs['entity_slug']
         entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user)
         entity_model = get_object_or_404(entity_model_qs, slug__exact=entity_slug)
-        ItemModel.add_root(**form.cleaned_data,
-                           entity=entity_model,
-                           is_product_or_service=True,
-                           for_inventory=False)
-        return HttpResponseRedirect(self.get_success_url())
+        item_model: ItemModel = form.save(commit=False)
+        item_model.entity = entity_model
+        item_model.item_role = ItemModel.ITEM_ROLE_PRODUCT
+        return super().form_valid(form=form)
 
 
-class ProductOrServiceUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class ProductUpdateView(DjangoLedgerSecurityMixIn,
+                        ProductItemModelModelViewQuerySetMixIn,
+                        UpdateView):
     template_name = 'django_ledger/product/product_update.html'
-    PAGE_TITLE = _('Update Product or Service')
+    PAGE_TITLE = _('Update Product')
     context_object_name = 'item'
     pk_url_kwarg = 'item_pk'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
     def get_queryset(self):
-        return ItemModel.objects.products_and_services(
+        return ItemModel.objects.products(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user
         )
 
     def get_form(self, form_class=None):
-        return ProductOrServiceUpdateForm(
+        return ProductUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
     def get_success_url(self):
         return reverse('django_ledger:product-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
 
-class ProductOrServiceDeleteView(DjangoLedgerSecurityMixIn, DeleteView):
+class ProductDeleteView(DjangoLedgerSecurityMixIn,
+                        ProductItemModelModelViewQuerySetMixIn,
+                        DeleteView):
     template_name = 'django_ledger/product/product_delete.html'
     pk_url_kwarg = 'item_pk'
     context_object_name = 'item_model'
 
+    def form_valid(self, form):
+        try:
+            # todo: add success message...
+            return super(ProductDeleteView, self).form_valid(form)
+        except RestrictedError:
+
+            item_model: ItemModel = self.object
+            add_message(self.request,
+                        level=ERROR,
+                        message=f'Unable to delete Product or Service {item_model.name}. '
+                                'Remove dependencies before deleting.',
+                        extra_tags='is-danger')
+
+            return HttpResponseRedirect(
+                redirect_to=reverse('django_ledger:product-list',
+                                    kwargs={
+                                        'entity_slug': self.kwargs['entity_slug']
+                                    })
+            )
+
+    def get_success_url(self):
+        return reverse('django_ledger:product-list',
+                       kwargs={
+                           'entity_slug': self.kwargs['entity_slug']
+                       })
+
+
+# SERVICES VIEWS...
+class ServiceItemModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = ItemModel.objects.services(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related(
+                'earnings_account', 'cogs_account',
+                'inventory_account', 'uom').order_by('-updated')
+        return super().get_queryset()
+
+
+class ServiceListView(DjangoLedgerSecurityMixIn,
+                      ServiceItemModelModelViewQuerySetMixIn,
+                      ListView):
+    template_name = 'django_ledger/service/service_list.html'
+    PAGE_TITLE = _('Services')
+    context_object_name = 'service_list'
+    extra_context = {
+        'page_title': PAGE_TITLE,
+        'header_title': PAGE_TITLE,
+        'header_subtitle_icon': 'zmdi:collection-item'
+    }
+
+
+class ServiceCreateView(DjangoLedgerSecurityMixIn,
+                        ServiceItemModelModelViewQuerySetMixIn,
+                        CreateView):
+    template_name = 'django_ledger/service/service_create.html'
+    model = ItemModel
+    PAGE_TITLE = _('Create New Service')
+    extra_context = {
+        'page_title': PAGE_TITLE,
+        'header_title': PAGE_TITLE,
+        'header_subtitle_icon': 'zmdi:collection-item'
+    }
+
+    def get_success_url(self):
+        return reverse('django_ledger:service-list',
+                       kwargs={
+                           'entity_slug': self.kwargs['entity_slug']
+                       })
+
+    def get_form(self, form_class=None):
+        return ServiceCreateForm(
+            entity_slug=self.kwargs['entity_slug'],
+            user_model=self.request.user,
+            **self.get_form_kwargs()
+        )
+
+    def form_valid(self, form):
+        entity_slug = self.kwargs['entity_slug']
+        entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user)
+        entity_model = get_object_or_404(entity_model_qs, slug__exact=entity_slug)
+        item_model: ItemModel = form.save(commit=False)
+        item_model.entity = entity_model
+        return super().form_valid(form=form)
+
+
+class ServiceUpdateView(DjangoLedgerSecurityMixIn,
+                        ServiceItemModelModelViewQuerySetMixIn,
+                        UpdateView):
+    template_name = 'django_ledger/service/service_update.html'
+    PAGE_TITLE = _('Update Service')
+    context_object_name = 'item'
+    pk_url_kwarg = 'item_pk'
+    extra_context = {
+        'page_title': PAGE_TITLE,
+        'header_title': PAGE_TITLE,
+        'header_subtitle_icon': 'zmdi:collection-item'
+    }
+
     def get_queryset(self):
-        return ItemModel.objects.products_and_services(
+        return ItemModel.objects.services(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user
         )
 
+    def get_form(self, form_class=None):
+        return ServiceUpdateForm(
+            entity_slug=self.kwargs['entity_slug'],
+            user_model=self.request.user,
+            **self.get_form_kwargs()
+        )
+
+    def get_success_url(self):
+        return reverse('django_ledger:service-list',
+                       kwargs={
+                           'entity_slug': self.kwargs['entity_slug']
+                       })
+
+
+class ServiceDeleteView(DjangoLedgerSecurityMixIn,
+                        ServiceItemModelModelViewQuerySetMixIn,
+                        DeleteView):
+    template_name = 'django_ledger/service/service_delete.html'
+    pk_url_kwarg = 'item_pk'
+    context_object_name = 'item_model'
+
     def form_valid(self, form):
         try:
             # todo: add success message...
-            return super(ProductOrServiceDeleteView, self).form_valid(form)
+            return super(ServiceDeleteView, self).form_valid(form)
         except RestrictedError:
 
             item_model: ItemModel = self.object
             add_message(self.request,
                         level=ERROR,
                         message=f'Unable to delete Product or Service {item_model.name}. '
                                 'Remove dependencies before deleting.',
                         extra_tags='is-danger')
 
             return HttpResponseRedirect(
-                redirect_to=reverse('django_ledger:product-list',
+                redirect_to=reverse('django_ledger:service-list',
                                     kwargs={
                                         'entity_slug': self.kwargs['entity_slug']
                                     })
             )
 
     def get_success_url(self):
-        return reverse('django_ledger:product-list',
+        return reverse('django_ledger:service-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
 
 # EXPENSE ITEMS VIEW...
-class ExpenseItemModelListView(DjangoLedgerSecurityMixIn, ListView):
+
+class ExpenseItemItemModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = ItemModel.objects.expenses(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('expense_account', 'uom').order_by('-updated')
+        return super().get_queryset()
+
+
+class ExpenseItemModelListView(DjangoLedgerSecurityMixIn, ExpenseItemItemModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/expense/expense_list.html'
     PAGE_TITLE = _('Expense Items')
     context_object_name = 'expense_list'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
-    def get_queryset(self, **kwargs):
-        return ItemModel.objects.expenses(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('expense_account', 'uom').order_by('-updated')
 
-
-class ExpenseItemCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class ExpenseItemCreateView(DjangoLedgerSecurityMixIn, ExpenseItemItemModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/expense/expense_create.html'
     model = ItemModel
     PAGE_TITLE = _('Create New Expense Item')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
@@ -315,71 +456,72 @@
             **self.get_form_kwargs()
         )
 
     def form_valid(self, form):
         entity_slug = self.kwargs['entity_slug']
         entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user)
         entity_model = get_object_or_404(entity_model_qs, slug__exact=entity_slug)
-        ItemModel.add_root(**form.cleaned_data,
-                           entity=entity_model,
-                           is_product_or_service=False,
-                           for_inventory=False)
-        return HttpResponseRedirect(self.get_success_url())
+        item_model: ItemModel = form.save(commit=False)
+        item_model.entity = entity_model
+        item_model.item_role = ItemModel.ITEM_ROLE_EXPENSE
+        return super().form_valid(form=form)
 
 
-class ExpenseItemUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class ExpenseItemUpdateView(DjangoLedgerSecurityMixIn, ExpenseItemItemModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/expense/expense_update.html'
     PAGE_TITLE = _('Update Expense Item')
     context_object_name = 'item'
     slug_field = 'uuid'
     slug_url_kwarg = 'item_pk'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
-    def get_queryset(self):
-        return ItemModel.objects.expenses(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_form(self, form_class=None):
         return ExpenseItemUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
     def get_success_url(self):
         return reverse('django_ledger:expense-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
 
-class InventoryItemModelListView(DjangoLedgerSecurityMixIn, ListView):
+# INVENTORY VIEWS...
+
+class InventoryItemItemModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = ItemModel.objects.inventory_wip(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('inventory_account', 'cogs_account', 'uom').order_by('-updated')
+        return super().get_queryset()
+
+
+class InventoryItemModelListView(DjangoLedgerSecurityMixIn, InventoryItemItemModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/inventory/inventory_item_list.html'
     PAGE_TITLE = _('Inventory Items')
     context_object_name = 'inventory_item_list'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
-    def get_queryset(self, **kwargs):
-        return ItemModel.objects.inventory(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('inventory_account', 'cogs_account', 'uom').order_by('-updated')
 
-
-class InventoryItemCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class InventoryItemCreateView(DjangoLedgerSecurityMixIn, InventoryItemItemModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/inventory/inventory_item_create.html'
     model = ItemModel
     PAGE_TITLE = _('Create New Inventory Item')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
@@ -402,38 +544,32 @@
         """If the form is invalid, render the invalid form."""
         return self.render_to_response(self.get_context_data(form=form))
 
     def form_valid(self, form):
         entity_slug = self.kwargs['entity_slug']
         entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user)
         entity_model = get_object_or_404(entity_model_qs, slug__exact=entity_slug)
-        ItemModel.add_root(**form.cleaned_data,
-                           entity=entity_model,
-                           for_inventory=True)
-        return HttpResponseRedirect(self.get_success_url())
+        item_model: ItemModel = form.save(commit=False)
+        item_model.entity = entity_model
+        item_model.item_role = ItemModel.ITEM_ROLE_INVENTORY
+        return super().form_valid(form=form)
 
 
-class InventoryItemUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class InventoryItemUpdateView(DjangoLedgerSecurityMixIn, InventoryItemItemModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/inventory/inventory_item_update.html'
     PAGE_TITLE = _('Update Inventory Item')
     context_object_name = 'item'
     slug_field = 'uuid'
     slug_url_kwarg = 'item_pk'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'zmdi:collection-item'
     }
 
-    def get_queryset(self):
-        return ItemModel.objects.inventory(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_form(self, form_class=None):
         return InventoryItemUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
```

## django_ledger/views/journal_entry.py

```diff
@@ -3,70 +3,153 @@
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
 Miguel Sanda <msanda@arrobalytics.com>
 """
 from django.contrib import messages
 from django.core.exceptions import ImproperlyConfigured, ValidationError
+from django.http import HttpResponseForbidden
 from django.urls import reverse
-from django.utils.timezone import localdate
+from django.utils.timezone import localtime
 from django.utils.translation import gettext_lazy as _
 from django.views.generic import ListView, DetailView, UpdateView, CreateView, RedirectView
 from django.views.generic.detail import SingleObjectMixin
 
 from django_ledger.forms.journal_entry import JournalEntryModelUpdateForm, JournalEntryModelCreateForm
+from django_ledger.forms.transactions import get_transactionmodel_formset_class
 from django_ledger.models.journal_entry import JournalEntryModel
 from django_ledger.models.ledger import LedgerModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
+class JournalEntryModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = JournalEntryModel.objects.for_ledger(
+                ledger_pk=self.kwargs['ledger_pk'],
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('entity_unit', 'ledger', 'ledger__entity')
+        return super().get_queryset()
+
+
 # JE Views ---
-class JournalEntryListView(DjangoLedgerSecurityMixIn, ListView):
+class JournalEntryListView(DjangoLedgerSecurityMixIn, JournalEntryModelModelViewQuerySetMixIn, ListView):
     context_object_name = 'journal_entries'
     template_name = 'django_ledger/journal_entry/je_list.html'
     PAGE_TITLE = _('Journal Entries')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
     http_method_names = ['get']
 
-    def get_queryset(self):
-        sort = self.request.GET.get('sort')
-        if not sort:
-            sort = '-updated'
-        return JournalEntryModel.objects.for_ledger(
-            ledger_pk=self.kwargs['ledger_pk'],
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity_unit').order_by(sort)
-
 
-class JournalEntryDetailView(DjangoLedgerSecurityMixIn, DetailView):
+class JournalEntryDetailView(DjangoLedgerSecurityMixIn, JournalEntryModelModelViewQuerySetMixIn, DetailView):
     context_object_name = 'journal_entry'
     template_name = 'django_ledger/journal_entry/je_detail.html'
     slug_url_kwarg = 'je_pk'
     slug_field = 'uuid'
     PAGE_TITLE = _('Journal Entry Detail')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'bi:journal-plus'
     }
     http_method_names = ['get']
 
     def get_queryset(self):
-        return JournalEntryModel.objects.for_ledger(
-            entity_slug=self.kwargs['entity_slug'],
-            ledger_pk=self.kwargs['ledger_pk'],
-            user_model=self.request.user
-        ).select_related('entity_unit')
+        qs = super().get_queryset()
+        return qs.prefetch_related('transactionmodel_set', 'transactionmodel_set__account')
 
 
-class JournalEntryUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class JournalEntryModelTXSDetailView(DjangoLedgerSecurityMixIn, JournalEntryModelModelViewQuerySetMixIn, DetailView):
+    template_name = 'django_ledger/journal_entry/je_detail_txs.html'
+    PAGE_TITLE = _('Edit Transactions')
+    pk_url_kwarg = 'je_pk'
+    extra_context = {
+        'header_title': PAGE_TITLE,
+        'page_title': PAGE_TITLE
+    }
+    context_object_name = 'journal_entry'
+
+    def get_queryset(self):
+        qs = super().get_queryset()
+        return qs.prefetch_related('transactionmodel_set', 'transactionmodel_set__account')
+
+    def get_context_data(self, txs_formset=None, **kwargs):
+        context = super(JournalEntryModelTXSDetailView, self).get_context_data(**kwargs)
+        je_model: JournalEntryModel = self.object
+        if je_model.locked:
+            messages.add_message(self.request,
+                                 message=_('Locked Journal Entry. Must unlock to Edit.'),
+                                 level=messages.WARNING,
+                                 extra_tags='is-warning')
+        if not txs_formset:
+            TransactionModelFormSet = get_transactionmodel_formset_class(journal_entry_model=je_model)
+            context['txs_formset'] = TransactionModelFormSet(
+                user_model=self.request.user,
+                je_model=je_model,
+                ledger_pk=self.kwargs['ledger_pk'],
+                entity_slug=self.kwargs['entity_slug'],
+                queryset=je_model.transactionmodel_set.all().order_by('account__code')
+            )
+        else:
+            context['txs_formset'] = txs_formset
+        return context
+
+    def post(self, request, **kwargs):
+
+        if not request.user.is_authenticated:
+            return HttpResponseForbidden()
+
+        je_model: JournalEntryModel = self.get_object()
+        self.object = je_model
+
+        TransactionModelFormSet = get_transactionmodel_formset_class(journal_entry_model=je_model)
+        txs_formset = TransactionModelFormSet(request.POST,
+                                              user_model=self.request.user,
+                                              ledger_pk=kwargs['ledger_pk'],
+                                              entity_slug=kwargs['entity_slug'],
+                                              je_model=je_model)
+
+        if je_model.locked:
+            messages.add_message(self.request,
+                                 message=_('Cannot update a Locked Journal Entry.'),
+                                 level=messages.ERROR,
+                                 extra_tags='is-danger')
+            return self.render_to_response(context=self.get_context_data(txs_formset=txs_formset))
+
+        if not je_model.posted:
+            messages.add_message(self.request,
+                                 message=_('Journal Entry has not been posted.'),
+                                 level=messages.INFO,
+                                 extra_tags='is-info')
+
+        if txs_formset.is_valid():
+            txs_list = txs_formset.save(commit=False)
+
+            for txs in txs_list:
+                if not txs.journal_entry_id:
+                    txs.journal_entry_id = je_model.uuid
+
+            txs_formset.save()
+            messages.add_message(request, messages.SUCCESS, 'Successfully saved transactions.', extra_tags='is-success')
+        else:
+            messages.add_message(request,
+                                 messages.ERROR,
+                                 'Hmmm, this doesn\'t add up!. Check your math!',
+                                 extra_tags='is-danger')
+            return self.render_to_response(context=self.get_context_data(txs_formset=txs_formset))
+        return self.render_to_response(context=self.get_context_data())
+
+
+class JournalEntryUpdateView(DjangoLedgerSecurityMixIn, JournalEntryModelModelViewQuerySetMixIn, UpdateView):
     context_object_name = 'journal_entry'
     template_name = 'django_ledger/journal_entry/je_update.html'
     pk_url_kwarg = 'je_pk'
     PAGE_TITLE = _('Update Journal Entry')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
@@ -83,22 +166,19 @@
     def get_success_url(self):
         return reverse('django_ledger:je-list', kwargs={
             'entity_slug': self.kwargs['entity_slug'],
             'ledger_pk': self.kwargs['ledger_pk']
         })
 
     def get_queryset(self):
-        return JournalEntryModel.objects.for_ledger(
-            entity_slug=self.kwargs['entity_slug'],
-            ledger_pk=self.kwargs['ledger_pk'],
-            user_model=self.request.user
-        ).prefetch_related('transactionmodel_set', 'transactionmodel_set__account')
+        qs = super().get_queryset()
+        return qs.prefetch_related('transactionmodel_set', 'transactionmodel_set__account')
 
 
-class JournalEntryCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class JournalEntryCreateView(DjangoLedgerSecurityMixIn, JournalEntryModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/journal_entry/je_create.html'
     PAGE_TITLE = _('Create Journal Entry')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
 
@@ -117,15 +197,15 @@
         ).get(uuid__exact=self.kwargs['ledger_pk'])
         je_model: JournalEntryModel = form.save(commit=False)
         je_model.ledger = ledger_model
         return super().form_valid(form)
 
     def get_initial(self):
         return {
-            'timestamp': localdate(),
+            'timestamp': localtime(),
             'ledger': LedgerModel.objects.for_entity(
                 entity_slug=self.kwargs['entity_slug'],
                 user_model=self.request.user
             ).get(uuid__exact=self.kwargs['ledger_pk'])
         }
 
     def get_success_url(self):
```

## django_ledger/views/ledger.py

```diff
@@ -16,35 +16,37 @@
 from django_ledger.models.ledger import LedgerModel
 from django_ledger.views.mixins import (
     YearlyReportMixIn, QuarterlyReportMixIn,
     MonthlyReportMixIn, DjangoLedgerSecurityMixIn, DateReportMixIn, BaseDateNavigationUrlMixIn,
     EntityUnitMixIn)
 
 
-class LedgerModelListView(DjangoLedgerSecurityMixIn, ListView):
+class LedgerModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = LedgerModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('entity')
+        return super().get_queryset()
+
+
+class LedgerModelListView(DjangoLedgerSecurityMixIn, LedgerModelModelViewQuerySetMixIn, ListView):
     context_object_name = 'ledgers'
     template_name = 'django_ledger/ledger/ledger_list.html'
     PAGE_TITLE = _('Entity Ledgers')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
 
-    def get_queryset(self):
-        sort = self.request.GET.get('sort')
-        if not sort:
-            sort = '-updated'
-        entity_slug = self.kwargs.get('entity_slug')
-        return LedgerModel.objects.for_entity(
-            entity_slug=entity_slug,
-            user_model=self.request.user
-        ).order_by(sort)
-
 
-class LedgerModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class LedgerModelCreateView(DjangoLedgerSecurityMixIn, LedgerModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/ledger/ledger_create.html'
     PAGE_TITLE = _('Create Ledger')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE
     }
 
@@ -66,40 +68,32 @@
     def get_success_url(self):
         return reverse('django_ledger:ledger-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
 
-class LedgerModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
-    template_name = 'django_ledger/ledger/ledger_update.html'
+class LedgerModelUpdateView(DjangoLedgerSecurityMixIn, LedgerModelModelViewQuerySetMixIn, UpdateView):
     context_object_name = 'ledger'
-    slug_url_kwarg = 'ledger_pk'
-    slug_field = 'uuid'
+    pk_url_kwarg = 'ledger_pk'
+    template_name = 'django_ledger/ledger/ledger_update.html'
 
     def get_form(self, form_class=None):
         return LedgerModelUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
         context['page_title'] = _('Update Ledger: ') + self.object.name
         context['header_title'] = context['page_title']
         return context
 
-    def get_queryset(self):
-        entity_slug = self.kwargs['entity_slug']
-        return LedgerModel.objects.for_entity(
-            user_model=self.request.user,
-            entity_slug=entity_slug
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:ledger-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
 
@@ -112,35 +106,29 @@
             'entity_slug': self.kwargs['entity_slug'],
             'ledger_pk': self.kwargs['ledger_pk'],
             'year': year
         })
 
 
 class FiscalYearLedgerBalanceSheetView(DjangoLedgerSecurityMixIn,
+                                       LedgerModelModelViewQuerySetMixIn,
                                        BaseDateNavigationUrlMixIn,
                                        EntityUnitMixIn,
                                        YearlyReportMixIn,
                                        DetailView):
     context_object_name = 'ledger'
+    pk_url_kwarg = 'ledger_pk'
     template_name = 'django_ledger/financial_statements/balance_sheet.html'
-    slug_url_kwarg = 'ledger_pk'
-    slug_field = 'uuid'
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
         context['page_title'] = _('Ledger Balance Sheet: ') + self.object.name
         context['header_title'] = context['page_title']
         return context
 
-    def get_queryset(self):
-        entity_slug = self.kwargs['entity_slug']
-        return LedgerModel.objects.for_entity(
-            user_model=self.request.user,
-            entity_slug=entity_slug)
-
 
 class QuarterlyLedgerBalanceSheetView(QuarterlyReportMixIn, FiscalYearLedgerBalanceSheetView):
     """
     Quarter Balance Sheet View.
     """
 
 
@@ -166,35 +154,29 @@
                            'entity_slug': self.kwargs['entity_slug'],
                            'ledger_pk': self.kwargs['ledger_pk'],
                            'year': year
                        })
 
 
 class FiscalYearLedgerIncomeStatementView(DjangoLedgerSecurityMixIn,
+                                          LedgerModelModelViewQuerySetMixIn,
                                           BaseDateNavigationUrlMixIn,
                                           EntityUnitMixIn,
                                           YearlyReportMixIn,
                                           DetailView):
     context_object_name = 'ledger'
+    pk_url_kwarg = 'ledger_pk'
     template_name = 'django_ledger/financial_statements/income_statement.html'
-    slug_url_kwarg = 'ledger_pk'
-    slug_field = 'uuid'
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
         context['page_title'] = _('Ledger Income Statement: ') + self.object.name
         context['header_title'] = context['page_title']
         return context
 
-    def get_queryset(self):
-        entity_slug = self.kwargs['entity_slug']
-        return LedgerModel.objects.for_entity(
-            user_model=self.request.user,
-            entity_slug=entity_slug)
-
 
 class QuarterlyLedgerIncomeStatementView(QuarterlyReportMixIn, FiscalYearLedgerIncomeStatementView):
     """
     Quarterly Income Statement Quarter Report.
     """
 
 
@@ -204,7 +186,58 @@
     """
 
 
 class DateLedgerIncomeStatementView(DateReportMixIn, FiscalYearLedgerIncomeStatementView):
     """
     Date Income Statement Monthly Report.
     """
+
+
+# CASH FLOW STATEMENT ----
+class LedgerModelCashFlowStatementRedirectView(DjangoLedgerSecurityMixIn, RedirectView):
+
+    def get_redirect_url(self, *args, **kwargs):
+        year = localdate().year
+        return reverse('django_ledger:ledger-cf-year',
+                       kwargs={
+                           'entity_slug': self.kwargs['entity_slug'],
+                           'year': year
+                       })
+
+
+class FiscalYearLedgerModelCashFlowStatementView(DjangoLedgerSecurityMixIn,
+                                                 LedgerModelModelViewQuerySetMixIn,
+                                                 BaseDateNavigationUrlMixIn,
+                                                 EntityUnitMixIn,
+                                                 YearlyReportMixIn,
+                                                 DetailView):
+    """
+    Fiscal Year Cash Flow Statement View.
+    """
+
+    context_object_name = 'ledger'
+    pk_url_kwarg = 'ledger_pk'
+    template_name = 'django_ledger/financial_statements/cash_flow.html'
+
+    def get_context_data(self, **kwargs):
+        context = super().get_context_data(**kwargs)
+        context['page_title'] = _('Ledger Cash Flow Statement: ') + self.object.name
+        context['header_title'] = context['page_title']
+        return context
+
+
+class QuarterlyLedgerModelCashFlowStatementView(QuarterlyReportMixIn, FiscalYearLedgerModelCashFlowStatementView):
+    """
+    Quarter Cash Flow Statement View.
+    """
+
+
+class MonthlyLedgerModelCashFlowStatementView(MonthlyReportMixIn, FiscalYearLedgerModelCashFlowStatementView):
+    """
+    Monthly Cash Flow Statement View.
+    """
+
+
+class DateLedgerModelCashFlowStatementView(DateReportMixIn, FiscalYearLedgerModelCashFlowStatementView):
+    """
+    Date Cash Flow Statement View.
+    """
```

## django_ledger/views/mixins.py

```diff
@@ -318,15 +318,17 @@
 
 class DjangoLedgerPermissionMixIn(PermissionRequiredMixin):
 
     def has_permission(self):
         return self.request.user.is_authenticated
 
 
-class DjangoLedgerSecurityMixIn(DjangoLedgerPermissionMixIn, DjangoLedgerAccessMixIn, LoginRequiredMixin):
+class DjangoLedgerSecurityMixIn(DjangoLedgerPermissionMixIn,
+                                DjangoLedgerAccessMixIn,
+                                LoginRequiredMixin):
     pass
 
 
 class EntityUnitMixIn:
     UNIT_SLUG_KWARG = 'unit_slug'
     UNIT_SLUG_QUERY_PARAM = 'unit'
```

## django_ledger/views/purchase_order.py

```diff
@@ -19,58 +19,70 @@
                                                 DraftPurchaseOrderModelUpdateForm, ReviewPurchaseOrderModelUpdateForm,
                                                 ApprovedPurchaseOrderModelUpdateForm,
                                                 get_po_itemtxs_formset_class)
 from django_ledger.models import PurchaseOrderModel, ItemTransactionModel, EstimateModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
-class PurchaseOrderModelListView(DjangoLedgerSecurityMixIn, ArchiveIndexView):
+class PurchaseOrderModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = PurchaseOrderModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('entity', 'ce_model')
+        return super().get_queryset()
+
+
+class PurchaseOrderModelListView(DjangoLedgerSecurityMixIn,
+                                 PurchaseOrderModelModelViewQuerySetMixIn,
+                                 ArchiveIndexView):
     template_name = 'django_ledger/purchase_order/po_list.html'
     context_object_name = 'po_list'
     PAGE_TITLE = _('PO List')
     date_field = 'created'
     paginate_by = 10
     paginate_orphans = 2
     allow_empty = True
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'uil:bill'
     }
 
-    def get_queryset(self):
-        return PurchaseOrderModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).order_by('-created')
-
     def get_allow_future(self):
         allow_future = self.request.GET.get('allow_future')
         if allow_future:
             try:
                 allow_future = int(allow_future)
                 if allow_future in (0, 1):
                     return bool(allow_future)
             except ValueError:
                 pass
         return False
 
 
-class PurchaseOrderModelYearListView(YearArchiveView, PurchaseOrderModelListView):
+class PurchaseOrderModelYearListView(YearArchiveView,
+                                     PurchaseOrderModelListView):
     paginate_by = 10
     make_object_list = True
 
 
-class PurchaseOrderModelMonthListView(MonthArchiveView, PurchaseOrderModelListView):
+class PurchaseOrderModelMonthListView(MonthArchiveView,
+                                      PurchaseOrderModelListView):
     paginate_by = 10
     month_format = '%m'
     date_list_period = 'year'
 
 
-class PurchaseOrderModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class PurchaseOrderModelCreateView(DjangoLedgerSecurityMixIn,
+                                   PurchaseOrderModelModelViewQuerySetMixIn,
+                                   CreateView):
     template_name = 'django_ledger/purchase_order/po_create.html'
     PAGE_TITLE = _('Create Purchase Order')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'uil:bill'
     }
@@ -146,15 +158,17 @@
                            })
         return reverse('django_ledger:po-list',
                        kwargs={
                            'entity_slug': entity_slug
                        })
 
 
-class PurchaseOrderModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class PurchaseOrderModelUpdateView(DjangoLedgerSecurityMixIn,
+                                   PurchaseOrderModelModelViewQuerySetMixIn,
+                                   UpdateView):
     slug_url_kwarg = 'po_pk'
     slug_field = 'uuid'
     context_object_name = 'po_model'
     template_name = 'django_ledger/purchase_order/po_update.html'
     extra_context = {
         'header_subtitle_icon': 'uil:bill'
     }
@@ -296,20 +310,14 @@
         po_pk = self.kwargs['po_pk']
         return reverse('django_ledger:po-detail',
                        kwargs={
                            'entity_slug': entity_slug,
                            'po_pk': po_pk
                        })
 
-    def get_queryset(self):
-        return PurchaseOrderModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity', 'ce_model')
-
     def get_po_itemtxs_qs(self, po_model: PurchaseOrderModel):
         return po_model.itemtransactionmodel_set.select_related('bill_model', 'po_model').order_by('created')
 
     def form_valid(self, form: BasePurchaseOrderModelUpdateForm):
         po_model: PurchaseOrderModel = form.save(commit=False)
 
         if form.has_changed():
@@ -348,15 +356,17 @@
                              messages.SUCCESS,
                              f'{self.object.po_number} successfully updated.',
                              extra_tags='is-success')
 
         return super().form_valid(form)
 
 
-class PurchaseOrderModelDetailView(DjangoLedgerSecurityMixIn, DetailView):
+class PurchaseOrderModelDetailView(DjangoLedgerSecurityMixIn,
+                                   PurchaseOrderModelModelViewQuerySetMixIn,
+                                   DetailView):
     slug_url_kwarg = 'po_pk'
     slug_field = 'uuid'
     context_object_name = 'po_model'
     template_name = 'django_ledger/purchase_order/po_detail.html'
     extra_context = {
         'header_subtitle_icon': 'uil:bill',
         'hide_menu': True
@@ -367,30 +377,26 @@
         po_model: PurchaseOrderModel = self.object
         title = f'Purchase Order {po_model.po_number}'
         context['page_title'] = title
         context['header_title'] = title
 
         po_model: PurchaseOrderModel = self.object
         po_items_qs, item_data = po_model.get_itemtxs_data(
-            queryset=po_model.itemtransactionmodel_set.all().select_related('item_model')
+            queryset=po_model.itemtransactionmodel_set.all().select_related('item_model', 'bill_model')
         )
         context['po_items'] = po_items_qs
         context['po_total_amount'] = sum(
             i['po_total_amount'] for i in po_items_qs.values(
                 'po_total_amount', 'po_item_status') if i['po_item_status'] != 'cancelled')
         return context
 
-    def get_queryset(self):
-        return PurchaseOrderModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('ce_model', 'entity')
-
 
-class PurchaseOrderModelDeleteView(DjangoLedgerSecurityMixIn, DeleteView):
+class PurchaseOrderModelDeleteView(DjangoLedgerSecurityMixIn,
+                                   PurchaseOrderModelModelViewQuerySetMixIn,
+                                   DeleteView):
     slug_url_kwarg = 'po_pk'
     slug_field = 'uuid'
     context_object_name = 'po_model'
     template_name = 'django_ledger/purchase_order/po_delete.html'
     extra_context = {
         'hide_menu': True,
         'header_subtitle_icon': 'uil:bill'
@@ -399,27 +405,21 @@
     def get_context_data(self, *, object_list=None, **kwargs):
         context = super().get_context_data(object_list=object_list, **kwargs)
         po_model: PurchaseOrderModel = self.object
         context['page_title'] = _('Delete Purchase Order ') + po_model.po_number
         context['header_title'] = context['page_title']
         return context
 
-    def get_queryset(self):
-        return PurchaseOrderModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:entity-dashboard',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                        })
 
-    def delete(self, request, *args, **kwargs):
+    def form_valid(self, request, *args, **kwargs):
         po_model: PurchaseOrderModel = self.get_object()
         self.object = po_model
         po_items_qs = po_model.itemtransactionmodel_set.filter(bill_model__isnull=False)
         if po_items_qs.exists():
             messages.add_message(request,
                                  message=f'Cannot delete {po_model.po_number} because it has related bills.',
                                  level=messages.ERROR,
@@ -432,26 +432,23 @@
             return HttpResponseRedirect(url)
         success_url = self.get_success_url()
         self.object.delete()
         return HttpResponseRedirect(success_url)
 
 
 # ACTIONS...
-class BasePurchaseOrderActionActionView(DjangoLedgerSecurityMixIn, RedirectView, SingleObjectMixin):
+class BasePurchaseOrderActionActionView(DjangoLedgerSecurityMixIn,
+                                        PurchaseOrderModelModelViewQuerySetMixIn,
+                                        RedirectView,
+                                        SingleObjectMixin):
     http_method_names = ['get']
     pk_url_kwarg = 'po_pk'
     action_name = None
     commit = True
 
-    def get_queryset(self):
-        return PurchaseOrderModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_redirect_url(self, entity_slug, po_pk, *args, **kwargs):
         return reverse('django_ledger:po-update',
                        kwargs={
                            'entity_slug': entity_slug,
                            'po_pk': po_pk
                        })
```

## django_ledger/views/transactions.py

```diff
@@ -1,98 +1,7 @@
 """
 Django Ledger created by Miguel Sanda <msanda@arrobalytics.com>.
 Copyright EDMA Group Inc licensed under the GPLv3 Agreement.
 
 Contributions to this module:
 Miguel Sanda <msanda@arrobalytics.com>
 """
-
-from django.contrib import messages
-from django.http import HttpResponseForbidden
-from django.utils.translation import gettext_lazy as _
-from django.views.generic import DetailView
-
-from django_ledger.forms.transactions import get_transactionmodel_formset_class
-from django_ledger.models import JournalEntryModel
-from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
-
-
-class TXSJournalEntryView(DjangoLedgerSecurityMixIn, DetailView):
-    template_name = 'django_ledger/transaction/txs.html'
-    PAGE_TITLE = _('Edit Transactions')
-    pk_url_kwarg = 'je_pk'
-    extra_context = {
-        'header_title': PAGE_TITLE,
-        'page_title': PAGE_TITLE
-    }
-
-    def get_queryset(self):
-        return JournalEntryModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
-    def get_context_data(self, txs_formset=None, **kwargs):
-        context = super(TXSJournalEntryView, self).get_context_data(**kwargs)
-        je_model: JournalEntryModel = self.object
-        if je_model.locked:
-            messages.add_message(self.request,
-                                 message=_('Locked Journal Entry. Must unlock to Edit.'),
-                                 level=messages.WARNING,
-                                 extra_tags='is-warning')
-        if not txs_formset:
-            TransactionModelFormSet = get_transactionmodel_formset_class(journal_entry_model=je_model)
-            context['txs_formset'] = TransactionModelFormSet(
-                user_model=self.request.user,
-                je_model=je_model,
-                ledger_pk=self.kwargs['ledger_pk'],
-                entity_slug=self.kwargs['entity_slug'],
-                # queryset=self.get_queryset()
-            )
-        else:
-            context['txs_formset'] = txs_formset
-        return context
-
-    def post(self, request, **kwargs):
-
-        if not request.user.is_authenticated:
-            return HttpResponseForbidden()
-
-        je_model: JournalEntryModel = self.get_object()
-        self.object = je_model
-
-        TransactionModelFormSet = get_transactionmodel_formset_class(journal_entry_model=je_model)
-        txs_formset = TransactionModelFormSet(request.POST,
-                                              user_model=self.request.user,
-                                              ledger_pk=kwargs['ledger_pk'],
-                                              entity_slug=kwargs['entity_slug'],
-                                              je_model=je_model)
-
-        if je_model.locked:
-            messages.add_message(self.request,
-                                 message=_('Cannot update a Locked Journal Entry.'),
-                                 level=messages.ERROR,
-                                 extra_tags='is-danger')
-            return self.render_to_response(context=self.get_context_data(txs_formset=txs_formset))
-
-        if not je_model.posted:
-            messages.add_message(self.request,
-                                 message=_('Journal Entry has not been posted.'),
-                                 level=messages.INFO,
-                                 extra_tags='is-info')
-
-        if txs_formset.is_valid():
-            txs_list = txs_formset.save(commit=False)
-
-            for txs in txs_list:
-                if not txs.journal_entry_id:
-                    txs.journal_entry_id = je_model.uuid
-
-            txs_formset.save()
-            messages.add_message(request, messages.SUCCESS, 'Successfully saved transactions.', extra_tags='is-success')
-        else:
-            messages.add_message(request,
-                                 messages.ERROR,
-                                 'Hmmm, this doesn\'t add up!. Check your math!',
-                                 extra_tags='is-danger')
-            return self.render_to_response(context=self.get_context_data(txs_formset=txs_formset))
-        return self.render_to_response(context=self.get_context_data())
```

## django_ledger/views/unit.py

```diff
@@ -4,56 +4,55 @@
 from django.utils.timezone import localdate
 from django.utils.translation import gettext_lazy as _
 from django.views.generic import ListView, CreateView, UpdateView, DetailView, RedirectView
 
 from django_ledger.forms.unit import EntityUnitModelCreateForm, EntityUnitModelUpdateForm
 from django_ledger.models import EntityUnitModel, EntityModel
 from django_ledger.views.entity import (
-    FiscalYearEntityModelBalanceSheetView, FiscalYearEntityModelIncomeStatementView,
-    FiscalYearEntityModelCashFlowStatementView)
+    FiscalYearEntityModelIncomeStatementView)
 from django_ledger.views.mixins import (DjangoLedgerSecurityMixIn, QuarterlyReportMixIn, MonthlyReportMixIn,
-                                        DateReportMixIn)
+                                        DateReportMixIn, BaseDateNavigationUrlMixIn, EntityUnitMixIn, YearlyReportMixIn)
 
 
-class EntityUnitModelListView(DjangoLedgerSecurityMixIn, ListView):
+class EntityUnitModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = EntityUnitModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).select_related('entity')
+        return super().get_queryset()
+
+
+class EntityUnitModelListView(DjangoLedgerSecurityMixIn, EntityUnitModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/unit/unit_list.html'
     PAGE_TITLE = _('Entity Unit List')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         # 'header_subtitle_icon': 'dashicons:businesswoman'
     }
     context_object_name = 'unit_list'
 
-    def get_queryset(self):
-        return EntityUnitModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity')
-
 
-class EntityUnitModelDetailView(DjangoLedgerSecurityMixIn, DetailView):
+class EntityUnitModelDetailView(DjangoLedgerSecurityMixIn, EntityUnitModelModelViewQuerySetMixIn, DetailView):
     template_name = 'django_ledger/unit/unit_detail.html'
     PAGE_TITLE = _('Entity Unit Detail')
     slug_url_kwarg = 'unit_slug'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         # 'header_subtitle_icon': 'dashicons:businesswoman'
     }
     context_object_name = 'unit'
 
-    def get_queryset(self):
-        return EntityUnitModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity')
 
-
-class EntityUnitModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class EntityUnitModelCreateView(DjangoLedgerSecurityMixIn, EntityUnitModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/unit/unit_create.html'
     PAGE_TITLE = _('Entity Unit Create')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         # 'header_subtitle_icon': 'dashicons:businesswoman'
     }
@@ -69,38 +68,32 @@
         return reverse('django_ledger:unit-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def form_valid(self, form):
         entity_unit_model: EntityUnitModel = form.save(commit=False)
-        entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user )
+        entity_model_qs = EntityModel.objects.for_user(user_model=self.request.user)
         entity_model = get_object_or_404(entity_model_qs, slug__exact=self.kwargs['entity_slug'])
         entity_unit_model.entity = entity_model
         EntityUnitModel.add_root(instance=entity_unit_model)
         return HttpResponseRedirect(self.get_success_url())
 
 
-class EntityUnitUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class EntityUnitUpdateView(DjangoLedgerSecurityMixIn, EntityUnitModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/unit/unit_update.html'
     PAGE_TITLE = _('Entity Unit Update')
     slug_url_kwarg = 'unit_slug'
     context_object_name = 'unit'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         # 'header_subtitle_icon': 'dashicons:businesswoman'
     }
 
-    def get_queryset(self):
-        return EntityUnitModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity')
-
     def get_form(self, form_class=None):
         return EntityUnitModelUpdateForm(
             entity_slug=self.kwargs['entity_slug'],
             user_model=self.request.user,
             **self.get_form_kwargs()
         )
 
@@ -129,37 +122,33 @@
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'unit_slug': self.kwargs['unit_slug'],
                            'year': year
                        })
 
 
-class FiscalYearEntityUnitModelBalanceSheetView(FiscalYearEntityModelBalanceSheetView):
+class FiscalYearEntityUnitModelBalanceSheetView(DjangoLedgerSecurityMixIn,
+                                                EntityUnitModelModelViewQuerySetMixIn,
+                                                BaseDateNavigationUrlMixIn,
+                                                EntityUnitMixIn,
+                                                YearlyReportMixIn,
+                                                DetailView):
     """
     Entity Unit Fiscal Year Balance Sheet View Class
     """
 
     context_object_name = 'unit_model'
     slug_url_kwarg = 'unit_slug'
+    template_name = 'django_ledger/financial_statements/balance_sheet.html'
 
     def get_context_data(self, **kwargs):
         context = super().get_context_data(**kwargs)
         context['entity_model'] = self.object.entity
         return context
 
-    def get_queryset(self):
-        return EntityUnitModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).select_related('entity')
-
-    def get_fy_start_month(self) -> int:
-        entity_unit: EntityUnitModel = self.object
-        return entity_unit.entity.fy_start_month
-
 
 class QuarterlyEntityUnitModelBalanceSheetView(QuarterlyReportMixIn, FiscalYearEntityUnitModelBalanceSheetView):
     """
     Entity Unit Fiscal Quarter Balance Sheet View Class.
     """
 
 
@@ -184,18 +173,23 @@
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'unit_slug': self.kwargs['unit_slug'],
                            'year': year
                        })
 
 
-class FiscalYearEntityUnitModelIncomeStatementView(FiscalYearEntityModelIncomeStatementView):
-    """
-    Entity Unit Fiscal Quarter Income Statement View Class
-    """
+class FiscalYearEntityUnitModelIncomeStatementView(DjangoLedgerSecurityMixIn,
+                                                   EntityUnitModelModelViewQuerySetMixIn,
+                                                   BaseDateNavigationUrlMixIn,
+                                                   EntityUnitMixIn,
+                                                   YearlyReportMixIn,
+                                                   DetailView):
+    context_object_name = 'unit_model'
+    slug_url_kwarg = 'unit_slug'
+    template_name = 'django_ledger/financial_statements/income_statement.html'
 
 
 class QuarterlyEntityUnitModelIncomeStatementView(QuarterlyReportMixIn, FiscalYearEntityModelIncomeStatementView):
     """
     Entity Unit Fiscal Quarter Income Statement View Class
     """
 
@@ -221,18 +215,23 @@
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug'],
                            'unit_slug': self.kwargs['unit_slug'],
                            'year': year
                        })
 
 
-class FiscalYearEntityUnitModelCashFlowStatementView(FiscalYearEntityModelCashFlowStatementView):
-    """
-    Entity Unit Fiscal Quarter Cash Flow Statement View Class
-    """
+class FiscalYearEntityUnitModelCashFlowStatementView(DjangoLedgerSecurityMixIn,
+                                                     EntityUnitModelModelViewQuerySetMixIn,
+                                                     BaseDateNavigationUrlMixIn,
+                                                     EntityUnitMixIn,
+                                                     YearlyReportMixIn,
+                                                     DetailView):
+    context_object_name = 'unit_model'
+    slug_url_kwarg = 'unit_slug'
+    template_name = 'django_ledger/financial_statements/cash_flow.html'
 
 
 class QuarterlyEntityUnitModelCashFlowStatementView(QuarterlyReportMixIn,
                                                     FiscalYearEntityUnitModelCashFlowStatementView):
     """
     Entity Unit Fiscal Quarter Cash Flow Statement View Class
     """
```

## django_ledger/views/vendor.py

```diff
@@ -12,48 +12,48 @@
 
 from django_ledger.forms.vendor import VendorModelForm
 from django_ledger.models.entity import EntityModel
 from django_ledger.models.vendor import VendorModel
 from django_ledger.views.mixins import DjangoLedgerSecurityMixIn
 
 
-class VendorModelListView(DjangoLedgerSecurityMixIn, ListView):
+class VendorModelModelViewQuerySetMixIn:
+    queryset = None
+
+    def get_queryset(self):
+        if not self.queryset:
+            self.queryset = VendorModel.objects.for_entity(
+                entity_slug=self.kwargs['entity_slug'],
+                user_model=self.request.user
+            ).order_by('-updated')
+        return super().get_queryset()
+
+
+class VendorModelListView(DjangoLedgerSecurityMixIn, VendorModelModelViewQuerySetMixIn, ListView):
     template_name = 'django_ledger/vendor/vendor_list.html'
     context_object_name = 'vendors'
     PAGE_TITLE = _('Vendor List')
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'bi:person-lines-fill'
     }
 
-    def get_queryset(self):
-        return VendorModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        ).order_by('-updated')
 
-
-class VendorModelCreateView(DjangoLedgerSecurityMixIn, CreateView):
+class VendorModelCreateView(DjangoLedgerSecurityMixIn, VendorModelModelViewQuerySetMixIn, CreateView):
     template_name = 'django_ledger/vendor/vendor_create.html'
     PAGE_TITLE = _('Create New Vendor')
     form_class = VendorModelForm
     context_object_name = 'vendor'
     extra_context = {
         'page_title': PAGE_TITLE,
         'header_title': PAGE_TITLE,
         'header_subtitle_icon': 'bi:person-lines-fill'
     }
 
-    def get_queryset(self):
-        return VendorModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:vendor-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def form_valid(self, form):
@@ -62,15 +62,15 @@
             user_model=self.request.user
         )
         entity_model = get_object_or_404(klass=entity_model_qs, slug__exact=self.kwargs['entity_slug'])
         vendor_model.entity_model = entity_model
         return super().form_valid(form)
 
 
-class VendorModelUpdateView(DjangoLedgerSecurityMixIn, UpdateView):
+class VendorModelUpdateView(DjangoLedgerSecurityMixIn, VendorModelModelViewQuerySetMixIn, UpdateView):
     template_name = 'django_ledger/vendor/vendor_update.html'
     PAGE_TITLE = _('Vendor Update')
     context_object_name = 'vendor'
     form_class = VendorModelForm
 
     slug_url_kwarg = 'vendor_pk'
     slug_field = 'uuid'
@@ -80,20 +80,14 @@
         vendor_model: VendorModel = self.object
         context['page_title'] = self.PAGE_TITLE
         context['header_title'] = self.PAGE_TITLE
         context['header_subtitle'] = vendor_model.vendor_number
         context['header_subtitle_icon'] = 'bi:person-lines-fill'
         return context
 
-    def get_queryset(self):
-        return VendorModel.objects.for_entity(
-            entity_slug=self.kwargs['entity_slug'],
-            user_model=self.request.user
-        )
-
     def get_success_url(self):
         return reverse('django_ledger:vendor-list',
                        kwargs={
                            'entity_slug': self.kwargs['entity_slug']
                        })
 
     def form_valid(self, form):
```

## Comparing `django_ledger-0.5.2.9.dist-info/AUTHORS.md` & `django_ledger-0.5.3.0.dist-info/AUTHORS.md`

 * *Files identical despite different names*

## Comparing `django_ledger-0.5.2.9.dist-info/LICENSE` & `django_ledger-0.5.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `django_ledger-0.5.2.9.dist-info/METADATA` & `django_ledger-0.5.3.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: django-ledger
-Version: 0.5.2.9
+Version: 0.5.3.0
 Summary: Bookkeeping & Financial analysis backend for Django. Balance Sheet, Income Statements, Chart of Accounts, Entities
 Author-email: Miguel Sanda <msanda@arrobalytics.com>
 Maintainer-email: Miguel Sanda <msanda@arrobalytics.com>
 License: GPLv3 License
 Project-URL: Homepage, https://www.djangoledger.com
 Project-URL: Bug Tracker, https://github.com/arrobalytics/django-ledger/issues
 Project-URL: Documentation, https://django-ledger.readthedocs.io/en/latest/
@@ -17,54 +17,66 @@
 Classifier: Intended Audience :: Financial and Insurance Industry
 Classifier: Intended Audience :: End Users/Desktop
 Classifier: License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 License-File: AUTHORS.md
-Requires-Dist: django (==4.1.3)
-Requires-Dist: django-treebeard (==4.5.1)
-Requires-Dist: faker (==15.3.3)
-Requires-Dist: markdown (==3.4.1)
-Requires-Dist: ofxtools (==0.9.5)
-Requires-Dist: pillow (==9.3.0)
-Requires-Dist: text-unidecode (==1.3)
-Requires-Dist: python-dateutil (==2.8.2) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3"
-Requires-Dist: six (==1.16.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3"
-Requires-Dist: sqlparse (==0.4.3) ; python_version >= "3.5"
-Requires-Dist: asgiref (==3.5.2) ; python_version >= "3.7"
-Requires-Dist: tzdata (==2022.2) ; sys_platform == "win32"
+Requires-Dist: django (>=2.2)
+Requires-Dist: django-treebeard (>=4.5.1)
+Requires-Dist: faker (>=15.3.3)
+Requires-Dist: markdown (>=3.4.1)
+Requires-Dist: ofxtools (>=0.9.5)
+Requires-Dist: pillow (>=9.3.0)
+Requires-Dist: text-unidecode (>=1.3)
+Requires-Dist: python-dateutil (>=2.8.2) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3"
+Requires-Dist: six (>=1.16.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3"
+Requires-Dist: sqlparse (>=0.4.3) ; python_version >= "3.5"
+Requires-Dist: asgiref (>=3.5.2) ; python_version >= "3.7"
+Requires-Dist: tzdata (>=2022.2) ; sys_platform == "win32"
 Provides-Extra: dev
 Requires-Dist: sphinx (~=4.5.0) ; extra == 'dev'
 Requires-Dist: behave (~=1.2.6) ; extra == 'dev'
 Requires-Dist: pipenv-setup ; extra == 'dev'
 Requires-Dist: pylint ; extra == 'dev'
 Requires-Dist: furo ; extra == 'dev'
 
 ![django ledger logo](https://us-east-1.linodeobjects.com/django-ledger/logo/django-ledger-logo@2x.png)
 
 ### An Accounting, Bookkeeping & Financial Analysis Engine for the Django Framework.
 
-__Django Ledger__ is a double entry accounting system, which aims to power financially driven applications by removing
-the complexity of the accounting domain into a simple, high-level API.
+__Django Ledger__ is a double entry accounting system based on
+the [Django Web Framework](https://www.djangoproject.com),
+which aims to power financially driven applications by removing the complexity of the accounting domain into a simple,
+high-level API. _Prior experience with Django is required to more effectively use this software_. 
 
-Due to its complexity we cannot offer a stable release until all features on the
-[Roadmap](https://github.com/arrobalytics/django-ledger/blob/develop/ROADMAP.md) has been implemented and tested.
+__Django Ledger__ was created and is currently maintained and developed by lead developer Miguel Sanda.
+If you want to contribute please consider joining our new discord channel here.
+
+### Join our Discord Channel [Here](https://discord.gg/PEugR227)
+
+The software is still in early stages of development. For more information, please check the
+[Roadmap](https://github.com/arrobalytics/django-ledger/blob/develop/ROADMAP.md).
+
+### How long until all features are implemented?
 
-### Wait, not stable yet?...
 Finance and Accounting is a complicated subject. Django Ledger is different from other Django projects
 as it aims to provide a developer-friendly accounting engine while providing a reliable and extensible API to
 power financially driven applications. This project in particular, not only requires Python AND Django programming
-experience, but also finance and accounting experience. So, that's the long way of saying, this project is complex and
-models may require breaking changes as we move along.
+experience, but also finance and accounting experience. So, that's the long way of saying, we need your help!
+Join our Discord Channel [here](https://discord.gg/PEugR227) to learn more.
 
 __This project can greatly benefit from contributions towards Documentation and Unit Tests.__
+__This is the best way to get started twith this project if you are not familiar with the models.__
 
 ### Documentation
-Access the latest documentation [here](https://django-ledger.readthedocs.io/en/latest/).
+
+Access the latest documentation and QuickStart guide [here](https://django-ledger.readthedocs.io/en/latest/).
+Also, you may download the QuickStart Jupyter Notebook
+[here](https://github.com/arrobalytics/django-ledger/blob/develop/notebooks/QuickStart%20Notebook.ipynb).
 
 Django Ledger supports:
 
 - Double entry accounting.
 - Hierarchical Chart of Accounts.
 - Financial Statements (Income Statement, Balance Sheet & Cash Flow Statement).
 - Purchase Orders, Sales Orders (Estimates), Bills and Invoices.
@@ -76,20 +88,15 @@
 - Bills & Invoices with optional cash/accrual functionality.
 - Basic navigational templates.
 - Entity administration & entity manager support.
 - Items, lists & inventory management.
 - Unit of Measures.
 - Bank Accounts.
 
-__WARNING__: Currently this project is under active development, it is not stable and is not recommended for production
-environments. Due to its high complexity, breaking changes may occur in future releases and migration backwards
-compatibility may not be preserved until the first __stable__ release. The author is actively working to provide a
-stable release as soon as possible and to incorporate the following functionality:
-
-# Roadmap to Version 1.0 Stable
+# Roadmap to Version 1.0.
 
 ### ~~Version 0.4~~ *completed*
 
 * __0.4.0__: Items, resources and & lists for bills & invoices itemization:
 * __0.4.0__: Enhance and optimize Django Ledger the random data generation functionality to properly populate relevant
   random data for testing.
 * __0.4.1__: Entity internal organizations, department, branches, etc.
@@ -104,22 +111,24 @@
 
 * __0.5.0__: Inventory tracking.
     * Average Cost.
 * __0.5.1__: Customer estimates & contract tracking.
     * Link Estimate/PO/Bill/Invoice workflow.
     * Journal Entry activity determination & validation (for cash flow).
 * __0.5.2__: Cash flow statement.
-  * Human Readable Journal Entry document numbers.
-  * Generate all Django Ledger Model documentation.
+    * Human Readable Journal Entry document numbers.
+    * Hierarchical Account Model Management.
+    * Generate all Django Ledger Model documentation.
 * __0.5.3__: Closing entries, snapshots & trial balance import.
-  * Chart of Accounts Import.
-  * Trial Balance Import.
-  * Closing entries and snapshots.
-  * Balance Sheet Statement, Income Statement & Cash Flow Statement API & PDF report export.
-  * GraphQL API.
+    * __0.5.3.0__: High Level EntityModel API.
+    * __0.5.3.1__: Balance Sheet Statement, Income Statement & Cash Flow Statement API & PDF report export.
+    * __0.5.3.2__: Closing entries and snapshots.
+    * __0.5.3.3__: Chart of Accounts Import.
+    * __0.5.3.4__: Trial Balance Import.
+    * __0.5.3.5__: GraphQL API.
 * __0.5.4__: Testing framework implementation that will include:
     * Unit tests using the [Built-in Django](https://docs.djangoproject.com/en/3.1/topics/testing/) unit test modules.
     * Behavioral Driven Testing using [behave](https://behave.readthedocs.io/en/latest/) library.
     * __Need help!!!! If you want to contribute PLEASE ADD UNIT TESTS!!!__
 * Start creating basic package documentation via [Sphinx](https://www.sphinx-doc.org/en/master/)
     * Document code and functions within code base.
     * Generate HTML documentation.
@@ -142,24 +151,22 @@
 * Produce financial statements in different currencies.
 * Update package and code documentation.
 * Bugfixes & UI/UX Enhancements.
 
 ### Version 0.8
 
 * User roles and permissions on views to support read/write permissions for assigned managers to entities.
-* Customer jobs & job tracking.
-* Client proposals & estimates.
 * User preferences and settings & account creation views.
 * Update package and code documentation.
 
 ### Version 0.9
 
-* Enable Hierarchical Entity structures via MPTT.
+* Enable Hierarchical Entity structures via TreeBeard.
 * Consolidated financial statements.
-* Intercompany transactions.
+* InterCompany transactions.
 * Update package and code documentation.
 
 ### Version 1.0
 
 * Complete Internationalization of all user-related fields.
 
 *** Roadmap subject to change based on user feedback and backlog priorities.
@@ -173,15 +180,15 @@
 # Contrib Packages
 
 * GraphQL API - See
   details [here.](https://github.com/arrobalytics/django-ledger/tree/develop/django_ledger/contrib/django_ledger_graphql)
 
 ## Quick Start
 
-Django Ledger comes with a default CoA ready to use or you could use your own. Make sure to select the appropriate
+Django Ledger comes with a default CoA ready to use, or you could use your own. Make sure to select the appropriate
 option when creating new entities.
 
 * Install Django Ledger
 
 ```shell script
 pip install django-ledger
 ```
```

