# Comparing `tmp/fudgeo-0.4.0-py3-none-any.whl.zip` & `tmp/fudgeo-0.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 24813 bytes, number of entries: 17
--rw-r--r--  2.0 unx      117 b- defN 23-May-06 22:44 fudgeo/__init__.py
--rw-r--r--  2.0 unx     2538 b- defN 23-May-06 22:16 fudgeo/constant.py
+Zip file size: 26635 bytes, number of entries: 17
+-rw-r--r--  2.0 unx      117 b- defN 23-May-08 18:27 fudgeo/__init__.py
+-rw-r--r--  2.0 unx     2538 b- defN 23-May-06 22:48 fudgeo/constant.py
 -rw-r--r--  2.0 unx     1157 b- defN 23-Jan-04 21:53 fudgeo/enumeration.py
--rw-r--r--  2.0 unx    20081 b- defN 23-May-06 13:55 fudgeo/geopkg.py
--rw-r--r--  2.0 unx     2673 b- defN 23-May-06 13:55 fudgeo/geopkg.sql
--rw-r--r--  2.0 unx     7768 b- defN 23-May-06 13:55 fudgeo/sql.py
--rw-r--r--  2.0 unx      974 b- defN 23-May-06 22:16 fudgeo/geometry/__init__.py
--rw-r--r--  2.0 unx     3244 b- defN 23-May-06 22:31 fudgeo/geometry/base.py
--rw-r--r--  2.0 unx    14233 b- defN 23-May-06 22:16 fudgeo/geometry/linestring.py
--rw-r--r--  2.0 unx    16511 b- defN 23-May-06 22:16 fudgeo/geometry/point.py
--rw-r--r--  2.0 unx    18766 b- defN 23-May-06 22:16 fudgeo/geometry/polygon.py
--rw-r--r--  2.0 unx     6508 b- defN 23-May-06 22:16 fudgeo/geometry/util.py
--rw-r--r--  2.0 unx     1088 b- defN 23-May-06 22:44 fudgeo-0.4.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     9095 b- defN 23-May-06 22:44 fudgeo-0.4.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-06 22:44 fudgeo-0.4.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 23-May-06 22:44 fudgeo-0.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1321 b- defN 23-May-06 22:44 fudgeo-0.4.0.dist-info/RECORD
-17 files, 106173 bytes uncompressed, 22681 bytes compressed:  78.6%
+-rw-r--r--  2.0 unx    20081 b- defN 23-May-06 22:48 fudgeo/geopkg.py
+-rw-r--r--  2.0 unx     2673 b- defN 23-May-06 22:48 fudgeo/geopkg.sql
+-rw-r--r--  2.0 unx     7768 b- defN 23-May-06 22:48 fudgeo/sql.py
+-rw-r--r--  2.0 unx      974 b- defN 23-May-06 22:48 fudgeo/geometry/__init__.py
+-rw-r--r--  2.0 unx     3250 b- defN 23-May-08 18:26 fudgeo/geometry/base.py
+-rw-r--r--  2.0 unx    16963 b- defN 23-May-08 18:26 fudgeo/geometry/linestring.py
+-rw-r--r--  2.0 unx    17903 b- defN 23-May-08 18:26 fudgeo/geometry/point.py
+-rw-r--r--  2.0 unx    22719 b- defN 23-May-08 18:26 fudgeo/geometry/polygon.py
+-rw-r--r--  2.0 unx    14620 b- defN 23-May-08 18:26 fudgeo/geometry/util.py
+-rw-r--r--  2.0 unx     1088 b- defN 23-May-08 18:29 fudgeo-0.4.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9095 b- defN 23-May-08 18:29 fudgeo-0.4.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-08 18:29 fudgeo-0.4.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-May-08 18:29 fudgeo-0.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1322 b- defN 23-May-08 18:29 fudgeo-0.4.1.dist-info/RECORD
+17 files, 122367 bytes uncompressed, 24503 bytes compressed:  80.0%
```

## zipnote {}

```diff
@@ -30,23 +30,23 @@
 
 Filename: fudgeo/geometry/polygon.py
 Comment: 
 
 Filename: fudgeo/geometry/util.py
 Comment: 
 
-Filename: fudgeo-0.4.0.dist-info/LICENSE
+Filename: fudgeo-0.4.1.dist-info/LICENSE
 Comment: 
 
-Filename: fudgeo-0.4.0.dist-info/METADATA
+Filename: fudgeo-0.4.1.dist-info/METADATA
 Comment: 
 
-Filename: fudgeo-0.4.0.dist-info/WHEEL
+Filename: fudgeo-0.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: fudgeo-0.4.0.dist-info/top_level.txt
+Filename: fudgeo-0.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: fudgeo-0.4.0.dist-info/RECORD
+Filename: fudgeo-0.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fudgeo/__init__.py

```diff
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
 """
 Package Initialization
 """
 
 
-__version__ = '0.4.0'
+__version__ = '0.4.1'
 
 
 if __name__ == '__main__':
     pass
```

## fudgeo/geometry/base.py

```diff
@@ -75,19 +75,20 @@
         Initialize the AbstractSpatialGeometryEnvelope class
         """
         super().__init__(srs_id=srs_id)
         self._envelope: Envelope = EMPTY_ENVELOPE
     # End init built-in
 
     @property
+    @abstractmethod
     def envelope(self) -> Envelope:
         """
         Envelope
         """
-        return self._envelope
+        pass
     # End envelope property
 # End AbstractSpatialGeometryEnvelope class
 
 
 class AbstractGeopackageGeometry(AbstractSpatialGeometry):
     """
     Abstract Geopackage Geometry
@@ -125,18 +126,19 @@
         Initialize the AbstractGeopackageGeometryEnvelope class
         """
         super().__init__(srs_id=srs_id)
         self._envelope: Envelope = EMPTY_ENVELOPE
     # End init built-in
 
     @property
+    @abstractmethod
     def envelope(self) -> Envelope:
         """
         Envelope
         """
-        return self._envelope
+        pass
     # End envelope property
 # End AbstractGeopackageGeometryEnvelope class
 
 
 if __name__ == '__main__':  # pragma: no cover
     pass
```

## fudgeo/geometry/linestring.py

```diff
@@ -11,15 +11,20 @@
     COUNT_CODE, DOUBLE, FOUR_D, HEADER_OFFSET, QUADRUPLE, THREE_D, TRIPLE,
     TWO_D, WKB_LINESTRING_M_PRE, WKB_LINESTRING_PRE, WKB_LINESTRING_ZM_PRE,
     WKB_LINESTRING_Z_PRE, WKB_MULTI_LINESTRING_M_PRE, WKB_MULTI_LINESTRING_PRE,
     WKB_MULTI_LINESTRING_ZM_PRE, WKB_MULTI_LINESTRING_Z_PRE)
 from fudgeo.geometry.base import AbstractGeopackageGeometryEnvelope
 from fudgeo.geometry.point import Point, PointM, PointZ, PointZM
 from fudgeo.geometry.util import (
-    pack_coordinates, unpack_envelope, unpack_header, unpack_line, unpack_lines)
+    EMPTY_ENVELOPE, Envelope, envelope_from_coordinates,
+    envelope_from_coordinates_m, envelope_from_coordinates_z,
+    envelope_from_coordinates_zm, envelope_from_geometries,
+    envelope_from_geometries_m, envelope_from_geometries_z,
+    envelope_from_geometries_zm, pack_coordinates, unpack_envelope,
+    unpack_header, unpack_line, unpack_lines)
 
 
 LINE_STRING_TYPES = Union[Type['LineString'], Type['LineStringZ'],
                           Type['LineStringM'], Type['LineStringZM']]
 MULTI_LINE_STRING_TYPES = Union[
     Type['MultiLineString'], Type['MultiLineStringZ'],
     Type['MultiLineStringM'], Type['MultiLineStringZM']]
@@ -93,14 +98,26 @@
         """
         Points
         """
         srs_id = self.srs_id
         return [Point(x=x, y=y, srs_id=srs_id) for x, y in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_LINESTRING_PRE + pack_coordinates(self.coordinates)
     # End _to_wkb method
 
@@ -153,14 +170,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointZ(x=x, y=y, z=z, srs_id=srs_id)
                 for x, y, z in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_z(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_LINESTRING_Z_PRE + pack_coordinates(
             self.coordinates, has_z=True)
     # End _to_wkb method
@@ -214,14 +243,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointM(x=x, y=y, m=m, srs_id=srs_id)
                 for x, y, m in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_m(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_LINESTRING_M_PRE + pack_coordinates(
             self.coordinates, has_m=True)
     # End _to_wkb method
@@ -275,14 +316,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointZM(x=x, y=y, z=z, m=m, srs_id=srs_id)
                 for x, y, z, m in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_zm(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_LINESTRING_ZM_PRE + pack_coordinates(
             self.coordinates, has_z=True, has_m=True)
     # End _to_wkb method
@@ -336,14 +389,26 @@
         To WKB
         """
         geoms = self.lines
         return (WKB_MULTI_LINESTRING_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
     # End _to_wkb method
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries(self.lines)
+        self._envelope = env
+        return env
+    # End envelope property
+
     @classmethod
     def from_gpkg(cls, value: bytes) -> 'MultiLineString':
         """
         From Geopackage
         """
         return _unpack_multi_linestring(cls=cls, value=value, dimension=TWO_D)
     # End from_gpkg method
@@ -380,14 +445,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.lines)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_z(self.lines)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.lines
         return (WKB_MULTI_LINESTRING_Z_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -433,14 +510,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.lines)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_m(self.lines)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.lines
         return (WKB_MULTI_LINESTRING_M_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -486,14 +575,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.lines)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_zm(self.lines)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.lines
         return (WKB_MULTI_LINESTRING_ZM_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
```

## fudgeo/geometry/point.py

```diff
@@ -13,15 +13,17 @@
     QUADRUPLE, THREE_D, THREE_D_PACK_CODE, THREE_D_UNPACK_CODE, TRIPLE, TWO_D,
     TWO_D_PACK_CODE, TWO_D_UNPACK_CODE, WKB_MULTI_POINT_M_PRE,
     WKB_MULTI_POINT_PRE, WKB_MULTI_POINT_ZM_PRE, WKB_MULTI_POINT_Z_PRE,
     WKB_POINT_M_PRE, WKB_POINT_PRE, WKB_POINT_ZM_PRE, WKB_POINT_Z_PRE)
 from fudgeo.geometry.base import (
     AbstractGeopackageGeometry, AbstractGeopackageGeometryEnvelope)
 from fudgeo.geometry.util import (
-    pack_coordinates, unpack_envelope,
+    EMPTY_ENVELOPE, Envelope, envelope_from_coordinates,
+    envelope_from_coordinates_m, envelope_from_coordinates_z,
+    envelope_from_coordinates_zm, pack_coordinates, unpack_envelope,
     unpack_header, unpack_points)
 
 
 MULTI_POINT_TYPES = Union[Type['MultiPoint'], Type['MultiPointZ'],
                           Type['MultiPointM'], Type['MultiPointZM']]
 
 
@@ -413,14 +415,26 @@
         """
         Points
         """
         srs_id = self.srs_id
         return [Point(x=x, y=y, srs_id=srs_id) for x, y in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_MULTI_POINT_PRE + pack_coordinates(
             self.coordinates, use_prefix=True)
     # End _to_wkb method
@@ -474,14 +488,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointZ(x=x, y=y, z=z, srs_id=srs_id)
                 for x, y, z in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_z(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_MULTI_POINT_Z_PRE + pack_coordinates(
             self.coordinates, has_z=True, use_prefix=True)
     # End _to_wkb method
@@ -535,14 +561,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointM(x=x, y=y, m=m, srs_id=srs_id)
                 for x, y, m in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_m(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_MULTI_POINT_M_PRE + pack_coordinates(
             self.coordinates, has_m=True, use_prefix=True)
     # End _to_wkb method
@@ -596,14 +634,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointZM(x=x, y=y, z=z, m=m, srs_id=srs_id)
                 for x, y, z, m in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_zm(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return WKB_MULTI_POINT_ZM_PRE + pack_coordinates(
             self.coordinates, has_z=True, has_m=True, use_prefix=True)
     # End _to_wkb method
```

## fudgeo/geometry/polygon.py

```diff
@@ -12,16 +12,20 @@
     TWO_D, WKB_MULTI_POLYGON_M_PRE, WKB_MULTI_POLYGON_PRE,
     WKB_MULTI_POLYGON_ZM_PRE, WKB_MULTI_POLYGON_Z_PRE, WKB_POLYGON_M_PRE,
     WKB_POLYGON_PRE, WKB_POLYGON_ZM_PRE, WKB_POLYGON_Z_PRE)
 from fudgeo.geometry.base import (
     AbstractGeopackageGeometryEnvelope, AbstractSpatialGeometryEnvelope)
 from fudgeo.geometry.point import Point, PointM, PointZ, PointZM
 from fudgeo.geometry.util import (
-    pack_coordinates, unpack_envelope, unpack_header, unpack_lines,
-    unpack_polygons)
+    EMPTY_ENVELOPE, Envelope, envelope_from_coordinates,
+    envelope_from_coordinates_m, envelope_from_coordinates_z,
+    envelope_from_coordinates_zm, envelope_from_geometries,
+    envelope_from_geometries_m, envelope_from_geometries_z,
+    envelope_from_geometries_zm, pack_coordinates, unpack_envelope,
+    unpack_header, unpack_lines, unpack_polygons)
 
 
 POLYGON_TYPES = Union[Type['Polygon'], Type['PolygonZ'],
                       Type['PolygonM'], Type['PolygonZM']]
 MULTI_POLYGON_TYPES = Union[Type['MultiPolygon'], Type['MultiPolygonZ'],
                             Type['MultiPolygonM'], Type['MultiPolygonZM']]
 
@@ -95,14 +99,26 @@
         """
         Points
         """
         srs_id = self.srs_id
         return [Point(x=x, y=y, srs_id=srs_id) for x, y in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return pack_coordinates(self.coordinates)
     # End _to_wkb method
 # End LinearRing class
@@ -153,14 +169,26 @@
 
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return pack_coordinates(self.coordinates, has_z=True)
     # End _to_wkb method
+
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_z(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
 # End LinearRingZ class
 
 
 class LinearRingM(AbstractSpatialGeometryEnvelope):
     """
     Linear Ring M
     """
@@ -199,14 +227,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointM(x=x, y=y, m=m, srs_id=srs_id)
                 for x, y, m in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_m(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return pack_coordinates(self.coordinates, has_m=True)
     # End _to_wkb method
 # End LinearRingM class
@@ -249,14 +289,26 @@
         Points
         """
         srs_id = self.srs_id
         return [PointZM(x=x, y=y, z=z, m=m, srs_id=srs_id)
                 for x, y, z, m in self.coordinates]
     # End points property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_coordinates_zm(self.coordinates)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         return pack_coordinates(self.coordinates, has_z=True, has_m=True)
     # End _to_wkb method
 # End LinearRingZM class
@@ -292,14 +344,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.rings)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries(self.rings)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.rings
         return (WKB_POLYGON_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -345,14 +409,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.rings)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_z(self.rings)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.rings
         return (WKB_POLYGON_Z_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -398,14 +474,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.rings)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_m(self.rings)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.rings
         return (WKB_POLYGON_M_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -451,14 +539,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.rings)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_zm(self.rings)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.rings
         return (WKB_POLYGON_ZM_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -505,14 +605,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.polygons)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries(self.polygons)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.polygons
         return (WKB_MULTI_POLYGON_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -559,14 +671,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.polygons)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_z(self.polygons)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.polygons
         return (WKB_MULTI_POLYGON_Z_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -613,14 +737,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.polygons)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_m(self.polygons)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.polygons
         return (WKB_MULTI_POLYGON_M_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
@@ -667,14 +803,26 @@
     def is_empty(self) -> bool:
         """
         Is Empty
         """
         return not len(self.polygons)
     # End is_empty property
 
+    @property
+    def envelope(self) -> Envelope:
+        """
+        Envelope
+        """
+        if self._envelope is not EMPTY_ENVELOPE:
+            return self._envelope
+        env = envelope_from_geometries_zm(self.polygons)
+        self._envelope = env
+        return env
+    # End envelope property
+
     def _to_wkb(self, use_prefix: bool = True) -> bytes:
         """
         To WKB
         """
         geoms = self.polygons
         return (WKB_MULTI_POLYGON_ZM_PRE + pack(COUNT_CODE, len(geoms)) +
                 self._join_geometries(geoms))
```

## fudgeo/geometry/util.py

```diff
@@ -1,56 +1,184 @@
 # -*- coding: utf-8 -*-
 """
 Utility Functions
 """
 
 
 from functools import lru_cache, reduce
-from math import nan
+from math import isfinite, nan
 from operator import add
-from struct import pack, unpack
-from typing import List, Tuple
+# noinspection PyPep8Naming
+from struct import error as StructError, pack, unpack
+from typing import List, TYPE_CHECKING, Tuple, Union
 
 from fudgeo.constant import (
-    COORDINATES, COUNT_CODE, EMPTY, ENVELOPE_COUNT, ENVELOPE_OFFSET, GP_MAGIC,
-    HEADER_CODE,
-    HEADER_OFFSET, POINT_PREFIX, TWO_D)
+    COORDINATES, COUNT_CODE, DOUBLE, EMPTY, ENVELOPE_COUNT, ENVELOPE_OFFSET,
+    GP_MAGIC, HEADER_CODE, HEADER_OFFSET, POINT_PREFIX, QUADRUPLE, TRIPLE,
+    TWO_D)
+
+
+if TYPE_CHECKING:  # pragma: no cover
+    # noinspection PyUnresolvedReferences
+    from fudgeo.geometry.linestring import (
+        LineString, LineStringZ, LineStringM, LineStringZM)
+    # noinspection PyUnresolvedReferences
+    from fudgeo.geometry.polygon import (
+        LinearRing, LinearRingZ, LinearRingM, LinearRingZM,
+        Polygon, PolygonZ, PolygonM, PolygonZM)
+
+
+GEOMS = Union[List['LineString'], List['LinearRing'], List['Polygon']]
+GEOMS_Z = Union[List['LineStringZ'], List['LinearRingZ'], List['PolygonZ']]
+GEOMS_M = Union[List['LineStringM'], List['LinearRingM'], List['PolygonM']]
+GEOMS_ZM = Union[List['LineStringZM'], List['LinearRingZM'], List['PolygonZM']]
+VALUES = List[float]
 
 
 class Envelope:
     """
     Envelope
     """
-    __slots__ = ['min_x', 'max_x', 'min_y', 'max_y',
-                 'min_z', 'max_z', 'min_m', 'max_m']
+    __slots__ = ['_code', '_min_x', '_max_x', '_min_y', '_max_y',
+                 '_min_z', '_max_z', '_min_m', '_max_m']
 
-    def __init__(self, min_x: float, max_x: float, min_y: float, max_y: float,
+    def __init__(self, code: int, min_x: float, max_x: float,
+                 min_y: float, max_y: float,
                  min_z: float = nan, max_z: float = nan,
                  min_m: float = nan, max_m: float = nan) -> None:
         """
         Initialize the Envelope class
         """
         super().__init__()
-        self.min_x: float = min_x
-        self.max_x: float = max_x
-        self.min_y: float = min_y
-        self.max_y: float = max_y
-        self.min_z: float = min_z
-        self.max_z: float = max_z
-        self.min_m: float = min_m
-        self.max_m: float = max_m
+        self._code: int = code
+        self._min_x: float = min_x
+        self._max_x: float = max_x
+        self._min_y: float = min_y
+        self._max_y: float = max_y
+        self._min_z: float = min_z
+        self._max_z: float = max_z
+        self._min_m: float = min_m
+        self._max_m: float = max_m
     # End init built-in
+
+    def __repr__(self) -> str:
+        """
+        String Representation
+        """
+        x = f'min_x={self.min_x}, max_x={self.max_x}'
+        y = f'min_y={self.min_y}, max_y={self.max_y}'
+        z = f'min_z={self.min_z}, max_z={self.max_z}'
+        m = f'min_m={self.min_m}, max_m={self.max_m}'
+        return f'Envelope(code={self.code}, {x}, {y}, {z}, {m})'
+    # End repr built-in
+
+    def __eq__(self, other: 'Envelope') -> bool:
+        """
+        Equality
+        """
+        if not isinstance(other, Envelope):
+            return NotImplemented
+        code = self.code
+        if code != other.code:
+            return False
+        if not code:
+            return True
+        same_x = self.min_x == other.min_x and self.max_x == other.max_x
+        same_y = self.min_y == other.min_y and self.max_y == other.max_y
+        same_xy = same_x and same_y
+        if not same_xy or code == 1:
+            return same_xy
+        same_z = self.min_z == other.min_z and self.max_z == other.max_z
+        if code == 2:
+            return same_z
+        same_m = self.min_m == other.min_m and self.max_m == other.max_m
+        if code == 3:
+            return same_m
+        return same_m and same_z
+    # End eq built-in
+
+    @property
+    def code(self) -> int:
+        """
+        Envelope Code
+        """
+        return self._code
+    # End code property
+
+    @property
+    def min_x(self) -> float:
+        """
+        Min X
+        """
+        return self._min_x
+    # End min_x property
+
+    @property
+    def max_x(self) -> float:
+        """
+        Max X
+        """
+        return self._max_x
+    # End max_x property
+
+    @property
+    def min_y(self) -> float:
+        """
+        Min Y
+        """
+        return self._min_y
+    # End min_y property
+
+    @property
+    def max_y(self) -> float:
+        """
+        Max Y
+        """
+        return self._max_y
+    # End max_y property
+
+    @property
+    def min_z(self) -> float:
+        """
+        Min Z
+        """
+        return self._min_z
+    # End min_z property
+
+    @property
+    def max_z(self) -> float:
+        """
+        Max Z
+        """
+        return self._max_z
+    # End max_z property
+
+    @property
+    def min_m(self) -> float:
+        """
+        Min M
+        """
+        return self._min_m
+    # End min_m property
+
+    @property
+    def max_m(self) -> float:
+        """
+        Max M
+        """
+        return self._max_m
+    # End max_m property
 # End Envelope class
 
 
-EMPTY_ENVELOPE = Envelope(min_x=nan, max_x=nan, min_y=nan, max_y=nan)
+EMPTY_ENVELOPE = Envelope(code=0, min_x=nan, max_x=nan, min_y=nan, max_y=nan)
 
 
 def unpack_line(value: bytes, dimension: int,
-                 is_ring: bool = False) -> List[Tuple[float, ...]]:
+                is_ring: bool = False) -> List[Tuple[float, ...]]:
     """
     Unpack Values for LineString
     """
     count, data = get_count_and_data(value, is_ring=is_ring)
     total = dimension * count
     values: Tuple[float, ...] = unpack(f'<{total}d', data)
     return [values[i:i + dimension] for i in range(0, total, dimension)]
@@ -179,24 +307,196 @@
     3: envelope is [minx, maxx, miny, maxy, minm, maxm], 48 bytes
     4: envelope is [minx, maxx, miny, maxy, minz, maxz, minm, maxm], 64 bytes
     """
     if not code:
         return EMPTY_ENVELOPE
     if code not in ENVELOPE_COUNT:
         return EMPTY_ENVELOPE
-    values = unpack(f'<{ENVELOPE_COUNT[code]}d', value[HEADER_OFFSET:])
+    try:
+        values = unpack(f'<{ENVELOPE_COUNT[code]}d', value[HEADER_OFFSET:])
+    except StructError:
+        return EMPTY_ENVELOPE
     min_x = max_x = min_y = max_y = min_z = max_z = min_m = max_m = nan
     if code == 1:
         min_x, max_x, min_y, max_y = values
     elif code == 2:
         min_x, max_x, min_y, max_y, min_z, max_z = values
     elif code == 3:
         min_x, max_x, min_y, max_y, min_m, max_m = values
     elif code == 4:
         min_x, max_x, min_y, max_y, min_z, max_z, min_m, max_m = values
-    return Envelope(min_x=min_x, max_x=max_x, min_y=min_y, max_y=max_y,
-                    min_z=min_z, max_z=max_z, min_m=min_m, max_m=max_m)
+    return Envelope(
+        code=code, min_x=min_x, max_x=max_x, min_y=min_y, max_y=max_y,
+        min_z=min_z, max_z=max_z, min_m=min_m, max_m=max_m)
 # End unpack_envelope function
 
 
+def _min_max(values: Union[VALUES, Tuple[float, ...]]) \
+        -> Tuple[float, float]:
+    """
+    Min and Max values, returns nan's if empty list or no finite values.
+    """
+    if not values:
+        return nan, nan
+    values = [v for v in values if isfinite(v)]
+    if not values:
+        return nan, nan
+    return min(values), max(values)
+# End _min_max function
+
+
+def envelope_from_geometries(geoms: GEOMS) -> Envelope:
+    """
+    Envelope from Geometries
+    """
+    if not geoms:
+        return EMPTY_ENVELOPE
+    xs, ys = [], []
+    for geom in geoms:
+        env = geom.envelope
+        xs.extend((env.min_x, env.max_x))
+        ys.extend((env.min_y, env.max_y))
+    return _envelope_xy(xs=xs, ys=ys)
+# End envelope_from_geometries function
+
+
+def envelope_from_geometries_z(geoms: GEOMS_Z) -> Envelope:
+    """
+    Envelope from Geometries with Z
+    """
+    if not geoms:
+        return EMPTY_ENVELOPE
+    xs, ys, zs = [], [], []
+    for geom in geoms:
+        env = geom.envelope
+        xs.extend((env.min_x, env.max_x))
+        ys.extend((env.min_y, env.max_y))
+        zs.extend((env.min_z, env.max_z))
+    return _envelope_xyz(xs=xs, ys=ys, zs=zs)
+# End envelope_from_geometries_z function
+
+
+def envelope_from_geometries_m(geoms: GEOMS_M) -> Envelope:
+    """
+    Envelope from Geometries with M
+    """
+    if not geoms:
+        return EMPTY_ENVELOPE
+    xs, ys, ms = [], [], []
+    for geom in geoms:
+        env = geom.envelope
+        xs.extend((env.min_x, env.max_x))
+        ys.extend((env.min_y, env.max_y))
+        ms.extend((env.min_m, env.max_m))
+    return _envelope_xym(xs=xs, ys=ys, ms=ms)
+# End envelope_from_geometries_m function
+
+
+def envelope_from_geometries_zm(geoms: GEOMS_ZM) -> Envelope:
+    """
+    Envelope from Geometries with ZM
+    """
+    if not geoms:
+        return EMPTY_ENVELOPE
+    xs, ys, zs, ms = [], [], [], []
+    for geom in geoms:
+        env = geom.envelope
+        xs.extend((env.min_x, env.max_x))
+        ys.extend((env.min_y, env.max_y))
+        zs.extend((env.min_z, env.max_z))
+        ms.extend((env.min_m, env.max_m))
+    return _envelope_xyzm(xs=xs, ys=ys, zs=zs, ms=ms)
+# End envelope_from_geometries_zm function
+
+
+def envelope_from_coordinates(coordinates: List[DOUBLE]) -> Envelope:
+    """
+    Envelope from Coordinates
+    """
+    if not coordinates:
+        return EMPTY_ENVELOPE
+    return _envelope_xy(*zip(*coordinates))
+# End envelope_from_coordinates function
+
+
+def envelope_from_coordinates_z(coordinates: List[TRIPLE]) -> Envelope:
+    """
+    Envelope from Coordinates with Z
+    """
+    if not coordinates:
+        return EMPTY_ENVELOPE
+    return _envelope_xyz(*zip(*coordinates))
+# End envelope_from_coordinates_z function
+
+
+def envelope_from_coordinates_m(coordinates: List[TRIPLE]) -> Envelope:
+    """
+    Envelope from Coordinates with M
+    """
+    if not coordinates:
+        return EMPTY_ENVELOPE
+    return _envelope_xym(*zip(*coordinates))
+# End envelope_from_coordinates_m function
+
+
+def envelope_from_coordinates_zm(coordinates: List[QUADRUPLE]) -> Envelope:
+    """
+    Envelope from Coordinates with ZM
+    """
+    if not coordinates:
+        return EMPTY_ENVELOPE
+    return _envelope_xyzm(*zip(*coordinates))
+# End envelope_from_coordinates_zm function
+
+
+def _envelope_xy(xs: VALUES, ys: VALUES) -> Envelope:
+    """
+    Envelope XY
+    """
+    min_x, max_x = _min_max(xs)
+    min_y, max_y = _min_max(ys)
+    return Envelope(code=1, min_x=min_x, max_x=max_x, min_y=min_y, max_y=max_y)
+# End _envelope_xy function
+
+
+def _envelope_xyz(xs: VALUES, ys: VALUES, zs: VALUES) -> Envelope:
+    """
+    Envelope XYZ
+    """
+    min_x, max_x = _min_max(xs)
+    min_y, max_y = _min_max(ys)
+    min_z, max_z = _min_max(zs)
+    return Envelope(code=2, min_x=min_x, max_x=max_x,
+                    min_y=min_y, max_y=max_y,
+                    min_z=min_z, max_z=max_z)
+# End _envelope_xyz function
+
+
+def _envelope_xym(xs: VALUES, ys: VALUES, ms: VALUES) -> Envelope:
+    """
+    Envelope XYM
+    """
+    min_x, max_x = _min_max(xs)
+    min_y, max_y = _min_max(ys)
+    min_m, max_m = _min_max(ms)
+    return Envelope(code=3, min_x=min_x, max_x=max_x,
+                    min_y=min_y, max_y=max_y,
+                    min_m=min_m, max_m=max_m)
+# End _envelope_xym function
+
+
+def _envelope_xyzm(xs: VALUES, ys: VALUES, zs: VALUES, ms: VALUES) -> Envelope:
+    """
+    Envelope XYZM
+    """
+    min_x, max_x = _min_max(xs)
+    min_y, max_y = _min_max(ys)
+    min_z, max_z = _min_max(zs)
+    min_m, max_m = _min_max(ms)
+    return Envelope(
+        code=4, min_x=min_x, max_x=max_x, min_y=min_y, max_y=max_y,
+        min_z=min_z, max_z=max_z, min_m=min_m, max_m=max_m)
+# End _envelope_xyzm function
+
+
 if __name__ == '__main__':  # pragma: no cover
     pass
```

## Comparing `fudgeo-0.4.0.dist-info/LICENSE` & `fudgeo-0.4.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `fudgeo-0.4.0.dist-info/METADATA` & `fudgeo-0.4.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fudgeo
-Version: 0.4.0
+Version: 0.4.1
 Summary: GeoPackage support from Python.  fudgeo is a simple package for creating OGC GeoPackages, Feature Classes, Tables, and geometries (read and write).
 Author-email: "Integrated Informatics Inc." <contact@integrated-informatics.com>
 License: MIT License
         
         Copyright (c) 2021-2023 Integrated Informatics Inc
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `fudgeo-0.4.0.dist-info/RECORD` & `fudgeo-0.4.1.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-fudgeo/__init__.py,sha256=NsEmidHTOtkkR61mmtVHQ8JuaQA8MGUbTclb4NbHBVI,117
+fudgeo/__init__.py,sha256=f96KQWKKaRHvdLvNXZ9Rv3ANscOL_YEUJ6HTiAuCAms,117
 fudgeo/constant.py,sha256=-fE2Lyobm43rnDNzxsLUhaCfMMlaO5cCUmOFEL05LCQ,2538
 fudgeo/enumeration.py,sha256=NvgtVBYxfULGVIks-J0rFLRxvGrtU2DM1bjZB0HxZRU,1157
 fudgeo/geopkg.py,sha256=LL5uO82kL5CgTlIdxbr_2hiUf-kqDVXdtz8vDASXj_g,20081
 fudgeo/geopkg.sql,sha256=Tt0Fi4w-ySR7tDUJsPt-5mA_Sw2oUs8co5rFGEleS24,2673
 fudgeo/sql.py,sha256=AJcNZAjvGHvmc88NCU1TTsfjJ0tVZ6muTyNzA8yZcW0,7768
 fudgeo/geometry/__init__.py,sha256=N4sf5FJB13JoNxB_GyyO9ohXbtKoSoVvbKTnltMXq-0,974
-fudgeo/geometry/base.py,sha256=wXhQmzdJEP4qSYAi1NO4DZoqIdeb21iZpWS6DU0AEqY,3244
-fudgeo/geometry/linestring.py,sha256=kRuMVrdA1lZz8XF7RqPrTt_lUU04q_qul5bml5BzqFw,14233
-fudgeo/geometry/point.py,sha256=bPBGQHrqkVplYemFlKNsXjX-lpu6IBzsEP1YDBYCI-4,16511
-fudgeo/geometry/polygon.py,sha256=m5EGf5MN0-6nFzZAyapa2c3fm4h6A6kAf613iWrfF9k,18766
-fudgeo/geometry/util.py,sha256=6fn-FyJZe27-_SxVYF1iTrRlo0z-AMM7-TGjazs-Gwo,6508
-fudgeo-0.4.0.dist-info/LICENSE,sha256=kg8K68wjqhzaDoPNP6FWgXT2UuLmZbswzv72syix3Gw,1088
-fudgeo-0.4.0.dist-info/METADATA,sha256=fwPqWbnSxXIxMZd9LUqBqq6eC3vWN-LaWOHOXJ_boww,9095
-fudgeo-0.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-fudgeo-0.4.0.dist-info/top_level.txt,sha256=RlcnukuWGTUINTexweATRDqQgM1d0q2iaOd6B6tBWWI,7
-fudgeo-0.4.0.dist-info/RECORD,,
+fudgeo/geometry/base.py,sha256=ETJLZMa6jb6A68QIzgPDWNjDoKnU7jq7AR_HevnDcEI,3250
+fudgeo/geometry/linestring.py,sha256=5tdWjJ9plRcvmU9PgXduVMQo_5cSz4XYK-PhZ2vixmQ,16963
+fudgeo/geometry/point.py,sha256=cgONWVNWC4C-c5TvZ3VuVoIRgnpBxfGo-SxypvARScc,17903
+fudgeo/geometry/polygon.py,sha256=pTVE2DXSAyzL1RmpBY5uOjlSKa21CpG7EvA2dC601CA,22719
+fudgeo/geometry/util.py,sha256=MkN3M-baAvzOvxNnLo6PHhX54j7MW4JfZVKJ3DAzlAY,14620
+fudgeo-0.4.1.dist-info/LICENSE,sha256=kg8K68wjqhzaDoPNP6FWgXT2UuLmZbswzv72syix3Gw,1088
+fudgeo-0.4.1.dist-info/METADATA,sha256=fm_GG0c2uPqvWvZ3cLfdSHb1qMNyQD7UEUxk8H5PUiQ,9095
+fudgeo-0.4.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+fudgeo-0.4.1.dist-info/top_level.txt,sha256=RlcnukuWGTUINTexweATRDqQgM1d0q2iaOd6B6tBWWI,7
+fudgeo-0.4.1.dist-info/RECORD,,
```

