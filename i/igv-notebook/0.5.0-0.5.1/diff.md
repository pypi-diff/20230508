# Comparing `tmp/igv-notebook-0.5.0.tar.gz` & `tmp/igv-notebook-0.5.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "igv-notebook-0.5.0.tar", last modified: Tue Mar 28 05:18:31 2023, max compression
+gzip compressed data, was "igv-notebook-0.5.1.tar", last modified: Mon May  8 02:51:11 2023, max compression
```

## Comparing `igv-notebook-0.5.0.tar` & `igv-notebook-0.5.1.tar`

### file list

```diff
@@ -1,25 +1,25 @@
-drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-03-28 05:18:31.980410 igv-notebook-0.5.0/
--rw-r--r--   0 jrobinso   (502) staff       (20)     1064 2022-02-24 04:59:37.000000 igv-notebook-0.5.0/LICENSE.md
--rw-r--r--   0 jrobinso   (502) staff       (20)      222 2022-07-07 17:19:34.000000 igv-notebook-0.5.0/MANIFEST.in
--rw-r--r--   0 jrobinso   (502) staff       (20)    11438 2023-03-28 05:18:31.980670 igv-notebook-0.5.0/PKG-INFO
--rw-r--r--   0 jrobinso   (502) staff       (20)    10795 2023-02-07 00:47:58.000000 igv-notebook-0.5.0/README.md
-drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-03-28 05:18:31.967859 igv-notebook-0.5.0/igv_notebook/
--rw-r--r--   0 jrobinso   (502) staff       (20)        5 2023-03-11 01:28:27.000000 igv-notebook-0.5.0/igv_notebook/VERSION
--rw-r--r--   0 jrobinso   (502) staff       (20)        6 2023-03-11 01:28:27.000000 igv-notebook-0.5.0/igv_notebook/VERSION_IGV
--rw-r--r--   0 jrobinso   (502) staff       (20)       77 2022-12-10 23:36:37.000000 igv-notebook-0.5.0/igv_notebook/__init__.py
--rw-r--r--   0 jrobinso   (502) staff       (20)     6918 2023-03-13 16:30:28.000000 igv-notebook-0.5.0/igv_notebook/browser.py
--rw-r--r--   0 jrobinso   (502) staff       (20)     1699 2022-07-05 16:40:17.000000 igv-notebook-0.5.0/igv_notebook/file_reader.py
-drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-03-28 05:18:31.979390 igv-notebook-0.5.0/igv_notebook/js/
--rw-r--r--   0 jrobinso   (502) staff       (20)   967854 2023-03-11 01:46:31.000000 igv-notebook-0.5.0/igv_notebook/js/igv.min.js
--rw-r--r--   0 jrobinso   (502) staff       (20)     6439 2023-03-13 18:53:02.000000 igv-notebook-0.5.0/igv_notebook/js/localNotebookFile.js
--rw-r--r--   0 jrobinso   (502) staff       (20)    15903 2023-03-13 18:59:26.000000 igv-notebook-0.5.0/igv_notebook/js/messageHandler.js
--rw-r--r--   0 jrobinso   (502) staff       (20)      698 2022-07-07 07:59:09.000000 igv-notebook-0.5.0/igv_notebook/svg.py
--rw-r--r--   0 jrobinso   (502) staff       (20)      173 2023-01-05 05:22:23.000000 igv-notebook-0.5.0/igv_notebook/version.py
-drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-03-28 05:18:31.971809 igv-notebook-0.5.0/igv_notebook.egg-info/
--rw-r--r--   0 jrobinso   (502) staff       (20)    11438 2023-03-28 05:18:31.000000 igv-notebook-0.5.0/igv_notebook.egg-info/PKG-INFO
--rw-r--r--   0 jrobinso   (502) staff       (20)      495 2023-03-28 05:18:31.000000 igv-notebook-0.5.0/igv_notebook.egg-info/SOURCES.txt
--rw-r--r--   0 jrobinso   (502) staff       (20)        1 2023-03-28 05:18:31.000000 igv-notebook-0.5.0/igv_notebook.egg-info/dependency_links.txt
--rw-r--r--   0 jrobinso   (502) staff       (20)       27 2023-03-28 05:18:31.000000 igv-notebook-0.5.0/igv_notebook.egg-info/requires.txt
--rw-r--r--   0 jrobinso   (502) staff       (20)       13 2023-03-28 05:18:31.000000 igv-notebook-0.5.0/igv_notebook.egg-info/top_level.txt
--rw-r--r--   0 jrobinso   (502) staff       (20)       79 2023-03-28 05:18:31.981660 igv-notebook-0.5.0/setup.cfg
--rw-r--r--   0 jrobinso   (502) staff       (20)     1382 2023-01-11 06:01:51.000000 igv-notebook-0.5.0/setup.py
+drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-05-08 02:51:11.287706 igv-notebook-0.5.1/
+-rw-r--r--   0 jrobinso   (502) staff       (20)     1064 2022-02-24 04:59:37.000000 igv-notebook-0.5.1/LICENSE.md
+-rw-r--r--   0 jrobinso   (502) staff       (20)      222 2022-07-07 17:19:34.000000 igv-notebook-0.5.1/MANIFEST.in
+-rw-r--r--   0 jrobinso   (502) staff       (20)    14511 2023-05-08 02:51:11.288032 igv-notebook-0.5.1/PKG-INFO
+-rw-r--r--   0 jrobinso   (502) staff       (20)    10922 2023-05-08 02:47:25.000000 igv-notebook-0.5.1/README.md
+drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-05-08 02:51:11.276238 igv-notebook-0.5.1/igv_notebook/
+-rw-r--r--   0 jrobinso   (502) staff       (20)        5 2023-05-08 02:50:13.000000 igv-notebook-0.5.1/igv_notebook/VERSION
+-rw-r--r--   0 jrobinso   (502) staff       (20)        7 2023-05-05 22:22:11.000000 igv-notebook-0.5.1/igv_notebook/VERSION_IGV
+-rw-r--r--   0 jrobinso   (502) staff       (20)       77 2022-12-10 23:36:37.000000 igv-notebook-0.5.1/igv_notebook/__init__.py
+-rw-r--r--   0 jrobinso   (502) staff       (20)     6918 2023-03-13 16:30:28.000000 igv-notebook-0.5.1/igv_notebook/browser.py
+-rw-r--r--   0 jrobinso   (502) staff       (20)     1699 2022-07-05 16:40:17.000000 igv-notebook-0.5.1/igv_notebook/file_reader.py
+drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-05-08 02:51:11.286910 igv-notebook-0.5.1/igv_notebook/js/
+-rw-r--r--   0 jrobinso   (502) staff       (20)   977181 2023-05-05 22:59:41.000000 igv-notebook-0.5.1/igv_notebook/js/igv.min.js
+-rw-r--r--   0 jrobinso   (502) staff       (20)     6439 2023-03-13 18:53:02.000000 igv-notebook-0.5.1/igv_notebook/js/localNotebookFile.js
+-rw-r--r--   0 jrobinso   (502) staff       (20)    15903 2023-03-13 18:59:26.000000 igv-notebook-0.5.1/igv_notebook/js/messageHandler.js
+-rw-r--r--   0 jrobinso   (502) staff       (20)      698 2022-07-07 07:59:09.000000 igv-notebook-0.5.1/igv_notebook/svg.py
+-rw-r--r--   0 jrobinso   (502) staff       (20)      173 2023-01-05 05:22:23.000000 igv-notebook-0.5.1/igv_notebook/version.py
+drwxr-xr-x   0 jrobinso   (502) staff       (20)        0 2023-05-08 02:51:11.279221 igv-notebook-0.5.1/igv_notebook.egg-info/
+-rw-r--r--   0 jrobinso   (502) staff       (20)    14511 2023-05-08 02:51:11.000000 igv-notebook-0.5.1/igv_notebook.egg-info/PKG-INFO
+-rw-r--r--   0 jrobinso   (502) staff       (20)      495 2023-05-08 02:51:11.000000 igv-notebook-0.5.1/igv_notebook.egg-info/SOURCES.txt
+-rw-r--r--   0 jrobinso   (502) staff       (20)        1 2023-05-08 02:51:11.000000 igv-notebook-0.5.1/igv_notebook.egg-info/dependency_links.txt
+-rw-r--r--   0 jrobinso   (502) staff       (20)       27 2023-05-08 02:51:11.000000 igv-notebook-0.5.1/igv_notebook.egg-info/requires.txt
+-rw-r--r--   0 jrobinso   (502) staff       (20)       13 2023-05-08 02:51:11.000000 igv-notebook-0.5.1/igv_notebook.egg-info/top_level.txt
+-rw-r--r--   0 jrobinso   (502) staff       (20)       79 2023-05-08 02:51:11.288645 igv-notebook-0.5.1/setup.cfg
+-rw-r--r--   0 jrobinso   (502) staff       (20)     1382 2023-01-11 06:01:51.000000 igv-notebook-0.5.1/setup.py
```

### Comparing `igv-notebook-0.5.0/LICENSE.md` & `igv-notebook-0.5.1/LICENSE.md`

 * *Files identical despite different names*

### Comparing `igv-notebook-0.5.0/PKG-INFO` & `igv-notebook-0.5.1/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,25 +1,7 @@
-Metadata-Version: 2.1
-Name: igv-notebook
-Version: 0.5.0
-Summary: Package for embedding the igv.js genome visualization in IPython notebooks
-Home-page: https://github.com/igvteam/igv-notebook
-Author: Jim Robinson
-License: MIT
-Keywords: igv,bioinformatics,genomics,visualization,ipython,jupyter
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python
-Classifier: Framework :: IPython
-Description-Content-Type: text/markdown
-License-File: LICENSE.md
-
 # igv.js notebook module
 
 [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/igvteam/igv-notebook/main?filepath=examples)   _**Jupyter Notebook**_
 
 [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/igvteam/igv-notebook/main?urlpath=lab/tree/examples)  _**JupyterLab**_
 
 [![Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1-4P_r07Dq-WxaOVUevlbHvVhC9Y11FWC?usp=sharing)    _**Google Colab**_
@@ -342,14 +324,23 @@
 ### Updating igv.js version
 
 1. Edit VERSION_IGV - enter igv.js version with no line feed.  Visit [npmjs.com](https://www.npmjs.com/package/igv) to find latest version
 2. Run ```python updateIGV.py``` 
 
 ## Release Notes
 
+**0.5.1**
+
+* Update igv.js version to 2.15.7
+
+**0.5.0**
+
+* Add support for loading an igv session
+* Generate links to igv-web
+
 **0.4.5**
 
 * Fix path/url problems when using JupyterLab
 
 **0.4.4**
 
 * Add missing requirements to setup.py
@@ -373,9 +364,7 @@
 * Update ```browser.to_svg()``` function to support Python 3.6.
 * Add ```igv_notebook.version()``` function.
 
 **0.3.0**
 
 * Add ```browser.to_svg()``` function to convert igv instance to static SVG image (Jupyter Notebook only).
 
-
-
```

### Comparing `igv-notebook-0.5.0/igv_notebook/browser.py` & `igv-notebook-0.5.1/igv_notebook/browser.py`

 * *Files identical despite different names*

### Comparing `igv-notebook-0.5.0/igv_notebook/file_reader.py` & `igv-notebook-0.5.1/igv_notebook/file_reader.py`

 * *Files identical despite different names*

### Comparing `igv-notebook-0.5.0/igv_notebook/js/igv.min.js` & `igv-notebook-0.5.1/igv_notebook/js/igv.min.js`

 * *Files 0% similar despite different names*

#### js-beautify {}

```diff
@@ -1,8 +1,8 @@
-window.igv = function() {
+var igv = function() {
     "use strict";
     /*!
      * jQuery JavaScript Library v3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector
      * https://jquery.com/
      *
      * Includes Sizzle.js
      * https://sizzlejs.com/
@@ -188,53 +188,53 @@
                 k = 0,
                 C = oe(),
                 S = oe(),
                 A = oe(),
                 E = function(e, t) {
                     return e === t && (d = !0), 0
                 },
-                T = {}.hasOwnProperty,
-                M = [],
-                R = M.pop,
-                L = M.push,
-                I = M.push,
-                B = M.slice,
-                N = function(e, t) {
+                M = {}.hasOwnProperty,
+                T = [],
+                R = T.pop,
+                L = T.push,
+                I = T.push,
+                B = T.slice,
+                F = function(e, t) {
                     for (var i = 0, n = e.length; i < n; i++)
                         if (e[i] === t) return i;
                     return -1
                 },
-                F = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
-                P = "[\\x20\\t\\r\\n\\f]",
-                O = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
-                D = "\\[" + P + "*(" + O + ")(?:" + P + "*([*^$|!~]?=)" + P + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + O + "))|)" + P + "*\\]",
-                z = ":(" + O + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + D + ")*)|.*)\\)|)",
-                H = new RegExp(P + "+", "g"),
-                V = new RegExp("^" + P + "+|((?:^|[^\\\\])(?:\\\\.)*)" + P + "+$", "g"),
-                U = new RegExp("^" + P + "*," + P + "*"),
-                q = new RegExp("^" + P + "*([>+~]|" + P + ")" + P + "*"),
-                j = new RegExp("=" + P + "*([^\\]'\"]*?)" + P + "*\\]", "g"),
+                N = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
+                O = "[\\x20\\t\\r\\n\\f]",
+                P = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
+                D = "\\[" + O + "*(" + P + ")(?:" + O + "*([*^$|!~]?=)" + O + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + P + "))|)" + O + "*\\]",
+                z = ":(" + P + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + D + ")*)|.*)\\)|)",
+                H = new RegExp(O + "+", "g"),
+                V = new RegExp("^" + O + "+|((?:^|[^\\\\])(?:\\\\.)*)" + O + "+$", "g"),
+                U = new RegExp("^" + O + "*," + O + "*"),
+                q = new RegExp("^" + O + "*([>+~]|" + O + ")" + O + "*"),
+                j = new RegExp("=" + O + "*([^\\]'\"]*?)" + O + "*\\]", "g"),
                 $ = new RegExp(z),
-                W = new RegExp("^" + O + "$"),
+                W = new RegExp("^" + P + "$"),
                 G = {
-                    ID: new RegExp("^#(" + O + ")"),
-                    CLASS: new RegExp("^\\.(" + O + ")"),
-                    TAG: new RegExp("^(" + O + "|[*])"),
+                    ID: new RegExp("^#(" + P + ")"),
+                    CLASS: new RegExp("^\\.(" + P + ")"),
+                    TAG: new RegExp("^(" + P + "|[*])"),
                     ATTR: new RegExp("^" + D),
                     PSEUDO: new RegExp("^" + z),
-                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + P + "*(even|odd|(([+-]|)(\\d*)n|)" + P + "*(?:([+-]|)" + P + "*(\\d+)|))" + P + "*\\)|)", "i"),
-                    bool: new RegExp("^(?:" + F + ")$", "i"),
-                    needsContext: new RegExp("^" + P + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + P + "*((?:-\\d)?\\d*)" + P + "*\\)|)(?=[^-]|$)", "i")
+                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + O + "*(even|odd|(([+-]|)(\\d*)n|)" + O + "*(?:([+-]|)" + O + "*(\\d+)|))" + O + "*\\)|)", "i"),
+                    bool: new RegExp("^(?:" + N + ")$", "i"),
+                    needsContext: new RegExp("^" + O + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + O + "*((?:-\\d)?\\d*)" + O + "*\\)|)(?=[^-]|$)", "i")
                 },
                 Z = /^(?:input|select|textarea|button)$/i,
                 Q = /^h\d$/i,
                 X = /^[^{]+\{\s*\[native \w/,
                 Y = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                 K = /[+~]/,
-                J = new RegExp("\\\\([\\da-f]{1,6}" + P + "?|(" + P + ")|.)", "ig"),
+                J = new RegExp("\\\\([\\da-f]{1,6}" + O + "?|(" + O + ")|.)", "ig"),
                 ee = function(e, t, i) {
                     var n = "0x" + t - 65536;
                     return n != n || i ? t : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
                 },
                 te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                 ie = function(e, t) {
                     return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
@@ -245,18 +245,18 @@
                 re = be((function(e) {
                     return !0 === e.disabled && ("form" in e || "label" in e)
                 }), {
                     dir: "parentNode",
                     next: "legend"
                 });
             try {
-                I.apply(M = B.call(_.childNodes), _.childNodes), M[_.childNodes.length].nodeType
+                I.apply(T = B.call(_.childNodes), _.childNodes), T[_.childNodes.length].nodeType
             } catch (e) {
                 I = {
-                    apply: M.length ? function(e, t) {
+                    apply: T.length ? function(e, t) {
                         L.apply(e, B.call(t))
                     } : function(e, t) {
                         for (var i = e.length, n = 0; e[i++] = t[n++];);
                         e.length = i - 1
                     }
                 }
             }
@@ -400,42 +400,42 @@
                             for (; i = s[r++];) 1 === i.nodeType && n.push(i);
                             return n
                         }
                         return s
                     }, n.find.CLASS = i.getElementsByClassName && function(e, t) {
                         if (void 0 !== t.getElementsByClassName && g) return t.getElementsByClassName(e)
                     }, b = [], m = [], (i.qsa = X.test(f.querySelectorAll)) && (le((function(e) {
-                        p.appendChild(e).innerHTML = "<a id='" + y + "'></a><select id='" + y + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && m.push("[*^$]=" + P + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || m.push("\\[" + P + "*(?:value|" + F + ")"), e.querySelectorAll("[id~=" + y + "-]").length || m.push("~="), e.querySelectorAll(":checked").length || m.push(":checked"), e.querySelectorAll("a#" + y + "+*").length || m.push(".#.+[+~]")
+                        p.appendChild(e).innerHTML = "<a id='" + y + "'></a><select id='" + y + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && m.push("[*^$]=" + O + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || m.push("\\[" + O + "*(?:value|" + N + ")"), e.querySelectorAll("[id~=" + y + "-]").length || m.push("~="), e.querySelectorAll(":checked").length || m.push(":checked"), e.querySelectorAll("a#" + y + "+*").length || m.push(".#.+[+~]")
                     })), le((function(e) {
                         e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                         var t = f.createElement("input");
-                        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && m.push("name" + P + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && m.push(":enabled", ":disabled"), p.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && m.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), m.push(",.*:")
+                        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && m.push("name" + O + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && m.push(":enabled", ":disabled"), p.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && m.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), m.push(",.*:")
                     }))), (i.matchesSelector = X.test(w = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.oMatchesSelector || p.msMatchesSelector)) && le((function(e) {
                         i.disconnectedMatch = w.call(e, "*"), w.call(e, "[s!='']:x"), b.push("!=", z)
                     })), m = m.length && new RegExp(m.join("|")), b = b.length && new RegExp(b.join("|")), t = X.test(p.compareDocumentPosition), v = t || X.test(p.contains) ? function(e, t) {
                         var i = 9 === e.nodeType ? e.documentElement : e,
                             n = t && t.parentNode;
                         return e === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(n)))
                     } : function(e, t) {
                         if (t)
                             for (; t = t.parentNode;)
                                 if (t === e) return !0;
                         return !1
                     }, E = t ? function(e, t) {
                         if (e === t) return d = !0, 0;
                         var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
-                        return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !i.sortDetached && t.compareDocumentPosition(e) === n ? e === f || e.ownerDocument === _ && v(_, e) ? -1 : t === f || t.ownerDocument === _ && v(_, t) ? 1 : c ? N(c, e) - N(c, t) : 0 : 4 & n ? -1 : 1)
+                        return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !i.sortDetached && t.compareDocumentPosition(e) === n ? e === f || e.ownerDocument === _ && v(_, e) ? -1 : t === f || t.ownerDocument === _ && v(_, t) ? 1 : c ? F(c, e) - F(c, t) : 0 : 4 & n ? -1 : 1)
                     } : function(e, t) {
                         if (e === t) return d = !0, 0;
                         var i, n = 0,
                             r = e.parentNode,
                             s = t.parentNode,
                             o = [e],
                             a = [t];
-                        if (!r || !s) return e === f ? -1 : t === f ? 1 : r ? -1 : s ? 1 : c ? N(c, e) - N(c, t) : 0;
+                        if (!r || !s) return e === f ? -1 : t === f ? 1 : r ? -1 : s ? 1 : c ? F(c, e) - F(c, t) : 0;
                         if (r === s) return he(e, t);
                         for (i = e; i = i.parentNode;) o.unshift(i);
                         for (i = t; i = i.parentNode;) a.unshift(i);
                         for (; o[n] === a[n];) n++;
                         return n ? he(o[n], a[n]) : o[n] === _ ? -1 : a[n] === _ ? 1 : 0
                     }, f) : f
                 }, se.matches = function(e, t) {
@@ -447,15 +447,15 @@
                     } catch (e) {}
                     return se(t, f, null, [e]).length > 0
                 }, se.contains = function(e, t) {
                     return (e.ownerDocument || e) !== f && u(e), v(e, t)
                 }, se.attr = function(e, t) {
                     (e.ownerDocument || e) !== f && u(e);
                     var r = n.attrHandle[t.toLowerCase()],
-                        s = r && T.call(n.attrHandle, t.toLowerCase()) ? r(e, t, !g) : void 0;
+                        s = r && M.call(n.attrHandle, t.toLowerCase()) ? r(e, t, !g) : void 0;
                     return void 0 !== s ? s : i.attributes || !g ? e.getAttribute(t) : (s = e.getAttributeNode(t)) && s.specified ? s.value : null
                 }, se.escape = function(e) {
                     return (e + "").replace(te, ie)
                 }, se.error = function(e) {
                     throw new Error("Syntax error, unrecognized expression: " + e)
                 }, se.uniqueSort = function(e) {
                     var t, n = [],
@@ -519,15 +519,15 @@
                                 return !0
                             } : function(e) {
                                 return e.nodeName && e.nodeName.toLowerCase() === t
                             }
                         },
                         CLASS: function(e) {
                             var t = C[e + " "];
-                            return t || (t = new RegExp("(^|" + P + ")" + e + "(" + P + "|$)")) && C(e, (function(e) {
+                            return t || (t = new RegExp("(^|" + O + ")" + e + "(" + O + "|$)")) && C(e, (function(e) {
                                 return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                             }))
                         },
                         ATTR: function(e, t, i) {
                             return function(n) {
                                 var r = se.attr(n, e);
                                 return null == r ? "!=" === t : !t || (r += "", "=" === t ? r === i : "!=" === t ? r !== i : "^=" === t ? i && 0 === r.indexOf(i) : "*=" === t ? i && r.indexOf(i) > -1 : "$=" === t ? i && r.slice(-i.length) === i : "~=" === t ? (" " + r.replace(H, " ") + " ").indexOf(i) > -1 : "|=" === t && (r === i || r.slice(0, i.length + 1) === i + "-"))
@@ -566,15 +566,15 @@
                                     return (v -= r) === n || v % n == 0 && v / n >= 0
                                 }
                             }
                         },
                         PSEUDO: function(e, t) {
                             var i, r = n.pseudos[e] || n.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                             return r[y] ? r(t) : r.length > 1 ? (i = [e, e, "", t], n.setFilters.hasOwnProperty(e.toLowerCase()) ? ae((function(e, i) {
-                                for (var n, s = r(e, t), o = s.length; o--;) e[n = N(e, s[o])] = !(i[n] = s[o])
+                                for (var n, s = r(e, t), o = s.length; o--;) e[n = F(e, s[o])] = !(i[n] = s[o])
                             })) : function(e) {
                                 return r(e, 0, i)
                             }) : r
                         }
                     },
                     pseudos: {
                         not: ae((function(e) {
@@ -748,25 +748,25 @@
                         for (h = ve(b, f), n(h, [], a, l), c = h.length; c--;)(d = h[c]) && (b[f[c]] = !(m[f[c]] = d));
                     if (s) {
                         if (r || e) {
                             if (r) {
                                 for (h = [], c = b.length; c--;)(d = b[c]) && h.push(m[c] = d);
                                 r(null, b = [], h, l)
                             }
-                            for (c = b.length; c--;)(d = b[c]) && (h = r ? N(s, d) : u[c]) > -1 && (s[h] = !(o[h] = d))
+                            for (c = b.length; c--;)(d = b[c]) && (h = r ? F(s, d) : u[c]) > -1 && (s[h] = !(o[h] = d))
                         }
                     } else b = ve(b === o ? b.splice(p, b.length) : b), r ? r(null, o, b, l) : I.apply(o, b)
                 }))
             }
 
             function _e(e) {
                 for (var t, i, r, s = e.length, o = n.relative[e[0].type], a = o || n.relative[" "], l = o ? 1 : 0, c = be((function(e) {
                         return e === t
                     }), a, !0), d = be((function(e) {
-                        return N(t, e) > -1
+                        return F(t, e) > -1
                     }), a, !0), u = [function(e, i, n) {
                         var r = !o && (n || i !== h) || ((t = i).nodeType ? c(e, i, n) : d(e, i, n));
                         return t = null, r
                     }]; l < s; l++)
                     if (i = n.relative[e[l].type]) u = [be(we(u), i)];
                     else {
                         if ((i = n.filter[e[l].type].apply(null, e[l].matches))[y]) {
@@ -869,15 +869,15 @@
         S = v.expr.match.needsContext;
 
     function A(e, t) {
         return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
     }
     var E = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
 
-    function T(e, t, i) {
+    function M(e, t, i) {
         return f(t) ? v.grep(e, (function(e, n) {
             return !!t.call(e, n, e) !== i
         })) : t.nodeType ? v.grep(e, (function(e) {
             return e === t !== i
         })) : "string" != typeof t ? v.grep(e, (function(e) {
             return o.call(t, e) > -1 !== i
         })) : v.filter(t, e, i)
@@ -895,38 +895,38 @@
                 for (t = 0; t < n; t++)
                     if (v.contains(r[t], this)) return !0
             })));
             for (i = this.pushStack([]), t = 0; t < n; t++) v.find(e, r[t], i);
             return n > 1 ? v.uniqueSort(i) : i
         },
         filter: function(e) {
-            return this.pushStack(T(this, e || [], !1))
+            return this.pushStack(M(this, e || [], !1))
         },
         not: function(e) {
-            return this.pushStack(T(this, e || [], !0))
+            return this.pushStack(M(this, e || [], !0))
         },
         is: function(e) {
-            return !!T(this, "string" == typeof e && S.test(e) ? v(e) : e || [], !1).length
+            return !!M(this, "string" == typeof e && S.test(e) ? v(e) : e || [], !1).length
         }
     });
-    var M, R = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
+    var T, R = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
     (v.fn.init = function(e, i, n) {
         var r, s;
         if (!e) return this;
-        if (n = n || M, "string" == typeof e) {
+        if (n = n || T, "string" == typeof e) {
             if (!(r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : R.exec(e)) || !r[1] && i) return !i || i.jquery ? (i || n).find(e) : this.constructor(i).find(e);
             if (r[1]) {
                 if (i = i instanceof v ? i[0] : i, v.merge(this, v.parseHTML(r[1], i && i.nodeType ? i.ownerDocument || i : t, !0)), E.test(r[1]) && v.isPlainObject(i))
                     for (r in i) f(this[r]) ? this[r](i[r]) : this.attr(r, i[r]);
                 return this
             }
             return (s = t.getElementById(r[2])) && (this[0] = s, this.length = 1), this
         }
         return e.nodeType ? (this[0] = e, this.length = 1, this) : f(e) ? void 0 !== n.ready ? n.ready(e) : e(v) : v.makeArray(e, this)
-    }).prototype = v.fn, M = v(t);
+    }).prototype = v.fn, T = v(t);
     var L = /^(?:parents|prev(?:Until|All))/,
         I = {
             children: !0,
             contents: !0,
             next: !0,
             prev: !0
         };
@@ -1007,36 +1007,36 @@
         }
     }, (function(e, t) {
         v.fn[e] = function(i, n) {
             var r = v.map(this, t, i);
             return "Until" !== e.slice(-5) && (n = i), n && "string" == typeof n && (r = v.filter(n, r)), this.length > 1 && (I[e] || v.uniqueSort(r), L.test(e) && r.reverse()), this.pushStack(r)
         }
     }));
-    var N = /[^\x20\t\r\n\f]+/g;
+    var F = /[^\x20\t\r\n\f]+/g;
 
-    function F(e) {
+    function N(e) {
         return e
     }
 
-    function P(e) {
+    function O(e) {
         throw e
     }
 
-    function O(e, t, i, n) {
+    function P(e, t, i, n) {
         var r;
         try {
             e && f(r = e.promise) ? r.call(e).done(t).fail(i) : e && f(r = e.then) ? r.call(e, t, i) : t.apply(void 0, [e].slice(n))
         } catch (e) {
             i.apply(void 0, [e])
         }
     }
     v.Callbacks = function(e) {
         e = "string" == typeof e ? function(e) {
             var t = {};
-            return v.each(e.match(N) || [], (function(e, i) {
+            return v.each(e.match(F) || [], (function(e, i) {
                 t[i] = !0
             })), t
         }(e) : v.extend({}, e);
         var t, i, n, r, s = [],
             o = [],
             a = -1,
             l = function() {
@@ -1124,29 +1124,29 @@
                             return function() {
                                 var o = this,
                                     a = arguments,
                                     l = function() {
                                         var l, h;
                                         if (!(e < r)) {
                                             if ((l = i.apply(o, a)) === t.promise()) throw new TypeError("Thenable self-resolution");
-                                            h = l && ("object" == typeof l || "function" == typeof l) && l.then, f(h) ? n ? h.call(l, s(r, t, F, n), s(r, t, P, n)) : (r++, h.call(l, s(r, t, F, n), s(r, t, P, n), s(r, t, F, t.notifyWith))) : (i !== F && (o = void 0, a = [l]), (n || t.resolveWith)(o, a))
+                                            h = l && ("object" == typeof l || "function" == typeof l) && l.then, f(h) ? n ? h.call(l, s(r, t, N, n), s(r, t, O, n)) : (r++, h.call(l, s(r, t, N, n), s(r, t, O, n), s(r, t, N, t.notifyWith))) : (i !== N && (o = void 0, a = [l]), (n || t.resolveWith)(o, a))
                                         }
                                     },
                                     h = n ? l : function() {
                                         try {
                                             l()
                                         } catch (n) {
-                                            v.Deferred.exceptionHook && v.Deferred.exceptionHook(n, h.stackTrace), e + 1 >= r && (i !== P && (o = void 0, a = [n]), t.rejectWith(o, a))
+                                            v.Deferred.exceptionHook && v.Deferred.exceptionHook(n, h.stackTrace), e + 1 >= r && (i !== O && (o = void 0, a = [n]), t.rejectWith(o, a))
                                         }
                                     };
                                 e ? h() : (v.Deferred.getStackHook && (h.stackTrace = v.Deferred.getStackHook()), window.setTimeout(h))
                             }
                         }
                         return v.Deferred((function(r) {
-                            t[0][3].add(s(0, r, f(n) ? n : F, r.notifyWith)), t[1][3].add(s(0, r, f(e) ? e : F)), t[2][3].add(s(0, r, f(i) ? i : P))
+                            t[0][3].add(s(0, r, f(n) ? n : N, r.notifyWith)), t[1][3].add(s(0, r, f(e) ? e : N)), t[2][3].add(s(0, r, f(i) ? i : O))
                         })).promise()
                     },
                     promise: function(e) {
                         return null != e ? v.extend(e, n) : n
                     }
                 },
                 r = {};
@@ -1167,16 +1167,16 @@
                 s = n.call(arguments),
                 o = v.Deferred(),
                 a = function(e) {
                     return function(i) {
                         r[e] = this, s[e] = arguments.length > 1 ? n.call(arguments) : i, --t || o.resolveWith(r, s)
                     }
                 };
-            if (t <= 1 && (O(e, o.done(a(i)).resolve, o.reject, !t), "pending" === o.state() || f(s[i] && s[i].then))) return o.then();
-            for (; i--;) O(s[i], a(i), o.reject);
+            if (t <= 1 && (P(e, o.done(a(i)).resolve, o.reject, !t), "pending" === o.state() || f(s[i] && s[i].then))) return o.then();
+            for (; i--;) P(s[i], a(i), o.reject);
             return o.promise()
         }
     });
     var D = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
     v.Deferred.exceptionHook = function(e, t) {
         window.console && window.console.warn && e && D.test(e.name) && window.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
     }, v.readyException = function(e) {
@@ -1250,15 +1250,15 @@
         access: function(e, t, i) {
             return void 0 === t || t && "string" == typeof t && void 0 === i ? this.get(e, t) : (this.set(e, t, i), void 0 !== i ? i : t)
         },
         remove: function(e, t) {
             var i, n = e[this.expando];
             if (void 0 !== n) {
                 if (void 0 !== t) {
-                    i = (t = Array.isArray(t) ? t.map($) : (t = $(t)) in n ? [t] : t.match(N) || []).length;
+                    i = (t = Array.isArray(t) ? t.map($) : (t = $(t)) in n ? [t] : t.match(F) || []).length;
                     for (; i--;) delete n[t[i]]
                 }(void 0 === t || v.isEmptyObject(n)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
             }
         },
         hasData: function(e) {
             var t = e[this.expando];
             return void 0 !== t && !v.isEmptyObject(t)
@@ -1491,29 +1491,29 @@
     v.event = {
         global: {},
         add: function(e, t, i, n, r) {
             var s, o, a, l, h, c, d, u, f, p, g, m = Z.get(e);
             if (m)
                 for (i.handler && (i = (s = i).handler, r = s.selector), r && v.find.matchesSelector(ge, r), i.guid || (i.guid = v.guid++), (l = m.events) || (l = m.events = {}), (o = m.handle) || (o = m.handle = function(t) {
                         return void 0 !== v && v.event.triggered !== t.type ? v.event.dispatch.apply(e, arguments) : void 0
-                    }), h = (t = (t || "").match(N) || [""]).length; h--;) f = g = (a = we.exec(t[h]) || [])[1], p = (a[2] || "").split(".").sort(), f && (d = v.event.special[f] || {}, f = (r ? d.delegateType : d.bindType) || f, d = v.event.special[f] || {}, c = v.extend({
+                    }), h = (t = (t || "").match(F) || [""]).length; h--;) f = g = (a = we.exec(t[h]) || [])[1], p = (a[2] || "").split(".").sort(), f && (d = v.event.special[f] || {}, f = (r ? d.delegateType : d.bindType) || f, d = v.event.special[f] || {}, c = v.extend({
                     type: f,
                     origType: g,
                     data: n,
                     handler: i,
                     guid: i.guid,
                     selector: r,
                     needsContext: r && v.expr.match.needsContext.test(r),
                     namespace: p.join(".")
                 }, s), (u = l[f]) || ((u = l[f] = []).delegateCount = 0, d.setup && !1 !== d.setup.call(e, n, p, o) || e.addEventListener && e.addEventListener(f, o)), d.add && (d.add.call(e, c), c.handler.guid || (c.handler.guid = i.guid)), r ? u.splice(u.delegateCount++, 0, c) : u.push(c), v.event.global[f] = !0)
         },
         remove: function(e, t, i, n, r) {
             var s, o, a, l, h, c, d, u, f, p, g, m = Z.hasData(e) && Z.get(e);
             if (m && (l = m.events)) {
-                for (h = (t = (t || "").match(N) || [""]).length; h--;)
+                for (h = (t = (t || "").match(F) || [""]).length; h--;)
                     if (f = g = (a = we.exec(t[h]) || [])[1], p = (a[2] || "").split(".").sort(), f) {
                         for (d = v.event.special[f] || {}, u = l[f = (n ? d.delegateType : d.bindType) || f] || [], a = a[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = s = u.length; s--;) c = u[s], !r && g !== c.origType || i && i.guid !== c.guid || a && !a.test(c.namespace) || n && n !== c.selector && ("**" !== n || !c.selector) || (u.splice(s, 1), c.selector && u.delegateCount--, d.remove && d.remove.call(e, c));
                         o && !u.length && (d.teardown && !1 !== d.teardown.call(e, p, m.handle) || v.removeEvent(e, f, m.handle), delete l[f])
                     } else
                         for (f in l) v.event.remove(e, f + t[h], i, n, !0);
                 v.isEmptyObject(l) && Z.remove(e, "handle events")
             }
@@ -1697,19 +1697,19 @@
         Se = /checked\s*(?:[^=]|=\s*.checked.)/i,
         Ae = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
 
     function Ee(e, t) {
         return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && v(e).children("tbody")[0] || e
     }
 
-    function Te(e) {
+    function Me(e) {
         return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
     }
 
-    function Me(e) {
+    function Te(e) {
         return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
     }
 
     function Re(e, t) {
         var i, n, r, s, o, a, l, h;
         if (1 === t.nodeType) {
             if (Z.hasData(e) && (s = Z.access(e), o = Z.set(t, s), h = s.events))
@@ -1732,17 +1732,17 @@
             b = t[0],
             w = f(b);
         if (w || p > 1 && "string" == typeof b && !u.checkClone && Se.test(b)) return e.each((function(r) {
             var s = e.eq(r);
             w && (t[0] = b.call(this, r, s.html())), Ie(s, t, i, n)
         }));
         if (p && (o = (s = pe(t, e[0].ownerDocument, !1, e, n)).firstChild, 1 === s.childNodes.length && (s = o), o || n)) {
-            for (l = (a = v.map(de(s, "script"), Te)).length; d < p; d++) h = s, d !== g && (h = v.clone(h, !0, !0), l && v.merge(a, de(h, "script"))), i.call(e[d], h, d);
+            for (l = (a = v.map(de(s, "script"), Me)).length; d < p; d++) h = s, d !== g && (h = v.clone(h, !0, !0), l && v.merge(a, de(h, "script"))), i.call(e[d], h, d);
             if (l)
-                for (c = a[a.length - 1].ownerDocument, v.map(a, Me), d = 0; d < l; d++) h = a[d], he.test(h.type || "") && !Z.access(h, "globalEval") && v.contains(c, h) && (h.src && "module" !== (h.type || "").toLowerCase() ? v._evalUrl && v._evalUrl(h.src) : m(h.textContent.replace(Ae, ""), c, h))
+                for (c = a[a.length - 1].ownerDocument, v.map(a, Te), d = 0; d < l; d++) h = a[d], he.test(h.type || "") && !Z.access(h, "globalEval") && v.contains(c, h) && (h.src && "module" !== (h.type || "").toLowerCase() ? v._evalUrl && v._evalUrl(h.src) : m(h.textContent.replace(Ae, ""), c, h))
         }
         return e
     }
 
     function Be(e, t, i) {
         for (var n, r = t ? v.filter(t, e) : e, s = 0; null != (n = r[s]); s++) i || 1 !== n.nodeType || v.cleanData(de(n)), n.parentNode && (i && v.contains(n.ownerDocument, n) && ue(de(n, "script")), n.parentNode.removeChild(n));
         return e
@@ -1850,24 +1850,24 @@
         replaceAll: "replaceWith"
     }, (function(e, t) {
         v.fn[e] = function(e) {
             for (var i, n = [], r = v(e), o = r.length - 1, a = 0; a <= o; a++) i = a === o ? this : this.clone(!0), v(r[a])[t](i), s.apply(n, i.get());
             return this.pushStack(n)
         }
     }));
-    var Ne = new RegExp("^(" + J + ")(?!px)[a-z%]+$", "i"),
-        Fe = function(e) {
+    var Fe = new RegExp("^(" + J + ")(?!px)[a-z%]+$", "i"),
+        Ne = function(e) {
             var t = e.ownerDocument.defaultView;
             return t && t.opener || (t = window), t.getComputedStyle(e)
         },
-        Pe = new RegExp(te.join("|"), "i");
+        Oe = new RegExp(te.join("|"), "i");
 
-    function Oe(e, t, i) {
+    function Pe(e, t, i) {
         var n, r, s, o, a = e.style;
-        return (i = i || Fe(e)) && ("" !== (o = i.getPropertyValue(t) || i[t]) || v.contains(e.ownerDocument, e) || (o = v.style(e, t)), !u.pixelBoxStyles() && Ne.test(o) && Pe.test(t) && (n = a.width, r = a.minWidth, s = a.maxWidth, a.minWidth = a.maxWidth = a.width = o, o = i.width, a.width = n, a.minWidth = r, a.maxWidth = s)), void 0 !== o ? o + "" : o
+        return (i = i || Ne(e)) && ("" !== (o = i.getPropertyValue(t) || i[t]) || v.contains(e.ownerDocument, e) || (o = v.style(e, t)), !u.pixelBoxStyles() && Fe.test(o) && Oe.test(t) && (n = a.width, r = a.minWidth, s = a.maxWidth, a.minWidth = a.maxWidth = a.width = o, o = i.width, a.width = n, a.minWidth = r, a.maxWidth = s)), void 0 !== o ? o + "" : o
     }
 
     function De(e, t) {
         return {
             get: function() {
                 if (!e()) return (this.get = t).apply(this, arguments);
                 delete this.get
@@ -1939,30 +1939,30 @@
             l = 0;
         if (i === (n ? "border" : "content")) return 0;
         for (; o < 4; o += 2) "margin" === i && (l += v.css(e, i + te[o], !0, r)), n ? ("content" === i && (l -= v.css(e, "padding" + te[o], !0, r)), "margin" !== i && (l -= v.css(e, "border" + te[o] + "Width", !0, r))) : (l += v.css(e, "padding" + te[o], !0, r), "padding" !== i ? l += v.css(e, "border" + te[o] + "Width", !0, r) : a += v.css(e, "border" + te[o] + "Width", !0, r));
         return !n && s >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - s - l - a - .5))), l
     }
 
     function Xe(e, t, i) {
-        var n = Fe(e),
-            r = Oe(e, t, n),
+        var n = Ne(e),
+            r = Pe(e, t, n),
             s = "border-box" === v.css(e, "boxSizing", !1, n),
             o = s;
-        if (Ne.test(r)) {
+        if (Fe.test(r)) {
             if (!i) return r;
             r = "auto"
         }
         return o = o && (u.boxSizingReliable() || r === e.style[t]), ("auto" === r || !parseFloat(r) && "inline" === v.css(e, "display", !1, n)) && (r = e["offset" + t[0].toUpperCase() + t.slice(1)], o = !0), (r = parseFloat(r) || 0) + Qe(e, t, i || (s ? "border" : "content"), o, n, r) + "px"
     }
     v.extend({
         cssHooks: {
             opacity: {
                 get: function(e, t) {
                     if (t) {
-                        var i = Oe(e, "opacity");
+                        var i = Pe(e, "opacity");
                         return "" === i ? "1" : i
                     }
                 }
             }
         },
         cssNumber: {
             animationIterationCount: !0,
@@ -2002,32 +2002,32 @@
                     }
                     return i && (c = +c || +l || 0, r = i[1] ? c + (i[1] + 1) * i[2] : +i[2], n && (n.unit = h, n.start = c, n.end = r)), r
                 }(e, t, r), s = "number"), null != i && i == i && ("number" === s && (i += r && r[3] || (v.cssNumber[a] ? "" : "px")), u.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (h[t] = "inherit"), o && "set" in o && void 0 === (i = o.set(e, i, n)) || (l ? h.setProperty(t, i) : h[t] = i))
             }
         },
         css: function(e, t, i, n) {
             var r, s, o, a = $(t);
-            return Ue.test(t) || (t = Ge(a)), (o = v.cssHooks[t] || v.cssHooks[a]) && "get" in o && (r = o.get(e, !0, i)), void 0 === r && (r = Oe(e, t, n)), "normal" === r && t in je && (r = je[t]), "" === i || i ? (s = parseFloat(r), !0 === i || isFinite(s) ? s || 0 : r) : r
+            return Ue.test(t) || (t = Ge(a)), (o = v.cssHooks[t] || v.cssHooks[a]) && "get" in o && (r = o.get(e, !0, i)), void 0 === r && (r = Pe(e, t, n)), "normal" === r && t in je && (r = je[t]), "" === i || i ? (s = parseFloat(r), !0 === i || isFinite(s) ? s || 0 : r) : r
         }
     }), v.each(["height", "width"], (function(e, t) {
         v.cssHooks[t] = {
             get: function(e, i, n) {
                 if (i) return !Ve.test(v.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Xe(e, t, n) : ne(e, qe, (function() {
                     return Xe(e, t, n)
                 }))
             },
             set: function(e, i, n) {
-                var r, s = Fe(e),
+                var r, s = Ne(e),
                     o = "border-box" === v.css(e, "boxSizing", !1, s),
                     a = n && Qe(e, t, n, o, s);
                 return o && u.scrollboxSize() === s.position && (a -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(s[t]) - Qe(e, t, "border", !1, s) - .5)), a && (r = ee.exec(i)) && "px" !== (r[3] || "px") && (e.style[t] = i, i = v.css(e, t)), Ze(0, i, a)
             }
         }
     })), v.cssHooks.marginLeft = De(u.reliableMarginLeft, (function(e, t) {
-        if (t) return (parseFloat(Oe(e, "marginLeft")) || e.getBoundingClientRect().left - ne(e, {
+        if (t) return (parseFloat(Pe(e, "marginLeft")) || e.getBoundingClientRect().left - ne(e, {
             marginLeft: 0
         }, (function() {
             return e.getBoundingClientRect().left
         }))) + "px"
     })), v.each({
         margin: "",
         padding: "",
@@ -2041,15 +2041,15 @@
         }, "margin" !== e && (v.cssHooks[e + t].set = Ze)
     })), v.fn.extend({
         css: function(e, t) {
             return V(this, (function(e, t, i) {
                 var n, r, s = {},
                     o = 0;
                 if (Array.isArray(t)) {
-                    for (n = Fe(e), r = t.length; o < r; o++) s[t[o]] = v.css(e, t[o], !1, n);
+                    for (n = Ne(e), r = t.length; o < r; o++) s[t[o]] = v.css(e, t[o], !1, n);
                     return s
                 }
                 return void 0 !== i ? v.style(e, t, i) : v.css(e, t)
             }), e, t, arguments.length > 1)
         }
     }), v.fn.delay = function(e, t) {
         return e = v.fx && v.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function(t, i) {
@@ -2082,15 +2082,15 @@
                         return e.setAttribute("type", t), i && (e.value = i), t
                     }
                 }
             }
         },
         removeAttr: function(e, t) {
             var i, n = 0,
-                r = t && t.match(N);
+                r = t && t.match(F);
             if (r && 1 === e.nodeType)
                 for (; i = r[n++];) e.removeAttribute(i)
         }
     }), Ye = {
         set: function(e, t, i) {
             return !1 === t ? v.removeAttr(e, i) : e.setAttribute(i, i), i
         }
@@ -2101,23 +2101,23 @@
             return n || (s = Ke[o], Ke[o] = r, r = null != i(e, t, n) ? o : null, Ke[o] = s), r
         }
     }));
     var Je = /^(?:input|select|textarea|button)$/i,
         et = /^(?:a|area)$/i;
 
     function tt(e) {
-        return (e.match(N) || []).join(" ")
+        return (e.match(F) || []).join(" ")
     }
 
     function it(e) {
         return e.getAttribute && e.getAttribute("class") || ""
     }
 
     function nt(e) {
-        return Array.isArray(e) ? e : "string" == typeof e && e.match(N) || []
+        return Array.isArray(e) ? e : "string" == typeof e && e.match(F) || []
     }
     v.fn.extend({
         prop: function(e, t) {
             return V(this, v.prop, e, t, arguments.length > 1)
         },
         removeProp: function(e) {
             return this.each((function() {
@@ -2441,15 +2441,15 @@
                 var s;
                 if (p(e) ? s = e : 9 === e.nodeType && (s = e.defaultView), void 0 === r) return s ? s[t] : e[n];
                 s ? s.scrollTo(i ? s.pageXOffset : r, i ? r : s.pageYOffset) : e[n] = r
             }), e, n, arguments.length)
         }
     })), v.each(["top", "left"], (function(e, t) {
         v.cssHooks[t] = De(u.pixelPosition, (function(e, i) {
-            if (i) return i = Oe(e, t), Ne.test(i) ? v(e).position()[t] + "px" : i
+            if (i) return i = Pe(e, t), Fe.test(i) ? v(e).position()[t] + "px" : i
         }))
     })), v.each({
         Height: "height",
         Width: "width"
     }, (function(e, t) {
         v.each({
             padding: "inner" + e,
@@ -2672,61 +2672,61 @@
 
     function Et(e, t) {
         var i = document.createElement("div");
         e.appendChild(i), i.appendChild(kt("times")), i.addEventListener("click", (function(e) {
             e.preventDefault(), e.stopPropagation(), t()
         }))
     }
-    var Tt = Object.freeze({
+    var Mt = Object.freeze({
         __proto__: null,
         attachDialogCloseHandlerWithParent: Et
     });
-    let Mt;
+    let Tt;
 
     function Rt(e, t, i) {
         t.addEventListener("mousedown", function(e) {
             e.stopPropagation(), e.preventDefault();
             const t = Lt.bind(this),
                 n = It.bind(this),
                 r = getComputedStyle(this);
-            Mt = {
+            Tt = {
                 constraint: i,
                 dragFunction: t,
                 dragEndFunction: n,
                 screenX: e.screenX,
                 screenY: e.screenY,
                 top: parseInt(r.top.replace("px", "")),
                 left: parseInt(r.left.replace("px", ""))
             }, document.addEventListener("mousemove", t), document.addEventListener("mouseup", n), document.addEventListener("mouseleave", n), document.addEventListener("mouseexit", n)
         }.bind(e))
     }
 
     function Lt(e) {
-        if (!Mt) return void console.error("No drag data!");
+        if (!Tt) return void console.error("No drag data!");
         e.stopPropagation(), e.preventDefault();
-        const t = e.screenX - Mt.screenX,
-            i = e.screenY - Mt.screenY,
-            n = Mt.left + t,
-            r = Mt.constraint ? Math.max(Mt.constraint.minY, Mt.top + i) : Mt.top + i;
+        const t = e.screenX - Tt.screenX,
+            i = e.screenY - Tt.screenY,
+            n = Tt.left + t,
+            r = Tt.constraint ? Math.max(Tt.constraint.minY, Tt.top + i) : Tt.top + i;
         this.style.left = `${n}px`, this.style.top = `${r}px`
     }
 
     function It(e) {
-        if (!Mt) return void console.error("No drag data!");
+        if (!Tt) return void console.error("No drag data!");
         e.stopPropagation(), e.preventDefault();
-        const t = Mt.dragFunction,
-            i = Mt.dragEndFunction;
-        document.removeEventListener("mousemove", t), document.removeEventListener("mouseup", i), document.removeEventListener("mouseleave", i), document.removeEventListener("mouseexit", i), Mt = void 0
+        const t = Tt.dragFunction,
+            i = Tt.dragEndFunction;
+        document.removeEventListener("mousemove", t), document.removeEventListener("mouseup", i), document.removeEventListener("mouseleave", i), document.removeEventListener("mouseexit", i), Tt = void 0
     }
     const Bt = {
         401: "Access unauthorized",
         403: "Access forbidden",
         404: "Not found"
     };
-    class Nt {
+    class Ft {
         constructor(e, t) {
             this.alertProps = Object.assign({
                 shouldFocus: !0,
                 preventScroll: !1
             }, t), this.container = pt({
                 class: "igv-ui-alert-dialog-container"
             }), e.appendChild(this.container), this.container.setAttribute("tabIndex", "-1");
@@ -2753,15 +2753,15 @@
             this.errorHeadline.textContent = e.message ? "ERROR" : "";
             let i = e.message || e;
             Bt.hasOwnProperty(i) && (i = Bt[i]), this.body.innerHTML = i, this.callback = t, bt(this.container), this.alertProps.shouldFocus && this.container.focus({
                 preventScroll: this.alertProps.preventScroll
             })
         }
     }
-    class Ft {
+    class Nt {
         constructor(e) {
             this.parent = e, this.container = pt({
                 class: "igv-ui-generic-dialog-container"
             }), e.appendChild(this.container);
             const t = pt({
                 class: "igv-ui-generic-dialog-header"
             });
@@ -2790,15 +2790,15 @@
             const {
                 width: i,
                 height: n
             } = this.container.getBoundingClientRect(), r = window.innerHeight, s = window.innerWidth, o = Math.min(r - n, t), a = Math.min(s - i, e);
             this.container.style.left = `${a}px`, this.container.style.top = `${o}px`
         }
     }
-    const Pt = {
+    const Ot = {
         licorice: "#000000",
         lead: "#1e1e1e",
         tungsten: "#3a3a3a",
         iron: "#545453",
         steel: "#6e6e6e",
         tin: "#878687",
         nickel: "#888787",
@@ -2840,15 +2840,15 @@
         ice: "#68fdff",
         sky: "#6acfff",
         orchid: "#6e76ff",
         lavender: "#d278ff",
         bubblegum: "#ff7aff",
         carnation: "#ff7fd3"
     };
-    class Ot {
+    class Pt {
         constructor({
             parent: e,
             top: t,
             left: i,
             width: n,
             height: r,
             border: s,
@@ -2869,15 +2869,15 @@
         hide() {
             mt(this.container)
         }
         dispose() {
             this.container.parent && this.container.parent.removeChild(this.container)
         }
     }
-    class Dt extends Ot {
+    class Dt extends Pt {
         constructor({
             parent: e,
             top: t,
             left: i,
             width: n,
             height: r,
             defaultColors: s,
@@ -2890,15 +2890,15 @@
                 width: n,
                 height: r,
                 border: "1px solid gray"
             }), zt(this.container, o, s)
         }
     }
     const zt = (e, t, i) => {
-            const n = Object.values(Pt);
+            const n = Object.values(Ot);
             for (let i of n) {
                 const n = pt({
                     class: "igv-ui-color-swatch"
                 });
                 e.appendChild(n), Ht(n, i, t)
             }
             if (i)
@@ -2990,15 +2990,15 @@
         } = yt(e, t.parentNode);
         t.style.top = `${r}px`;
         const {
             width: o
         } = t.getBoundingClientRect(), a = n + o, l = a - s;
         t.style.left = `${a>s?n-l:n}px`, i.style.maxWidth = `${Math.min(o,s)}px`
     }
-    class qt extends Ot {
+    class qt extends Pt {
         constructor({
             parent: e,
             width: t
         }) {
             super({
                 parent: e,
                 width: t,
@@ -3009,15 +3009,15 @@
             this.colorHandlers = t, this.setActiveColorHandler("color"), this.createSwatches(e)
         }
         setActiveColorHandler(e) {
             this.activeColorHandler = this.colorHandlers[e]
         }
         createSwatches(e) {
             this.container.querySelectorAll(".igv-ui-color-swatch").forEach((e => e.remove()));
-            const t = Object.values(Pt);
+            const t = Object.values(Ot);
             for (let e of t) {
                 const t = pt({
                     class: "igv-ui-color-swatch"
                 });
                 this.container.appendChild(t), this.decorateSwatch(t, e)
             }
             if (e)
@@ -3033,20 +3033,20 @@
                 e.stopPropagation(), this.activeColorHandler(t)
             })), e.addEventListener("touchend", (e => {
                 e.stopPropagation(), this.activeColorHandler(t)
             }))
         }
     }
     if ("undefined" != typeof document) {
-        function Gb(e) {
+        function Hb(e) {
             for (let t of document.styleSheets)
                 if (t = t.href ? t.href.replace(/^.*[\\\/]/, "") : "", t === e) return !0;
             return !1
         }
-        Gb("igv-ui.css") || function() {
+        Hb("igv-ui.css") || function() {
             const e = document.createElement("style");
             e.setAttribute("type", "text/css"), e.setAttribute("title", "igv-ui.css"), e.innerHTML = '.igv-ui-popover {\n  cursor: default;\n  position: absolute;\n  z-index: 2048;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: 1px;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  background-color: white;\n}\n.igv-ui-popover > div:first-child {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-ui-popover > div:first-child > div:first-child {\n  margin-left: 4px;\n}\n.igv-ui-popover > div:first-child > div:last-child {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-ui-popover > div:first-child > div:last-child:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-ui-popover > div:last-child {\n  overflow-y: auto;\n  overflow-x: hidden;\n  max-height: 400px;\n  max-width: 800px;\n  background-color: white;\n}\n.igv-ui-popover > div:last-child > div {\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n  margin-left: 4px;\n  margin-right: 4px;\n  min-width: 220px;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.igv-ui-popover > div:last-child > div > span {\n  font-weight: bolder;\n}\n.igv-ui-popover > div:last-child hr {\n  width: 100%;\n}\n\n.igv-ui-alert-dialog-container {\n  box-sizing: content-box;\n  position: absolute;\n  z-index: 2048;\n  top: 50%;\n  left: 50%;\n  width: 400px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  outline: none;\n  font-family: "Open Sans", sans-serif;\n  font-size: 15px;\n  font-weight: 400;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n}\n.igv-ui-alert-dialog-container > div:first-child {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-ui-alert-dialog-container > div:first-child div:first-child {\n  padding-left: 8px;\n}\n.igv-ui-alert-dialog-container .igv-ui-alert-dialog-body {\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n  color: #373737;\n  width: 100%;\n  height: calc(100% - 24px - 64px);\n  overflow-y: scroll;\n}\n.igv-ui-alert-dialog-container .igv-ui-alert-dialog-body .igv-ui-alert-dialog-body-copy {\n  margin: 16px;\n  width: auto;\n  height: auto;\n  overflow-wrap: break-word;\n  word-break: break-word;\n  background-color: white;\n  border: unset;\n}\n.igv-ui-alert-dialog-container > div:last-child {\n  width: 100%;\n  margin-bottom: 10px;\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-ui-alert-dialog-container > div:last-child div {\n  margin: unset;\n  width: 40px;\n  height: 30px;\n  line-height: 30px;\n  text-align: center;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  border-color: #2B81AF;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 4px;\n  background-color: #2B81AF;\n}\n.igv-ui-alert-dialog-container > div:last-child div:hover {\n  cursor: pointer;\n  border-color: #25597f;\n  background-color: #25597f;\n}\n\n.igv-ui-color-swatch {\n  position: relative;\n  box-sizing: content-box;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: wrap;\n  justify-content: center;\n  align-items: center;\n  width: 32px;\n  height: 32px;\n  border-style: solid;\n  border-width: 2px;\n  border-color: white;\n  border-radius: 4px;\n}\n\n.igv-ui-color-swatch:hover {\n  border-color: dimgray;\n}\n\n.igv-ui-colorpicker-menu-close-button {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 32px;\n  margin-top: 4px;\n  margin-bottom: 4px;\n  padding-right: 8px;\n}\n.igv-ui-colorpicker-menu-close-button i.fa {\n  display: block;\n  margin-left: 4px;\n  margin-right: 4px;\n  color: #5f5f5f;\n}\n.igv-ui-colorpicker-menu-close-button i.fa:hover,\n.igv-ui-colorpicker-menu-close-button i.fa:focus,\n.igv-ui-colorpicker-menu-close-button i.fa:active {\n  cursor: pointer;\n  color: #0f0f0f;\n}\n\n.igv-ui-generic-dialog-container {\n  box-sizing: content-box;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  z-index: 2048;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-one-liner {\n  color: #373737;\n  width: 95%;\n  height: 24px;\n  line-height: 24px;\n  text-align: left;\n  margin-top: 8px;\n  padding-left: 8px;\n  overflow-wrap: break-word;\n  background-color: white;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input {\n  margin-top: 8px;\n  width: 95%;\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  padding-left: 8px;\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input div {\n  width: 30%;\n  height: 100%;\n  font-size: 16px;\n  text-align: right;\n  padding-right: 8px;\n  background-color: white;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {\n  width: 50%;\n  font-size: 16px;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input {\n  margin-top: 8px;\n  width: calc(100% - 16px);\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {\n  font-size: 16px;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel {\n  width: 100%;\n  height: 28px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div {\n  margin-top: 32px;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  width: 75px;\n  height: 28px;\n  line-height: 28px;\n  text-align: center;\n  border-color: transparent;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 2px;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child {\n  margin-left: 32px;\n  margin-right: 0;\n  background-color: #5ea4e0;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child {\n  margin-left: 0;\n  margin-right: 32px;\n  background-color: #c4c4c4;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child:hover {\n  cursor: pointer;\n  background-color: #3b5c7f;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child:hover {\n  cursor: pointer;\n  background-color: #7f7f7f;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok {\n  width: 100%;\n  height: 36px;\n  margin-top: 32px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div {\n  width: 98px;\n  height: 36px;\n  line-height: 36px;\n  text-align: center;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  border-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 4px;\n  background-color: #2B81AF;\n}\n.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div:hover {\n  cursor: pointer;\n  background-color: #25597f;\n}\n\n.igv-ui-generic-container {\n  box-sizing: content-box;\n  position: absolute;\n  z-index: 2048;\n  background-color: white;\n  cursor: pointer;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-ui-generic-container > div:first-child {\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  height: 24px;\n  width: 100%;\n  background-color: #dddddd;\n}\n.igv-ui-generic-container > div:first-child > div {\n  display: block;\n  color: #5f5f5f;\n  cursor: pointer;\n  width: 14px;\n  height: 14px;\n  margin-right: 8px;\n  margin-bottom: 4px;\n}\n\n.igv-ui-dialog {\n  z-index: 2048;\n  position: fixed;\n  width: fit-content;\n  height: fit-content;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  background-color: white;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n}\n.igv-ui-dialog .igv-ui-dialog-header {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-ui-dialog .igv-ui-dialog-header div {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-ui-dialog .igv-ui-dialog-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-ui-dialog .igv-ui-dialog-one-liner {\n  width: 95%;\n  height: 24px;\n  line-height: 24px;\n  text-align: left;\n  margin: 8px;\n  overflow-wrap: break-word;\n  background-color: white;\n  font-weight: bold;\n}\n.igv-ui-dialog .igv-ui-dialog-ok-cancel {\n  width: 100%;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-ui-dialog .igv-ui-dialog-ok-cancel div {\n  margin: 16px;\n  margin-top: 32px;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  width: 75px;\n  height: 28px;\n  line-height: 28px;\n  text-align: center;\n  border-color: transparent;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 2px;\n}\n.igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child {\n  background-color: #5ea4e0;\n}\n.igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child {\n  background-color: #c4c4c4;\n}\n.igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child:hover {\n  cursor: pointer;\n  background-color: #3b5c7f;\n}\n.igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child:hover {\n  cursor: pointer;\n  background-color: #7f7f7f;\n}\n.igv-ui-dialog .igv-ui-dialog-ok {\n  width: 100%;\n  height: 36px;\n  margin-top: 32px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-ui-dialog .igv-ui-dialog-ok div {\n  width: 98px;\n  height: 36px;\n  line-height: 36px;\n  text-align: center;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  border-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 4px;\n  background-color: #2B81AF;\n}\n.igv-ui-dialog .igv-ui-dialog-ok div:hover {\n  cursor: pointer;\n  background-color: #25597f;\n}\n\n.igv-ui-panel, .igv-ui-panel-row, .igv-ui-panel-column {\n  z-index: 2048;\n  background-color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  display: flex;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n\n.igv-ui-panel-column {\n  display: flex;\n  flex-direction: column;\n}\n\n.igv-ui-panel-row {\n  display: flex;\n  flex-direction: row;\n}\n\n.igv-ui-textbox {\n  background-color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  display: flex;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n\n.igv-ui-table {\n  background-color: white;\n}\n\n.igv-ui-table thead {\n  position: sticky;\n  top: 0;\n}\n\n.igv-ui-table th {\n  text-align: left;\n}\n\n.igv-ui-table td {\n  padding-right: 20px;\n}\n\n.igv-ui-table tr:hover {\n  background-color: lightblue;\n}\n\n/*# sourceMappingURL=igv-ui.css.map */\n', document.head.append(e)
         }()
     }
 
     function jt(e, t) {
         const i = _t.div({
@@ -3222,15 +3222,15 @@
             }), t.append(this.$container), this.$container.offset({
                 left: 0,
                 top: 0
             });
             const n = ft("<div>", {
                 class: "igv-generic-dialog-header"
             });
-            this.$container.append(n), Tt.attachDialogCloseHandlerWithParent(n[0], (() => {
+            this.$container.append(n), Mt.attachDialogCloseHandlerWithParent(n[0], (() => {
                 this.$minimum_input.val(void 0), this.$maximum_input.val(void 0), this.$container.offset({
                     left: 0,
                     top: 0
                 }), this.$container.hide()
             })), this.$minimum = ft("<div>", {
                 class: "igv-generic-dialog-label-input"
             }), this.$container.append(this.$minimum);
@@ -3316,128 +3316,127 @@
         }
         throw Error("Expected File or string, got " + typeof e)
     }
 
     function ti(e) {
         return !!e && ("function" != typeof e && (e instanceof File || e.hasOwnProperty("name") && "function" == typeof e.slice && "function" == typeof e.arrayBuffer))
     }
-    const ii = ti;
 
-    function ni(e, t) {
+    function ii(e, t) {
         const i = document.createElement("a");
         i.setAttribute("href", t), i.setAttribute("download", e), i.style.display = "none", document.body.appendChild(i), i.click(), document.body.removeChild(i)
     }
 
-    function ri(e) {
-        for (var t = si, i = t.parser.loose.exec(e), n = {}, r = 14; r--;) n[t.key[r]] = i[r] || "";
+    function ni(e) {
+        for (var t = ri, i = t.parser.loose.exec(e), n = {}, r = 14; r--;) n[t.key[r]] = i[r] || "";
         return n[t.q.name] = {}, n[t.key[12]].replace(t.q.parser, (function(e, i, r) {
             i && (n[t.q.name][i] = r)
         })), n
     }
     "object" == typeof process && "undefined" == typeof window && (global.atob = function(e) {
         return Buffer.from(e, "base64").toString("binary")
     });
-    const si = {
+    const ri = {
         strictMode: !1,
         key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
         q: {
             name: "queryKey",
             parser: /(?:^|&)([^&=]*)=?([^&]*)/g
         },
         parser: {
             strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
             loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
         }
     };
 
-    function oi(e) {
+    function si(e) {
         let t = e.length;
         for (; --t >= 0;) e[t] = 0
     }
-    const ai = 256,
-        li = 286,
-        hi = 30,
-        ci = 15,
-        di = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
-        ui = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
-        fi = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
-        pi = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
-        gi = new Array(576);
-    oi(gi);
-    const mi = new Array(60);
-    oi(mi);
-    const bi = new Array(512);
-    oi(bi);
-    const wi = new Array(256);
-    oi(wi);
-    const vi = new Array(29);
-    oi(vi);
-    const yi = new Array(hi);
+    const oi = 256,
+        ai = 286,
+        li = 30,
+        hi = 15,
+        ci = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
+        di = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
+        ui = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
+        fi = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
+        pi = new Array(576);
+    si(pi);
+    const gi = new Array(60);
+    si(gi);
+    const mi = new Array(512);
+    si(mi);
+    const bi = new Array(256);
+    si(bi);
+    const wi = new Array(29);
+    si(wi);
+    const vi = new Array(li);
 
-    function _i(e, t, i, n, r) {
+    function yi(e, t, i, n, r) {
         this.static_tree = e, this.extra_bits = t, this.extra_base = i, this.elems = n, this.max_length = r, this.has_stree = e && e.length
     }
-    let xi, ki, Ci;
+    let _i, xi, ki;
 
-    function Si(e, t) {
+    function Ci(e, t) {
         this.dyn_tree = e, this.max_code = 0, this.stat_desc = t
     }
-    oi(yi);
-    const Ai = e => e < 256 ? bi[e] : bi[256 + (e >>> 7)],
-        Ei = (e, t) => {
+    si(vi);
+    const Si = e => e < 256 ? mi[e] : mi[256 + (e >>> 7)],
+        Ai = (e, t) => {
             e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255
         },
-        Ti = (e, t, i) => {
-            e.bi_valid > 16 - i ? (e.bi_buf |= t << e.bi_valid & 65535, Ei(e, e.bi_buf), e.bi_buf = t >> 16 - e.bi_valid, e.bi_valid += i - 16) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += i)
+        Ei = (e, t, i) => {
+            e.bi_valid > 16 - i ? (e.bi_buf |= t << e.bi_valid & 65535, Ai(e, e.bi_buf), e.bi_buf = t >> 16 - e.bi_valid, e.bi_valid += i - 16) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += i)
         },
         Mi = (e, t, i) => {
-            Ti(e, i[2 * t], i[2 * t + 1])
+            Ei(e, i[2 * t], i[2 * t + 1])
         },
-        Ri = (e, t) => {
+        Ti = (e, t) => {
             let i = 0;
             do {
                 i |= 1 & e, e >>>= 1, i <<= 1
             } while (--t > 0);
             return i >>> 1
         },
-        Li = (e, t, i) => {
+        Ri = (e, t, i) => {
             const n = new Array(16);
             let r, s, o = 0;
-            for (r = 1; r <= ci; r++) o = o + i[r - 1] << 1, n[r] = o;
+            for (r = 1; r <= hi; r++) o = o + i[r - 1] << 1, n[r] = o;
             for (s = 0; s <= t; s++) {
                 let t = e[2 * s + 1];
-                0 !== t && (e[2 * s] = Ri(n[t]++, t))
+                0 !== t && (e[2 * s] = Ti(n[t]++, t))
             }
         },
-        Ii = e => {
+        Li = e => {
             let t;
-            for (t = 0; t < li; t++) e.dyn_ltree[2 * t] = 0;
-            for (t = 0; t < hi; t++) e.dyn_dtree[2 * t] = 0;
+            for (t = 0; t < ai; t++) e.dyn_ltree[2 * t] = 0;
+            for (t = 0; t < li; t++) e.dyn_dtree[2 * t] = 0;
             for (t = 0; t < 19; t++) e.bl_tree[2 * t] = 0;
             e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0
         },
-        Bi = e => {
-            e.bi_valid > 8 ? Ei(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0
+        Ii = e => {
+            e.bi_valid > 8 ? Ai(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0
         },
-        Ni = (e, t, i, n) => {
+        Bi = (e, t, i, n) => {
             const r = 2 * t,
                 s = 2 * i;
             return e[r] < e[s] || e[r] === e[s] && n[t] <= n[i]
         },
         Fi = (e, t, i) => {
             const n = e.heap[i];
             let r = i << 1;
-            for (; r <= e.heap_len && (r < e.heap_len && Ni(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !Ni(t, n, e.heap[r], e.depth));) e.heap[i] = e.heap[r], i = r, r <<= 1;
+            for (; r <= e.heap_len && (r < e.heap_len && Bi(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !Bi(t, n, e.heap[r], e.depth));) e.heap[i] = e.heap[r], i = r, r <<= 1;
             e.heap[i] = n
         },
-        Pi = (e, t, i) => {
+        Ni = (e, t, i) => {
             let n, r, s, o, a = 0;
             if (0 !== e.sym_next)
                 do {
-                    n = 255 & e.pending_buf[e.sym_buf + a++], n += (255 & e.pending_buf[e.sym_buf + a++]) << 8, r = e.pending_buf[e.sym_buf + a++], 0 === n ? Mi(e, r, t) : (s = wi[r], Mi(e, s + ai + 1, t), o = di[s], 0 !== o && (r -= vi[s], Ti(e, r, o)), n--, s = Ai(n), Mi(e, s, i), o = ui[s], 0 !== o && (n -= yi[s], Ti(e, n, o)))
+                    n = 255 & e.pending_buf[e.sym_buf + a++], n += (255 & e.pending_buf[e.sym_buf + a++]) << 8, r = e.pending_buf[e.sym_buf + a++], 0 === n ? Mi(e, r, t) : (s = bi[r], Mi(e, s + oi + 1, t), o = ci[s], 0 !== o && (r -= wi[s], Ei(e, r, o)), n--, s = Si(n), Mi(e, s, i), o = di[s], 0 !== o && (n -= vi[s], Ei(e, n, o)))
                 } while (a < e.sym_next);
             Mi(e, 256, t)
         },
         Oi = (e, t) => {
             const i = t.dyn_tree,
                 n = t.stat_desc.static_tree,
                 r = t.stat_desc.has_stree,
@@ -3455,144 +3454,144 @@
                     n = t.max_code,
                     r = t.stat_desc.static_tree,
                     s = t.stat_desc.has_stree,
                     o = t.stat_desc.extra_bits,
                     a = t.stat_desc.extra_base,
                     l = t.stat_desc.max_length;
                 let h, c, d, u, f, p, g = 0;
-                for (u = 0; u <= ci; u++) e.bl_count[u] = 0;
+                for (u = 0; u <= hi; u++) e.bl_count[u] = 0;
                 for (i[2 * e.heap[e.heap_max] + 1] = 0, h = e.heap_max + 1; h < 573; h++) c = e.heap[h], u = i[2 * i[2 * c + 1] + 1] + 1, u > l && (u = l, g++), i[2 * c + 1] = u, c > n || (e.bl_count[u]++, f = 0, c >= a && (f = o[c - a]), p = i[2 * c], e.opt_len += p * (u + f), s && (e.static_len += p * (r[2 * c + 1] + f)));
                 if (0 !== g) {
                     do {
                         for (u = l - 1; 0 === e.bl_count[u];) u--;
                         e.bl_count[u]--, e.bl_count[u + 1] += 2, e.bl_count[l]--, g -= 2
                     } while (g > 0);
                     for (u = l; 0 !== u; u--)
                         for (c = e.bl_count[u]; 0 !== c;) d = e.heap[--h], d > n || (i[2 * d + 1] !== u && (e.opt_len += (u - i[2 * d + 1]) * i[2 * d], i[2 * d + 1] = u), c--)
                 }
-            })(e, t), Li(i, h, e.bl_count)
+            })(e, t), Ri(i, h, e.bl_count)
         },
-        Di = (e, t, i) => {
+        Pi = (e, t, i) => {
             let n, r, s = -1,
                 o = t[1],
                 a = 0,
                 l = 7,
                 h = 4;
             for (0 === o && (l = 138, h = 3), t[2 * (i + 1) + 1] = 65535, n = 0; n <= i; n++) r = o, o = t[2 * (n + 1) + 1], ++a < l && r === o || (a < h ? e.bl_tree[2 * r] += a : 0 !== r ? (r !== s && e.bl_tree[2 * r]++, e.bl_tree[32]++) : a <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, a = 0, s = r, 0 === o ? (l = 138, h = 3) : r === o ? (l = 6, h = 3) : (l = 7, h = 4))
         },
-        zi = (e, t, i) => {
+        Di = (e, t, i) => {
             let n, r, s = -1,
                 o = t[1],
                 a = 0,
                 l = 7,
                 h = 4;
             for (0 === o && (l = 138, h = 3), n = 0; n <= i; n++)
                 if (r = o, o = t[2 * (n + 1) + 1], !(++a < l && r === o)) {
                     if (a < h)
                         do {
                             Mi(e, r, e.bl_tree)
                         } while (0 != --a);
-                    else 0 !== r ? (r !== s && (Mi(e, r, e.bl_tree), a--), Mi(e, 16, e.bl_tree), Ti(e, a - 3, 2)) : a <= 10 ? (Mi(e, 17, e.bl_tree), Ti(e, a - 3, 3)) : (Mi(e, 18, e.bl_tree), Ti(e, a - 11, 7));
+                    else 0 !== r ? (r !== s && (Mi(e, r, e.bl_tree), a--), Mi(e, 16, e.bl_tree), Ei(e, a - 3, 2)) : a <= 10 ? (Mi(e, 17, e.bl_tree), Ei(e, a - 3, 3)) : (Mi(e, 18, e.bl_tree), Ei(e, a - 11, 7));
                     a = 0, s = r, 0 === o ? (l = 138, h = 3) : r === o ? (l = 6, h = 3) : (l = 7, h = 4)
                 }
         };
-    let Hi = !1;
-    const Vi = (e, t, i, n) => {
-        Ti(e, 0 + (n ? 1 : 0), 3), Bi(e), Ei(e, i), Ei(e, ~i), i && e.pending_buf.set(e.window.subarray(t, t + i), e.pending), e.pending += i
+    let zi = !1;
+    const Hi = (e, t, i, n) => {
+        Ei(e, 0 + (n ? 1 : 0), 3), Ii(e), Ai(e, i), Ai(e, ~i), i && e.pending_buf.set(e.window.subarray(t, t + i), e.pending), e.pending += i
     };
-    var Ui = (e, t, i, n) => {
+    var Vi = (e, t, i, n) => {
             let r, s, o = 0;
             e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e => {
                 let t, i = 4093624447;
                 for (t = 0; t <= 31; t++, i >>>= 1)
                     if (1 & i && 0 !== e.dyn_ltree[2 * t]) return 0;
                 if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1;
-                for (t = 32; t < ai; t++)
+                for (t = 32; t < oi; t++)
                     if (0 !== e.dyn_ltree[2 * t]) return 1;
                 return 0
             })(e)), Oi(e, e.l_desc), Oi(e, e.d_desc), o = (e => {
                 let t;
-                for (Di(e, e.dyn_ltree, e.l_desc.max_code), Di(e, e.dyn_dtree, e.d_desc.max_code), Oi(e, e.bl_desc), t = 18; t >= 3 && 0 === e.bl_tree[2 * pi[t] + 1]; t--);
+                for (Pi(e, e.dyn_ltree, e.l_desc.max_code), Pi(e, e.dyn_dtree, e.d_desc.max_code), Oi(e, e.bl_desc), t = 18; t >= 3 && 0 === e.bl_tree[2 * fi[t] + 1]; t--);
                 return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t
-            })(e), r = e.opt_len + 3 + 7 >>> 3, s = e.static_len + 3 + 7 >>> 3, s <= r && (r = s)) : r = s = i + 5, i + 4 <= r && -1 !== t ? Vi(e, t, i, n) : 4 === e.strategy || s === r ? (Ti(e, 2 + (n ? 1 : 0), 3), Pi(e, gi, mi)) : (Ti(e, 4 + (n ? 1 : 0), 3), ((e, t, i, n) => {
+            })(e), r = e.opt_len + 3 + 7 >>> 3, s = e.static_len + 3 + 7 >>> 3, s <= r && (r = s)) : r = s = i + 5, i + 4 <= r && -1 !== t ? Hi(e, t, i, n) : 4 === e.strategy || s === r ? (Ei(e, 2 + (n ? 1 : 0), 3), Ni(e, pi, gi)) : (Ei(e, 4 + (n ? 1 : 0), 3), ((e, t, i, n) => {
                 let r;
-                for (Ti(e, t - 257, 5), Ti(e, i - 1, 5), Ti(e, n - 4, 4), r = 0; r < n; r++) Ti(e, e.bl_tree[2 * pi[r] + 1], 3);
-                zi(e, e.dyn_ltree, t - 1), zi(e, e.dyn_dtree, i - 1)
-            })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1), Pi(e, e.dyn_ltree, e.dyn_dtree)), Ii(e), n && Bi(e)
+                for (Ei(e, t - 257, 5), Ei(e, i - 1, 5), Ei(e, n - 4, 4), r = 0; r < n; r++) Ei(e, e.bl_tree[2 * fi[r] + 1], 3);
+                Di(e, e.dyn_ltree, t - 1), Di(e, e.dyn_dtree, i - 1)
+            })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1), Ni(e, e.dyn_ltree, e.dyn_dtree)), Li(e), n && Ii(e)
         },
-        qi = {
+        Ui = {
             _tr_init: e => {
-                Hi || ((() => {
+                zi || ((() => {
                     let e, t, i, n, r;
                     const s = new Array(16);
                     for (i = 0, n = 0; n < 28; n++)
-                        for (vi[n] = i, e = 0; e < 1 << di[n]; e++) wi[i++] = n;
-                    for (wi[i - 1] = n, r = 0, n = 0; n < 16; n++)
-                        for (yi[n] = r, e = 0; e < 1 << ui[n]; e++) bi[r++] = n;
-                    for (r >>= 7; n < hi; n++)
-                        for (yi[n] = r << 7, e = 0; e < 1 << ui[n] - 7; e++) bi[256 + r++] = n;
-                    for (t = 0; t <= ci; t++) s[t] = 0;
-                    for (e = 0; e <= 143;) gi[2 * e + 1] = 8, e++, s[8]++;
-                    for (; e <= 255;) gi[2 * e + 1] = 9, e++, s[9]++;
-                    for (; e <= 279;) gi[2 * e + 1] = 7, e++, s[7]++;
-                    for (; e <= 287;) gi[2 * e + 1] = 8, e++, s[8]++;
-                    for (Li(gi, 287, s), e = 0; e < hi; e++) mi[2 * e + 1] = 5, mi[2 * e] = Ri(e, 5);
-                    xi = new _i(gi, di, 257, li, ci), ki = new _i(mi, ui, 0, hi, ci), Ci = new _i(new Array(0), fi, 0, 19, 7)
-                })(), Hi = !0), e.l_desc = new Si(e.dyn_ltree, xi), e.d_desc = new Si(e.dyn_dtree, ki), e.bl_desc = new Si(e.bl_tree, Ci), e.bi_buf = 0, e.bi_valid = 0, Ii(e)
+                        for (wi[n] = i, e = 0; e < 1 << ci[n]; e++) bi[i++] = n;
+                    for (bi[i - 1] = n, r = 0, n = 0; n < 16; n++)
+                        for (vi[n] = r, e = 0; e < 1 << di[n]; e++) mi[r++] = n;
+                    for (r >>= 7; n < li; n++)
+                        for (vi[n] = r << 7, e = 0; e < 1 << di[n] - 7; e++) mi[256 + r++] = n;
+                    for (t = 0; t <= hi; t++) s[t] = 0;
+                    for (e = 0; e <= 143;) pi[2 * e + 1] = 8, e++, s[8]++;
+                    for (; e <= 255;) pi[2 * e + 1] = 9, e++, s[9]++;
+                    for (; e <= 279;) pi[2 * e + 1] = 7, e++, s[7]++;
+                    for (; e <= 287;) pi[2 * e + 1] = 8, e++, s[8]++;
+                    for (Ri(pi, 287, s), e = 0; e < li; e++) gi[2 * e + 1] = 5, gi[2 * e] = Ti(e, 5);
+                    _i = new yi(pi, ci, 257, ai, hi), xi = new yi(gi, di, 0, li, hi), ki = new yi(new Array(0), ui, 0, 19, 7)
+                })(), zi = !0), e.l_desc = new Ci(e.dyn_ltree, _i), e.d_desc = new Ci(e.dyn_dtree, xi), e.bl_desc = new Ci(e.bl_tree, ki), e.bi_buf = 0, e.bi_valid = 0, Li(e)
             },
-            _tr_stored_block: Vi,
-            _tr_flush_block: Ui,
-            _tr_tally: (e, t, i) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = i, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * (wi[i] + ai + 1)]++, e.dyn_dtree[2 * Ai(t)]++), e.sym_next === e.sym_end),
+            _tr_stored_block: Hi,
+            _tr_flush_block: Vi,
+            _tr_tally: (e, t, i) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = i, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * (bi[i] + oi + 1)]++, e.dyn_dtree[2 * Si(t)]++), e.sym_next === e.sym_end),
             _tr_align: e => {
-                Ti(e, 2, 3), Mi(e, 256, gi), (e => {
-                    16 === e.bi_valid ? (Ei(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8)
+                Ei(e, 2, 3), Mi(e, 256, pi), (e => {
+                    16 === e.bi_valid ? (Ai(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8)
                 })(e)
             }
         };
-    var ji = (e, t, i, n) => {
+    var qi = (e, t, i, n) => {
         let r = 65535 & e | 0,
             s = e >>> 16 & 65535 | 0,
             o = 0;
         for (; 0 !== i;) {
             o = i > 2e3 ? 2e3 : i, i -= o;
             do {
                 r = r + t[n++] | 0, s = s + r | 0
             } while (--o);
             r %= 65521, s %= 65521
         }
         return r | s << 16 | 0
     };
-    const $i = new Uint32Array((() => {
+    const ji = new Uint32Array((() => {
         let e, t = [];
         for (var i = 0; i < 256; i++) {
             e = i;
             for (var n = 0; n < 8; n++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
             t[i] = e
         }
         return t
     })());
-    var Wi = (e, t, i, n) => {
-            const r = $i,
+    var $i = (e, t, i, n) => {
+            const r = ji,
                 s = n + i;
             e ^= -1;
             for (let i = n; i < s; i++) e = e >>> 8 ^ r[255 & (e ^ t[i])];
             return -1 ^ e
         },
-        Gi = {
+        Wi = {
             2: "need dictionary",
             1: "stream end",
             0: "",
             "-1": "file error",
             "-2": "stream error",
             "-3": "data error",
             "-4": "insufficient memory",
             "-5": "buffer error",
             "-6": "incompatible version"
         },
-        Zi = {
+        Gi = {
             Z_NO_FLUSH: 0,
             Z_PARTIAL_FLUSH: 1,
             Z_SYNC_FLUSH: 2,
             Z_FULL_FLUSH: 3,
             Z_FINISH: 4,
             Z_BLOCK: 5,
             Z_TREES: 6,
@@ -3615,334 +3614,334 @@
             Z_DEFAULT_STRATEGY: 0,
             Z_BINARY: 0,
             Z_TEXT: 1,
             Z_UNKNOWN: 2,
             Z_DEFLATED: 8
         };
     const {
-        _tr_init: Qi,
-        _tr_stored_block: Xi,
-        _tr_flush_block: Yi,
-        _tr_tally: Ki,
-        _tr_align: Ji
-    } = qi, {
-        Z_NO_FLUSH: en,
-        Z_PARTIAL_FLUSH: tn,
-        Z_FULL_FLUSH: nn,
-        Z_FINISH: rn,
-        Z_BLOCK: sn,
-        Z_OK: on,
-        Z_STREAM_END: an,
-        Z_STREAM_ERROR: ln,
-        Z_DATA_ERROR: hn,
-        Z_BUF_ERROR: cn,
-        Z_DEFAULT_COMPRESSION: dn,
-        Z_FILTERED: un,
-        Z_HUFFMAN_ONLY: fn,
-        Z_RLE: pn,
-        Z_FIXED: gn,
-        Z_DEFAULT_STRATEGY: mn,
-        Z_UNKNOWN: bn,
-        Z_DEFLATED: wn
-    } = Zi, vn = 286, yn = 30, _n = 19, xn = 2 * vn + 1, kn = 15, Cn = 258, Sn = 262, An = 42, En = 113, Tn = 666, Mn = (e, t) => (e.msg = Gi[t], t), Rn = e => 2 * e - (e > 4 ? 9 : 0), Ln = e => {
+        _tr_init: Zi,
+        _tr_stored_block: Qi,
+        _tr_flush_block: Xi,
+        _tr_tally: Yi,
+        _tr_align: Ki
+    } = Ui, {
+        Z_NO_FLUSH: Ji,
+        Z_PARTIAL_FLUSH: en,
+        Z_FULL_FLUSH: tn,
+        Z_FINISH: nn,
+        Z_BLOCK: rn,
+        Z_OK: sn,
+        Z_STREAM_END: on,
+        Z_STREAM_ERROR: an,
+        Z_DATA_ERROR: ln,
+        Z_BUF_ERROR: hn,
+        Z_DEFAULT_COMPRESSION: cn,
+        Z_FILTERED: dn,
+        Z_HUFFMAN_ONLY: un,
+        Z_RLE: fn,
+        Z_FIXED: pn,
+        Z_DEFAULT_STRATEGY: gn,
+        Z_UNKNOWN: mn,
+        Z_DEFLATED: bn
+    } = Gi, wn = 258, vn = 262, yn = 42, _n = 113, xn = 666, kn = (e, t) => (e.msg = Wi[t], t), Cn = e => 2 * e - (e > 4 ? 9 : 0), Sn = e => {
         let t = e.length;
         for (; --t >= 0;) e[t] = 0
-    }, In = e => {
+    }, An = e => {
         let t, i, n, r = e.w_size;
         t = e.hash_size, n = t;
         do {
             i = e.head[--n], e.head[n] = i >= r ? i - r : 0
         } while (--t);
         t = r, n = t;
         do {
             i = e.prev[--n], e.prev[n] = i >= r ? i - r : 0
         } while (--t)
     };
-    let Bn = (e, t, i) => (t << e.hash_shift ^ i) & e.hash_mask;
-    const Nn = e => {
+    let En = (e, t, i) => (t << e.hash_shift ^ i) & e.hash_mask;
+    const Mn = e => {
             const t = e.state;
             let i = t.pending;
             i > e.avail_out && (i = e.avail_out), 0 !== i && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + i), e.next_out), e.next_out += i, t.pending_out += i, e.total_out += i, e.avail_out -= i, t.pending -= i, 0 === t.pending && (t.pending_out = 0))
         },
-        Fn = (e, t) => {
-            Yi(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Nn(e.strm)
+        Tn = (e, t) => {
+            Xi(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Mn(e.strm)
         },
-        Pn = (e, t) => {
+        Rn = (e, t) => {
             e.pending_buf[e.pending++] = t
         },
-        On = (e, t) => {
+        Ln = (e, t) => {
             e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t
         },
-        Dn = (e, t, i, n) => {
+        In = (e, t, i, n) => {
             let r = e.avail_in;
-            return r > n && (r = n), 0 === r ? 0 : (e.avail_in -= r, t.set(e.input.subarray(e.next_in, e.next_in + r), i), 1 === e.state.wrap ? e.adler = ji(e.adler, t, r, i) : 2 === e.state.wrap && (e.adler = Wi(e.adler, t, r, i)), e.next_in += r, e.total_in += r, r)
+            return r > n && (r = n), 0 === r ? 0 : (e.avail_in -= r, t.set(e.input.subarray(e.next_in, e.next_in + r), i), 1 === e.state.wrap ? e.adler = qi(e.adler, t, r, i) : 2 === e.state.wrap && (e.adler = $i(e.adler, t, r, i)), e.next_in += r, e.total_in += r, r)
         },
-        zn = (e, t) => {
+        Bn = (e, t) => {
             let i, n, r = e.max_chain_length,
                 s = e.strstart,
                 o = e.prev_length,
                 a = e.nice_match;
-            const l = e.strstart > e.w_size - Sn ? e.strstart - (e.w_size - Sn) : 0,
+            const l = e.strstart > e.w_size - vn ? e.strstart - (e.w_size - vn) : 0,
                 h = e.window,
                 c = e.w_mask,
                 d = e.prev,
-                u = e.strstart + Cn;
+                u = e.strstart + wn;
             let f = h[s + o - 1],
                 p = h[s + o];
             e.prev_length >= e.good_match && (r >>= 2), a > e.lookahead && (a = e.lookahead);
             do {
                 if (i = t, h[i + o] === p && h[i + o - 1] === f && h[i] === h[s] && h[++i] === h[s + 1]) {
                     s += 2, i++;
                     do {} while (h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && s < u);
-                    if (n = Cn - (u - s), s = u - Cn, n > o) {
+                    if (n = wn - (u - s), s = u - wn, n > o) {
                         if (e.match_start = t, o = n, n >= a) break;
                         f = h[s + o - 1], p = h[s + o]
                     }
                 }
             } while ((t = d[t & c]) > l && 0 != --r);
             return o <= e.lookahead ? o : e.lookahead
         },
-        Hn = e => {
+        Fn = e => {
             const t = e.w_size;
             let i, n, r;
             do {
-                if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - Sn) && (e.window.set(e.window.subarray(t, t + t - n), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), In(e), n += t), 0 === e.strm.avail_in) break;
-                if (i = Dn(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += i, e.lookahead + e.insert >= 3)
-                    for (r = e.strstart - e.insert, e.ins_h = e.window[r], e.ins_h = Bn(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = Bn(e, e.ins_h, e.window[r + 3 - 1]), e.prev[r & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = r, r++, e.insert--, !(e.lookahead + e.insert < 3)););
-            } while (e.lookahead < Sn && 0 !== e.strm.avail_in)
+                if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - vn) && (e.window.set(e.window.subarray(t, t + t - n), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), An(e), n += t), 0 === e.strm.avail_in) break;
+                if (i = In(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += i, e.lookahead + e.insert >= 3)
+                    for (r = e.strstart - e.insert, e.ins_h = e.window[r], e.ins_h = En(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = En(e, e.ins_h, e.window[r + 3 - 1]), e.prev[r & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = r, r++, e.insert--, !(e.lookahead + e.insert < 3)););
+            } while (e.lookahead < vn && 0 !== e.strm.avail_in)
         },
-        Vn = (e, t) => {
+        Nn = (e, t) => {
             let i, n, r, s = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5,
                 o = 0,
                 a = e.strm.avail_in;
             do {
                 if (i = 65535, r = e.bi_valid + 42 >> 3, e.strm.avail_out < r) break;
-                if (r = e.strm.avail_out - r, n = e.strstart - e.block_start, i > n + e.strm.avail_in && (i = n + e.strm.avail_in), i > r && (i = r), i < s && (0 === i && t !== rn || t === en || i !== n + e.strm.avail_in)) break;
-                o = t === rn && i === n + e.strm.avail_in ? 1 : 0, Xi(e, 0, 0, o), e.pending_buf[e.pending - 4] = i, e.pending_buf[e.pending - 3] = i >> 8, e.pending_buf[e.pending - 2] = ~i, e.pending_buf[e.pending - 1] = ~i >> 8, Nn(e.strm), n && (n > i && (n = i), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + n), e.strm.next_out), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n, e.block_start += n, i -= n), i && (Dn(e.strm, e.strm.output, e.strm.next_out, i), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i)
+                if (r = e.strm.avail_out - r, n = e.strstart - e.block_start, i > n + e.strm.avail_in && (i = n + e.strm.avail_in), i > r && (i = r), i < s && (0 === i && t !== nn || t === Ji || i !== n + e.strm.avail_in)) break;
+                o = t === nn && i === n + e.strm.avail_in ? 1 : 0, Qi(e, 0, 0, o), e.pending_buf[e.pending - 4] = i, e.pending_buf[e.pending - 3] = i >> 8, e.pending_buf[e.pending - 2] = ~i, e.pending_buf[e.pending - 1] = ~i >> 8, Mn(e.strm), n && (n > i && (n = i), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + n), e.strm.next_out), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n, e.block_start += n, i -= n), i && (In(e.strm, e.strm.output, e.strm.next_out, i), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i)
             } while (0 === o);
-            return a -= e.strm.avail_in, a && (a >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= a && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - a, e.strm.next_in), e.strstart), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), o ? 4 : t !== en && t !== rn && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart, e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, r += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), r > e.strm.avail_in && (r = e.strm.avail_in), r && (Dn(e.strm, e.window, e.strstart, r), e.strstart += r, e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r), e.high_water < e.strstart && (e.high_water = e.strstart), r = e.bi_valid + 42 >> 3, r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r, s = r > e.w_size ? e.w_size : r, n = e.strstart - e.block_start, (n >= s || (n || t === rn) && t !== en && 0 === e.strm.avail_in && n <= r) && (i = n > r ? r : n, o = t === rn && 0 === e.strm.avail_in && i === n ? 1 : 0, Xi(e, e.block_start, i, o), e.block_start += i, Nn(e.strm)), o ? 3 : 1)
+            return a -= e.strm.avail_in, a && (a >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= a && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - a, e.strm.next_in), e.strstart), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), o ? 4 : t !== Ji && t !== nn && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart, e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, r += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), r > e.strm.avail_in && (r = e.strm.avail_in), r && (In(e.strm, e.window, e.strstart, r), e.strstart += r, e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r), e.high_water < e.strstart && (e.high_water = e.strstart), r = e.bi_valid + 42 >> 3, r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r, s = r > e.w_size ? e.w_size : r, n = e.strstart - e.block_start, (n >= s || (n || t === nn) && t !== Ji && 0 === e.strm.avail_in && n <= r) && (i = n > r ? r : n, o = t === nn && 0 === e.strm.avail_in && i === n ? 1 : 0, Qi(e, e.block_start, i, o), e.block_start += i, Mn(e.strm)), o ? 3 : 1)
         },
-        Un = (e, t) => {
+        On = (e, t) => {
             let i, n;
             for (;;) {
-                if (e.lookahead < Sn) {
-                    if (Hn(e), e.lookahead < Sn && t === en) return 1;
+                if (e.lookahead < vn) {
+                    if (Fn(e), e.lookahead < vn && t === Ji) return 1;
                     if (0 === e.lookahead) break
                 }
-                if (i = 0, e.lookahead >= 3 && (e.ins_h = Bn(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== i && e.strstart - i <= e.w_size - Sn && (e.match_length = zn(e, i)), e.match_length >= 3)
-                    if (n = Ki(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
+                if (i = 0, e.lookahead >= 3 && (e.ins_h = En(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== i && e.strstart - i <= e.w_size - vn && (e.match_length = Bn(e, i)), e.match_length >= 3)
+                    if (n = Yi(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
                         e.match_length--;
                         do {
-                            e.strstart++, e.ins_h = Bn(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart
+                            e.strstart++, e.ins_h = En(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart
                         } while (0 != --e.match_length);
                         e.strstart++
-                    } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Bn(e, e.ins_h, e.window[e.strstart + 1]);
-                else n = Ki(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
-                if (n && (Fn(e, !1), 0 === e.strm.avail_out)) return 1
+                    } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = En(e, e.ins_h, e.window[e.strstart + 1]);
+                else n = Yi(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
+                if (n && (Tn(e, !1), 0 === e.strm.avail_out)) return 1
             }
-            return e.insert = e.strstart < 2 ? e.strstart : 2, t === rn ? (Fn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Fn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
+            return e.insert = e.strstart < 2 ? e.strstart : 2, t === nn ? (Tn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
         },
-        qn = (e, t) => {
+        Pn = (e, t) => {
             let i, n, r;
             for (;;) {
-                if (e.lookahead < Sn) {
-                    if (Hn(e), e.lookahead < Sn && t === en) return 1;
+                if (e.lookahead < vn) {
+                    if (Fn(e), e.lookahead < vn && t === Ji) return 1;
                     if (0 === e.lookahead) break
                 }
-                if (i = 0, e.lookahead >= 3 && (e.ins_h = Bn(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, 0 !== i && e.prev_length < e.max_lazy_match && e.strstart - i <= e.w_size - Sn && (e.match_length = zn(e, i), e.match_length <= 5 && (e.strategy === un || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)), e.prev_length >= 3 && e.match_length <= e.prev_length) {
-                    r = e.strstart + e.lookahead - 3, n = Ki(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
+                if (i = 0, e.lookahead >= 3 && (e.ins_h = En(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, 0 !== i && e.prev_length < e.max_lazy_match && e.strstart - i <= e.w_size - vn && (e.match_length = Bn(e, i), e.match_length <= 5 && (e.strategy === dn || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)), e.prev_length >= 3 && e.match_length <= e.prev_length) {
+                    r = e.strstart + e.lookahead - 3, n = Yi(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
                     do {
-                        ++e.strstart <= r && (e.ins_h = Bn(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart)
+                        ++e.strstart <= r && (e.ins_h = En(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart)
                     } while (0 != --e.prev_length);
-                    if (e.match_available = 0, e.match_length = 2, e.strstart++, n && (Fn(e, !1), 0 === e.strm.avail_out)) return 1
+                    if (e.match_available = 0, e.match_length = 2, e.strstart++, n && (Tn(e, !1), 0 === e.strm.avail_out)) return 1
                 } else if (e.match_available) {
-                    if (n = Ki(e, 0, e.window[e.strstart - 1]), n && Fn(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return 1
+                    if (n = Yi(e, 0, e.window[e.strstart - 1]), n && Tn(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return 1
                 } else e.match_available = 1, e.strstart++, e.lookahead--
             }
-            return e.match_available && (n = Ki(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, t === rn ? (Fn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Fn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
+            return e.match_available && (n = Yi(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, t === nn ? (Tn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
         };
 
-    function jn(e, t, i, n, r) {
+    function Dn(e, t, i, n, r) {
         this.good_length = e, this.max_lazy = t, this.nice_length = i, this.max_chain = n, this.func = r
     }
-    const $n = [new jn(0, 0, 0, 0, Vn), new jn(4, 4, 8, 4, Un), new jn(4, 5, 16, 8, Un), new jn(4, 6, 32, 32, Un), new jn(4, 4, 16, 16, qn), new jn(8, 16, 32, 32, qn), new jn(8, 16, 128, 128, qn), new jn(8, 32, 128, 256, qn), new jn(32, 128, 258, 1024, qn), new jn(32, 258, 258, 4096, qn)];
+    const zn = [new Dn(0, 0, 0, 0, Nn), new Dn(4, 4, 8, 4, On), new Dn(4, 5, 16, 8, On), new Dn(4, 6, 32, 32, On), new Dn(4, 4, 16, 16, Pn), new Dn(8, 16, 32, 32, Pn), new Dn(8, 16, 128, 128, Pn), new Dn(8, 32, 128, 256, Pn), new Dn(32, 128, 258, 1024, Pn), new Dn(32, 258, 258, 4096, Pn)];
 
-    function Wn() {
-        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = wn, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * xn), this.dyn_dtree = new Uint16Array(2 * (2 * yn + 1)), this.bl_tree = new Uint16Array(2 * (2 * _n + 1)), Ln(this.dyn_ltree), Ln(this.dyn_dtree), Ln(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(kn + 1), this.heap = new Uint16Array(2 * vn + 1), Ln(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * vn + 1), Ln(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
+    function Hn() {
+        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = bn, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Sn(this.dyn_ltree), Sn(this.dyn_dtree), Sn(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Sn(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Sn(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
     }
-    const Gn = e => {
+    const Vn = e => {
             if (!e) return 1;
             const t = e.state;
-            return !t || t.strm !== e || t.status !== An && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== En && t.status !== Tn ? 1 : 0
+            return !t || t.strm !== e || t.status !== yn && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== _n && t.status !== xn ? 1 : 0
         },
-        Zn = e => {
-            if (Gn(e)) return Mn(e, ln);
-            e.total_in = e.total_out = 0, e.data_type = bn;
+        Un = e => {
+            if (Vn(e)) return kn(e, an);
+            e.total_in = e.total_out = 0, e.data_type = mn;
             const t = e.state;
-            return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = 2 === t.wrap ? 57 : t.wrap ? An : En, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = -2, Qi(t), on
+            return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = 2 === t.wrap ? 57 : t.wrap ? yn : _n, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = -2, Zi(t), sn
         },
-        Qn = e => {
-            const t = Zn(e);
+        qn = e => {
+            const t = Un(e);
             var i;
-            return t === on && ((i = e.state).window_size = 2 * i.w_size, Ln(i.head), i.max_lazy_match = $n[i.level].max_lazy, i.good_match = $n[i.level].good_length, i.nice_match = $n[i.level].nice_length, i.max_chain_length = $n[i.level].max_chain, i.strstart = 0, i.block_start = 0, i.lookahead = 0, i.insert = 0, i.match_length = i.prev_length = 2, i.match_available = 0, i.ins_h = 0), t
+            return t === sn && ((i = e.state).window_size = 2 * i.w_size, Sn(i.head), i.max_lazy_match = zn[i.level].max_lazy, i.good_match = zn[i.level].good_length, i.nice_match = zn[i.level].nice_length, i.max_chain_length = zn[i.level].max_chain, i.strstart = 0, i.block_start = 0, i.lookahead = 0, i.insert = 0, i.match_length = i.prev_length = 2, i.match_available = 0, i.ins_h = 0), t
         },
-        Xn = (e, t, i, n, r, s) => {
-            if (!e) return ln;
+        jn = (e, t, i, n, r, s) => {
+            if (!e) return an;
             let o = 1;
-            if (t === dn && (t = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), r < 1 || r > 9 || i !== wn || n < 8 || n > 15 || t < 0 || t > 9 || s < 0 || s > gn || 8 === n && 1 !== o) return Mn(e, ln);
+            if (t === cn && (t = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), r < 1 || r > 9 || i !== bn || n < 8 || n > 15 || t < 0 || t > 9 || s < 0 || s > pn || 8 === n && 1 !== o) return kn(e, an);
             8 === n && (n = 9);
-            const a = new Wn;
-            return e.state = a, a.strm = e, a.status = An, a.wrap = o, a.gzhead = null, a.w_bits = n, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = t, a.strategy = s, a.method = i, Qn(e)
+            const a = new Hn;
+            return e.state = a, a.strm = e, a.status = yn, a.wrap = o, a.gzhead = null, a.w_bits = n, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = t, a.strategy = s, a.method = i, qn(e)
         };
-    var Yn = (e, t) => {
+    var $n = (e, t) => {
             let i = t.length;
-            if (Gn(e)) return ln;
+            if (Vn(e)) return an;
             const n = e.state,
                 r = n.wrap;
-            if (2 === r || 1 === r && n.status !== An || n.lookahead) return ln;
-            if (1 === r && (e.adler = ji(e.adler, t, i, 0)), n.wrap = 0, i >= n.w_size) {
-                0 === r && (Ln(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
+            if (2 === r || 1 === r && n.status !== yn || n.lookahead) return an;
+            if (1 === r && (e.adler = qi(e.adler, t, i, 0)), n.wrap = 0, i >= n.w_size) {
+                0 === r && (Sn(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
                 let e = new Uint8Array(n.w_size);
                 e.set(t.subarray(i - n.w_size, i), 0), t = e, i = n.w_size
             }
             const s = e.avail_in,
                 o = e.next_in,
                 a = e.input;
-            for (e.avail_in = i, e.next_in = 0, e.input = t, Hn(n); n.lookahead >= 3;) {
+            for (e.avail_in = i, e.next_in = 0, e.input = t, Fn(n); n.lookahead >= 3;) {
                 let e = n.strstart,
                     t = n.lookahead - 2;
                 do {
-                    n.ins_h = Bn(n, n.ins_h, n.window[e + 3 - 1]), n.prev[e & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = e, e++
+                    n.ins_h = En(n, n.ins_h, n.window[e + 3 - 1]), n.prev[e & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = e, e++
                 } while (--t);
-                n.strstart = e, n.lookahead = 2, Hn(n)
+                n.strstart = e, n.lookahead = 2, Fn(n)
             }
-            return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = 2, n.match_available = 0, e.next_in = o, e.input = a, e.avail_in = s, n.wrap = r, on
+            return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = 2, n.match_available = 0, e.next_in = o, e.input = a, e.avail_in = s, n.wrap = r, sn
         },
-        Kn = {
-            deflateInit: (e, t) => Xn(e, t, wn, 15, 8, mn),
-            deflateInit2: Xn,
-            deflateReset: Qn,
-            deflateResetKeep: Zn,
-            deflateSetHeader: (e, t) => Gn(e) || 2 !== e.state.wrap ? ln : (e.state.gzhead = t, on),
+        Wn = {
+            deflateInit: (e, t) => jn(e, t, bn, 15, 8, gn),
+            deflateInit2: jn,
+            deflateReset: qn,
+            deflateResetKeep: Un,
+            deflateSetHeader: (e, t) => Vn(e) || 2 !== e.state.wrap ? an : (e.state.gzhead = t, sn),
             deflate: (e, t) => {
-                if (Gn(e) || t > sn || t < 0) return e ? Mn(e, ln) : ln;
+                if (Vn(e) || t > rn || t < 0) return e ? kn(e, an) : an;
                 const i = e.state;
-                if (!e.output || 0 !== e.avail_in && !e.input || i.status === Tn && t !== rn) return Mn(e, 0 === e.avail_out ? cn : ln);
+                if (!e.output || 0 !== e.avail_in && !e.input || i.status === xn && t !== nn) return kn(e, 0 === e.avail_out ? hn : an);
                 const n = i.last_flush;
                 if (i.last_flush = t, 0 !== i.pending) {
-                    if (Nn(e), 0 === e.avail_out) return i.last_flush = -1, on
-                } else if (0 === e.avail_in && Rn(t) <= Rn(n) && t !== rn) return Mn(e, cn);
-                if (i.status === Tn && 0 !== e.avail_in) return Mn(e, cn);
-                if (i.status === An && 0 === i.wrap && (i.status = En), i.status === An) {
-                    let t = wn + (i.w_bits - 8 << 4) << 8,
+                    if (Mn(e), 0 === e.avail_out) return i.last_flush = -1, sn
+                } else if (0 === e.avail_in && Cn(t) <= Cn(n) && t !== nn) return kn(e, hn);
+                if (i.status === xn && 0 !== e.avail_in) return kn(e, hn);
+                if (i.status === yn && 0 === i.wrap && (i.status = _n), i.status === yn) {
+                    let t = bn + (i.w_bits - 8 << 4) << 8,
                         n = -1;
-                    if (n = i.strategy >= fn || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3, t |= n << 6, 0 !== i.strstart && (t |= 32), t += 31 - t % 31, On(i, t), 0 !== i.strstart && (On(i, e.adler >>> 16), On(i, 65535 & e.adler)), e.adler = 1, i.status = En, Nn(e), 0 !== i.pending) return i.last_flush = -1, on
+                    if (n = i.strategy >= un || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3, t |= n << 6, 0 !== i.strstart && (t |= 32), t += 31 - t % 31, Ln(i, t), 0 !== i.strstart && (Ln(i, e.adler >>> 16), Ln(i, 65535 & e.adler)), e.adler = 1, i.status = _n, Mn(e), 0 !== i.pending) return i.last_flush = -1, sn
                 }
                 if (57 === i.status)
-                    if (e.adler = 0, Pn(i, 31), Pn(i, 139), Pn(i, 8), i.gzhead) Pn(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), Pn(i, 255 & i.gzhead.time), Pn(i, i.gzhead.time >> 8 & 255), Pn(i, i.gzhead.time >> 16 & 255), Pn(i, i.gzhead.time >> 24 & 255), Pn(i, 9 === i.level ? 2 : i.strategy >= fn || i.level < 2 ? 4 : 0), Pn(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (Pn(i, 255 & i.gzhead.extra.length), Pn(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = Wi(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69;
-                    else if (Pn(i, 0), Pn(i, 0), Pn(i, 0), Pn(i, 0), Pn(i, 0), Pn(i, 9 === i.level ? 2 : i.strategy >= fn || i.level < 2 ? 4 : 0), Pn(i, 3), i.status = En, Nn(e), 0 !== i.pending) return i.last_flush = -1, on;
+                    if (e.adler = 0, Rn(i, 31), Rn(i, 139), Rn(i, 8), i.gzhead) Rn(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), Rn(i, 255 & i.gzhead.time), Rn(i, i.gzhead.time >> 8 & 255), Rn(i, i.gzhead.time >> 16 & 255), Rn(i, i.gzhead.time >> 24 & 255), Rn(i, 9 === i.level ? 2 : i.strategy >= un || i.level < 2 ? 4 : 0), Rn(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (Rn(i, 255 & i.gzhead.extra.length), Rn(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = $i(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69;
+                    else if (Rn(i, 0), Rn(i, 0), Rn(i, 0), Rn(i, 0), Rn(i, 0), Rn(i, 9 === i.level ? 2 : i.strategy >= un || i.level < 2 ? 4 : 0), Rn(i, 3), i.status = _n, Mn(e), 0 !== i.pending) return i.last_flush = -1, sn;
                 if (69 === i.status) {
                     if (i.gzhead.extra) {
                         let t = i.pending,
                             n = (65535 & i.gzhead.extra.length) - i.gzindex;
                         for (; i.pending + n > i.pending_buf_size;) {
                             let r = i.pending_buf_size - i.pending;
-                            if (i.pending_buf.set(i.gzhead.extra.subarray(i.gzindex, i.gzindex + r), i.pending), i.pending = i.pending_buf_size, i.gzhead.hcrc && i.pending > t && (e.adler = Wi(e.adler, i.pending_buf, i.pending - t, t)), i.gzindex += r, Nn(e), 0 !== i.pending) return i.last_flush = -1, on;
+                            if (i.pending_buf.set(i.gzhead.extra.subarray(i.gzindex, i.gzindex + r), i.pending), i.pending = i.pending_buf_size, i.gzhead.hcrc && i.pending > t && (e.adler = $i(e.adler, i.pending_buf, i.pending - t, t)), i.gzindex += r, Mn(e), 0 !== i.pending) return i.last_flush = -1, sn;
                             t = 0, n -= r
                         }
                         let r = new Uint8Array(i.gzhead.extra);
-                        i.pending_buf.set(r.subarray(i.gzindex, i.gzindex + n), i.pending), i.pending += n, i.gzhead.hcrc && i.pending > t && (e.adler = Wi(e.adler, i.pending_buf, i.pending - t, t)), i.gzindex = 0
+                        i.pending_buf.set(r.subarray(i.gzindex, i.gzindex + n), i.pending), i.pending += n, i.gzhead.hcrc && i.pending > t && (e.adler = $i(e.adler, i.pending_buf, i.pending - t, t)), i.gzindex = 0
                     }
                     i.status = 73
                 }
                 if (73 === i.status) {
                     if (i.gzhead.name) {
                         let t, n = i.pending;
                         do {
                             if (i.pending === i.pending_buf_size) {
-                                if (i.gzhead.hcrc && i.pending > n && (e.adler = Wi(e.adler, i.pending_buf, i.pending - n, n)), Nn(e), 0 !== i.pending) return i.last_flush = -1, on;
+                                if (i.gzhead.hcrc && i.pending > n && (e.adler = $i(e.adler, i.pending_buf, i.pending - n, n)), Mn(e), 0 !== i.pending) return i.last_flush = -1, sn;
                                 n = 0
                             }
-                            t = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, Pn(i, t)
+                            t = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, Rn(i, t)
                         } while (0 !== t);
-                        i.gzhead.hcrc && i.pending > n && (e.adler = Wi(e.adler, i.pending_buf, i.pending - n, n)), i.gzindex = 0
+                        i.gzhead.hcrc && i.pending > n && (e.adler = $i(e.adler, i.pending_buf, i.pending - n, n)), i.gzindex = 0
                     }
                     i.status = 91
                 }
                 if (91 === i.status) {
                     if (i.gzhead.comment) {
                         let t, n = i.pending;
                         do {
                             if (i.pending === i.pending_buf_size) {
-                                if (i.gzhead.hcrc && i.pending > n && (e.adler = Wi(e.adler, i.pending_buf, i.pending - n, n)), Nn(e), 0 !== i.pending) return i.last_flush = -1, on;
+                                if (i.gzhead.hcrc && i.pending > n && (e.adler = $i(e.adler, i.pending_buf, i.pending - n, n)), Mn(e), 0 !== i.pending) return i.last_flush = -1, sn;
                                 n = 0
                             }
-                            t = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, Pn(i, t)
+                            t = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, Rn(i, t)
                         } while (0 !== t);
-                        i.gzhead.hcrc && i.pending > n && (e.adler = Wi(e.adler, i.pending_buf, i.pending - n, n))
+                        i.gzhead.hcrc && i.pending > n && (e.adler = $i(e.adler, i.pending_buf, i.pending - n, n))
                     }
                     i.status = 103
                 }
                 if (103 === i.status) {
                     if (i.gzhead.hcrc) {
-                        if (i.pending + 2 > i.pending_buf_size && (Nn(e), 0 !== i.pending)) return i.last_flush = -1, on;
-                        Pn(i, 255 & e.adler), Pn(i, e.adler >> 8 & 255), e.adler = 0
+                        if (i.pending + 2 > i.pending_buf_size && (Mn(e), 0 !== i.pending)) return i.last_flush = -1, sn;
+                        Rn(i, 255 & e.adler), Rn(i, e.adler >> 8 & 255), e.adler = 0
                     }
-                    if (i.status = En, Nn(e), 0 !== i.pending) return i.last_flush = -1, on
+                    if (i.status = _n, Mn(e), 0 !== i.pending) return i.last_flush = -1, sn
                 }
-                if (0 !== e.avail_in || 0 !== i.lookahead || t !== en && i.status !== Tn) {
-                    let n = 0 === i.level ? Vn(i, t) : i.strategy === fn ? ((e, t) => {
+                if (0 !== e.avail_in || 0 !== i.lookahead || t !== Ji && i.status !== xn) {
+                    let n = 0 === i.level ? Nn(i, t) : i.strategy === un ? ((e, t) => {
                         let i;
                         for (;;) {
-                            if (0 === e.lookahead && (Hn(e), 0 === e.lookahead)) {
-                                if (t === en) return 1;
+                            if (0 === e.lookahead && (Fn(e), 0 === e.lookahead)) {
+                                if (t === Ji) return 1;
                                 break
                             }
-                            if (e.match_length = 0, i = Ki(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, i && (Fn(e, !1), 0 === e.strm.avail_out)) return 1
+                            if (e.match_length = 0, i = Yi(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, i && (Tn(e, !1), 0 === e.strm.avail_out)) return 1
                         }
-                        return e.insert = 0, t === rn ? (Fn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Fn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
-                    })(i, t) : i.strategy === pn ? ((e, t) => {
+                        return e.insert = 0, t === nn ? (Tn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
+                    })(i, t) : i.strategy === fn ? ((e, t) => {
                         let i, n, r, s;
                         const o = e.window;
                         for (;;) {
-                            if (e.lookahead <= Cn) {
-                                if (Hn(e), e.lookahead <= Cn && t === en) return 1;
+                            if (e.lookahead <= wn) {
+                                if (Fn(e), e.lookahead <= wn && t === Ji) return 1;
                                 if (0 === e.lookahead) break
                             }
                             if (e.match_length = 0, e.lookahead >= 3 && e.strstart > 0 && (r = e.strstart - 1, n = o[r], n === o[++r] && n === o[++r] && n === o[++r])) {
-                                s = e.strstart + Cn;
+                                s = e.strstart + wn;
                                 do {} while (n === o[++r] && n === o[++r] && n === o[++r] && n === o[++r] && n === o[++r] && n === o[++r] && n === o[++r] && n === o[++r] && r < s);
-                                e.match_length = Cn - (s - r), e.match_length > e.lookahead && (e.match_length = e.lookahead)
+                                e.match_length = wn - (s - r), e.match_length > e.lookahead && (e.match_length = e.lookahead)
                             }
-                            if (e.match_length >= 3 ? (i = Ki(e, 1, e.match_length - 3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (i = Ki(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), i && (Fn(e, !1), 0 === e.strm.avail_out)) return 1
+                            if (e.match_length >= 3 ? (i = Yi(e, 1, e.match_length - 3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (i = Yi(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), i && (Tn(e, !1), 0 === e.strm.avail_out)) return 1
                         }
-                        return e.insert = 0, t === rn ? (Fn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Fn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
-                    })(i, t) : $n[i.level].func(i, t);
-                    if (3 !== n && 4 !== n || (i.status = Tn), 1 === n || 3 === n) return 0 === e.avail_out && (i.last_flush = -1), on;
-                    if (2 === n && (t === tn ? Ji(i) : t !== sn && (Xi(i, 0, 0, !1), t === nn && (Ln(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), Nn(e), 0 === e.avail_out)) return i.last_flush = -1, on
+                        return e.insert = 0, t === nn ? (Tn(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tn(e, !1), 0 === e.strm.avail_out) ? 1 : 2
+                    })(i, t) : zn[i.level].func(i, t);
+                    if (3 !== n && 4 !== n || (i.status = xn), 1 === n || 3 === n) return 0 === e.avail_out && (i.last_flush = -1), sn;
+                    if (2 === n && (t === en ? Ki(i) : t !== rn && (Qi(i, 0, 0, !1), t === tn && (Sn(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), Mn(e), 0 === e.avail_out)) return i.last_flush = -1, sn
                 }
-                return t !== rn ? on : i.wrap <= 0 ? an : (2 === i.wrap ? (Pn(i, 255 & e.adler), Pn(i, e.adler >> 8 & 255), Pn(i, e.adler >> 16 & 255), Pn(i, e.adler >> 24 & 255), Pn(i, 255 & e.total_in), Pn(i, e.total_in >> 8 & 255), Pn(i, e.total_in >> 16 & 255), Pn(i, e.total_in >> 24 & 255)) : (On(i, e.adler >>> 16), On(i, 65535 & e.adler)), Nn(e), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? on : an)
+                return t !== nn ? sn : i.wrap <= 0 ? on : (2 === i.wrap ? (Rn(i, 255 & e.adler), Rn(i, e.adler >> 8 & 255), Rn(i, e.adler >> 16 & 255), Rn(i, e.adler >> 24 & 255), Rn(i, 255 & e.total_in), Rn(i, e.total_in >> 8 & 255), Rn(i, e.total_in >> 16 & 255), Rn(i, e.total_in >> 24 & 255)) : (Ln(i, e.adler >>> 16), Ln(i, 65535 & e.adler)), Mn(e), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? sn : on)
             },
             deflateEnd: e => {
-                if (Gn(e)) return ln;
+                if (Vn(e)) return an;
                 const t = e.state.status;
-                return e.state = null, t === En ? Mn(e, hn) : on
+                return e.state = null, t === _n ? kn(e, ln) : sn
             },
-            deflateSetDictionary: Yn,
+            deflateSetDictionary: $n,
             deflateInfo: "pako deflate (from Nodeca project)"
         };
-    const Jn = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
-    var er = {
+    const Gn = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
+    var Zn = {
         assign: function(e) {
             const t = Array.prototype.slice.call(arguments, 1);
             for (; t.length;) {
                 const i = t.shift();
                 if (i) {
                     if ("object" != typeof i) throw new TypeError(i + "must be non-object");
-                    for (const t in i) Jn(i, t) && (e[t] = i[t])
+                    for (const t in i) Gn(i, t) && (e[t] = i[t])
                 }
             }
             return e
         },
         flattenChunks: e => {
             let t = 0;
             for (let i = 0, n = e.length; i < n; i++) t += e[i].length;
@@ -3950,24 +3949,24 @@
             for (let t = 0, n = 0, r = e.length; t < r; t++) {
                 let r = e[t];
                 i.set(r, n), n += r.length
             }
             return i
         }
     };
-    let tr = !0;
+    let Qn = !0;
     try {
         String.fromCharCode.apply(null, new Uint8Array(1))
-    } catch (Zb) {
-        tr = !1
+    } catch (Vb) {
+        Qn = !1
     }
-    const ir = new Uint8Array(256);
-    for (let Qb = 0; Qb < 256; Qb++) ir[Qb] = Qb >= 252 ? 6 : Qb >= 248 ? 5 : Qb >= 240 ? 4 : Qb >= 224 ? 3 : Qb >= 192 ? 2 : 1;
-    ir[254] = ir[254] = 1;
-    var nr = {
+    const Xn = new Uint8Array(256);
+    for (let Ub = 0; Ub < 256; Ub++) Xn[Ub] = Ub >= 252 ? 6 : Ub >= 248 ? 5 : Ub >= 240 ? 4 : Ub >= 224 ? 3 : Ub >= 192 ? 2 : 1;
+    Xn[254] = Xn[254] = 1;
+    var Yn = {
         string2buf: e => {
             if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(e);
             let t, i, n, r, s, o = e.length,
                 a = 0;
             for (r = 0; r < o; r++) i = e.charCodeAt(r), 55296 == (64512 & i) && r + 1 < o && (n = e.charCodeAt(r + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), r++)), a += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
             for (t = new Uint8Array(a), s = 0, r = 0; s < a; r++) i = e.charCodeAt(r), 55296 == (64512 & i) && r + 1 < o && (n = e.charCodeAt(r + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), r++)), i < 128 ? t[s++] = i : i < 2048 ? (t[s++] = 192 | i >>> 6, t[s++] = 128 | 63 & i) : i < 65536 ? (t[s++] = 224 | i >>> 12, t[s++] = 128 | i >>> 6 & 63, t[s++] = 128 | 63 & i) : (t[s++] = 240 | i >>> 18, t[s++] = 128 | i >>> 12 & 63, t[s++] = 128 | i >>> 6 & 63, t[s++] = 128 | 63 & i);
             return t
@@ -3979,110 +3978,110 @@
             const s = new Array(2 * i);
             for (r = 0, n = 0; n < i;) {
                 let t = e[n++];
                 if (t < 128) {
                     s[r++] = t;
                     continue
                 }
-                let o = ir[t];
+                let o = Xn[t];
                 if (o > 4) s[r++] = 65533, n += o - 1;
                 else {
                     for (t &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && n < i;) t = t << 6 | 63 & e[n++], o--;
                     o > 1 ? s[r++] = 65533 : t < 65536 ? s[r++] = t : (t -= 65536, s[r++] = 55296 | t >> 10 & 1023, s[r++] = 56320 | 1023 & t)
                 }
             }
             return ((e, t) => {
-                if (t < 65534 && e.subarray && tr) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
+                if (t < 65534 && e.subarray && Qn) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                 let i = "";
                 for (let n = 0; n < t; n++) i += String.fromCharCode(e[n]);
                 return i
             })(s, r)
         },
         utf8border: (e, t) => {
             (t = t || e.length) > e.length && (t = e.length);
             let i = t - 1;
             for (; i >= 0 && 128 == (192 & e[i]);) i--;
-            return i < 0 || 0 === i ? t : i + ir[e[i]] > t ? i : t
+            return i < 0 || 0 === i ? t : i + Xn[e[i]] > t ? i : t
         }
     };
-    var rr = function() {
+    var Kn = function() {
         this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
     };
-    const sr = Object.prototype.toString,
+    const Jn = Object.prototype.toString,
         {
-            Z_NO_FLUSH: or,
-            Z_SYNC_FLUSH: ar,
-            Z_FULL_FLUSH: lr,
-            Z_FINISH: hr,
-            Z_OK: cr,
-            Z_STREAM_END: dr,
-            Z_DEFAULT_COMPRESSION: ur,
-            Z_DEFAULT_STRATEGY: fr,
-            Z_DEFLATED: pr
-        } = Zi;
-
-    function gr(e) {
-        this.options = er.assign({
-            level: ur,
-            method: pr,
+            Z_NO_FLUSH: er,
+            Z_SYNC_FLUSH: tr,
+            Z_FULL_FLUSH: ir,
+            Z_FINISH: nr,
+            Z_OK: rr,
+            Z_STREAM_END: sr,
+            Z_DEFAULT_COMPRESSION: or,
+            Z_DEFAULT_STRATEGY: ar,
+            Z_DEFLATED: lr
+        } = Gi;
+
+    function hr(e) {
+        this.options = Zn.assign({
+            level: or,
+            method: lr,
             chunkSize: 16384,
             windowBits: 15,
             memLevel: 8,
-            strategy: fr
+            strategy: ar
         }, e || {});
         let t = this.options;
-        t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new rr, this.strm.avail_out = 0;
-        let i = Kn.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
-        if (i !== cr) throw new Error(Gi[i]);
-        if (t.header && Kn.deflateSetHeader(this.strm, t.header), t.dictionary) {
+        t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Kn, this.strm.avail_out = 0;
+        let i = Wn.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
+        if (i !== rr) throw new Error(Wi[i]);
+        if (t.header && Wn.deflateSetHeader(this.strm, t.header), t.dictionary) {
             let e;
-            if (e = "string" == typeof t.dictionary ? nr.string2buf(t.dictionary) : "[object ArrayBuffer]" === sr.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, i = Kn.deflateSetDictionary(this.strm, e), i !== cr) throw new Error(Gi[i]);
+            if (e = "string" == typeof t.dictionary ? Yn.string2buf(t.dictionary) : "[object ArrayBuffer]" === Jn.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, i = Wn.deflateSetDictionary(this.strm, e), i !== rr) throw new Error(Wi[i]);
             this._dict_set = !0
         }
     }
 
-    function mr(e, t) {
-        const i = new gr(t);
-        if (i.push(e, !0), i.err) throw i.msg || Gi[i.err];
+    function cr(e, t) {
+        const i = new hr(t);
+        if (i.push(e, !0), i.err) throw i.msg || Wi[i.err];
         return i.result
     }
-    gr.prototype.push = function(e, t) {
+    hr.prototype.push = function(e, t) {
         const i = this.strm,
             n = this.options.chunkSize;
         let r, s;
         if (this.ended) return !1;
-        for (s = t === ~~t ? t : !0 === t ? hr : or, "string" == typeof e ? i.input = nr.string2buf(e) : "[object ArrayBuffer]" === sr.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;)
-            if (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), (s === ar || s === lr) && i.avail_out <= 6) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;
+        for (s = t === ~~t ? t : !0 === t ? nr : er, "string" == typeof e ? i.input = Yn.string2buf(e) : "[object ArrayBuffer]" === Jn.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;)
+            if (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), (s === tr || s === ir) && i.avail_out <= 6) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;
             else {
-                if (r = Kn.deflate(i, s), r === dr) return i.next_out > 0 && this.onData(i.output.subarray(0, i.next_out)), r = Kn.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === cr;
+                if (r = Wn.deflate(i, s), r === sr) return i.next_out > 0 && this.onData(i.output.subarray(0, i.next_out)), r = Wn.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === rr;
                 if (0 !== i.avail_out) {
                     if (s > 0 && i.next_out > 0) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;
                     else if (0 === i.avail_in) break
                 } else this.onData(i.output)
             } return !0
-    }, gr.prototype.onData = function(e) {
+    }, hr.prototype.onData = function(e) {
         this.chunks.push(e)
-    }, gr.prototype.onEnd = function(e) {
-        e === cr && (this.result = er.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
+    }, hr.prototype.onEnd = function(e) {
+        e === rr && (this.result = Zn.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
     };
-    var br = function(e, t) {
-            return (t = t || {}).raw = !0, mr(e, t)
+    var dr = function(e, t) {
+            return (t = t || {}).raw = !0, cr(e, t)
         },
-        wr = function(e, t) {
-            return (t = t || {}).gzip = !0, mr(e, t)
+        ur = function(e, t) {
+            return (t = t || {}).gzip = !0, cr(e, t)
         },
-        vr = {
-            Deflate: gr,
-            deflate: mr,
-            deflateRaw: br,
-            gzip: wr,
-            constants: Zi
+        fr = {
+            Deflate: hr,
+            deflate: cr,
+            deflateRaw: dr,
+            gzip: ur,
+            constants: Gi
         };
-    const yr = 16209;
-    var _r = function(e, t) {
+    const pr = 16209;
+    var gr = function(e, t) {
         let i, n, r, s, o, a, l, h, c, d, u, f, p, g, m, b, w, v, y, _, x, k, C, S;
         const A = e.state;
         i = e.next_in, C = e.input, n = i + (e.avail_in - 5), r = e.next_out, S = e.output, s = r - (t - e.avail_out), o = r + (e.avail_out - 257), a = A.dmax, l = A.wsize, h = A.whave, c = A.wnext, d = A.window, u = A.hold, f = A.bits, p = A.lencode, g = A.distcode, m = (1 << A.lenbits) - 1, b = (1 << A.distbits) - 1;
         e: do {
             f < 15 && (u += C[i++] << f, f += 8, u += C[i++] << f, f += 8), w = p[u & m];
             t: for (;;) {
                 if (v = w >>> 24, u >>>= v, f -= v, v = w >>> 16 & 255, 0 === v) S[r++] = 65535 & w;
@@ -4092,34 +4091,34 @@
                             w = p[(65535 & w) + (u & (1 << v) - 1)];
                             continue t
                         }
                         if (32 & v) {
                             A.mode = 16191;
                             break e
                         }
-                        e.msg = "invalid literal/length code", A.mode = yr;
+                        e.msg = "invalid literal/length code", A.mode = pr;
                         break e
                     }
                     y = 65535 & w, v &= 15, v && (f < v && (u += C[i++] << f, f += 8), y += u & (1 << v) - 1, u >>>= v, f -= v), f < 15 && (u += C[i++] << f, f += 8, u += C[i++] << f, f += 8), w = g[u & b];
                     i: for (;;) {
                         if (v = w >>> 24, u >>>= v, f -= v, v = w >>> 16 & 255, !(16 & v)) {
                             if (0 == (64 & v)) {
                                 w = g[(65535 & w) + (u & (1 << v) - 1)];
                                 continue i
                             }
-                            e.msg = "invalid distance code", A.mode = yr;
+                            e.msg = "invalid distance code", A.mode = pr;
                             break e
                         }
                         if (_ = 65535 & w, v &= 15, f < v && (u += C[i++] << f, f += 8, f < v && (u += C[i++] << f, f += 8)), _ += u & (1 << v) - 1, _ > a) {
-                            e.msg = "invalid distance too far back", A.mode = yr;
+                            e.msg = "invalid distance too far back", A.mode = pr;
                             break e
                         }
                         if (u >>>= v, f -= v, v = r - s, _ > v) {
                             if (v = _ - v, v > h && A.sane) {
-                                e.msg = "invalid distance too far back", A.mode = yr;
+                                e.msg = "invalid distance too far back", A.mode = pr;
                                 break e
                             }
                             if (x = 0, k = d, 0 === c) {
                                 if (x += l - v, v < y) {
                                     y -= v;
                                     do {
                                         S[r++] = d[x++]
@@ -4160,50 +4159,50 @@
                     }
                 }
                 break
             }
         } while (i < n && r < o);
         y = f >> 3, i -= y, f -= y << 3, u &= (1 << f) - 1, e.next_in = i, e.next_out = r, e.avail_in = i < n ? n - i + 5 : 5 - (i - n), e.avail_out = r < o ? o - r + 257 : 257 - (r - o), A.hold = u, A.bits = f
     };
-    const xr = 15,
-        kr = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
-        Cr = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
-        Sr = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
-        Ar = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
-    var Er = (e, t, i, n, r, s, o, a) => {
+    const mr = 15,
+        br = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
+        wr = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
+        vr = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
+        yr = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
+    var _r = (e, t, i, n, r, s, o, a) => {
         const l = a.bits;
         let h, c, d, u, f, p, g = 0,
             m = 0,
             b = 0,
             w = 0,
             v = 0,
             y = 0,
             _ = 0,
             x = 0,
             k = 0,
             C = 0,
             S = null;
         const A = new Uint16Array(16),
             E = new Uint16Array(16);
-        let T, M, R, L = null;
-        for (g = 0; g <= xr; g++) A[g] = 0;
+        let M, T, R, L = null;
+        for (g = 0; g <= mr; g++) A[g] = 0;
         for (m = 0; m < n; m++) A[t[i + m]]++;
-        for (v = l, w = xr; w >= 1 && 0 === A[w]; w--);
+        for (v = l, w = mr; w >= 1 && 0 === A[w]; w--);
         if (v > w && (v = w), 0 === w) return r[s++] = 20971520, r[s++] = 20971520, a.bits = 1, 0;
         for (b = 1; b < w && 0 === A[b]; b++);
-        for (v < b && (v = b), x = 1, g = 1; g <= xr; g++)
+        for (v < b && (v = b), x = 1, g = 1; g <= mr; g++)
             if (x <<= 1, x -= A[g], x < 0) return -1;
         if (x > 0 && (0 === e || 1 !== w)) return -1;
-        for (E[1] = 0, g = 1; g < xr; g++) E[g + 1] = E[g] + A[g];
+        for (E[1] = 0, g = 1; g < mr; g++) E[g + 1] = E[g] + A[g];
         for (m = 0; m < n; m++) 0 !== t[i + m] && (o[E[t[i + m]]++] = m);
-        if (0 === e ? (S = L = o, p = 20) : 1 === e ? (S = kr, L = Cr, p = 257) : (S = Sr, L = Ar, p = 0), C = 0, m = 0, g = b, f = s, y = v, _ = 0, d = -1, k = 1 << v, u = k - 1, 1 === e && k > 852 || 2 === e && k > 592) return 1;
+        if (0 === e ? (S = L = o, p = 20) : 1 === e ? (S = br, L = wr, p = 257) : (S = vr, L = yr, p = 0), C = 0, m = 0, g = b, f = s, y = v, _ = 0, d = -1, k = 1 << v, u = k - 1, 1 === e && k > 852 || 2 === e && k > 592) return 1;
         for (;;) {
-            T = g - _, o[m] + 1 < p ? (M = 0, R = o[m]) : o[m] >= p ? (M = L[o[m] - p], R = S[o[m] - p]) : (M = 96, R = 0), h = 1 << g - _, c = 1 << y, b = c;
+            M = g - _, o[m] + 1 < p ? (T = 0, R = o[m]) : o[m] >= p ? (T = L[o[m] - p], R = S[o[m] - p]) : (T = 96, R = 0), h = 1 << g - _, c = 1 << y, b = c;
             do {
-                c -= h, r[f + (C >> _) + c] = T << 24 | M << 16 | R | 0
+                c -= h, r[f + (C >> _) + c] = M << 24 | T << 16 | R | 0
             } while (0 !== c);
             for (h = 1 << g - 1; C & h;) h >>= 1;
             if (0 !== h ? (C &= h - 1, C += h) : C = 0, m++, 0 == --A[g]) {
                 if (g === w) break;
                 g = t[i + o[m]]
             }
             if (g > v && (C & u) !== d) {
@@ -4211,269 +4210,269 @@
                 if (k += 1 << y, 1 === e && k > 852 || 2 === e && k > 592) return 1;
                 d = C & u, r[d] = v << 24 | y << 16 | f - s | 0
             }
         }
         return 0 !== C && (r[f + C] = g - _ << 24 | 64 << 16 | 0), a.bits = v, 0
     };
     const {
-        Z_FINISH: Tr,
-        Z_BLOCK: Mr,
-        Z_TREES: Rr,
-        Z_OK: Lr,
-        Z_STREAM_END: Ir,
-        Z_NEED_DICT: Br,
-        Z_STREAM_ERROR: Nr,
-        Z_DATA_ERROR: Fr,
-        Z_MEM_ERROR: Pr,
-        Z_BUF_ERROR: Or,
-        Z_DEFLATED: Dr
-    } = Zi, zr = 16180, Hr = 16190, Vr = 16191, Ur = 16192, qr = 16194, jr = 16199, $r = 16200, Wr = 16206, Gr = 16209, Zr = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
+        Z_FINISH: xr,
+        Z_BLOCK: kr,
+        Z_TREES: Cr,
+        Z_OK: Sr,
+        Z_STREAM_END: Ar,
+        Z_NEED_DICT: Er,
+        Z_STREAM_ERROR: Mr,
+        Z_DATA_ERROR: Tr,
+        Z_MEM_ERROR: Rr,
+        Z_BUF_ERROR: Lr,
+        Z_DEFLATED: Ir
+    } = Gi, Br = 16180, Fr = 16190, Nr = 16191, Or = 16192, Pr = 16194, Dr = 16199, zr = 16200, Hr = 16206, Vr = 16209, Ur = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
 
-    function Qr() {
+    function qr() {
         this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
     }
-    const Xr = e => {
+    const jr = e => {
             if (!e) return 1;
             const t = e.state;
-            return !t || t.strm !== e || t.mode < zr || t.mode > 16211 ? 1 : 0
+            return !t || t.strm !== e || t.mode < Br || t.mode > 16211 ? 1 : 0
         },
-        Yr = e => {
-            if (Xr(e)) return Nr;
+        $r = e => {
+            if (jr(e)) return Mr;
             const t = e.state;
-            return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = zr, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, Lr
+            return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = Br, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, Sr
         },
-        Kr = e => {
-            if (Xr(e)) return Nr;
+        Wr = e => {
+            if (jr(e)) return Mr;
             const t = e.state;
-            return t.wsize = 0, t.whave = 0, t.wnext = 0, Yr(e)
+            return t.wsize = 0, t.whave = 0, t.wnext = 0, $r(e)
         },
-        Jr = (e, t) => {
+        Gr = (e, t) => {
             let i;
-            if (Xr(e)) return Nr;
+            if (jr(e)) return Mr;
             const n = e.state;
-            return t < 0 ? (i = 0, t = -t) : (i = 5 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Nr : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, Kr(e))
+            return t < 0 ? (i = 0, t = -t) : (i = 5 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Mr : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, Wr(e))
         },
-        es = (e, t) => {
-            if (!e) return Nr;
-            const i = new Qr;
-            e.state = i, i.strm = e, i.window = null, i.mode = zr;
-            const n = Jr(e, t);
-            return n !== Lr && (e.state = null), n
+        Zr = (e, t) => {
+            if (!e) return Mr;
+            const i = new qr;
+            e.state = i, i.strm = e, i.window = null, i.mode = Br;
+            const n = Gr(e, t);
+            return n !== Sr && (e.state = null), n
         };
-    let ts, is, ns = !0;
-    const rs = e => {
-            if (ns) {
-                ts = new Int32Array(512), is = new Int32Array(32);
+    let Qr, Xr, Yr = !0;
+    const Kr = e => {
+            if (Yr) {
+                Qr = new Int32Array(512), Xr = new Int32Array(32);
                 let t = 0;
                 for (; t < 144;) e.lens[t++] = 8;
                 for (; t < 256;) e.lens[t++] = 9;
                 for (; t < 280;) e.lens[t++] = 7;
                 for (; t < 288;) e.lens[t++] = 8;
-                for (Er(1, e.lens, 0, 288, ts, 0, e.work, {
+                for (_r(1, e.lens, 0, 288, Qr, 0, e.work, {
                         bits: 9
                     }), t = 0; t < 32;) e.lens[t++] = 5;
-                Er(2, e.lens, 0, 32, is, 0, e.work, {
+                _r(2, e.lens, 0, 32, Xr, 0, e.work, {
                     bits: 5
-                }), ns = !1
+                }), Yr = !1
             }
-            e.lencode = ts, e.lenbits = 9, e.distcode = is, e.distbits = 5
+            e.lencode = Qr, e.lenbits = 9, e.distcode = Xr, e.distbits = 5
         },
-        ss = (e, t, i, n) => {
+        Jr = (e, t, i, n) => {
             let r;
             const s = e.state;
             return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), n >= s.wsize ? (s.window.set(t.subarray(i - s.wsize, i), 0), s.wnext = 0, s.whave = s.wsize) : (r = s.wsize - s.wnext, r > n && (r = n), s.window.set(t.subarray(i - n, i - n + r), s.wnext), (n -= r) ? (s.window.set(t.subarray(i - n, i), 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += r, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += r))), 0
         };
-    var os = (e, t) => {
+    var es = (e, t) => {
             let i, n, r, s, o, a, l, h, c, d, u, f, p, g, m, b, w, v, y, _, x, k, C = 0;
             const S = new Uint8Array(4);
             let A, E;
-            const T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
-            if (Xr(e) || !e.output || !e.input && 0 !== e.avail_in) return Nr;
-            i = e.state, i.mode === Vr && (i.mode = Ur), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, d = a, u = l, k = Lr;
+            const M = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
+            if (jr(e) || !e.output || !e.input && 0 !== e.avail_in) return Mr;
+            i = e.state, i.mode === Nr && (i.mode = Or), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, d = a, u = l, k = Sr;
             e: for (;;) switch (i.mode) {
-                case zr:
+                case Br:
                     if (0 === i.wrap) {
-                        i.mode = Ur;
+                        i.mode = Or;
                         break
                     }
                     for (; c < 16;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if (2 & i.wrap && 35615 === h) {
-                        0 === i.wbits && (i.wbits = 15), i.check = 0, S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Wi(i.check, S, 2, 0), h = 0, c = 0, i.mode = 16181;
+                        0 === i.wbits && (i.wbits = 15), i.check = 0, S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = $i(i.check, S, 2, 0), h = 0, c = 0, i.mode = 16181;
                         break
                     }
                     if (i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) {
-                        e.msg = "incorrect header check", i.mode = Gr;
+                        e.msg = "incorrect header check", i.mode = Vr;
                         break
                     }
-                    if ((15 & h) !== Dr) {
-                        e.msg = "unknown compression method", i.mode = Gr;
+                    if ((15 & h) !== Ir) {
+                        e.msg = "unknown compression method", i.mode = Vr;
                         break
                     }
                     if (h >>>= 4, c -= 4, x = 8 + (15 & h), 0 === i.wbits && (i.wbits = x), x > 15 || x > i.wbits) {
-                        e.msg = "invalid window size", i.mode = Gr;
+                        e.msg = "invalid window size", i.mode = Vr;
                         break
                     }
-                    i.dmax = 1 << i.wbits, i.flags = 0, e.adler = i.check = 1, i.mode = 512 & h ? 16189 : Vr, h = 0, c = 0;
+                    i.dmax = 1 << i.wbits, i.flags = 0, e.adler = i.check = 1, i.mode = 512 & h ? 16189 : Nr, h = 0, c = 0;
                     break;
                 case 16181:
                     for (; c < 16;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    if (i.flags = h, (255 & i.flags) !== Dr) {
-                        e.msg = "unknown compression method", i.mode = Gr;
+                    if (i.flags = h, (255 & i.flags) !== Ir) {
+                        e.msg = "unknown compression method", i.mode = Vr;
                         break
                     }
                     if (57344 & i.flags) {
-                        e.msg = "unknown header flags set", i.mode = Gr;
+                        e.msg = "unknown header flags set", i.mode = Vr;
                         break
                     }
-                    i.head && (i.head.text = h >> 8 & 1), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Wi(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 16182;
+                    i.head && (i.head.text = h >> 8 & 1), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = $i(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 16182;
                 case 16182:
                     for (; c < 32;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    i.head && (i.head.time = h), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, S[2] = h >>> 16 & 255, S[3] = h >>> 24 & 255, i.check = Wi(i.check, S, 4, 0)), h = 0, c = 0, i.mode = 16183;
+                    i.head && (i.head.time = h), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, S[2] = h >>> 16 & 255, S[3] = h >>> 24 & 255, i.check = $i(i.check, S, 4, 0)), h = 0, c = 0, i.mode = 16183;
                 case 16183:
                     for (; c < 16;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    i.head && (i.head.xflags = 255 & h, i.head.os = h >> 8), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Wi(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 16184;
+                    i.head && (i.head.xflags = 255 & h, i.head.os = h >> 8), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = $i(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 16184;
                 case 16184:
                     if (1024 & i.flags) {
                         for (; c < 16;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
-                        i.length = h, i.head && (i.head.extra_len = h), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Wi(i.check, S, 2, 0)), h = 0, c = 0
+                        i.length = h, i.head && (i.head.extra_len = h), 512 & i.flags && 4 & i.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = $i(i.check, S, 2, 0)), h = 0, c = 0
                     } else i.head && (i.head.extra = null);
                     i.mode = 16185;
                 case 16185:
-                    if (1024 & i.flags && (f = i.length, f > a && (f = a), f && (i.head && (x = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(n.subarray(s, s + f), x)), 512 & i.flags && 4 & i.wrap && (i.check = Wi(i.check, n, f, s)), a -= f, s += f, i.length -= f), i.length)) break e;
+                    if (1024 & i.flags && (f = i.length, f > a && (f = a), f && (i.head && (x = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(n.subarray(s, s + f), x)), 512 & i.flags && 4 & i.wrap && (i.check = $i(i.check, n, f, s)), a -= f, s += f, i.length -= f), i.length)) break e;
                     i.length = 0, i.mode = 16186;
                 case 16186:
                     if (2048 & i.flags) {
                         if (0 === a) break e;
                         f = 0;
                         do {
                             x = n[s + f++], i.head && x && i.length < 65536 && (i.head.name += String.fromCharCode(x))
                         } while (x && f < a);
-                        if (512 & i.flags && 4 & i.wrap && (i.check = Wi(i.check, n, f, s)), a -= f, s += f, x) break e
+                        if (512 & i.flags && 4 & i.wrap && (i.check = $i(i.check, n, f, s)), a -= f, s += f, x) break e
                     } else i.head && (i.head.name = null);
                     i.length = 0, i.mode = 16187;
                 case 16187:
                     if (4096 & i.flags) {
                         if (0 === a) break e;
                         f = 0;
                         do {
                             x = n[s + f++], i.head && x && i.length < 65536 && (i.head.comment += String.fromCharCode(x))
                         } while (x && f < a);
-                        if (512 & i.flags && 4 & i.wrap && (i.check = Wi(i.check, n, f, s)), a -= f, s += f, x) break e
+                        if (512 & i.flags && 4 & i.wrap && (i.check = $i(i.check, n, f, s)), a -= f, s += f, x) break e
                     } else i.head && (i.head.comment = null);
                     i.mode = 16188;
                 case 16188:
                     if (512 & i.flags) {
                         for (; c < 16;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         if (4 & i.wrap && h !== (65535 & i.check)) {
-                            e.msg = "header crc mismatch", i.mode = Gr;
+                            e.msg = "header crc mismatch", i.mode = Vr;
                             break
                         }
                         h = 0, c = 0
                     }
-                    i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = Vr;
+                    i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = Nr;
                     break;
                 case 16189:
                     for (; c < 32;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    e.adler = i.check = Zr(h), h = 0, c = 0, i.mode = Hr;
-                case Hr:
-                    if (0 === i.havedict) return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, Br;
-                    e.adler = i.check = 1, i.mode = Vr;
-                case Vr:
-                    if (t === Mr || t === Rr) break e;
-                case Ur:
+                    e.adler = i.check = Ur(h), h = 0, c = 0, i.mode = Fr;
+                case Fr:
+                    if (0 === i.havedict) return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, Er;
+                    e.adler = i.check = 1, i.mode = Nr;
+                case Nr:
+                    if (t === kr || t === Cr) break e;
+                case Or:
                     if (i.last) {
-                        h >>>= 7 & c, c -= 7 & c, i.mode = Wr;
+                        h >>>= 7 & c, c -= 7 & c, i.mode = Hr;
                         break
                     }
                     for (; c < 3;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     switch (i.last = 1 & h, h >>>= 1, c -= 1, 3 & h) {
                         case 0:
                             i.mode = 16193;
                             break;
                         case 1:
-                            if (rs(i), i.mode = jr, t === Rr) {
+                            if (Kr(i), i.mode = Dr, t === Cr) {
                                 h >>>= 2, c -= 2;
                                 break e
                             }
                             break;
                         case 2:
                             i.mode = 16196;
                             break;
                         case 3:
-                            e.msg = "invalid block type", i.mode = Gr
+                            e.msg = "invalid block type", i.mode = Vr
                     }
                     h >>>= 2, c -= 2;
                     break;
                 case 16193:
                     for (h >>>= 7 & c, c -= 7 & c; c < 32;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if ((65535 & h) != (h >>> 16 ^ 65535)) {
-                        e.msg = "invalid stored block lengths", i.mode = Gr;
+                        e.msg = "invalid stored block lengths", i.mode = Vr;
                         break
                     }
-                    if (i.length = 65535 & h, h = 0, c = 0, i.mode = qr, t === Rr) break e;
-                case qr:
+                    if (i.length = 65535 & h, h = 0, c = 0, i.mode = Pr, t === Cr) break e;
+                case Pr:
                     i.mode = 16195;
                 case 16195:
                     if (f = i.length, f) {
                         if (f > a && (f = a), f > l && (f = l), 0 === f) break e;
                         r.set(n.subarray(s, s + f), o), a -= f, s += f, l -= f, o += f, i.length -= f;
                         break
                     }
-                    i.mode = Vr;
+                    i.mode = Nr;
                     break;
                 case 16196:
                     for (; c < 14;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if (i.nlen = 257 + (31 & h), h >>>= 5, c -= 5, i.ndist = 1 + (31 & h), h >>>= 5, c -= 5, i.ncode = 4 + (15 & h), h >>>= 4, c -= 4, i.nlen > 286 || i.ndist > 30) {
-                        e.msg = "too many length or distance symbols", i.mode = Gr;
+                        e.msg = "too many length or distance symbols", i.mode = Vr;
                         break
                     }
                     i.have = 0, i.mode = 16197;
                 case 16197:
                     for (; i.have < i.ncode;) {
                         for (; c < 3;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
-                        i.lens[T[i.have++]] = 7 & h, h >>>= 3, c -= 3
+                        i.lens[M[i.have++]] = 7 & h, h >>>= 3, c -= 3
                     }
-                    for (; i.have < 19;) i.lens[T[i.have++]] = 0;
+                    for (; i.have < 19;) i.lens[M[i.have++]] = 0;
                     if (i.lencode = i.lendyn, i.lenbits = 7, A = {
                             bits: i.lenbits
-                        }, k = Er(0, i.lens, 0, 19, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
-                        e.msg = "invalid code lengths set", i.mode = Gr;
+                        }, k = _r(0, i.lens, 0, 19, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
+                        e.msg = "invalid code lengths set", i.mode = Vr;
                         break
                     }
                     i.have = 0, i.mode = 16198;
                 case 16198:
                     for (; i.have < i.nlen + i.ndist;) {
                         for (; C = i.lencode[h & (1 << i.lenbits) - 1], m = C >>> 24, b = C >>> 16 & 255, w = 65535 & C, !(m <= c);) {
                             if (0 === a) break e;
@@ -4483,15 +4482,15 @@
                         else {
                             if (16 === w) {
                                 for (E = m + 2; c < E;) {
                                     if (0 === a) break e;
                                     a--, h += n[s++] << c, c += 8
                                 }
                                 if (h >>>= m, c -= m, 0 === i.have) {
-                                    e.msg = "invalid bit length repeat", i.mode = Gr;
+                                    e.msg = "invalid bit length repeat", i.mode = Vr;
                                     break
                                 }
                                 x = i.lens[i.have - 1], f = 3 + (3 & h), h >>>= 2, c -= 2
                             } else if (17 === w) {
                                 for (E = m + 3; c < E;) {
                                     if (0 === a) break e;
                                     a--, h += n[s++] << c, c += 8
@@ -4501,43 +4500,43 @@
                                 for (E = m + 7; c < E;) {
                                     if (0 === a) break e;
                                     a--, h += n[s++] << c, c += 8
                                 }
                                 h >>>= m, c -= m, x = 0, f = 11 + (127 & h), h >>>= 7, c -= 7
                             }
                             if (i.have + f > i.nlen + i.ndist) {
-                                e.msg = "invalid bit length repeat", i.mode = Gr;
+                                e.msg = "invalid bit length repeat", i.mode = Vr;
                                 break
                             }
                             for (; f--;) i.lens[i.have++] = x
                         }
                     }
-                    if (i.mode === Gr) break;
+                    if (i.mode === Vr) break;
                     if (0 === i.lens[256]) {
-                        e.msg = "invalid code -- missing end-of-block", i.mode = Gr;
+                        e.msg = "invalid code -- missing end-of-block", i.mode = Vr;
                         break
                     }
                     if (i.lenbits = 9, A = {
                             bits: i.lenbits
-                        }, k = Er(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
-                        e.msg = "invalid literal/lengths set", i.mode = Gr;
+                        }, k = _r(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
+                        e.msg = "invalid literal/lengths set", i.mode = Vr;
                         break
                     }
                     if (i.distbits = 6, i.distcode = i.distdyn, A = {
                             bits: i.distbits
-                        }, k = Er(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, A), i.distbits = A.bits, k) {
-                        e.msg = "invalid distances set", i.mode = Gr;
+                        }, k = _r(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, A), i.distbits = A.bits, k) {
+                        e.msg = "invalid distances set", i.mode = Vr;
                         break
                     }
-                    if (i.mode = jr, t === Rr) break e;
-                case jr:
-                    i.mode = $r;
-                case $r:
+                    if (i.mode = Dr, t === Cr) break e;
+                case Dr:
+                    i.mode = zr;
+                case zr:
                     if (a >= 6 && l >= 258) {
-                        e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, _r(e, u), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, i.mode === Vr && (i.back = -1);
+                        e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, gr(e, u), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, i.mode === Nr && (i.back = -1);
                         break
                     }
                     for (i.back = 0; C = i.lencode[h & (1 << i.lenbits) - 1], m = C >>> 24, b = C >>> 16 & 255, w = 65535 & C, !(m <= c);) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if (b && 0 == (240 & b)) {
@@ -4548,19 +4547,19 @@
                         h >>>= v, c -= v, i.back += v
                     }
                     if (h >>>= m, c -= m, i.back += m, i.length = w, 0 === b) {
                         i.mode = 16205;
                         break
                     }
                     if (32 & b) {
-                        i.back = -1, i.mode = Vr;
+                        i.back = -1, i.mode = Nr;
                         break
                     }
                     if (64 & b) {
-                        e.msg = "invalid literal/length code", i.mode = Gr;
+                        e.msg = "invalid literal/length code", i.mode = Vr;
                         break
                     }
                     i.extra = 15 & b, i.mode = 16201;
                 case 16201:
                     if (i.extra) {
                         for (E = i.extra; c < E;) {
                             if (0 === a) break e;
@@ -4578,270 +4577,270 @@
                         for (v = m, y = b, _ = w; C = i.distcode[_ + ((h & (1 << v + y) - 1) >> v)], m = C >>> 24, b = C >>> 16 & 255, w = 65535 & C, !(v + m <= c);) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         h >>>= v, c -= v, i.back += v
                     }
                     if (h >>>= m, c -= m, i.back += m, 64 & b) {
-                        e.msg = "invalid distance code", i.mode = Gr;
+                        e.msg = "invalid distance code", i.mode = Vr;
                         break
                     }
                     i.offset = w, i.extra = 15 & b, i.mode = 16203;
                 case 16203:
                     if (i.extra) {
                         for (E = i.extra; c < E;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         i.offset += h & (1 << i.extra) - 1, h >>>= i.extra, c -= i.extra, i.back += i.extra
                     }
                     if (i.offset > i.dmax) {
-                        e.msg = "invalid distance too far back", i.mode = Gr;
+                        e.msg = "invalid distance too far back", i.mode = Vr;
                         break
                     }
                     i.mode = 16204;
                 case 16204:
                     if (0 === l) break e;
                     if (f = u - l, i.offset > f) {
                         if (f = i.offset - f, f > i.whave && i.sane) {
-                            e.msg = "invalid distance too far back", i.mode = Gr;
+                            e.msg = "invalid distance too far back", i.mode = Vr;
                             break
                         }
                         f > i.wnext ? (f -= i.wnext, p = i.wsize - f) : p = i.wnext - f, f > i.length && (f = i.length), g = i.window
                     } else g = r, p = o - i.offset, f = i.length;
                     f > l && (f = l), l -= f, i.length -= f;
                     do {
                         r[o++] = g[p++]
                     } while (--f);
-                    0 === i.length && (i.mode = $r);
+                    0 === i.length && (i.mode = zr);
                     break;
                 case 16205:
                     if (0 === l) break e;
-                    r[o++] = i.length, l--, i.mode = $r;
+                    r[o++] = i.length, l--, i.mode = zr;
                     break;
-                case Wr:
+                case Hr:
                     if (i.wrap) {
                         for (; c < 32;) {
                             if (0 === a) break e;
                             a--, h |= n[s++] << c, c += 8
                         }
-                        if (u -= l, e.total_out += u, i.total += u, 4 & i.wrap && u && (e.adler = i.check = i.flags ? Wi(i.check, r, u, o - u) : ji(i.check, r, u, o - u)), u = l, 4 & i.wrap && (i.flags ? h : Zr(h)) !== i.check) {
-                            e.msg = "incorrect data check", i.mode = Gr;
+                        if (u -= l, e.total_out += u, i.total += u, 4 & i.wrap && u && (e.adler = i.check = i.flags ? $i(i.check, r, u, o - u) : qi(i.check, r, u, o - u)), u = l, 4 & i.wrap && (i.flags ? h : Ur(h)) !== i.check) {
+                            e.msg = "incorrect data check", i.mode = Vr;
                             break
                         }
                         h = 0, c = 0
                     }
                     i.mode = 16207;
                 case 16207:
                     if (i.wrap && i.flags) {
                         for (; c < 32;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         if (4 & i.wrap && h !== (4294967295 & i.total)) {
-                            e.msg = "incorrect length check", i.mode = Gr;
+                            e.msg = "incorrect length check", i.mode = Vr;
                             break
                         }
                         h = 0, c = 0
                     }
                     i.mode = 16208;
                 case 16208:
-                    k = Ir;
+                    k = Ar;
                     break e;
-                case Gr:
-                    k = Fr;
+                case Vr:
+                    k = Tr;
                     break e;
                 case 16210:
-                    return Pr;
+                    return Rr;
                 default:
-                    return Nr
+                    return Mr
             }
-            return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, (i.wsize || u !== e.avail_out && i.mode < Gr && (i.mode < Wr || t !== Tr)) && ss(e, e.output, e.next_out, u - e.avail_out), d -= e.avail_in, u -= e.avail_out, e.total_in += d, e.total_out += u, i.total += u, 4 & i.wrap && u && (e.adler = i.check = i.flags ? Wi(i.check, r, u, e.next_out - u) : ji(i.check, r, u, e.next_out - u)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === Vr ? 128 : 0) + (i.mode === jr || i.mode === qr ? 256 : 0), (0 === d && 0 === u || t === Tr) && k === Lr && (k = Or), k
+            return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, (i.wsize || u !== e.avail_out && i.mode < Vr && (i.mode < Hr || t !== xr)) && Jr(e, e.output, e.next_out, u - e.avail_out), d -= e.avail_in, u -= e.avail_out, e.total_in += d, e.total_out += u, i.total += u, 4 & i.wrap && u && (e.adler = i.check = i.flags ? $i(i.check, r, u, e.next_out - u) : qi(i.check, r, u, e.next_out - u)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === Nr ? 128 : 0) + (i.mode === Dr || i.mode === Pr ? 256 : 0), (0 === d && 0 === u || t === xr) && k === Sr && (k = Lr), k
         },
-        as = {
-            inflateReset: Kr,
-            inflateReset2: Jr,
-            inflateResetKeep: Yr,
-            inflateInit: e => es(e, 15),
-            inflateInit2: es,
-            inflate: os,
+        ts = {
+            inflateReset: Wr,
+            inflateReset2: Gr,
+            inflateResetKeep: $r,
+            inflateInit: e => Zr(e, 15),
+            inflateInit2: Zr,
+            inflate: es,
             inflateEnd: e => {
-                if (Xr(e)) return Nr;
+                if (jr(e)) return Mr;
                 let t = e.state;
-                return t.window && (t.window = null), e.state = null, Lr
+                return t.window && (t.window = null), e.state = null, Sr
             },
             inflateGetHeader: (e, t) => {
-                if (Xr(e)) return Nr;
+                if (jr(e)) return Mr;
                 const i = e.state;
-                return 0 == (2 & i.wrap) ? Nr : (i.head = t, t.done = !1, Lr)
+                return 0 == (2 & i.wrap) ? Mr : (i.head = t, t.done = !1, Sr)
             },
             inflateSetDictionary: (e, t) => {
                 const i = t.length;
                 let n, r, s;
-                return Xr(e) ? Nr : (n = e.state, 0 !== n.wrap && n.mode !== Hr ? Nr : n.mode === Hr && (r = 1, r = ji(r, t, i, 0), r !== n.check) ? Fr : (s = ss(e, t, i, i), s ? (n.mode = 16210, Pr) : (n.havedict = 1, Lr)))
+                return jr(e) ? Mr : (n = e.state, 0 !== n.wrap && n.mode !== Fr ? Mr : n.mode === Fr && (r = 1, r = qi(r, t, i, 0), r !== n.check) ? Tr : (s = Jr(e, t, i, i), s ? (n.mode = 16210, Rr) : (n.havedict = 1, Sr)))
             },
             inflateInfo: "pako inflate (from Nodeca project)"
         };
-    var ls = function() {
+    var is = function() {
         this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
     };
-    const hs = Object.prototype.toString,
+    const ns = Object.prototype.toString,
         {
-            Z_NO_FLUSH: cs,
-            Z_FINISH: ds,
-            Z_OK: us,
-            Z_STREAM_END: fs,
-            Z_NEED_DICT: ps,
-            Z_STREAM_ERROR: gs,
-            Z_DATA_ERROR: ms,
-            Z_MEM_ERROR: bs
-        } = Zi;
+            Z_NO_FLUSH: rs,
+            Z_FINISH: ss,
+            Z_OK: os,
+            Z_STREAM_END: as,
+            Z_NEED_DICT: ls,
+            Z_STREAM_ERROR: hs,
+            Z_DATA_ERROR: cs,
+            Z_MEM_ERROR: ds
+        } = Gi;
 
-    function ws(e) {
-        this.options = er.assign({
+    function us(e) {
+        this.options = Zn.assign({
             chunkSize: 65536,
             windowBits: 15,
             to: ""
         }, e || {});
         const t = this.options;
-        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new rr, this.strm.avail_out = 0;
-        let i = as.inflateInit2(this.strm, t.windowBits);
-        if (i !== us) throw new Error(Gi[i]);
-        if (this.header = new ls, as.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = nr.string2buf(t.dictionary) : "[object ArrayBuffer]" === hs.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = as.inflateSetDictionary(this.strm, t.dictionary), i !== us))) throw new Error(Gi[i])
+        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Kn, this.strm.avail_out = 0;
+        let i = ts.inflateInit2(this.strm, t.windowBits);
+        if (i !== os) throw new Error(Wi[i]);
+        if (this.header = new is, ts.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = Yn.string2buf(t.dictionary) : "[object ArrayBuffer]" === ns.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = ts.inflateSetDictionary(this.strm, t.dictionary), i !== os))) throw new Error(Wi[i])
     }
 
-    function vs(e, t) {
-        const i = new ws(t);
-        if (i.push(e), i.err) throw i.msg || Gi[i.err];
+    function fs(e, t) {
+        const i = new us(t);
+        if (i.push(e), i.err) throw i.msg || Wi[i.err];
         return i.result
     }
-    ws.prototype.push = function(e, t) {
+    us.prototype.push = function(e, t) {
         const i = this.strm,
             n = this.options.chunkSize,
             r = this.options.dictionary;
         let s, o, a;
         if (this.ended) return !1;
-        for (o = t === ~~t ? t : !0 === t ? ds : cs, "[object ArrayBuffer]" === hs.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;) {
-            for (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), s = as.inflate(i, o), s === ps && r && (s = as.inflateSetDictionary(i, r), s === us ? s = as.inflate(i, o) : s === ms && (s = ps)); i.avail_in > 0 && s === fs && i.state.wrap > 0 && 0 !== e[i.next_in];) as.inflateReset(i), s = as.inflate(i, o);
+        for (o = t === ~~t ? t : !0 === t ? ss : rs, "[object ArrayBuffer]" === ns.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;) {
+            for (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), s = ts.inflate(i, o), s === ls && r && (s = ts.inflateSetDictionary(i, r), s === os ? s = ts.inflate(i, o) : s === cs && (s = ls)); i.avail_in > 0 && s === as && i.state.wrap > 0 && 0 !== e[i.next_in];) ts.inflateReset(i), s = ts.inflate(i, o);
             switch (s) {
-                case gs:
-                case ms:
-                case ps:
-                case bs:
+                case hs:
+                case cs:
+                case ls:
+                case ds:
                     return this.onEnd(s), this.ended = !0, !1
             }
-            if (a = i.avail_out, i.next_out && (0 === i.avail_out || s === fs))
+            if (a = i.avail_out, i.next_out && (0 === i.avail_out || s === as))
                 if ("string" === this.options.to) {
-                    let e = nr.utf8border(i.output, i.next_out),
+                    let e = Yn.utf8border(i.output, i.next_out),
                         t = i.next_out - e,
-                        r = nr.buf2string(i.output, e);
+                        r = Yn.buf2string(i.output, e);
                     i.next_out = t, i.avail_out = n - t, t && i.output.set(i.output.subarray(e, e + t), 0), this.onData(r)
                 } else this.onData(i.output.length === i.next_out ? i.output : i.output.subarray(0, i.next_out));
-            if (s !== us || 0 !== a) {
-                if (s === fs) return s = as.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
+            if (s !== os || 0 !== a) {
+                if (s === as) return s = ts.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
                 if (0 === i.avail_in) break
             }
         }
         return !0
-    }, ws.prototype.onData = function(e) {
+    }, us.prototype.onData = function(e) {
         this.chunks.push(e)
-    }, ws.prototype.onEnd = function(e) {
-        e === us && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = er.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
+    }, us.prototype.onEnd = function(e) {
+        e === os && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Zn.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
     };
-    var ys = function(e, t) {
-            return (t = t || {}).raw = !0, vs(e, t)
+    var ps = function(e, t) {
+            return (t = t || {}).raw = !0, fs(e, t)
         },
-        _s = {
-            Inflate: ws,
-            inflate: vs,
-            inflateRaw: ys,
-            ungzip: vs,
-            constants: Zi
+        gs = {
+            Inflate: us,
+            inflate: fs,
+            inflateRaw: ps,
+            ungzip: fs,
+            constants: Gi
         };
     const {
-        Deflate: xs,
-        deflate: ks,
-        deflateRaw: Cs,
-        gzip: Ss
-    } = vr, {
-        Inflate: As,
-        inflate: Es,
-        inflateRaw: Ts,
-        ungzip: Ms
-    } = _s;
-    var Rs = Cs,
-        Ls = Es,
-        Is = Ts,
-        Bs = Ms;
-    const Ns = 4;
+        Deflate: ms,
+        deflate: bs,
+        deflateRaw: ws,
+        gzip: vs
+    } = fr, {
+        Inflate: ys,
+        inflate: _s,
+        inflateRaw: xs,
+        ungzip: ks
+    } = gs;
+    var Cs = ws,
+        Ss = _s,
+        As = xs,
+        Es = ks;
+    const Ms = 4;
 
-    function Fs(e, t) {
+    function Ts(e, t) {
         const i = [];
         let n = 0,
             r = 0;
         for (t = t || e.byteLength - 18; n < t;) try {
             const t = ArrayBuffer.isView(e) ? e : new Uint8Array(e, n, 18),
                 s = t[11] << 8 | t[10],
                 o = (t[3], t[12], t[13], t[15], t[14], 1 + (t[17] << 8 | t[16])),
                 a = 12 + s + n,
                 l = e.byteLength - a,
                 h = o - s - 19;
             if (l < h || h <= 0) break;
             const c = new Uint8Array(e, a, h),
-                d = Is(c);
+                d = As(c);
             n += h - 1 + 26, r += d.byteLength, i.push(d)
         } catch (e) {
             console.error(e);
             break
         }
         if (1 === i.length) return i[0]; {
             const e = new Uint8Array(r);
             let t = 0;
             for (let n = 0; n < i.length; ++n) {
                 var s = new Uint8Array(i[n]);
-                Ds(s, 0, e, t, s.length), t += s.length
+                Is(s, 0, e, t, s.length), t += s.length
             }
             return e
         }
     }
 
-    function Ps(e) {
+    function Rs(e) {
         const t = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
         return 1 + (t[17] << 8 | t[16])
     }
-    const Os = "function" == typeof new Uint8Array(1).subarray;
+    const Ls = "function" == typeof new Uint8Array(1).subarray;
 
-    function Ds(e, t, i, n, r) {
+    function Is(e, t, i, n, r) {
         if (0 !== r) {
             if (!e) throw "Undef src";
             if (!i) throw "Undef dest";
-            0 === t && r === e.length ? zs(e, i, n) : Os ? zs(e.subarray(t, t + r), i, n) : 1 === e.BYTES_PER_ELEMENT && r > 100 ? zs(new Uint8Array(e.buffer, e.byteOffset + t, r), i, n) : function(e, t, i, n, r) {
+            0 === t && r === e.length ? Bs(e, i, n) : Ls ? Bs(e.subarray(t, t + r), i, n) : 1 === e.BYTES_PER_ELEMENT && r > 100 ? Bs(new Uint8Array(e.buffer, e.byteOffset + t, r), i, n) : function(e, t, i, n, r) {
                 for (let s = 0; s < r; ++s) i[n + s] = e[t + s]
             }(e, t, i, n, r)
         }
     }
 
-    function zs(e, t, i) {
+    function Bs(e, t, i) {
         t.set(e, i)
     }
 
-    function Hs(e, t) {
+    function Fs(e, t) {
         const i = e.split(","),
             n = i[0].split(":")[1];
         let r = i[1];
         if (n.indexOf("base64") >= 0) {
             r = atob(r);
             const e = new Uint8Array(r.length);
             for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);
             let i;
-            return i = t || n.indexOf("gzip") > 0 ? Bs(e) : e, i
+            return i = t || n.indexOf("gzip") > 0 ? Es(e) : e, i
         }
         return decodeURIComponent(r)
     }
-    const Vs = {
+    const Ns = {
         lerp: (e, t, i) => (1 - i) * e + i * t,
         mean: function(e) {
             var t, i = 0,
                 n = 0;
             for (t = 0; t < e.length; t++) isNaN(e[t]) || (i += e[t], n++);
             return n > 0 ? i / n : 0
         },
@@ -4864,15 +4863,15 @@
         },
         percentile: function(e, t) {
             if (0 !== e.length) {
                 var i = Math.floor(e.length * ((100 - t) / 100));
                 return 0 === i ? (e.sort((function(e, t) {
                     return t - e
                 })), e[i]) : function(e, t) {
-                    var i, n = new Us;
+                    var i, n = new Os;
                     for (i = 0; i < e.length; i++) {
                         var r = e[i];
                         (n.content.length < t || r > n.content[0]) && (n.content.length === t && n.pop(), n.push(r))
                     }
                     return n.content[0]
                 }(e, i)
             }
@@ -4881,22 +4880,22 @@
             return Math.min(Math.max(e, t), i)
         },
         log2: function(e) {
             return Math.log(e) / Math.LN2
         }
     };
 
-    function Us() {
+    function Os() {
         this.content = []
     }
 
-    function qs(e, t) {
+    function Ps(e, t) {
         return Math.random() * (t - e) + e
     }
-    Us.prototype = {
+    Os.prototype = {
         push: function(e) {
             this.content.push(e), this.bubbleUp(this.content.length - 1)
         },
         pop: function() {
             var e = this.content[0],
                 t = this.content.pop();
             return this.content.length > 0 && (this.content[0] = t, this.sinkDown(0)), e
@@ -4933,23 +4932,23 @@
                 }
                 if (r < t) this.content[r] < (null == o ? n : l) && (o = r);
                 if (null == o) break;
                 this.content[e] = this.content[o], this.content[o] = i, e = o
             }
         }
     };
-    const js = {
+    const Ds = {
             rgbListFromHSV: () => {
                 let e = [];
                 for (let t = 1; t >= .5; t -= .1)
                     for (let i = 0; i < 1; i += 1 / 28) {
-                        const n = "rgb(" + js.hsvToRgb(i, 1, t).join(",") + ")";
+                        const n = "rgb(" + Ds.hsvToRgb(i, 1, t).join(",") + ")";
                         e.push(n)
                     }
-                return e.pop(), e.push(js.rgbColor(16, 16, 16)), e
+                return e.pop(), e.push(Ds.rgbColor(16, 16, 16)), e
             },
             rgbToHex: function(e) {
                 return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : ""
             },
             hexToRgb: function(e) {
                 var t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
                 if (null !== t) return "rgb(" + parseInt(t[1], 16) + "," + parseInt(t[2], 16) + "," + parseInt(t[3], 16) + ")"
@@ -4983,56 +4982,56 @@
             },
             hslToRgb: function(e, t, i) {
                 var n, r, s;
                 if (0 === t) n = r = s = i;
                 else {
                     var o = i < .5 ? i * (1 + t) : i + t - i * t,
                         a = 2 * i - o;
-                    n = js.hue2rgb(a, o, e + 1 / 3), r = js.hue2rgb(a, o, e), s = js.hue2rgb(a, o, e - 1 / 3)
+                    n = Ds.hue2rgb(a, o, e + 1 / 3), r = Ds.hue2rgb(a, o, e), s = Ds.hue2rgb(a, o, e - 1 / 3)
                 }
                 return [255 * n, 255 * r, 255 * s]
             },
             hue2rgb: (e, t, i) => (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e),
             rgbaColor: function(e, t, i, n) {
-                return "rgba(" + (e = Vs.clamp(e, 0, 255)) + "," + (t = Vs.clamp(t, 0, 255)) + "," + (i = Vs.clamp(i, 0, 255)) + "," + (n = Vs.clamp(n, 0, 1)) + ")"
+                return "rgba(" + (e = Ns.clamp(e, 0, 255)) + "," + (t = Ns.clamp(t, 0, 255)) + "," + (i = Ns.clamp(i, 0, 255)) + "," + (n = Ns.clamp(n, 0, 1)) + ")"
             },
             rgbColor: function(e, t, i) {
-                return "rgb(" + (e = Vs.clamp(e, 0, 255)) + "," + (t = Vs.clamp(t, 0, 255)) + "," + (i = Vs.clamp(i, 0, 255)) + ")"
+                return "rgb(" + (e = Ns.clamp(e, 0, 255)) + "," + (t = Ns.clamp(t, 0, 255)) + "," + (i = Ns.clamp(i, 0, 255)) + ")"
             },
             greyScale: function(e) {
-                var t = Vs.clamp(e, 0, 255);
+                var t = Ns.clamp(e, 0, 255);
                 return "rgb(" + t + "," + t + "," + t + ")"
             },
             randomGrey: function(e, t) {
-                e = Vs.clamp(e, 0, 255), t = Vs.clamp(t, 0, 255);
-                var i = Math.round(qs(e, t)).toString(10);
+                e = Ns.clamp(e, 0, 255), t = Ns.clamp(t, 0, 255);
+                var i = Math.round(Ps(e, t)).toString(10);
                 return "rgb(" + i + "," + i + "," + i + ")"
             },
             randomRGB: function(e, t) {
-                return e = Vs.clamp(e, 0, 255), t = Vs.clamp(t, 0, 255), "rgb(" + Math.round(qs(e, t)).toString(10) + "," + Math.round(qs(e, t)).toString(10) + "," + Math.round(qs(e, t)).toString(10) + ")"
+                return e = Ns.clamp(e, 0, 255), t = Ns.clamp(t, 0, 255), "rgb(" + Math.round(Ps(e, t)).toString(10) + "," + Math.round(Ps(e, t)).toString(10) + "," + Math.round(Ps(e, t)).toString(10) + ")"
             },
             randomRGBConstantAlpha: function(e, t, i) {
-                return e = Vs.clamp(e, 0, 255), t = Vs.clamp(t, 0, 255), "rgba(" + Math.round(qs(e, t)).toString(10) + "," + Math.round(qs(e, t)).toString(10) + "," + Math.round(qs(e, t)).toString(10) + "," + i + ")"
+                return e = Ns.clamp(e, 0, 255), t = Ns.clamp(t, 0, 255), "rgba(" + Math.round(Ps(e, t)).toString(10) + "," + Math.round(Ps(e, t)).toString(10) + "," + Math.round(Ps(e, t)).toString(10) + "," + i + ")"
             },
             addAlpha: function(e, t) {
                 if ("0" === e || "." === e) e = "rgb(0,0,0)";
                 else {
                     const t = this.colorNameToHex(e);
                     t && (e = t)
                 }
                 var i = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e);
                 if (e.startsWith("rgba")) {
                     const i = e.lastIndexOf(",");
                     return e.substring(0, i + 1) + t.toString() + ")"
                 }
-                return i && (e = js.hexToRgb(e)), e.startsWith("rgb") ? e.replace("rgb", "rgba").replace(")", ", " + t + ")") : (console.log(e + " is not an rgb style string"), e)
+                return i && (e = Ds.hexToRgb(e)), e.startsWith("rgb") ? e.replace("rgb", "rgba").replace(")", ", " + t + ")") : (console.log(e + " is not an rgb style string"), e)
             },
             rgbComponents: function(e) {
                 if ("0" === e || "." === e) return [0, 0, 0];
-                if (/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e)) e = js.hexToRgb(e);
+                if (/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e)) e = Ds.hexToRgb(e);
                 else if (!e.startsWith("rgb")) {
                     const t = this.colorNameToHex(e);
                     e = this.hexToRgb(t)
                 }
                 if (e.startsWith("rgb(")) return e.substring(4, e.length - 1).split(",").map((e => Number.parseInt(e.trim())));
                 if (e.startsWith("rgba(")) return e.substring(5, e.length - 1).split(",").map(((e, t) => (e = e.trim(), 3 === t ? Number.parseFloat(e) : Number.parseInt(e))));
                 throw Error("Unrecognized color string: color")
@@ -5043,15 +5042,15 @@
             createColorString: function(e) {
                 return (e = function(e) {
                     return void 0 === e || ((e.startsWith("'") || e.startsWith('"')) && (e = e.substring(1)), (e.endsWith("'") || e.endsWith('"')) && (e = e.substring(0, e.length - 1))), e
                 }(e)).includes(",") ? e.startsWith("rgb") ? e : "rgb(" + e + ")" : e
             },
             darkenLighten: function(e, t) {
                 let i, n = this.colorNameToHex(e);
-                i = n ? js.hexToRgb(n) : e.startsWith("rgb(") ? e : js.hexToRgb(e);
+                i = n ? Ds.hexToRgb(n) : e.startsWith("rgb(") ? e : Ds.hexToRgb(e);
                 const r = i.replace(")", "").substring(4).split(","),
                     s = Math.max(0, Math.min(255, Number.parseInt(r[0].trim()) + t)),
                     o = Math.max(0, Math.min(255, Number.parseInt(r[1].trim()) + t)),
                     a = Math.max(0, Math.min(255, Number.parseInt(r[2].trim()) + t));
                 return "rgb(" + s.toString() + "," + o.toString() + "," + a.toString() + ")"
             },
             colorNameToHex: function(e) {
@@ -5202,62 +5201,62 @@
                     grey: "#808080",
                     lightgray: "#d3d3d3",
                     lightslategrey: "#778899",
                     slategrey: "#708090"
                 } [e]
             }
         },
-        $s = "googleapis";
-    class Ws {
+        zs = "googleapis";
+    class Hs {
         constructor() {
             this.oauthTokens = {}
         }
         setToken(e, t) {
-            t = t || $s, this.oauthTokens[t] = e
+            t = t || zs, this.oauthTokens[t] = e
         }
         getToken(e) {
             let t;
-            e = e || $s;
+            e = e || zs;
             for (let i of Object.keys(this.oauthTokens)) {
-                if (Gs(i).test(e)) {
+                if (Vs(i).test(e)) {
                     t = this.oauthTokens[i];
                     break
                 }
             }
             return t
         }
         removeToken(e) {
-            e = e || $s;
+            e = e || zs;
             for (let t of Object.keys(this.oauthTokens)) {
-                Gs(t).test(e) && (this.oauthTokens[t] = void 0)
+                Vs(t).test(e) && (this.oauthTokens[t] = void 0)
             }
         }
     }
 
-    function Gs(e) {
-        return new RegExp("^" + e.split(/\*+/).map(Zs).join(".*") + "$")
+    function Vs(e) {
+        return new RegExp("^" + e.split(/\*+/).map(Us).join(".*") + "$")
     }
 
-    function Zs(e) {
+    function Us(e) {
         return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
     }
 
-    function Qs(e) {
-        return e.includes("googleapis") && !e.includes("urlshortener") || Xs(e) || Ys(e)
+    function qs(e) {
+        return e.includes("googleapis") && !e.includes("urlshortener") || js(e) || $s(e)
     }
 
-    function Xs(e) {
+    function js(e) {
         return e.startsWith("gs://") || e.startsWith("https://www.googleapis.com/storage") || e.startsWith("https://storage.cloud.google.com") || e.startsWith("https://storage.googleapis.com")
     }
 
-    function Ys(e) {
+    function $s(e) {
         return e.indexOf("drive.google.com") >= 0 || e.indexOf("www.googleapis.com/drive") > 0
     }
 
-    function Ks(e) {
+    function Ws(e) {
         let {
             bucket: t,
             object: i
         } = function(e) {
             let t, i;
             if (e.startsWith("gs://")) {
                 const n = e.indexOf("/", 5);
@@ -5293,27 +5292,27 @@
                 object: i
             };
             throw Error(`Unrecognized Google Storage URI: ${e}`)
         }(e);
         i = function(e) {
             let t = "";
             return e.split("").forEach((function(e) {
-                Js.has(e) ? t += Js.get(e) : t += e
+                Gs.has(e) ? t += Gs.get(e) : t += e
             })), t
         }(i);
         const n = e.indexOf("?");
         return `https://storage.googleapis.com/storage/v1/b/${t}/o/${i}${n>0?e.substring(n)+"&alt=media":"?alt=media"}`
     }
-    const Js = new Map;
+    const Gs = new Map;
 
-    function eo() {
-        return void 0 !== google.igv
+    function Zs() {
+        return window.google && window.google.igv
     }
-    async function to(e) {
-        if (!eo()) throw Error("Google oAuth has not been initialized");
+    async function Qs(e) {
+        if (!Zs()) throw Error("Google oAuth has not been initialized");
         if (google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt && google.accounts.oauth2.hasGrantedAllScopes(google.igv.tokenResponse, e)) return google.igv.tokenResponse.access_token; {
             const t = google.igv.tokenClient;
             return new Promise(((i, n) => {
                 try {
                     t.callback = e => {
                         void 0 !== e.error && n(e), google.igv.tokenResponse = e, google.igv.tokenExpiresAt = Date.now() + 1e3 * e.expires_in, i(e.access_token)
                     }, t.requestAccessToken({
@@ -5322,24 +5321,24 @@
                 } catch (e) {
                     console.log(e)
                 }
             }))
         }
     }
 
-    function io() {
+    function Xs() {
         return google.igv.apiKey
     }
 
-    function no(e) {
-        var t = ro(e);
+    function Ys(e) {
+        var t = Ks(e);
         return t ? "https://www.googleapis.com/drive/v3/files/" + t + "?alt=media&supportsTeamDrives=true" : e
     }
 
-    function ro(e) {
+    function Ks(e) {
         if (e.includes("/open?id=")) {
             const t = e.indexOf("/open?id=") + 9,
                 i = e.indexOf("&");
             if (t > 0 && i > t) return e.substring(t, i);
             if (t > 0) return e.substring(t)
         } else {
             if (e.includes("/file/d/")) {
@@ -5351,16 +5350,16 @@
                 let t = e.indexOf("/files/");
                 const i = e.indexOf("?");
                 if (t > 0) return t += 7, i > 0 ? e.substring(t, i) : e.substring(t)
             }
         }
         throw Error("Unknown Google Drive url format: " + e)
     }
-    Js.set("!", "%21"), Js.set("#", "%23"), Js.set("$", "%24"), Js.set("%", "%25"), Js.set("&", "%26"), Js.set("'", "%27"), Js.set("(", "%28"), Js.set(")", "%29"), Js.set("*", "%2A"), Js.set("+", "%2B"), Js.set(",", "%2C"), Js.set("/", "%2F"), Js.set(":", "%3A"), Js.set(";", "%3B"), Js.set("=", "%3D"), Js.set("?", "%3F"), Js.set("@", "%40"), Js.set("[", "%5B"), Js.set("]", "%5D"), Js.set(" ", "%20");
-    class so {
+    Gs.set("!", "%21"), Gs.set("#", "%23"), Gs.set("$", "%24"), Gs.set("%", "%25"), Gs.set("&", "%26"), Gs.set("'", "%27"), Gs.set("(", "%28"), Gs.set(")", "%29"), Gs.set("*", "%2A"), Gs.set("+", "%2B"), Gs.set(",", "%2C"), Gs.set("/", "%2F"), Gs.set(":", "%3A"), Gs.set(";", "%3B"), Gs.set("=", "%3D"), Gs.set("?", "%3F"), Gs.set("@", "%40"), Gs.set("[", "%5B"), Gs.set("]", "%5D"), Gs.set(" ", "%20");
+    class Js {
         constructor(e) {
             this.requestsPerSecond = e.requestsPerSecond || 10, this.lastStartTime = 0, this.queued = []
         }
         add(e, t) {
             var i = this;
             return new Promise((function(t, n) {
                 i.queued.push({
@@ -5395,28 +5394,28 @@
                 e.resolve(i)
             } catch (t) {
                 e.reject(t)
             }
         }
     }
 
-    function oo() {
-        if (eo()) {
-            return eo() && google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt ? google.igv.tokenResponse.access_token : void 0
+    function eo() {
+        if (Zs()) {
+            return Zs() && google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt ? google.igv.tokenResponse.access_token : void 0
         }
     }
 
-    function ao(e) {
+    function to(e) {
         let t;
         return t = function(e) {
             const t = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
             return 31 === t[0] && 139 === t[1]
         }(e) ? function(e) {
             const t = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
-            return 0 != (t[3] & Ns) && 66 === t[12] && 67 === t[13] ? Fs(t.buffer) : Bs(t)
+            return 0 != (t[3] & Ms) && 66 === t[12] && 67 === t[13] ? Ts(t.buffer) : Es(t)
         }(e) : new Uint8Array(e), "TextDecoder" in function() {
             if ("undefined" != typeof self) return self;
             return "undefined" != typeof global ? global : window
         }() ? (new TextDecoder).decode(t) : function(e) {
             var t = "",
                 i = 0;
             for (; i < e.length;) {
@@ -5427,19 +5426,19 @@
                     for (var o = 0; o < r;) s = s << 6 | 63 & (n = e[i + o + 1]), o += 1;
                 else s = 65533, r = e.length - i;
                 t += String.fromCodePoint(s), i += r + 1
             }
             return t
         }(t)
     }
-    const lo = new class {
+    const io = new class {
         constructor() {
-            this.apiKey = void 0, this.googleThrottle = new so({
+            this.apiKey = void 0, this.googleThrottle = new Js({
                 requestsPerSecond: 8
-            }), this.RANGE_WARNING_GIVEN = !1, this.oauth = new Ws
+            }), this.RANGE_WARNING_GIVEN = !1, this.oauth = new Hs, this.contentLengthMap = new Map
         }
         setApiKey(e) {
             this.apiKey = e
         }
         async loadArrayBuffer(e, t) {
             return (t = t || {}).responseType || (t.responseType = "arraybuffer"), ti(e) ? this._loadFileSlice(e, t) : this.load(e, t)
         }
@@ -5453,224 +5452,235 @@
         }
         async load(e, t) {
             t = t || {};
             const i = typeof e;
             if (ti(e = await ("function" == typeof e ? e() : e))) return this._loadFileSlice(e, t);
             if ("function" == typeof e.startsWith) {
                 if (e.startsWith("data:")) {
-                    const i = Hs(e).buffer;
+                    const i = Fs(e).buffer;
                     if (t.range) {
                         const e = t.range.size ? t.range.start + t.range.size : i.byteLength;
                         return i.slice(t.range.start, e)
                     }
                     return i
                 }
-                return e.startsWith("https://drive.google.com") && (e = no(e)), Ys(e) || e.startsWith("https://www.dropbox.com") ? this.googleThrottle.add((async () => this._loadURL(e, t))) : this._loadURL(e, t)
+                return e.startsWith("https://drive.google.com") && (e = Ys(e)), $s(e) || e.startsWith("https://www.dropbox.com") ? this.googleThrottle.add((async () => this._loadURL(e, t))) : this._loadURL(e, t)
             }
             throw Error(`url must be either a 'File', 'string', 'function', or 'Promise'.  Actual type: ${i}`)
         }
         async _loadURL(e, t) {
+            const i = this;
+            let n = t.contentLength || this.contentLengthMap.get(e);
             e = function(e) {
-                return e.includes("//www.dropbox.com") ? e.replace("//www.dropbox.com", "//dl.dropboxusercontent.com") : e.includes("//drive.google.com") ? no(e) : e.includes("//www.broadinstitute.org/igvdata") ? e.replace("//www.broadinstitute.org/igvdata", "//data.broadinstitute.org/igvdata") : e.includes("//igvdata.broadinstitute.org") ? e.replace("//igvdata.broadinstitute.org", "https://dn7ywbm9isq8j.cloudfront.net") : e.startsWith("ftp://ftp.ncbi.nlm.nih.gov/geo") ? e.replace("ftp://", "https://") : e
+                return e.startsWith("https://www.dropbox.com") ? e.replace("//www.dropbox.com", "//dl.dropboxusercontent.com") : e.startsWith("https://drive.google.com") ? Ys(e) : e.includes("//www.broadinstitute.org/igvdata") ? e.replace("//www.broadinstitute.org/igvdata", "//data.broadinstitute.org/igvdata") : e.includes("//igvdata.broadinstitute.org") ? e.replace("//igvdata.broadinstitute.org", "//s3.amazonaws.com/igv.broadinstitute.org") : e.includes("//igv.genepattern.org") ? e.replace("//igv.genepattern.org", "//igv-genepattern-org.s3.amazonaws.com") : e.startsWith("ftp://ftp.ncbi.nlm.nih.gov/geo") ? e.replace("ftp://", "https://") : e
             }(e);
-            let i = (t = t || {}).oauthToken || this.getOauthToken(e);
-            return i && (i = await ("function" == typeof i ? i() : i)), new Promise((function(n, r) {
-                Qs(e) && ! function(e) {
+            let r = (t = t || {}).oauthToken || this.getOauthToken(e);
+            return r && (r = await ("function" == typeof r ? r() : r)), new Promise((function(s, o) {
+                qs(e) && ! function(e) {
                     return e.indexOf("X-Goog-Signature") > -1
-                }(e) && (Xs(e) && (e = Ks(e)), e = function(e) {
-                    let t = lo.apiKey;
+                }(e) && (js(e) && (e = Ws(e)), e = function(e) {
+                    let t = io.apiKey;
                     t || "undefined" == typeof gapi || (t = gapi.apiKey);
                     if (void 0 !== t && !e.includes("key=")) {
                         const i = e.includes("?") ? "&" : "?";
                         e = e + i + "key=" + t
                     }
                     return e
-                }(e), Ys(e) && function(e) {
+                }(e), $s(e) && function(e) {
                     if (e.includes("supportsTeamDrive")) return e; {
                         const t = e.includes("?") ? "&" : "?";
                         e = e + t + "supportsTeamDrive=true"
                     }
-                }(e), i || (i = oo()));
-                const s = t.headers || {};
-                i && function(e, t) {
+                }(e), r || (r = eo()));
+                const a = t.headers || {};
+                r && function(e, t) {
                     t && (e["Cache-Control"] = "no-cache", e.Authorization = "Bearer " + t)
-                }(s, i);
-                const o = t.range,
-                    a = new XMLHttpRequest,
-                    l = t.sendData || t.body,
-                    h = t.method || (l ? "POST" : "GET"),
-                    c = t.responseType,
-                    d = t.contentType,
-                    u = t.mimeType;
-                if (a.open(h, e), t.timeout && (a.timeout = t.timeout), o) {
-                    var f = o.size ? o.start + o.size - 1 : "";
-                    a.setRequestHeader("Range", "bytes=" + o.start + "-" + f)
-                }
-                if (d && a.setRequestHeader("Content-Type", d), u && a.overrideMimeType(u), c && (a.responseType = c), s)
-                    for (let e of Object.keys(s)) {
-                        const t = s[e];
-                        a.setRequestHeader(e, t)
-                    }!0 === t.withCredentials && (a.withCredentials = !0), a.onload = async function(i) {
-                        0 === a.status || a.status >= 200 && a.status <= 300 ? o && 206 !== a.status && 0 !== o.start ? (a.response.length > 1e5 && !this.RANGE_WARNING_GIVEN && alert(`Warning: Range header ignored for URL: ${e}.  This can have severe performance impacts.`), n(a.response.slice(o.start, o.start + o.size))) : n(a.response) : "undefined" == typeof gapi || 404 !== a.status && 401 !== a.status && 403 !== a.status || !Qs(e) || t.retries ? 403 === a.status ? p("Access forbidden: " + e) : 416 === a.status ? p("Unsatisfiable range") : p(a.status) : g()
-                    }, a.onerror = function(i) {
-                        Qs(e) && !t.retries && g(), p("Error accessing resource: " + e + " Status: " + a.status)
-                    }, a.ontimeout = function(e) {
-                        p("Timed out")
-                    }, a.onabort = function(e) {
-                        console.log("Aborted"), r(e)
+                }(a, r);
+                const l = t.range,
+                    h = new XMLHttpRequest,
+                    c = t.sendData || t.body,
+                    d = t.method || (c ? "POST" : "GET"),
+                    u = t.responseType,
+                    f = t.contentType,
+                    p = t.mimeType;
+                if (h.open(d, e), t.timeout && (h.timeout = t.timeout), l) {
+                    let e = "";
+                    l.size && (e = l.start + l.size - 1, n && (e = Math.min(e, n - 1))), h.setRequestHeader("Range", "bytes=" + l.start + "-" + e)
+                }
+                if (f && h.setRequestHeader("Content-Type", f), p && h.overrideMimeType(p), u && (h.responseType = u), a)
+                    for (let e of Object.keys(a)) {
+                        const t = a[e];
+                        h.setRequestHeader(e, t)
+                    }!0 === t.withCredentials && (h.withCredentials = !0), h.onload = async function(n) {
+                        t.GET_CONTENT_LENGTH && s(h.getResponseHeader("content-length")), 0 === h.status || h.status >= 200 && h.status <= 300 ? l && 206 !== h.status && 0 !== l.start ? (h.response.length > 1e5 && !i.RANGE_WARNING_GIVEN && alert(`Warning: Range header ignored for URL: ${e}.  This can have severe performance impacts.`), s(h.response.slice(l.start, l.start + l.size))) : s(h.response) : 416 === h.status ? g(Error("416 Unsatisfiable Range")) : "undefined" == typeof gapi || 404 !== h.status && 401 !== h.status && 403 !== h.status || !qs(e) || t.retries ? 403 === h.status ? g("Access forbidden: " + e) : g(h.status) : m()
+                    }, h.onerror = function(i) {
+                        qs(e) && !t.retries ? m() : g("Error accessing resource: " + e + " Status: " + h.status)
+                    }, h.ontimeout = function(e) {
+                        g("Timed out")
+                    }, h.onabort = function(e) {
+                        console.log("Aborted"), o(e)
                     };
                 try {
-                    a.send(l)
-                } catch (e) {
-                    r(e)
+                    h.send(c)
+                } catch (i) {
+                    qs(e) && !t.retries ? m() : g(i)
                 }
 
-                function p(e) {
-                    if (!r) throw e;
-                    r(e)
+                function g(e) {
+                    if (!o) throw e;
+                    o(e)
                 }
-                async function g() {
+                async function m() {
                     try {
-                        const i = await async function(e) {
-                            if (eo()) {
+                        const n = await async function(e) {
+                            if (Zs()) {
                                 const t = function(e) {
-                                    return Ys(e) ? "https://www.googleapis.com/auth/drive.file" : Xs(e) ? "https://www.googleapis.com/auth/devstorage.read_only" : "https://www.googleapis.com/auth/userinfo.profile"
+                                    return $s(e) ? "https://www.googleapis.com/auth/drive.readonly" : js(e) ? "https://www.googleapis.com/auth/devstorage.read_only" : "https://www.googleapis.com/auth/userinfo.profile"
                                 }(e);
-                                return await to(t)
+                                return await Qs(t)
                             }
                             throw Error("Authorization is required, but Google oAuth has not been initalized. Contact your site administrator for assistance.")
                         }(e);
-                        t.retries = 1, t.oauthToken = i;
-                        const r = await this._load(e, t);
-                        n(r)
+                        t.retries = 1, t.oauthToken = n;
+                        const r = await i.load(e, t);
+                        s(r)
                     } catch (e) {
                         if (e.error) {
                             const t = e.error.startsWith("popup_blocked") ? "Google login popup blocked by browser." : e.error;
                             alert(t)
-                        } else p(e)
+                        } else g(e)
                     }
                 }
             }))
         }
         async _loadFileSlice(e, t) {
             let i = t && t.range ? e.slice(t.range.start, t.range.start + t.range.size) : e;
             const n = await i.arrayBuffer();
-            return "arraybuffer" === t.responseType ? n : ao(n)
+            return "arraybuffer" === t.responseType ? n : to(n)
         }
         async _loadStringFromFile(e, t) {
             const i = t.range ? e.slice(t.range.start, t.range.start + t.range.size) : e;
-            return ao(await i.arrayBuffer())
+            return to(await i.arrayBuffer())
         }
         async _loadStringFromUrl(e, t) {
             (t = t || {}).responseType = "arraybuffer";
-            return ao(await this.load(e, t))
+            return to(await this.load(e, t))
         }
         setOauthToken(e, t) {
             this.oauth.setToken(e, t)
         }
         getOauthToken(e) {
-            const t = Qs(e) ? void 0 : ri(e).host;
+            const t = qs(e) ? void 0 : ni(e).host;
             let i = this.oauth.getToken(t);
             if (i) return i;
             if (void 0 === t) {
-                const e = oo();
+                const e = eo();
                 if (e && e.expires_at > Date.now()) return e.access_token
             }
         }
+        async getContentLength(e, t) {
+            if (!this.contentLengthMap.has(e)) {
+                (t = t || {}).method = "HEAD", t.GET_CONTENT_LENGTH = !0;
+                const i = await this._loadURL(e, t),
+                    n = i ? Number.parseInt(i) : -1;
+                this.contentLengthMap.set(e, n)
+            }
+            return this.contentLengthMap.get(e)
+        }
     };
-    var ho = 2,
-        co = {
+    var no = 2,
+        ro = {
             color: 1
         };
-    co.parent = co, co.left = co, co.right = co;
-    class uo {
+    ro.parent = ro, ro.left = ro, ro.right = ro;
+    class so {
         constructor() {
-            this.root = co
+            this.root = ro
         }
         insert(e, t, i) {
-            var n = new wo(new bo(e, t, i));
-            for (this.treeInsert(n), n.color = ho; n !== this.root && n.parent.color === ho;)
+            var n = new uo(new co(e, t, i));
+            for (this.treeInsert(n), n.color = no; n !== this.root && n.parent.color === no;)
                 if (n.parent === n.parent.parent.left) {
                     let e = n.parent.parent.right;
-                    e.color === ho ? (n.parent.color = 1, e.color = 1, n.parent.parent.color = ho, n = n.parent.parent) : (n === n.parent.right && (n = n.parent, po.call(this, n)), n.parent.color = 1, n.parent.parent.color = ho, go.call(this, n.parent.parent))
+                    e.color === no ? (n.parent.color = 1, e.color = 1, n.parent.parent.color = no, n = n.parent.parent) : (n === n.parent.right && (n = n.parent, ao.call(this, n)), n.parent.color = 1, n.parent.parent.color = no, lo.call(this, n.parent.parent))
                 } else {
                     let e = n.parent.parent.left;
-                    e.color === ho ? (n.parent.color = 1, e.color = 1, n.parent.parent.color = ho, n = n.parent.parent) : (n === n.parent.left && (n = n.parent, go.call(this, n)), n.parent.color = 1, n.parent.parent.color = ho, po.call(this, n.parent.parent))
+                    e.color === no ? (n.parent.color = 1, e.color = 1, n.parent.parent.color = no, n = n.parent.parent) : (n === n.parent.left && (n = n.parent, lo.call(this, n)), n.parent.color = 1, n.parent.parent.color = no, ao.call(this, n.parent.parent))
                 } this.root.color = 1
         }
         findOverlapping(e, t) {
-            var i = new bo(e, t, 0);
-            if (this.root === co) return [];
-            var n = fo.call(this, i, this.root, []);
+            var i = new co(e, t, 0);
+            if (this.root === ro) return [];
+            var n = oo.call(this, i, this.root, []);
             return n.length > 1 && n.sort((function(e, t) {
                 return e.low - t.low
             })), n
         }
         logIntervals() {
             ! function e(t, i) {
                 for (var n = "", r = 0; r < i; r++) n += " ";
-                console.log(n + t.interval.low + " " + t.interval.high), i += 5, t.left !== co && e(t.left, i);
-                t.right !== co && e(t.right, i)
+                console.log(n + t.interval.low + " " + t.interval.high), i += 5, t.left !== ro && e(t.left, i);
+                t.right !== ro && e(t.right, i)
             }(this.root, 0)
         }
         mapIntervals(e) {
             ! function t(i) {
-                e(i.interval), i.left !== co && t(i.left);
-                i.right !== co && t(i.right)
+                e(i.interval), i.left !== ro && t(i.left);
+                i.right !== ro && t(i.right)
             }(this.root)
         }
         treeInsert(e) {
-            for (var t = this.root, i = co; t !== co;) i = t, t = e.interval.low <= t.interval.low ? t.left : t.right;
-            e.parent = i, i === co ? (this.root = e, e.left = e.right = co) : e.interval.low <= i.interval.low ? i.left = e : i.right = e, mo.call(this, e)
+            for (var t = this.root, i = ro; t !== ro;) i = t, t = e.interval.low <= t.interval.low ? t.left : t.right;
+            e.parent = i, i === ro ? (this.root = e, e.left = e.right = ro) : e.interval.low <= i.interval.low ? i.left = e : i.right = e, ho.call(this, e)
         }
     }
 
-    function fo(e, t, i) {
-        return t.interval.overlaps(e) && i.push(t.interval), t.left !== co && t.left.max >= e.low && fo.call(this, e, t.left, i), t.right !== co && t.right.min <= e.high && fo.call(this, e, t.right, i), i
+    function oo(e, t, i) {
+        return t.interval.overlaps(e) && i.push(t.interval), t.left !== ro && t.left.max >= e.low && oo.call(this, e, t.left, i), t.right !== ro && t.right.min <= e.high && oo.call(this, e, t.right, i), i
     }
 
-    function po(e) {
+    function ao(e) {
         var t = e.right;
-        e.right = t.left, t.left !== co && (t.left.parent = e), t.parent = e.parent, e.parent === co ? this.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, mo.call(this, e)
+        e.right = t.left, t.left !== ro && (t.left.parent = e), t.parent = e.parent, e.parent === ro ? this.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, ho.call(this, e)
     }
 
-    function go(e) {
+    function lo(e) {
         var t = e.left;
-        e.left = t.right, t.right !== co && (t.right.parent = e), t.parent = e.parent, e.parent === co ? this.root = t : e.parent.right === e ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, mo.call(this, e)
+        e.left = t.right, t.right !== ro && (t.right.parent = e), t.parent = e.parent, e.parent === ro ? this.root = t : e.parent.right === e ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, ho.call(this, e)
     }
 
-    function mo(e) {
-        for (; e !== co;) {
+    function ho(e) {
+        for (; e !== ro;) {
             var t = e.left.max > e.right.max ? e.left.max : e.right.max,
                 i = e.interval.high;
             e.max = t > i ? t : i;
             var n = e.left.min < e.right.min ? e.left.min : e.right.min,
                 r = e.interval.low;
             e.min = n < r ? n : r, e = e.parent
         }
     }
-    class bo {
+    class co {
         constructor(e, t, i) {
             this.low = e, this.high = t, this.value = i
         }
         equals(e) {
             return !!e && (this === e || this.low === e.low && this.high === e.high)
         }
         compareTo(e) {
             return this.low < e.low ? -1 : this.low > e.low ? 1 : this.high < e.high ? -1 : this.high > e.high ? 1 : 0
         }
         overlaps(e) {
             return this.low <= e.high && e.low <= this.high
         }
     }
 
-    function wo(e) {
-        this.parent = co, this.left = co, this.right = co, this.interval = e, this.color = ho
+    function uo(e) {
+        this.parent = ro, this.left = ro, this.right = ro, this.interval = e, this.color = no
     }
-    class vo {
+    class fo {
         constructor(e, t, i) {
             e = e || [], this.treeMap = this.buildTreeMap(e, t), this.range = i, this.count = e.length
         }
         containsRange(e) {
             return void 0 === this.range || this.range.contains(e.chr, e.start, e.end)
         }
         queryFeatures(e, t, i) {
@@ -5709,44 +5719,44 @@
                     let r = this.allFeatures[e];
                     r || (n.push(e), r = [], this.allFeatures[e] = r), r.push(i)
                 }
                 for (let e of n) {
                     const t = this.allFeatures[e];
                     t.sort((function(e, t) {
                         return e.start === t.start ? 0 : e.start > t.start ? 1 : -1
-                    })), i[e] = yo(t)
+                    })), i[e] = po(t)
                 }
             }
             return i
         }
     }
 
-    function yo(e) {
-        const t = new uo,
+    function po(e) {
+        const t = new so,
             i = e.length,
             n = Math.max(10, Math.round(i / 10));
         for (let r = 0; r < i; r += n) {
             const s = Math.min(i, r + n),
-                o = new _o(r, s),
+                o = new go(r, s),
                 a = e[r].start;
             let l = a;
             for (let t = r; t < s; t++) l = Math.max(l, e[t].end);
             t.insert(a, l, o)
         }
         return t
     }
-    class _o {
+    class go {
         constructor(e, t) {
             this.start = e, this.end = t
         }
     }
-    const xo = function(e, t, i) {
+    const mo = function(e, t, i) {
         if (e && 0 !== e.length) {
             const n = function(e) {
-                    const t = new uo,
+                    const t = new so,
                         i = e.length,
                         n = Math.max(10, Math.round(i / 100));
                     e.sort((function(e, t) {
                         return e.start === t.start ? 0 : e.start > t.start ? 1 : -1
                     }));
                     for (let r = 0; r < i; r += n) {
                         const s = Math.min(i, r + n),
@@ -5770,15 +5780,15 @@
                 }
             })), e.sort((function(e, t) {
                 return e.start - t.start
             })), e)
         }
         return []
     };
-    const ko = {
+    const bo = {
         cantaloupe: {
             r: 255,
             g: 206,
             b: 110
         },
         honeydew: {
             r: 206,
@@ -6012,53 +6022,53 @@
         },
         nickel: {
             r: 136,
             g: 135,
             b: 135
         }
     };
-    const Co = {
+    const wo = {
         Set1: ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(166,86,40)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(247,129,191)", "rgb(153,153,153)", "rgb(255,255,51)"],
         Dark2: ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)", "rgb(166,118,29)", "rgb(102,102,102)"],
         Set2: ["rgb(102, 194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)", "rgb(229,196,148)", "rgb(179,179,179)"],
         Set3: ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)", "rgb(204,235,197)", "rgb(255,237,111)"],
         Pastel1: ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)", "rgb(253,218,236)"],
         Pastel2: ["rgb(173,226,207)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)", "rgb(243,225,206)"],
         Accent: ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)", "rgb(191,91,23)"]
     };
-    class So {
+    class vo {
         constructor(e) {
-            this.colors = Co[e], Array.isArray(this.colors) || (this.colors = []), this.colorTable = {}, this.nextIdx = 0, this.colorGenerator = new Eo
+            this.colors = wo[e], Array.isArray(this.colors) || (this.colors = []), this.colorTable = {}, this.nextIdx = 0, this.colorGenerator = new _o
         }
         getColor(e) {
             return this.colorTable.hasOwnProperty(e) || (this.nextIdx < this.colors.length ? this.colorTable[e] = this.colors[this.nextIdx] : this.colorTable[e] = this.colorGenerator.get(), this.nextIdx++), this.colorTable[e]
         }
     }
-    class Ao {
+    class yo {
         constructor(e) {
-            this.colorTable = e || {}, this.nextIdx = 0, this.colorGenerator = new Eo
+            this.colorTable = e || {}, this.nextIdx = 0, this.colorGenerator = new _o
         }
         getColor(e) {
             if (!this.colorTable.hasOwnProperty(e)) {
                 if (this.colorTable.hasOwnProperty("*")) return this.colorTable["*"];
                 this.colorTable[e] = this.colorGenerator.get()
             }
             return this.colorTable[e]
         }
     }
 
-    function Eo() {
+    function _o() {
         this.hue = Math.random(), this.goldenRatio = .618033988749895, this.hexwidth = 2
     }
 
-    function To(e, t) {
-        e = Vs.clamp(e, 0, 255), t = Vs.clamp(t, 0, 255);
+    function xo(e, t) {
+        e = Ns.clamp(e, 0, 255), t = Ns.clamp(t, 0, 255);
         return `rgb(${Math.round(Math.random()*(t-e)+e).toString(10)},${Math.round(Math.random()*(t-e)+e).toString(10)},${Math.round(Math.random()*(t-e)+e).toString(10)})`
     }
-    Eo.prototype.hsvToRgb = function(e, t, i) {
+    _o.prototype.hsvToRgb = function(e, t, i) {
         var n = Math.floor(6 * e),
             r = 6 * e - n,
             s = i * (1 - t),
             o = i * (1 - r * t),
             a = i * (1 - (1 - r) * t),
             l = 255,
             h = 255,
@@ -6079,297 +6089,295 @@
             case 4:
                 l = a, h = s, c = i;
                 break;
             case 5:
                 l = i, h = s, c = o
         }
         return [Math.floor(256 * l), Math.floor(256 * h), Math.floor(256 * c)]
-    }, Eo.prototype.padHex = function(e) {
+    }, _o.prototype.padHex = function(e) {
         return e.length > this.hexwidth ? e : new Array(this.hexwidth - e.length + 1).join("0") + e
-    }, Eo.prototype.get = function(e, t) {
+    }, _o.prototype.get = function(e, t) {
         this.hue += this.goldenRatio, this.hue %= 1, "number" != typeof e && (e = .5), "number" != typeof t && (t = .95);
         var i = this.hsvToRgb(this.hue, e, t);
         return "#" + this.padHex(i[0].toString(16)) + this.padHex(i[1].toString(16)) + this.padHex(i[2].toString(16))
-    }, new Eo;
-    const Mo = {
+    }, new _o;
+    const ko = {
         configureHighDPICanvas: function(e, t, i) {
             const n = window.devicePixelRatio;
             e.canvas.style.width = `${t}px`, e.canvas.width = Math.floor(n * t), e.canvas.style.height = `${i}px`, e.canvas.height = Math.floor(n * i), e.scale(n, n)
         },
         setProperties: function(e, t) {
             for (var i in t)
                 if (t.hasOwnProperty(i)) {
                     var n = t[i];
                     e[i] = n
                 }
         },
         strokeLine: function(e, t, i, n, r, s) {
-            t = Math.floor(t) + .5, i = Math.floor(i) + .5, n = Math.floor(n) + .5, r = Math.floor(r) + .5, s && (e.save(), Mo.setProperties(e, s)), e.beginPath(), e.moveTo(t, i), e.lineTo(n, r), e.stroke(), s && e.restore()
+            t = Math.floor(t) + .5, i = Math.floor(i) + .5, n = Math.floor(n) + .5, r = Math.floor(r) + .5, s && (e.save(), ko.setProperties(e, s)), e.beginPath(), e.moveTo(t, i), e.lineTo(n, r), e.stroke(), s && e.restore()
         },
         fillRect: function(e, t, i, n, r, s) {
-            t = Math.round(t), i = Math.round(i), s && (e.save(), Mo.setProperties(e, s)), e.fillRect(t, i, n, r), s && e.restore()
+            t = Math.round(t), i = Math.round(i), s && (e.save(), ko.setProperties(e, s)), e.fillRect(t, i, n, r), s && e.restore()
         },
         fillPolygon: function(e, t, i, n) {
-            n && (e.save(), Mo.setProperties(e, n)), Ro(e, t, i), e.fill(), n && e.restore()
+            n && (e.save(), ko.setProperties(e, n)), Co(e, t, i), e.fill(), n && e.restore()
         },
         strokePolygon: function(e, t, i, n) {
-            n && (e.save(), Mo.setProperties(e, n)), Ro(e, t, i), e.stroke(), n && e.restore()
+            n && (e.save(), ko.setProperties(e, n)), Co(e, t, i), e.stroke(), n && e.restore()
         },
         fillText: function(e, t, i, n, r, s) {
-            if ((r || s) && e.save(), r && Mo.setProperties(e, r), s) {
+            if ((r || s) && e.save(), r && ko.setProperties(e, r), s) {
                 for (var o in e.translate(i, n), s) {
                     var a = s[o];
                     "translate" === o && e.translate(a.x, a.y), "rotate" === o && e.rotate(a.angle * Math.PI / 180)
                 }
                 e.fillText(t, 0, 0)
             } else e.fillText(t, i, n);
             (r || s) && e.restore()
         },
         strokeText: function(e, t, i, n, r, s) {
-            if ((r || s) && e.save(), r && Mo.setProperties(e, r), s) {
+            if ((r || s) && e.save(), r && ko.setProperties(e, r), s) {
                 for (var o in e.translate(i, n), s) {
                     var a = s[o];
                     "translate" === o && e.translate(a.x, a.y), "rotate" === o && e.rotate(a.angle * Math.PI / 180)
                 }
                 e.strokeText(t, 0, 0)
             } else e.strokeText(t, i, n);
             (r || s) && e.restore()
         },
         strokeCircle: function(e, t, i, n, r) {
-            r && (e.save(), Mo.setProperties(e, r)), e.beginPath(), e.arc(t, i, n, 0, 2 * Math.PI), e.stroke(), r && e.restore()
+            r && (e.save(), ko.setProperties(e, r)), e.beginPath(), e.arc(t, i, n, 0, 2 * Math.PI), e.stroke(), r && e.restore()
         },
         fillCircle: function(e, t, i, n, r) {
-            r && (e.save(), Mo.setProperties(e, r)), e.beginPath(), e.arc(t, i, n, 0, 2 * Math.PI), e.fill(), r && e.restore()
+            r && (e.save(), ko.setProperties(e, r)), e.beginPath(), e.arc(t, i, n, 0, 2 * Math.PI), e.fill(), r && e.restore()
         },
         drawArrowhead: function(e, t, i, n, r) {
             e.save(), n || (n = 5), r && (e.lineWidth = r), e.beginPath(), e.moveTo(t, i - n / 2), e.lineTo(t, i + n / 2), e.lineTo(t + n, i), e.lineTo(t, i - n / 2), e.closePath(), e.fill(), e.restore()
         },
         dashedLine: function(e, t, i, n, r, s, o = {}) {
-            void 0 === s && (s = 2), e.setLineDash([s, s]), Mo.strokeLine(e, t, i, n, r, o), e.setLineDash([])
+            void 0 === s && (s = 2), e.setLineDash([s, s]), ko.strokeLine(e, t, i, n, r, o), e.setLineDash([])
         },
         roundRect: function(e, t, i, n, r, s, o, a) {
             void 0 === a && (a = !0), void 0 === s && (s = 5), e.beginPath(), e.moveTo(t + s, i), e.lineTo(t + n - s, i), e.quadraticCurveTo(t + n, i, t + n, i + s), e.lineTo(t + n, i + r - s), e.quadraticCurveTo(t + n, i + r, t + n - s, i + r), e.lineTo(t + s, i + r), e.quadraticCurveTo(t, i + r, t, i + r - s), e.lineTo(t, i + s), e.quadraticCurveTo(t, i, t + s, i), e.closePath(), a && e.stroke(), o && e.fill()
         },
         polygon: function(e, t, i, n, r) {
             void 0 === r && (r = !0), e.beginPath();
             var s = t.length;
             e.moveTo(t[0], i[0]);
             for (var o = 1; o < s; o++) e.lineTo(t[o], i[o]);
             e.closePath(), r && e.stroke(), n && e.fill()
         },
         drawRandomColorVerticalLines: e => {
-            for (let t = 0; t < e.canvas.width; t++) Mo.fillRect(e, t, 0, 1, e.canvas.height, {
-                fillStyle: To(100, 250)
+            for (let t = 0; t < e.canvas.width; t++) ko.fillRect(e, t, 0, 1, e.canvas.height, {
+                fillStyle: xo(100, 250)
             })
         },
         labelTransformWithContext: (e, t) => {
             e.translate(t, 0), e.scale(-1, 1), e.translate(-t, 0)
         }
     };
 
-    function Ro(e, t, i) {
+    function Co(e, t, i) {
         var n, r = t.length;
         for (n = 0; n < r; n++) t[n] = Math.round(t[n]), i[n] = Math.round(i[n]);
         for (e.beginPath(), e.moveTo(t[0], i[0]), n = 1; n < r; n++) e.lineTo(t[n], i[n]);
         e.closePath()
     }
-    class Lo {
+    class So {
         constructor(e) {
-            this.dialog = new Nt(e)
+            this.dialog = new Ft(e)
         }
         present(e, t) {
             this.dialog.present(e, t)
         }
     }
-    const Io = {
+    const Ao = {
         gwascatalog: {
             fields: ["bin", "chr", "start", "end", "name", "pubMedID", "author", "pubDate", "journal", "title", "trait", "initSample", "replSample", "region", "genes", "riskAllele", "riskAlFreq", "pValue", "pValueDesc", "orOrBeta", "ci95", "platform", "cnv"]
         },
         wgrna: {
             fields: ["bin", "chr", "start", "end", "name", "score", "strand", "thickStart", "thickEnd", "type"]
         },
         cpgislandext: {
             fields: ["bin", "chr", "start", "end", "name", "length", "cpgNum", "gcNum", "perCpg", "perGc", "obsExp"]
         },
         clinVarMain: {
             fields: ["chr1", "start", "end", "name", "score", "strand", "thickStart", "thickEnd", "reserved", "blockCount", "blockSizes", "chromStarts", "origName", "clinSign", "reviewStatus", "type", "geneId", "snpId", "nsvId", "rcvAcc", "testedInGtr", "phenotypeList", "phenotype", "origin", "assembly", "cytogenetic", "hgvsCod", "hgvsProt", "numSubmit", "lastEval", "guidelines", "otherIds"]
         }
     };
 
-    function Bo(e) {
+    function Eo(e) {
         const t = new Set(["boolean", "number", "string", "symbol"]),
             i = typeof e;
         return void 0 !== e && (t.has(i) || e.substring || e.toFixed)
     }
 
-    function No(e, t) {
+    function Mo(e, t) {
         var i = {
             oauthToken: e.oauthToken,
             headers: e.headers,
             withCredentials: e.withCredentials,
             filename: e.filename
         };
         return Object.assign(i, t)
     }
-    const Fo = function(e) {
+    const To = function(e) {
             var t, i;
             if (e && e.length > 0) {
                 t = Number.MAX_VALUE, i = -Number.MAX_VALUE;
                 for (let n of e) Number.isNaN(n.value) || (t = Math.min(t, n.value), i = Math.max(i, n.value));
                 i > 0 && (t = Math.min(0, t)), i < 0 && (i = 0)
             } else t = 0, i = 100;
             return {
                 min: t,
                 max: i
             }
         },
-        Po = function(e, t, i) {
+        Ro = function(e, t, i) {
             let n = t.start,
                 r = t.end;
             if (void 0 === r) n -= i / 2, r = n + i, r > e ? (r = e, n = r - i) : n < 0 && (n = 0, r = i);
             else if (r - n < i) {
                 const t = (r + n) / 2;
                 t - i / 2 < 0 ? (n = 0, r = n + i) : t + i / 2 > e ? (r = e, n = r - i) : (n = t - i / 2, r = n + i)
             }
             t.start = Math.ceil(n), t.end = Math.floor(r)
-        },
-        Oo = function(e) {
-            return "number" == typeof e ? e - e == 0 : "string" == typeof e && "" !== e.trim() && (Number.isFinite ? Number.isFinite(+e) : isFinite(+e))
         };
-    async function Do(e) {
+    async function Lo(e) {
         if (Qt(e) && e.startsWith("https://drive.google.com")) {
-            if (void 0 === io()) throw Error("Google drive is referenced, but API key is not defined.  An API key is required for Google Drive access");
+            if (void 0 === Xs()) throw Error("Google drive is referenced, but API key is not defined.  An API key is required for Google Drive access");
             const t = await async function(e) {
-                let t = "https://www.googleapis.com/drive/v3/files/" + ro(e) + "?supportsTeamDrives=true";
-                const i = io();
+                let t = "https://www.googleapis.com/drive/v3/files/" + Ks(e) + "?supportsTeamDrives=true";
+                const i = Xs();
                 i && (t += "&key=" + i);
                 const n = await fetch(t);
                 let r = await n.json();
                 if (r.error && 404 === r.error.code) {
-                    const e = await to("https://www.googleapis.com/auth/drive.readonly");
-                    if (!e) throw Error(r.error); {
-                        const i = await fetch(t, {
+                    let e = "https://www.googleapis.com/auth/drive.readonly";
+                    const i = await Qs(e);
+                    if (!i) throw Error(r.error); {
+                        const e = await fetch(t, {
                             headers: {
-                                Authorization: `Bearer ${e}`
+                                Authorization: `Bearer ${i}`
                             }
                         });
-                        if (r = await i.json(), r.error) throw Error(r.error)
+                        if (r = await e.json(), r.error) throw Error(r.error)
                     }
                 }
                 return r
             }(e);
             return t.originalFileName || t.name
         }
         return ei(e)
     }
 
-    function zo(e) {
+    function Io(e) {
         var t, i;
         return e > 1e7 ? (t = " mb", i = e / 1e6, Math.floor(i).toString() + t) : e > 1e4 ? (t = " kb", i = e / 1e3, Xt(Math.floor(i)) + t) : Xt(e) + " bp"
     }
 
-    function Ho(e) {
+    function Bo(e) {
         return Qt(e) && e.startsWith("data:")
     }
 
-    function Vo(e, t) {
+    function Fo(e, t) {
         const i = _t.div({
             class: t
         });
         e.appendChild(i)
     }
 
-    function Uo(e, t) {
+    function No(e, t) {
         t.parentNode.insertBefore(e, t)
     }
 
-    function qo(e, t) {
+    function Oo(e, t) {
         t.parentNode.insertBefore(e, t.nextSibling)
     }
 
-    function jo() {
+    function Po() {
         return "https:" === window.location.protocol || "localhost" === window.location.hostname
     }
 
-    function $o(e, t) {
+    function Do(e, t) {
         if (e.length < 6) return void console.log("Skipping line: " + e.join(" "));
         var i = {
             chr1: e[0],
             start1: Number.parseInt(e[1]),
             end1: Number.parseInt(e[2]),
             chr2: e[3],
             start2: Number.parseInt(e[4]),
             end2: Number.parseInt(e[5])
         };
         if (isNaN(i.start1) || isNaN(i.end1) || isNaN(i.start2) || isNaN(i.end2)) return;
-        t && void 0 === t.hiccups && (t.hiccups = !!t.columnNames && Go(t.columnNames));
+        t && void 0 === t.hiccups && (t.hiccups = !!t.columnNames && Ho(t.columnNames));
         const n = t && t.hiccups,
             r = n ? 6 : 10;
         if (n || (e.length > 6 && "." !== e[6] && (i.name = e[6]), e.length > 7 && "." !== e[7] && (i.score = Number(e[7])), e.length > 8 && "." !== e[8] && (i.strand1 = e[8]), e.length > 9 && "." !== e[9] && (i.strand2 = e[9])), t) {
             const n = t.colorColumn;
-            n && n < e.length && (i.color = js.createColorString(e[n]));
+            n && n < e.length && (i.color = Ds.createColorString(e[n]));
             const s = t.thicknessColumn;
             s && s < e.length && (i.thickness = e[s]), e.length > r && t.columnNames && t.columnNames.length === e.length && (i.extras = e.slice(r))
         }
         return i.chr1 === i.chr2 && (i.chr = i.chr1, i.start = Math.min(i.start1, i.start2), i.end = Math.max(i.end1, i.end2)), i
     }
 
-    function Wo(e, t) {
+    function zo(e, t) {
         if (!(e.length < 8)) return {
             chr: e[0],
             start: Number.parseInt(e[1]),
             end: Number.parseInt(e[2]),
-            color: js.createColorString(e[6]),
+            color: Ds.createColorString(e[6]),
             value: Number(e[7])
         }
     }
 
-    function Go(e) {
+    function Ho(e) {
         return e && (e.includes("fdrDonut") || e.includes("fdr_donut"))
     }
-    const Zo = new Set(["narrowpeak", "broadpeak", "regionpeak", "peaks", "bedgraph", "wig", "gff3", "gff", "gtf", "fusionjuncspan", "refflat", "seg", "aed", "bed", "vcf", "bb", "bigbed", "biginteract", "biggenepred", "bignarrowpeak", "bw", "bigwig", "bam", "tdf", "refgene", "genepred", "genepredext", "bedpe", "bp", "snp", "rmsk", "cram", "gwas", "maf", "mut", "tsv", "hiccups", "fasta", "fa", "fna", "pytor"]);
+    const Vo = new Set(["narrowpeak", "broadpeak", "regionpeak", "peaks", "bedgraph", "wig", "gff3", "gff", "gtf", "fusionjuncspan", "refflat", "seg", "aed", "bed", "vcf", "bb", "bigbed", "biginteract", "biggenepred", "bignarrowpeak", "bw", "bigwig", "bam", "tdf", "refgene", "genepred", "genepredext", "bedpe", "bp", "snp", "rmsk", "cram", "gwas", "maf", "mut", "tsv", "hiccups", "fasta", "fa", "fna", "pytor"]);
 
-    function Qo(e) {
-        return Io && Io[e] ? function(e) {
+    function Uo(e) {
+        return Ao && Ao[e] ? function(e) {
             const t = e.fields,
                 i = ["chr", "start", "end"];
             for (let n = 0; n < t.length; n++)
                 for (let r of i) r === t[n] && (e[r] = n);
             return e
-        }(Io[e]) : void 0
+        }(Ao[e]) : void 0
     }
 
-    function Xo(e) {
+    function qo(e) {
         var t, i;
         if ((e = e.toLowerCase()).endsWith("refgene.txt.gz") || e.endsWith("refgene.txt.bgz") || e.endsWith("refgene.txt") || e.endsWith("refgene.sorted.txt.gz") || e.endsWith("refgene.sorted.txt.bgz")) return "refgene";
         switch ((t = e.indexOf("?")) > 0 && (e = e.substr(0, t)), e.endsWith(".gz") && (e = e.substr(0, e.length - 3)), (e.endsWith(".txt") || e.endsWith(".tab") || e.endsWith(".bgz")) && (e = e.substr(0, e.length - 4)), i = (t = e.lastIndexOf(".")) < 0 ? e : e.substr(t + 1)) {
             case "bw":
                 return "bigwig";
             case "bb":
                 return "bigbed";
             case "fasta":
             case "fa":
             case "fna":
                 return "fasta";
             default:
-                return Zo.has(i) ? i : void 0
+                return Vo.has(i) ? i : void 0
         }
     }
 
-    function Yo(e, t) {
+    function jo(e, t) {
         if (Qt(e)) {
             if (e.includes("?")) {
                 const i = e.indexOf("?");
                 return e.substring(0, i) + "." + t + e.substring(i)
             }
             return e + "." + t
         }
     }
 
-    function Ko(e) {
+    function $o(e) {
         if (function(e) {
                 e.featureType && (e.type = e.type || e.featureType, e.featureType = void 0);
                 "junctions" === e.type ? e.type = "junction" : "bed" === e.type ? (e.type = "annotation", e.format = e.format || "bed") : "annotations" === e.type ? e.type = "annotation" : "alignments" === e.type ? e.type = "alignment" : "bam" === e.type ? (e.type = "alignment", e.format = "bam") : "vcf" === e.type ? (e.type = "variant", e.format = "vcf") : "t2d" === e.type ? e.type = "gwas" : "FusionJuncSpan" !== e.type || e.format ? "aed" === e.type && (e.type = "annotation", e.format = e.format || "aed") : e.format = "fusionjuncspan"
             }(e), e.type) return e.type;
         if (e.format) {
             switch (e.format.toLowerCase()) {
                 case "bw":
@@ -6408,73 +6416,73 @@
                 case "pytor":
                     return "cnvpytor";
                 default:
                     return "annotation"
             }
         }
     }
-    async function Jo(e) {
+    async function Wo(e) {
         if (e.url) {
-            const t = await lo.loadString(e.url, No(e, {
+            const t = await io.loadString(e.url, Mo(e, {
                 range: {
                     start: 0,
                     size: 1e3
                 }
             }));
             if (t) {
-                if (Go(t.split("\n")[0].split("\t"))) return "hiccups"
+                if (Ho(t.split("\n")[0].split("\t"))) return "hiccups"
             }
         }
     }
-    var ea = Object.freeze({
+    var Go = Object.freeze({
         __proto__: null,
-        knownFileExtensions: Zo,
-        getFormat: Qo,
-        inferFileFormat: Xo,
-        inferFileFormatFromHeader: Jo,
-        inferTrackType: Ko,
-        inferIndexPath: Yo
+        knownFileExtensions: Vo,
+        getFormat: Uo,
+        inferFileFormat: qo,
+        inferFileFormatFromHeader: Wo,
+        inferTrackType: $o,
+        inferIndexPath: jo
     });
-    const ta = [
+    const Zo = [
             ["A", "T"],
             ["G", "C"],
             ["Y", "R"],
             ["W", "S"],
             ["K", "M"],
             ["D", "H"],
             ["B", "V"]
         ],
-        ia = new Map;
-    for (let Xb of ta) {
-        const Yb = Xb[0],
-            Kb = Xb[1];
-        ia.set(Yb, Kb), ia.set(Kb, Yb), ia.set(Yb.toLowerCase(), Kb.toLowerCase()), ia.set(Kb.toLowerCase(), Yb.toLowerCase())
+        Qo = new Map;
+    for (let qb of Zo) {
+        const jb = qb[0],
+            $b = qb[1];
+        Qo.set(jb, $b), Qo.set($b, jb), Qo.set(jb.toLowerCase(), $b.toLowerCase()), Qo.set($b.toLowerCase(), jb.toLowerCase())
     }
 
-    function na(e) {
+    function Xo(e) {
         let t = "",
             i = e.length;
         for (; i-- > 0;) {
             const n = e[i];
-            t += ia.has(n) ? ia.get(n) : n
+            t += Qo.has(n) ? Qo.get(n) : n
         }
         return t
     }
-    class ra {
+    class Yo {
         constructor(e, t, i) {
             this.name = e, this.order = t, this.bpLength = i
         }
     }
-    const sa = Yt,
-        oa = new Set(["fastaURL", "indexURL", "cytobandURL", "indexed"]);
-    class aa {
+    const Ko = Yt,
+        Jo = new Set(["fastaURL", "indexURL", "cytobandURL", "indexed"]);
+    class ea {
         constructor(e) {
             this.fastaURL = e.fastaURL, this.withCredentials = e.withCredentials, this.chromosomeNames = [], this.chromosomes = {}, this.sequences = new Map;
             const t = {};
-            for (let i in e) e.hasOwnProperty(i) && !oa.has(i) && (t[i] = e[i]);
+            for (let i in e) e.hasOwnProperty(i) && !Jo.has(i) && (t[i] = e[i]);
             this.config = t
         }
         async init() {
             return this.loadAll()
         }
         async getSequence(e, t, i) {
             if (!this.sequences.has(e)) return;
@@ -6487,21 +6495,21 @@
             if (i <= 0) return Promise.resolve(r);
             const s = n.sequence,
                 o = Math.min(i, s.length);
             return r + s.substring(t, o)
         }
         async loadAll() {
             let e;
-            if (Ho(this.fastaURL)) {
-                let t = Hs(this.fastaURL);
+            if (Bo(this.fastaURL)) {
+                let t = Fs(this.fastaURL);
                 e = "";
                 for (let i of t) e += String.fromCharCode(i)
-            } else e = await lo.load(this.fastaURL, No(this.config));
+            } else e = await io.load(this.fastaURL, Mo(this.config));
             const t = new Set,
-                i = sa(e),
+                i = Ko(e),
                 n = i.length;
             let r, s = 0,
                 o = 0,
                 a = {};
             for (; s < n;) {
                 if (r = i[s++].trim(), r.startsWith("#") || 0 === r.length);
                 else if (r.startsWith(">")) {
@@ -6523,48 +6531,48 @@
             }
 
             function l(e, i) {
                 const n = e.length || e.offset + e.seq.length;
                 if (t.has(e.chr)) {
                     const t = this.chromosomes[e.chr];
                     t.bpLength = Math.max(t.bpLength, n)
-                } else this.chromosomeNames.push(e.chr), this.sequences.set(e.chr, []), this.chromosomes[e.chr] = new ra(e.chr, i, n), t.add(e.chr);
-                this.sequences.get(e.chr).push(new la(e.offset, e.seq))
+                } else this.chromosomeNames.push(e.chr), this.sequences.set(e.chr, []), this.chromosomes[e.chr] = new Yo(e.chr, i, n), t.add(e.chr);
+                this.sequences.get(e.chr).push(new ta(e.offset, e.seq))
             }
         }
     }
-    class la {
+    class ta {
         constructor(e, t) {
             this.offset = e, this.sequence = t
         }
         contains(e, t) {
             return this.offset <= e && this.end >= t
         }
         overlaps(e, t) {
             return this.offset < t && this.end > e
         }
         get end() {
             return this.offset + this.sequence.length
         }
     }
-    const ha = function(e, t, i, n) {
+    const ia = function(e, t, i, n) {
         this.chr = e, this.start = t, this.end = i, this.features = n
     };
-    ha.prototype.contains = function(e, t, i) {
+    ia.prototype.contains = function(e, t, i) {
         return this.chr === e && this.start <= t && this.end >= i
-    }, ha.prototype.containsRange = function(e) {
+    }, ia.prototype.containsRange = function(e) {
         return this.chr === e.chr && this.start <= e.start && this.end >= e.end
     };
-    const ca = Yt,
-        da = new Set(["fastaURL", "indexURL", "compressedIndexURL", "cytobandURL", "indexed"]);
-    class ua {
+    const na = Yt,
+        ra = new Set(["fastaURL", "indexURL", "compressedIndexURL", "cytobandURL", "indexed"]);
+    class sa {
         constructor(e) {
             this.file = e.fastaURL, this.indexFile = e.indexURL || e.indexFile || this.file + ".fai", this.compressedIndexFile = e.compressedIndexURL || !1, this.withCredentials = e.withCredentials, this.chromosomeNames = [], this.chromosomes = {}, this.sequences = {}, this.offsets = {};
             const t = {};
-            for (let i in e) e.hasOwnProperty(i) && !da.has(i) && (t[i] = e[i]);
+            for (let i in e) e.hasOwnProperty(i) && !ra.has(i) && (t[i] = e[i]);
             this.config = t
         }
         async init() {
             return this.getIndex()
         }
         async getSequence(e, t, i) {
             if (!(this.interval && this.interval.contains(e, t, i))) {
@@ -6572,49 +6580,49 @@
                     r = i;
                 if (i - t < 5e4) {
                     const e = i - t,
                         s = Math.round(t + e / 2);
                     n = Math.max(0, s - 25e3), r = s + 25e3
                 }
                 const s = await this.readSequence(e, n, r);
-                this.interval = new ha(e, n, r, s)
+                this.interval = new ia(e, n, r, s)
             }
             const n = t - this.interval.start,
                 r = i - t;
             return this.interval.features ? this.interval.features.substr(n, r) : null
         }
         async getIndex() {
             if (this.index) return this.index; {
-                const e = await lo.load(this.indexFile, No(this.config)),
-                    t = ca(e),
+                const e = await io.load(this.indexFile, Mo(this.config)),
+                    t = na(e),
                     i = t.length;
                 let n = 0,
                     r = 0;
                 for (this.index = {}; n < i;) {
                     const e = t[n++].split("\t");
                     if (5 === e.length) {
                         const t = e[0],
                             i = parseInt(e[1]),
                             n = {
                                 size: i,
                                 position: parseInt(e[2]),
                                 basesPerLine: parseInt(e[3]),
                                 bytesPerLine: parseInt(e[4])
                             };
-                        this.chromosomeNames.push(t), this.index[t] = n, this.chromosomes[t] = new ra(t, r++, i)
+                        this.chromosomeNames.push(t), this.index[t] = n, this.chromosomes[t] = new Yo(t, r++, i)
                     }
                 }
                 return this.index
             }
         }
         async getCompressedIndex() {
             if (this.compressedIndex) return this.compressedIndex;
             if (!this.compressedIndexFile) return this.compressedIndex = [], this.compressedIndex;
             this.compressedIndex = [];
-            const e = await lo.loadArrayBuffer(this.compressedIndexFile, No(this.config)),
+            const e = await io.loadArrayBuffer(this.compressedIndexFile, Mo(this.config)),
                 t = e.byteLength;
             if (t < 8) return console.log("Cannot parse GZI index file: length (" + t + " bytes) is insufficient to determine content of index."), this.compressedIndex;
             const i = e.slice(0, 8),
                 n = Number(new DataView(i).getBigUint64(0, !0)),
                 r = 8 + 2 * n * 8;
             if (t != r) return console.log("Incorrect file size of reference genome index. Expected : " + r + ". Received : " + t), this.compressedIndex;
             this.compressedIndex.push([0, 0]);
@@ -6665,40 +6673,40 @@
             for (let t = 0; t < e.length - 1; t++) {
                 const n = e[t],
                     r = this.compressedIndex[n][0],
                     s = e[t + 1];
                 let o = [];
                 if (-1 != s) {
                     const e = this.compressedIndex[s][0] - r;
-                    o = await lo.loadArrayBuffer(this.file, No(this.config, {
+                    o = await io.loadArrayBuffer(this.file, Mo(this.config, {
                         range: {
                             start: r,
                             size: e
                         }
                     }))
-                } else o = await lo.loadArrayBuffer(this.file, No(this.config, {
+                } else o = await io.loadArrayBuffer(this.file, Mo(this.config, {
                     range: {
                         start: r
                     }
                 }));
-                const a = await Fs(o);
+                const a = await Ts(o);
                 i[t] = a
             }
             let n = "";
             for (let e = 0; e < i.length; e++)
                 for (let t = 0; t < i[e].length; t++) {
                     n += String.fromCharCode(i[e][t])
                 }
             const r = t - this.compressedIndex[e[0]][1];
             return n = n.substring(r), n
         }
         async readSequence(e, t, i) {
             await this.getIndex(), await this.getCompressedIndex();
             const n = this.index[e];
-            if (!n) return console.log("No index entry for chr: " + e), this.interval = new ha(e, t, i, null), null;
+            if (!n) return console.log("No index entry for chr: " + e), this.interval = new ia(e, t, i, null), null;
             const r = Math.max(0, t),
                 s = Math.min(n.size, i),
                 o = n.bytesPerLine,
                 a = n.basesPerLine,
                 l = n.position,
                 h = o - a,
                 c = Math.floor(r / a),
@@ -6709,69 +6717,69 @@
                 g = p - f + 1;
             if (g <= 0) return console.error("No sequence for " + e + ":" + t + "-" + i), null;
             let m;
             if (this.compressedIndexFile) {
                 let e = await this.getRelevantCompressedBlockNumbers(f, p);
                 if (0 === e.length) return console.log("No blocks in the compressed index that correspond with the requested byte positions (" + f + "," + p + ")"), null;
                 m = await this.loadAndUncompressBlocks(e, f)
-            } else m = await lo.load(this.file, No(this.config, {
+            } else m = await io.load(this.file, Mo(this.config, {
                 range: {
                     start: f,
                     size: g
                 }
             }));
             if (!m) return null;
             let b, w = "",
                 v = 0,
                 y = m.length;
             for (u > 0 && (b = Math.min(s - r, a - u), w += m.substr(v, b), v += b + h); v < y;) b = Math.min(a, y - v), w += m.substr(v, b), v += b + h;
             return w
         }
     }
-    const fa = Yt;
-    class pa {
+    const oa = Yt;
+    class aa {
         constructor(e) {
             this.url = e, this.chromosomeNames = [], this.chromosomes = {}
         }
         async init() {
             return this.loadAll()
         }
         async getSequence(e, t, i) {}
         async loadAll() {
             let e;
-            if (Ho(this.url)) {
-                let t = Hs(this.fastaURL);
+            if (Bo(this.url)) {
+                let t = Fs(this.fastaURL);
                 e = "";
                 for (let i of t) e += String.fromCharCode(i)
-            } else e = await lo.load(this.url, {});
+            } else e = await io.load(this.url, {});
             this.chromosomeNames = [], this.chromosomes = {};
-            const t = fa(e);
+            const t = oa(e);
             let i = 0;
             for (let e of t) {
                 const t = e.split("\t");
                 this.chromosomeNames.push(t[0]);
                 const n = Number.parseInt(t[1]),
-                    r = new ra(t[0], i++, n);
+                    r = new Yo(t[0], i++, n);
                 this.chromosomes[t[0]] = r
             }
         }
     }
-    async function ga(e) {
+    async function la(e) {
         let t;
-        return t = "chromsizes" === e.format ? new pa(e.fastaURL) : Ho(e.fastaURL) || !1 === e.indexed ? new aa(e) : new ua(e), await t.init(), t
+        return t = "chromsizes" === e.format ? new aa(e.fastaURL) : Bo(e.fastaURL) || !1 === e.indexed ? new ea(e) : new sa(e), await t.init(), t
     }
-    const ma = {
+    const ha = {
             A: "rgb(  0, 200,   0)",
             C: "rgb(  0,0,200)",
             T: "rgb(255,0,0)",
             G: "rgb(209,113,  5)",
             N: "rgb(80,80,80)"
         },
-        ba = Number.MIN_SAFE_INTEGER,
-        wa = {
+        ca = Number.MIN_SAFE_INTEGER,
+        da = {
             TTT: "F",
             TTC: "F",
             TTA: "L",
             TTG: "L",
             CTT: "L",
             CTC: "L",
             CTA: "L",
@@ -6829,35 +6837,35 @@
             AGA: "R",
             AGG: "R",
             GGT: "G",
             GGC: "G",
             GGA: "G",
             GGG: "G"
         },
-        va = {},
-        ya = ["A", "G", "C", "T", "Y", "R", "W", "S", "K", "M", "D", "V", "H", "B", "N", "X"],
-        _a = ["T", "C", "G", "A", "R", "Y", "W", "S", "M", "K", "H", "B", "D", "V", "N", "X"];
-    for (let Jb = 0; Jb < ya.length; Jb++) va[ya[Jb]] = _a[Jb], va[ya[Jb].toLowerCase()] = _a[Jb].toLowerCase();
-    const xa = 115;
-    class ka {
+        ua = {},
+        fa = ["A", "G", "C", "T", "Y", "R", "W", "S", "K", "M", "D", "V", "H", "B", "N", "X"],
+        pa = ["T", "C", "G", "A", "R", "Y", "W", "S", "M", "K", "H", "B", "D", "V", "N", "X"];
+    for (let Wb = 0; Wb < fa.length; Wb++) ua[fa[Wb]] = pa[Wb], ua[fa[Wb].toLowerCase()] = pa[Wb].toLowerCase();
+    const ga = 115;
+    class ma {
         constructor(e, t) {
-            this.config = e, this.browser = t, this.type = "sequence", this.removable = void 0 === e.removable || e.removable, this.name = e.name, this.id = e.id, this.sequenceType = e.sequenceType || "dna", this.disableButtons = !1, this.order = e.order || ba, this.ignoreTrackMenu = !1, this.reversed = !0 === e.reversed, this.frameTranslate = !0 === e.frameTranslate, this.height = this.frameTranslate ? xa : 25, e.url && (e.fastaURL = e.url), e.fastaURL || (this.id = e.id || "sequence")
+            this.config = e, this.browser = t, this.type = "sequence", this.removable = void 0 === e.removable || e.removable, this.name = e.name, this.id = e.id, this.sequenceType = e.sequenceType || "dna", this.disableButtons = !1, this.order = e.order || ca, this.ignoreTrackMenu = !1, this.reversed = !0 === e.reversed, this.frameTranslate = !0 === e.frameTranslate, this.height = this.frameTranslate ? ga : 25, e.url && (e.fastaURL = e.url), e.fastaURL || (this.id = e.id || "sequence")
         }
         menuItemList() {
             return [{
                 name: this.reversed ? "Forward" : "Reverse",
                 click: () => {
                     this.reversed = !this.reversed, this.trackView.repaintViews()
                 }
             }, {
                 name: this.frameTranslate ? "Close Translation" : "Three-frame Translate",
                 click: () => {
                     if (this.frameTranslate = !this.frameTranslate, this.frameTranslate) {
-                        for (let e of this.trackView.viewports) e.setContentHeight(xa);
-                        this.trackView.setTrackHeight(xa)
+                        for (let e of this.trackView.viewports) e.setContentHeight(ga);
+                        this.trackView.setTrackHeight(ga)
                     } else {
                         for (let e of this.trackView.viewports) e.setContentHeight(25);
                         this.trackView.setTrackHeight(25)
                     }
                     this.trackView.repaintViews()
                 }
             }]
@@ -6869,22 +6877,22 @@
                     i = t.referenceFrame.chr,
                     n = Math.floor(t.referenceFrame.start),
                     r = Math.ceil(n + e),
                     s = [{
                         label: this.reversed ? "View visible sequence (reversed)..." : "View visible sequence...",
                         click: async () => {
                             let e = await this.browser.genome.sequence.getSequence(i, n, r);
-                            e ? this.reversed && (e = na(e)) : e = "Unknown sequence", this.browser.alert.present(e)
+                            e ? this.reversed && (e = Xo(e)) : e = "Unknown sequence", this.browser.alert.present(e)
                         }
                     }];
-                return jo() && s.push({
+                return Po() && s.push({
                     label: "Copy visible sequence",
                     click: async () => {
                         let e = await this.browser.genome.sequence.getSequence(i, n, r);
-                        e ? this.reversed && (e = na(e)) : e = "Unknown sequence";
+                        e ? this.reversed && (e = Xo(e)) : e = "Unknown sequence";
                         try {
                             await navigator.clipboard.writeText(e)
                         } catch (e) {
                             console.error(e), this.browser.alert.present(`error copying sequence to clipboard ${e}`)
                         }
                     }
                 }), s.push("<hr/>"), s
@@ -6897,25 +6905,25 @@
                 []
             ];
             for (let i of [0, 1, 2]) {
                 let n = i;
                 for (; e.length - n >= 3;) {
                     let r = e.slice(n, n + 3);
                     this.reversed && (r = r.split("").reverse().join(""));
-                    const s = wa[r.toUpperCase()] || "";
+                    const s = da[r.toUpperCase()] || "";
                     t[i].push({
                         codons: r,
                         aminoA: s
                     }), n += 3
                 }
             }
             return t
         }
         async getSequenceSource() {
-            return this.config.fastaURL ? (this.fasta || (this.fasta = new Ca(this.config, this.browser.genome), await this.fasta.init()), this.fasta) : this.browser.genome.sequence
+            return this.config.fastaURL ? (this.fasta || (this.fasta = new ba(this.config, this.browser.genome), await this.fasta.init()), this.fasta) : this.browser.genome.sequence
         }
         async getFeatures(e, t, i, n) {
             if (t = Math.floor(t), i = Math.floor(i), n && n > 10) return null; {
                 const n = await this.getSequenceSource();
                 return {
                     bpStart: t,
                     sequence: await n.getSequence(e, t, i)
@@ -6924,33 +6932,33 @@
         }
         draw(e) {
             const t = e.context;
             if (e.features) {
                 let i = e.features.sequence;
                 if (!i) return;
                 this.reversed && (i = i.split("").map((function(e) {
-                    return va[e]
+                    return ua[e]
                 })).join(""));
                 const n = e.features.bpStart,
                     r = 1 + e.bpStart + e.pixelWidth * e.bpPerPixel;
                 for (let s = Math.floor(e.bpStart); s <= r; s++) {
                     const r = Math.floor(s - n);
                     if (r >= 0 && r < i.length) {
                         const n = (s - e.bpStart) / e.bpPerPixel,
                             o = 1 / e.bpPerPixel,
                             a = i[r],
                             l = this.fillColor(a.toUpperCase());
-                        if (e.bpPerPixel > .1) Mo.fillRect(t, n, 5, o, 10, {
+                        if (e.bpPerPixel > .1) ko.fillRect(t, n, 5, o, 10, {
                             fillStyle: l
                         });
                         else {
                             const i = n + .5 * (o - t.measureText(a).width);
-                            "y" === e.axis ? (t.save(), Mo.labelTransformWithContext(t, i), Mo.strokeText(t, a, i, 15, {
+                            "y" === e.axis ? (t.save(), ko.labelTransformWithContext(t, i), ko.strokeText(t, a, i, 15, {
                                 strokeStyle: l
-                            }), t.restore()) : Mo.strokeText(t, a, i, 15, {
+                            }), t.restore()) : ko.strokeText(t, a, i, 15, {
                                 strokeStyle: l
                             })
                         }
                     }
                 }
                 if (this.frameTranslate) {
                     let r = 25;
@@ -6963,55 +6971,55 @@
                                 h = n + i + 3 * s - e.bpStart,
                                 c = Math.floor(h / e.bpPerPixel),
                                 d = Math.floor((h + 3) / e.bpPerPixel),
                                 u = Math.round((c + d) / 2);
                             if (d < 0) continue;
                             if (c > e.pixelWidth) break;
                             let f = l.aminoA;
-                            l.aminoA.indexOf("STOP") > -1 ? (a = "rgb(255, 0, 0)", f = "STOP") : "M" === l.aminoA && (a = "rgb(0, 153, 0)", f = "START"), Mo.fillRect(t, c, r, d - c, 25, {
+                            l.aminoA.indexOf("STOP") > -1 ? (a = "rgb(255, 0, 0)", f = "STOP") : "M" === l.aminoA && (a = "rgb(0, 153, 0)", f = "START"), ko.fillRect(t, c, r, d - c, 25, {
                                 fillStyle: a
-                            }), e.bpPerPixel <= .1 && Mo.strokeText(t, f, u - t.measureText(f).width / 2, r + 15)
+                            }), e.bpPerPixel <= .1 && ko.strokeText(t, f, u - t.measureText(f).width / 2, r + 15)
                         }
                         r += 30
                     }
                 }
             }
         }
         get supportsWholeGenome() {
             return !1
         }
         computePixelHeight(e) {
-            return this.height = this.frameTranslate ? xa : 25, this.height
+            return this.height = this.frameTranslate ? ga : 25, this.height
         }
         fillColor(e) {
-            return this.color ? this.color : "dna" === this.sequenceType ? ma[e] || "gray" : "rgb(0, 0, 150)"
+            return this.color ? this.color : "dna" === this.sequenceType ? ha[e] || "gray" : "rgb(0, 0, 150)"
         }
         getState() {
             const e = {
                 type: "sequence"
             };
-            return this.order !== ba && (e.order = this.order), this.reversed && (e.revealed = !0), e
+            return this.order !== ca && (e.order = this.order), this.reversed && (e.revealed = !0), e
         }
     }
-    class Ca {
+    class ba {
         constructor(e, t) {
             this.config = e, this.genome = t
         }
         async init() {
-            this.fasta = await ga(this.config), this.chrNameMap = new Map;
+            this.fasta = await la(this.config), this.chrNameMap = new Map;
             for (let e of this.fasta.chromosomeNames) this.chrNameMap.set(this.genome.getChromosomeName(e), e)
         }
         async getSequence(e, t, i) {
             const n = this.chrNameMap.has(e) ? this.chrNameMap.get(e) : e;
             return this.fasta.getSequence(n, t, i)
         }
     }
-    class Sa {
+    class wa {
         constructor(e, t, i, n) {
-            this.guid = _t.guid(), this.trackView = e, this.referenceFrame = i, this.browser = e.browser, this.$viewport = ft('<div class="igv-viewport">'), t.appendChild(this.$viewport.get(0)), e.track.height && (this.$viewport.get(0).style.height = `${e.track.height}px`), e.track instanceof ka && (this.alert = new Nt(this.$viewport.get(0))), this.contentTop = 0, this.contentHeight = this.$viewport.height(), this.$viewport.width(n), this.initializationHelper()
+            this.guid = _t.guid(), this.trackView = e, this.referenceFrame = i, this.browser = e.browser, this.$viewport = ft('<div class="igv-viewport">'), t.appendChild(this.$viewport.get(0)), e.track.height && (this.$viewport.get(0).style.height = `${e.track.height}px`), e.track instanceof ma && (this.alert = new Ft(this.$viewport.get(0))), this.contentTop = 0, this.contentHeight = this.$viewport.height(), this.$viewport.width(n), this.initializationHelper()
         }
         initializationHelper() {}
         showMessage(e) {
             this.messageDiv || (this.messageDiv = document.createElement("div"), this.messageDiv.className = "igv-viewport-message", this.$viewport.append(ft(this.messageDiv))), this.messageDiv.textContent = e, this.messageDiv.style.display = "inline-block"
         }
         hideMessage(e) {
             this.messageDiv && (this.messageDiv.style.display = "none")
@@ -7080,51 +7088,51 @@
      *  http://www.opensource.org/licenses/mit-license.php
      *
      *  Author:
      *  Kerry Liu
      *
      *  Copyright (c) 2014 Gliffy Inc.
      */
-    function Aa(e, t) {
+    function va(e, t) {
         var i, n = Object.keys(t);
         for (i = 0; i < n.length; i++) e = e.replace(new RegExp("\\{" + n[i] + "\\}", "gi"), t[n[i]]);
         return e
     }
 
-    function Ea(e) {
+    function ya(e) {
         var t, i, n;
         if (!e) throw new Error("cannot create a random attribute name for an undefined object");
         t = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", i = "";
         do {
             for (i = "", n = 0; n < 12; n++) i += t[Math.floor(Math.random() * t.length)]
         } while (e[i]);
         return i
     }
 
-    function Ta(e) {
+    function _a(e) {
         var t = {
             alphabetic: "alphabetic",
             hanging: "hanging",
             top: "text-before-edge",
             bottom: "text-after-edge",
             middle: "central"
         };
         return t[e] || t.alphabetic
     }
 
-    function Ma(e) {
+    function xa(e) {
         var t = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
         return [e[0] / t, e[1] / t]
     }
-    const Ra = function(e, t) {
+    const ka = function(e, t) {
             var i, n, r, s = {};
             for (e = e.split(","), t = t || 10, i = 0; i < e.length; i += 2) n = "&" + e[i + 1] + ";", r = parseInt(e[i], t), s[n] = "&#" + r + ";";
             return s["\\xa0"] = "&#160;", s
         }("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32),
-        La = {
+        Ca = {
             strokeStyle: {
                 svgAttr: "stroke",
                 canvas: "#000000",
                 svg: "none",
                 apply: "stroke"
             },
             fillStyle: {
@@ -7187,35 +7195,35 @@
             lineDash: {
                 svgAttr: "stroke-dasharray",
                 canvas: [],
                 svg: null,
                 apply: "stroke"
             }
         };
-    class Ia {
+    class Sa {
         constructor(e, t) {
             this.__root = e, this.__ctx = t
         }
         addColorStop(e, t) {
             var i, n = this.__ctx.__createElement("stop");
-            n.setAttribute("offset", e), t && -1 !== t.indexOf("rgba") ? (i = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi.exec(t), n.setAttribute("stop-color", Aa("rgb({r},{g},{b})", {
+            n.setAttribute("offset", e), t && -1 !== t.indexOf("rgba") ? (i = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi.exec(t), n.setAttribute("stop-color", va("rgb({r},{g},{b})", {
                 r: i[1],
                 g: i[2],
                 b: i[3]
             })), n.setAttribute("stop-opacity", i[4])) : n.setAttribute("stop-color", t), this.__root.appendChild(n)
         }
     }
-    class Ba {
+    class Aa {
         constructor(e, t) {
             this.__root = e, this.__ctx = t
         }
     }
-    class Na {
+    class Ea {
         constructor(e) {
-            if (!(this instanceof Na)) return new Na(e);
+            if (!(this instanceof Ea)) return new Ea(e);
             if (this.config = e, this.width = e.width, this.height = e.height, this.enableMirroring = e.enableMirroring || !1, this.canvas = this, this.__document = document, e.ctx ? this.__ctx = e.ctx : (this.__canvas = this.__document.createElement("canvas"), this.__ctx = this.__canvas.getContext("2d")), this.isSVG = !0, this.__setDefaultStyles(), this.__stack = [this.__getStyleState()], this.__groupStack = [], this.__root = this.__createElement("svg"), this.__root.setAttribute("width", this.width), this.__root.setAttribute("height", this.height), this.__root.setAttribute("overflow", "visible"), e.viewbox) {
                 const t = e.viewbox.x + " " + e.viewbox.y + " " + e.viewbox.width + " " + e.viewbox.height;
                 this.__root.setAttribute("viewBox", t), this.viewbox = e.viewbox
             }
             this.__ids = {}, this.__defs = this.__createElement("defs"), this.__root.appendChild(this.__defs), this.multiLocusGap = e.multiLocusGap;
             let t = {
                     id: "svg_output_backdrop",
@@ -7242,52 +7250,52 @@
             void 0 === t && (t = {});
             let n = this.__document.createElementNS("http://www.w3.org/2000/svg", e);
             i && (n.setAttribute("fill", "none"), n.setAttribute("stroke", "none"));
             for (let e of Object.keys(t)) n.setAttribute(e, t[e]);
             return n
         }
         __setDefaultStyles() {
-            var e, t, i = Object.keys(La);
-            for (e = 0; e < i.length; e++) this[t = i[e]] = La[t].canvas
+            var e, t, i = Object.keys(Ca);
+            for (e = 0; e < i.length; e++) this[t = i[e]] = Ca[t].canvas
         }
         __applyStyleState(e) {
             var t, i, n = Object.keys(e);
             for (t = 0; t < n.length; t++) this[i = n[t]] = e[i]
         }
         __getStyleState() {
             var e, t, i = {},
-                n = Object.keys(La);
+                n = Object.keys(Ca);
             for (e = 0; e < n.length; e++) i[t = n[e]] = this[t];
             return i
         }
         __applyStyleToCurrentElement(e) {
             var t = this.__currentElement,
                 i = this.__currentElementsToStyle;
             i && (t.setAttribute(e, ""), t = i.element, i.children.forEach((function(t) {
                 t.setAttribute(e, "")
             })));
-            var n, r, s, o, a, l = Object.keys(La);
+            var n, r, s, o, a, l = Object.keys(Ca);
             for (n = 0; n < l.length; n++)
-                if (r = La[l[n]], s = this[l[n]], r.apply)
-                    if (s instanceof Ba) {
+                if (r = Ca[l[n]], s = this[l[n]], r.apply)
+                    if (s instanceof Aa) {
                         if (s.__ctx)
                             for (; s.__ctx.__defs.childNodes.length;) o = s.__ctx.__defs.childNodes[0].getAttribute("id"), this.__ids[o] = o, this.__defs.appendChild(s.__ctx.__defs.childNodes[0]);
-                        t.setAttribute(r.apply, Aa("url(#{id})", {
+                        t.setAttribute(r.apply, va("url(#{id})", {
                             id: s.__root.getAttribute("id")
                         }))
-                    } else if (s instanceof Ia) t.setAttribute(r.apply, Aa("url(#{id})", {
+                    } else if (s instanceof Sa) t.setAttribute(r.apply, va("url(#{id})", {
                 id: s.__root.getAttribute("id")
             }));
             else if (r && -1 !== r.apply.indexOf(e) && r.svg !== s)
                 if ("stroke" !== r.svgAttr && "fill" !== r.svgAttr || !s || -1 === s.indexOf("rgba")) {
                     var h = r.svgAttr;
                     if ("globalAlpha" === l[n] && (h = e + "-" + r.svgAttr, t.getAttribute(h))) continue;
                     t.setAttribute(h, s)
                 } else {
-                    a = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi.exec(s), t.setAttribute(r.svgAttr, Aa("rgb({r},{g},{b})", {
+                    a = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi.exec(s), t.setAttribute(r.svgAttr, va("rgb({r},{g},{b})", {
                         r: a[1],
                         g: a[2],
                         b: a[3]
                     }));
                     var c = a[4],
                         d = this.globalAlpha;
                     null != d && (c *= d), t.setAttribute(r.svgAttr + "-opacity", c)
@@ -7295,15 +7303,15 @@
         }
         __closestGroupOrSvg(e) {
             return "g" === (e = e || this.__currentElement).nodeName || "svg" === e.nodeName ? e : this.__closestGroupOrSvg(e.parentNode)
         }
         getSerializedSvg(e) {
             var t, i, n, r, s, o = (new XMLSerializer).serializeToString(this.__root);
             if (e)
-                for (t = Object.keys(Ra), i = 0; i < t.length; i++) n = t[i], r = Ra[n], (s = new RegExp(n, "gi")).test(o) && (o = o.replace(s, r));
+                for (t = Object.keys(ka), i = 0; i < t.length; i++) n = t[i], r = ka[n], (s = new RegExp(n, "gi")).test(o) && (o = o.replace(s, r));
             return o
         }
         getSvg() {
             return this.__root
         }
         saveWithTranslationAndClipRect(e, t, i, n, r, s) {
             const o = `${e}_clip_rect`;
@@ -7315,18 +7323,18 @@
                 x: "0",
                 y: s.toString(),
                 width: n.toString(),
                 height: r.toString()
             };
             a.appendChild(this.__createElement("rect", l));
             const h = this.__createElement("g");
-            h.setAttribute("transform", Aa("translate({x},{y})", {
+            h.setAttribute("transform", va("translate({x},{y})", {
                 x: t,
                 y: i
-            })), h.setAttribute("clip-path", Aa("url(#{id})", {
+            })), h.setAttribute("clip-path", va("url(#{id})", {
                 id: o
             }));
             const c = this.__closestGroupOrSvg();
             c.appendChild(h), this.__groupStack.push(c), this.__currentElement = h, this.__stack.push(this.__getStyleState())
         }
         save() {
             var e = this.__createElement("g"),
@@ -7359,43 +7367,43 @@
             this.__defs.appendChild(a), a.appendChild(this.__createElement("rect", {
                 x: "0",
                 y: s.toString(),
                 width: n.toString(),
                 height: r.toString()
             }));
             let l = this.__createElement("g");
-            this.__rootGroup.appendChild(l), l.setAttribute("transform", Aa("translate({x},{y})", {
+            this.__rootGroup.appendChild(l), l.setAttribute("transform", va("translate({x},{y})", {
                 x: t,
                 y: i
-            })), l.setAttribute("id", e + "_group"), l.setAttribute("clip-path", Aa("url(#{id})", {
+            })), l.setAttribute("id", e + "_group"), l.setAttribute("clip-path", va("url(#{id})", {
                 id: o
             })), this.__currentElement = l
         }
         scale(e, t) {
-            void 0 === t && (t = e), this.__addTransform(Aa("scale({x},{y})", {
+            void 0 === t && (t = e), this.__addTransform(va("scale({x},{y})", {
                 x: e,
                 y: t
             }))
         }
         rotate(e) {
             var t = 180 * e / Math.PI;
-            this.__addTransform(Aa("rotate({angle},{cx},{cy})", {
+            this.__addTransform(va("rotate({angle},{cx},{cy})", {
                 angle: t,
                 cx: 0,
                 cy: 0
             }))
         }
         translate(e, t) {
-            this.__addTransform(Aa("translate({x},{y})", {
+            this.__addTransform(va("translate({x},{y})", {
                 x: e,
                 y: t
             }))
         }
         transform(e, t, i, n, r, s) {
-            this.__addTransform(Aa("matrix({a},{b},{c},{d},{e},{f})", {
+            this.__addTransform(va("matrix({a},{b},{c},{d},{e},{f})", {
                 a: e,
                 b: t,
                 c: i,
                 d: n,
                 e: r,
                 f: s
             }))
@@ -7411,71 +7419,71 @@
         __addPathCommand(e) {
             this.__currentDefaultPath += " ", this.__currentDefaultPath += e
         }
         moveTo(e, t) {
             "path" !== this.__currentElement.nodeName && this.beginPath(), this.__currentPosition = {
                 x: e,
                 y: t
-            }, this.__addPathCommand(Aa("M {x} {y}", {
+            }, this.__addPathCommand(va("M {x} {y}", {
                 x: e,
                 y: t
             }))
         }
         closePath() {
             this.__currentDefaultPath && this.__addPathCommand("Z")
         }
         lineTo(e, t) {
             this.__currentPosition = {
                 x: e,
                 y: t
-            }, this.__currentDefaultPath && this.__currentDefaultPath.indexOf("M") > -1 ? this.__addPathCommand(Aa("L {x} {y}", {
+            }, this.__currentDefaultPath && this.__currentDefaultPath.indexOf("M") > -1 ? this.__addPathCommand(va("L {x} {y}", {
                 x: e,
                 y: t
-            })) : this.__addPathCommand(Aa("M {x} {y}", {
+            })) : this.__addPathCommand(va("M {x} {y}", {
                 x: e,
                 y: t
             }))
         }
         bezierCurveTo(e, t, i, n, r, s) {
             this.__currentPosition = {
                 x: r,
                 y: s
-            }, this.__addPathCommand(Aa("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}", {
+            }, this.__addPathCommand(va("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}", {
                 cp1x: e,
                 cp1y: t,
                 cp2x: i,
                 cp2y: n,
                 x: r,
                 y: s
             }))
         }
         quadraticCurveTo(e, t, i, n) {
             this.__currentPosition = {
                 x: i,
                 y: n
-            }, this.__addPathCommand(Aa("Q {cpx} {cpy} {x} {y}", {
+            }, this.__addPathCommand(va("Q {cpx} {cpy} {x} {y}", {
                 cpx: e,
                 cpy: t,
                 x: i,
                 y: n
             }))
         }
         arcTo(e, t, i, n, r) {
             var s = this.__currentPosition && this.__currentPosition.x,
                 o = this.__currentPosition && this.__currentPosition.y;
             if (void 0 !== s && void 0 !== o) {
                 if (r < 0) throw new Error("IndexSizeError: The radius provided (" + r + ") is negative.");
                 if (s === e && o === t || e === i && t === n || 0 === r) this.lineTo(e, t);
                 else {
-                    var a = Ma([s - e, o - t]),
-                        l = Ma([i - e, n - t]);
+                    var a = xa([s - e, o - t]),
+                        l = xa([i - e, n - t]);
                     if (a[0] * l[1] != a[1] * l[0]) {
                         var h = a[0] * l[0] + a[1] * l[1],
                             c = Math.acos(Math.abs(h)),
-                            d = Ma([a[0] + l[0], a[1] + l[1]]),
+                            d = xa([a[0] + l[0], a[1] + l[1]]),
                             u = r / Math.sin(c / 2),
                             f = e + u * d[0],
                             p = t + u * d[1],
                             g = [-a[1], a[0]],
                             m = [l[1], -l[0]],
                             b = function(e) {
                                 var t = e[0];
@@ -7546,34 +7554,34 @@
                     height: n,
                     fill: "#FFFFFF"
                 }, !0), s.appendChild(r)
             } else this.__clearCanvas()
         }
         createLinearGradient(e, t, i, n) {
             var r = this.__createElement("linearGradient", {
-                id: Ea(this.__ids),
+                id: ya(this.__ids),
                 x1: e + "px",
                 x2: i + "px",
                 y1: t + "px",
                 y2: n + "px",
                 gradientUnits: "userSpaceOnUse"
             }, !1);
-            return this.__defs.appendChild(r), new Ia(r, this)
+            return this.__defs.appendChild(r), new Sa(r, this)
         }
         createRadialGradient(e, t, i, n, r, s) {
             var o = this.__createElement("radialGradient", {
-                id: Ea(this.__ids),
+                id: ya(this.__ids),
                 cx: n + "px",
                 cy: r + "px",
                 r: s + "px",
                 fx: e + "px",
                 fy: t + "px",
                 gradientUnits: "userSpaceOnUse"
             }, !1);
-            return this.__defs.appendChild(o), new Ia(o, this)
+            return this.__defs.appendChild(o), new Sa(o, this)
         }
         __parseFont() {
             var e = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i.exec(this.font),
                 t = {
                     style: e[1] || "normal",
                     size: e[4] || "10px",
                     family: e[6] || "sans-serif",
@@ -7604,15 +7612,15 @@
                     "text-anchor": (r = this.textAlign, s = {
                         left: "start",
                         right: "end",
                         center: "middle",
                         start: "start",
                         end: "end"
                     }, s[r] || s.start),
-                    "dominant-baseline": Ta(this.textBaseline)
+                    "dominant-baseline": _a(this.textBaseline)
                 }, !0);
             l.appendChild(this.__document.createTextNode(e)), this.__currentElement = l, this.__applyStyleToCurrentElement(n), a.appendChild(this.__wrapTextLink(o, l))
         }
         fillText(e, t, i) {
             this.__applyText(e, t, i, "fill")
         }
         strokeText(e, t, i) {
@@ -7627,15 +7635,15 @@
                 var o = e + i * Math.cos(r),
                     a = t + i * Math.sin(r),
                     l = e + i * Math.cos(n),
                     h = t + i * Math.sin(n),
                     c = s ? 0 : 1,
                     d = 0,
                     u = r - n;
-                u < 0 && (u += 2 * Math.PI), d = s ? u > Math.PI ? 0 : 1 : u > Math.PI ? 1 : 0, this.lineTo(l, h), this.__addPathCommand(Aa("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}", {
+                u < 0 && (u += 2 * Math.PI), d = s ? u > Math.PI ? 0 : 1 : u > Math.PI ? 1 : 0, this.lineTo(l, h), this.__addPathCommand(va("A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}", {
                     rx: i,
                     ry: i,
                     xAxisRotation: 0,
                     largeArcFlag: d,
                     sweepFlag: c,
                     endX: o,
                     endY: a
@@ -7644,17 +7652,17 @@
                     y: a
                 }
             }
         }
         clip() {
             var e = this.__closestGroupOrSvg(),
                 t = this.__createElement("clipPath"),
-                i = Ea(this.__ids),
+                i = ya(this.__ids),
                 n = this.__createElement("g");
-            this.__applyCurrentDefaultPath(), e.removeChild(this.__currentElement), t.setAttribute("id", i), t.appendChild(this.__currentElement), this.__defs.appendChild(t), e.setAttribute("clip-path", Aa("url(#{id})", {
+            this.__applyCurrentDefaultPath(), e.removeChild(this.__currentElement), t.setAttribute("id", i), t.appendChild(this.__currentElement), this.__defs.appendChild(t), e.setAttribute("clip-path", va("url(#{id})", {
                 id: i
             })), e.appendChild(n), this.__currentElement = n
         }
         drawImage() {
             var e, t, i, n, r, s, o, a, l, h, c, d, u, f = Array.prototype.slice.call(arguments),
                 p = f[0],
                 g = 0,
@@ -7663,141 +7671,140 @@
             else if (5 === f.length) e = f[1], t = f[2], i = f[3], n = f[4], r = p.width, s = p.height;
             else {
                 if (9 !== f.length) throw new Error("Invalid number of arguments passed to drawImage: " + arguments.length);
                 g = f[1], m = f[2], r = f[3], s = f[4], e = f[5], t = f[6], i = f[7], n = f[8]
             }
             o = this.__closestGroupOrSvg(), this.__currentElement;
             var b = "translate(" + e + ", " + t + ")";
-            if (p instanceof Na) {
+            if (p instanceof Ea) {
                 if ((a = p.getSvg().cloneNode(!0)).childNodes && a.childNodes.length > 1) {
                     for (l = a.childNodes[0]; l.childNodes.length;) u = l.childNodes[0].getAttribute("id"), this.__ids[u] = u, this.__defs.appendChild(l.childNodes[0]);
                     if (h = a.childNodes[1]) {
                         var w, v = h.getAttribute("transform");
                         w = v ? v + " " + b : b, h.setAttribute("transform", w), o.appendChild(h)
                     }
                 }
             } else "CANVAS" !== p.nodeName && "IMG" !== p.nodeName || ((c = this.__createElement("image")).setAttribute("width", i), c.setAttribute("height", n), c.setAttribute("preserveAspectRatio", "none"), (g || m || r !== p.width || s !== p.height) && ((d = this.__document.createElement("canvas")).width = i, d.height = n, d.getContext("2d").drawImage(p, g, m, r, s, 0, 0, i, n), p = d), c.setAttribute("transform", b), c.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "CANVAS" === p.nodeName ? p.toDataURL() : p.getAttribute("src")), o.appendChild(c))
         }
         createPattern(e, t) {
             let i, n = this.__document.__createElement("pattern"),
-                r = Ea(this.__ids);
-            return n.setAttribute("id", r), n.setAttribute("width", e.width), n.setAttribute("height", e.height), "CANVAS" === e.nodeName || "IMG" === e.nodeName ? (i = this.__createElement("image"), i.setAttribute("width", e.width), i.setAttribute("height", e.height), i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "CANVAS" === e.nodeName ? e.toDataURL() : e.getAttribute("src")), n.appendChild(i), this.__defs.appendChild(n)) : e instanceof Na && (n.appendChild(e.__root.childNodes[1]), this.__defs.appendChild(n)), new Ba(n, this)
+                r = ya(this.__ids);
+            return n.setAttribute("id", r), n.setAttribute("width", e.width), n.setAttribute("height", e.height), "CANVAS" === e.nodeName || "IMG" === e.nodeName ? (i = this.__createElement("image"), i.setAttribute("width", e.width), i.setAttribute("height", e.height), i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "CANVAS" === e.nodeName ? e.toDataURL() : e.getAttribute("src")), n.appendChild(i), this.__defs.appendChild(n)) : e instanceof Ea && (n.appendChild(e.__root.childNodes[1]), this.__defs.appendChild(n)), new Aa(n, this)
         }
         setLineDash(e) {
             e && e.length > 0 ? this.lineDash = e.join(",") : this.lineDash = null
         }
         drawFocusRing() {}
         createImageData() {}
         getImageData() {}
         putImageData() {}
         globalCompositeOperation() {}
         setTransform() {}
     }
-    const Fa = function(e, t, i, n) {
-            this.start = e, this.end = t, this.name = i, this.stain = 0, "acen" === n ? this.type = "c" : (this.type = n.charAt(1), "p" === this.type && (this.stain = parseInt(n.substring(4))))
-        },
-        Pa = "2.14.0";
+    const Ma = function(e, t, i, n) {
+        this.start = e, this.end = t, this.name = i, this.stain = 0, "acen" === n ? this.type = "c" : (this.type = n.charAt(1), "p" === this.type && (this.stain = parseInt(n.substring(4))))
+    };
 
-    function Oa() {
-        return Pa
+    function Ta() {
+        return "2.15.7"
     }
-    const Da = Yt,
-        za = {
+    const Ra = Yt,
+        La = {
             loadGenome: async function(e) {
                 const t = e.cytobandURL,
                     i = e.aliasURL,
-                    n = await ga(e);
+                    n = await la(e);
                 let r;
                 i && (r = await
                     function(e, t) {
-                        return lo.loadString(e, No(t)).then((function(e) {
-                            var t = Da(e),
+                        return io.loadString(e, Mo(t)).then((function(e) {
+                            var t = Ra(e),
                                 i = [];
                             return t.forEach((function(e) {
                                 !e.startsWith("#") && e.length > 0 && i.push(e.split("\t"))
                             })), i
                         }))
                     }(i, n.config));
-                const s = new Ha(e, n, r);
+                const s = new Ia(e, n, r);
                 return t && (s.cytobands = await async function(e, t, i) {
                     let n;
-                    if (Ho(e)) {
-                        const t = Hs(e);
+                    if (Bo(e)) {
+                        const t = Fs(e);
                         n = "";
                         const i = t.length;
                         for (let e = 0; e < i; e++) n += String.fromCharCode(t[e])
-                    } else n = await lo.loadString(e, No(t));
+                    } else n = await io.loadString(e, Mo(t));
                     const r = {};
                     let s, o = [];
-                    const a = Da(n);
+                    const a = Ra(n);
                     for (let e of a) {
                         var l = e.split("\t"),
                             h = i.getChromosomeName(l[0]);
                         if (s || (s = h), h !== s && (r[s] = o, o = [], s = h), 5 === l.length) {
                             var c = parseInt(l[1]),
                                 d = parseInt(l[2]),
                                 u = l[3],
                                 f = l[4];
-                            o.push(new Fa(c, d, u, f))
+                            o.push(new Ma(c, d, u, f))
                         }
                     }
                     return r
                 }(t, n.config, s)), s
             },
             initializeGenomes: async function(e) {
-                if (!za.KNOWN_GENOMES) {
+                if (!La.KNOWN_GENOMES) {
                     const t = {};
                     if (!1 !== e.loadDefaultGenomes) try {
-                        const r = `https://igv.org/genomes/genomes.json?randomSeed=${Math.random().toString(36)}&version=${Oa()}`;
-                        n(await lo.loadJson(r, {
+                        const r = `https://igv.org/genomes/genomes.json?randomSeed=${Math.random().toString(36)}&version=2.15.7`;
+                        n(await io.loadJson(r, {
                             timeout: 5e3
                         }))
                     } catch (s) {
                         console.error(s);
                         try {
-                            const o = `https://s3.amazonaws.com/igv.org.genomes/genomes.json?randomSeed=${Math.random().toString(36)}&version=${Oa()}`;
-                            n(await lo.loadJson(o, {}))
+                            const o = `https://s3.amazonaws.com/igv.org.genomes/genomes.json?randomSeed=${Math.random().toString(36)}&version=2.15.7`;
+                            n(await io.loadJson(o, {}))
                         } catch (a) {
                             console.error(a), console.warn("Errors loading default genome definitions.")
                         }
                     }
                     const i = e.genomeList || e.genomes;
                     if (i)
                         if ("string" == typeof i) {
-                            n(await lo.loadJson(i, {}))
+                            n(await io.loadJson(i, {}))
                         } else n(i);
 
                     function n(e) {
                         return e.forEach((function(e) {
                             t[e.id] = e
                         })), t
                     }
-                    za.KNOWN_GENOMES = t
+                    La.KNOWN_GENOMES = t
                 }
             },
             isWholeGenomeView: function(e) {
                 return "all" === e.toLowerCase()
             },
             expandReference: function(e, t) {
                 if (Qt(t) && t.startsWith("{")) try {
                     t = JSON.parse(t)
                 } catch (e) {}
                 let i;
                 if (Qt(t) ? i = t : t.genome ? i = t.genome : void 0 !== t.id && void 0 === t.fastaURL && (i = t.id), i) {
-                    const t = za.KNOWN_GENOMES[i];
+                    const t = La.KNOWN_GENOMES[i];
                     return t || e.present(new Error(`Unknown genome id: ${i}`), void 0), t
                 }
                 return t
             }
         };
-    class Ha {
+    class Ia {
         constructor(e, t, i) {
             this.config = e, this.id = e.id || function(e) {
                 return void 0 !== e.id ? e.id : e.fastaURL && Qt(e.fastaURL) ? e.fastaURL : e.fastaURL && e.fastaURL.name ? e.fastaURL.name : ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4)
-            }(e), this.sequence = t, this.chromosomeNames = t.chromosomeNames, this.chromosomes = t.chromosomes, this.featureDB = {}, this.wholeGenomeView = void 0 === e.wholeGenomeView || e.wholeGenomeView, this.wholeGenomeView && Object.keys(t.chromosomes).length > 1 ? function(e, t) {
+            }(e), this.sequence = t, this.chromosomeNames = t.chromosomeNames, this.chromosomes = t.chromosomes, this.featureDB = new Map, this.wholeGenomeView = void 0 === e.wholeGenomeView || e.wholeGenomeView, this.wholeGenomeView && Object.keys(t.chromosomes).length > 1 ? function(e, t) {
                 let i;
                 if (t.chromosomeOrder) Array.isArray(t.chromosomeOrder) ? e.wgChromosomeNames = t.chromosomeOrder : e.wgChromosomeNames = t.chromosomeOrder.split(",").map((e => e.trim())), i = e.wgChromosomeNames.map((t => e.chromosomes[t])).filter((e => void 0 !== e));
                 else {
                     const t = Object.keys(e.chromosomes).map((t => e.chromosomes[t].bpLength)).reduce(((e, t) => Math.max(e, t))) / 50;
                     i = Object.values(e.chromosomes).filter((e => e.bpLength > t));
                     const n = i.filter((e => r(e.name.replace("chr", "")))),
                         s = i.filter((e => !r(e.name.replace("chr", ""))));
@@ -7914,18 +7921,30 @@
                 })), this.bpLength = t
             }
             return this.bpLength
         }
         async getSequence(e, t, i) {
             return e = this.getChromosomeName(e), this.sequence.getSequence(e, t, i)
         }
+        addFeaturesToDB(e, t) {
+            const i = (e, t) => {
+                const i = this.featureDB.get(e);
+                i && (t = t.end - t.start > i.end - i.start ? t : i), this.featureDB.set(e, t)
+            };
+            for (let n of e)
+                if (n.name && i(n.name.toUpperCase(), n), n.gene && n.gene.name && i(n.gene.name.toUpperCase(), n), t.searchableFields)
+                    for (let e of t.searchableFields) {
+                        const t = n.getAttributeValue(e);
+                        t && (t.indexOf(" ") > 0 ? i(t.replaceAll(" ", "+").toUpperCase(), n) : i(t.toUpperCase(), n))
+                    }
+        }
     }
-    let Va, Ua = 0,
-        qa = 0;
-    class ja extends Sa {
+    let Ba, Fa = 0,
+        Na = 0;
+    class Oa extends wa {
         constructor(e, t, i, n) {
             super(e, t, i, n)
         }
         initializationHelper() {
             this.$spinner = ft("<div>", {
                 class: "igv-loading-spinner-container"
             }), this.$viewport.append(this.$spinner), this.$spinner.append(ft("<div>"));
@@ -8003,25 +8022,25 @@
                                 const i = await n.getFeatures(t, r, s, e.bpPerPixel);
                                 o.push({
                                     track: n,
                                     features: i
                                 })
                             }
                         const a = i && ("wig" === i.type || "merged" === i.type);
-                        return this.featureCache = new $a(t, r, s, e.bpPerPixel, n, o, a), this.loading = !1, this.hideMessage(), this.stopSpinner(), this.featureCache
+                        return this.featureCache = new Pa(t, r, s, e.bpPerPixel, n, o, a), this.loading = !1, this.hideMessage(), this.stopSpinner(), this.featureCache
                     }
                 } catch (e) {
                     this.trackView && !0 !== this.trackView.disposed && (this.showMessage("Error loading track data"), this.browser.alert.present(e), console.error(e))
                 } finally {
                     this.loading = !1, this.stopSpinner()
                 }
             }
         }
         repaintDimensions() {
-            const e = za.isWholeGenomeView(this.referenceFrame.chr),
+            const e = La.isWholeGenomeView(this.referenceFrame.chr),
                 t = e ? this.$viewport.width() : 3 * this.$viewport.width(),
                 i = this.referenceFrame.bpPerPixel;
             return {
                 bpStart: this.referenceFrame.start - (e ? 0 : t / 3 * i),
                 bpEnd: this.referenceFrame.end + (e ? 0 : t / 3 * i),
                 pixelWidth: t
             }
@@ -8092,22 +8111,22 @@
                 r = this.$viewport.height() * i,
                 s = -ft(this.canvas).position().left * i,
                 o = (-this.contentTop - t) * i,
                 a = this.canvas.getContext("2d").getImageData(s, o, n, r),
                 l = document.createElement("canvas"),
                 h = l.getContext("2d");
             l.width = a.width, l.height = a.height, h.putImageData(a, 0, 0);
-            ni((this.$trackLabel.text() ? this.$trackLabel.text() : "image") + ".png", l.toDataURL("image/png"))
+            ii((this.$trackLabel.text() ? this.$trackLabel.text() : "image") + ".png", l.toDataURL("image/png"))
         }
         saveSVG() {
             let {
                 width: e,
                 height: t
             } = this.browser.columnContainer.getBoundingClientRect();
-            const i = new Na({
+            const i = new Ea({
                     width: e,
                     height: 8e3,
                     backdropColor: "white",
                     multiLocusGap: 0,
                     viewbox: {
                         x: 0,
                         y: 0,
@@ -8122,15 +8141,15 @@
             this.renderViewportToSVG(i, n), i.setHeight(t);
             const r = (this.trackView.track.name || this.trackView.track.id).replace(/\W/g, ""),
                 s = this.browser.referenceFrameList.indexOf(this.referenceFrame),
                 o = i.getSerializedSvg(!0),
                 a = URL.createObjectURL(new Blob([o], {
                     type: "application/octet-stream"
                 }));
-            ni(`${`${r}_referenceFrame_${s}_guid_${_t.guid()}`}.svg`, a)
+            ii(`${`${r}_referenceFrame_${s}_guid_${_t.guid()}`}.svg`, a)
         }
         renderViewportToSVG(e, {
             deltaX: t,
             deltaY: i
         }) {
             if (this.$zoomInNotice && this.$zoomInNotice.is(":visible")) return;
             const {
@@ -8235,16 +8254,16 @@
                 this.enableClick = !0, this.browser.mouseDownOnViewport(e, this), _t.pageCoordinates(e)
             };
             e.addEventListener("mousedown", t), e.addEventListener("touchstart", t);
             const i = e => {
                 this.browser.dragObject || this.browser.isScrolling ? (this.browser.cancelTrackPan(), this.enableClick = !1) : (this.browser.cancelTrackPan(), this.browser.endTrackDrag())
             };
             e.addEventListener("mouseup", i), e.addEventListener("touchend", i), "function" == typeof this.trackView.track.hoverText && e.addEventListener("mousemove", (e => {
-                if (0 === e.buttons && Date.now() - qa > 100) {
-                    qa = Date.now();
+                if (0 === e.buttons && Date.now() - Na > 100) {
+                    Na = Date.now();
                     const t = this.createClickState(e);
                     if (t) {
                         const e = this.trackView.track.hoverText(t);
                         e ? this.$viewport[0].setAttribute("title", e) : this.$viewport[0].removeAttribute("title")
                     }
                 }
             })), this.addViewportClickHandler(this.$viewport.get(0)), this.trackView.track.name && "sequence" !== this.trackView.track.config.type && this.addTrackLabelClickHandler(this.$trackLabel.get(0))
@@ -8278,34 +8297,34 @@
                     if (ft(".igv-popover").hide(), this.browser.dragObject || this.browser.isScrolling) return;
                     e.preventDefault();
                     const t = _t.translateMouseCoordinates(e, this.$viewport.get(0)).x,
                         i = _t.translateMouseCoordinates(e, this.canvas).x,
                         n = this.referenceFrame,
                         r = Math.floor(n.start + n.toBP(i)),
                         s = Date.now();
-                    if (s - Ua < this.browser.constants.doubleClickDelay) {
-                        Va && (window.clearTimeout(Va), Va = void 0);
+                    if (s - Fa < this.browser.constants.doubleClickDelay) {
+                        Ba && (window.clearTimeout(Ba), Ba = void 0);
                         const e = Math.round(n.start + n.toBP(t));
                         let i;
                         if ("all" === this.referenceFrame.chr.toLowerCase()) {
                             const t = this.browser.genome.getChromosomeCoordinate(e).chr;
                             if (1 === this.browser.referenceFrameList.length) i = t;
                             else {
                                 const e = this.browser.referenceFrameList.map((({
                                     locusSearchString: e
                                 }) => e));
                                 e[this.browser.referenceFrameList.indexOf(this.referenceFrame)] = t, i = e.join(" ")
                             }
                             this.browser.search(i)
                         } else this.browser.zoomWithScaleFactor(.5, e, this.referenceFrame)
-                    } else e.shiftKey && "function" == typeof this.trackView.track.shiftClick ? this.trackView.track.shiftClick(r, e) : "function" == typeof this.trackView.track.popupData && (Va = setTimeout((() => {
+                    } else e.shiftKey && "function" == typeof this.trackView.track.shiftClick ? this.trackView.track.shiftClick(r, e) : "function" == typeof this.trackView.track.popupData && (Ba = setTimeout((() => {
                         const t = this.getPopupContent(e);
-                        t && (this.popover && this.popover.dispose(), this.popover = new Vt(this.browser.columnContainer), this.popover.presentContentWithEvent(e, t)), window.clearTimeout(Va), Va = void 0
+                        t && (this.popover && this.popover.dispose(), this.popover = new Vt(this.browser.columnContainer), this.popover.presentContentWithEvent(e, t)), window.clearTimeout(Ba), Ba = void 0
                     }), this.browser.constants.doubleClickDelay));
-                    Ua = s
+                    Fa = s
                 }
             }))
         }
         addTrackLabelClickHandler(e) {
             e.addEventListener("click", (e => {
                 e.stopPropagation();
                 const {
@@ -8343,28 +8362,28 @@
                     const t = `<span>${e.name}</span>&nbsp&nbsp&nbsp${e.value}`;
                     return `<div title="${e.value}">${t}</div>`
                 }
                 return "<hr>" === e ? e : e.html ? e.html : `<div title="${e}">${e}</div>`
             })).join("")) : "string" == typeof r && (s = r), s
         }
     }
-    class $a {
+    class Pa {
         constructor(e, t, i, n, r, s, o) {
             this.chr = e, this.bpStart = t, this.bpEnd = i, this.bpPerPixel = n, this.features = r, this.roiFeatures = s, this.multiresolution = o
         }
         containsRange(e, t, i, n) {
             const r = this.multiresolution ? this.bpPerPixel / n : 1;
             return t >= this.bpStart && i <= this.bpEnd && e === this.chr && r > .5 && r < 2
         }
         overlapsRange(e, t, i) {
             return this.chr === e && i >= this.bpStart && t <= this.bpEnd
         }
     }
 
-    function Wa(e, t) {
+    function Da(e, t) {
         if (!(e.length < 6)) return {
             chr: e[0],
             start: e[1],
             end: e[2],
             chr1: e[8],
             start1: Number.parseInt(e[9]),
             end1: Number.parseInt(e[10]),
@@ -8374,44 +8393,44 @@
             name: e[3],
             score: Number(e[4]),
             value: Number(e[5]),
             color: "." === e[7] ? void 0 : "0" === e[7] ? "rgb(0,0,0)" : e[7]
         };
         console.log("Skipping line: " + e.join(" "))
     }
-    const Ga = new Set(["transcript", "primary_transcript", "processed_transcript", "mRNA", "mrna", "lnc_RNA", "miRNA", "ncRNA", "rRNA", "scRNA", "snRNA", "snoRNA", "tRNA"]),
-        Za = new Set(["CDS", "cds"]),
-        Qa = new Set(["start_codon", "stop_codon"]),
-        Xa = new Set(["5UTR", "3UTR", "UTR", "five_prime_UTR", "three_prime_UTR", "3'-UTR", "5'-UTR"]),
-        Ya = new Set(["exon", "coding-exon"]),
-        Ka = new Set;
-    for (let ew of [Za, Qa, Xa, Ya])
-        for (let tw of ew) Ka.add(tw);
+    const za = new Set(["transcript", "primary_transcript", "processed_transcript", "mRNA", "mrna", "lnc_RNA", "miRNA", "ncRNA", "rRNA", "scRNA", "snRNA", "snoRNA", "tRNA"]),
+        Ha = new Set(["CDS", "cds"]),
+        Va = new Set(["start_codon", "stop_codon"]),
+        Ua = new Set(["5UTR", "3UTR", "UTR", "five_prime_UTR", "three_prime_UTR", "3'-UTR", "5'-UTR"]),
+        qa = new Set(["exon", "coding-exon"]),
+        ja = new Set;
+    for (let Gb of [Ha, Va, Ua, qa])
+        for (let Zb of Gb) ja.add(Zb);
 
-    function Ja(e) {
+    function $a(e) {
         return e.includes("intron")
     }
 
-    function el(e) {
-        return Za.has(e) || Qa.has(e)
+    function Wa(e) {
+        return Ha.has(e) || Va.has(e)
     }
 
-    function tl(e) {
-        return Xa.has(e)
+    function Ga(e) {
+        return Ua.has(e)
     }
 
-    function il(e) {
-        return Ga.has(e) || e.endsWith("RNA") || e.endsWith("transcript")
+    function Za(e) {
+        return za.has(e) || e.endsWith("RNA") || e.endsWith("transcript")
     }
 
-    function nl(e) {
-        return Ka.has(e) || e.endsWith("RNA") || Ja(e)
+    function Qa(e) {
+        return ja.has(e) || e.endsWith("RNA") || $a(e)
     }
-    const rl = new Set(["id", "parent", "name"]);
-    class sl {
+    const Xa = new Set(["id", "parent", "name"]);
+    class Ya {
         constructor(e) {
             Object.assign(this, e)
         }
         popupData(e) {
             const t = this.geneObject ? this.geneObject.popupData() : [];
             if (this.geneObject && t.push("<hr/>"), this.name && t.push({
                     name: "Name",
@@ -8422,39 +8441,39 @@
                 }), t.push({
                     name: "Source",
                     value: this.source
                 }), void 0 !== this.score && t.push({
                     name: "Score",
                     value: this.score
                 }), this.attributeString) {
-                const e = cl(this.attributeString, this.delim);
-                for (let [i, n] of e) void 0 !== n && n.length > 0 && !rl.has(i.toLowerCase()) && t.push({
+                const e = il(this.attributeString, this.delim);
+                for (let [i, n] of e) void 0 !== n && n.length > 0 && !Xa.has(i.toLowerCase()) && t.push({
                     name: i + ":",
                     value: n
                 })
             }
             return t.push({
                 name: "Location",
                 value: `${this.chr}:${Xt(this.start+1)}-${Xt(this.end)}`
             }), t
         }
         getAttributeValue(e) {
             if (this.hasOwnProperty(e)) return this[e];
             if (this._attributeCache || (this._attributeCache = new Map), this._attributeCache.has(e)) return this._attributeCache.get(e); {
-                const t = cl(this.attributeString, this.delim);
+                const t = il(this.attributeString, this.delim);
                 let i;
                 for (let [n, r] of t)
                     if (n === e) {
                         i = r;
                         break
                     } return this._attributeCache.set(e, i), i
             }
         }
     }
-    class ol extends sl {
+    class Ka extends Ya {
         constructor(e) {
             super(e), this.exons = [], this.parts = []
         }
         addExon(e) {
             this.exons.push(e), this.start = Math.min(this.start, e.start), this.end = Math.max(this.end, e.end)
         }
         addPart(e) {
@@ -8465,15 +8484,15 @@
             this.parts.sort((function(e, t) {
                 return e.start - t.start
             }));
             let e = this.parts[0].start,
                 t = this.parts[0].end;
             for (let i = 1; i < this.parts.length; i++) {
                 const n = this.parts[i];
-                if (!Ja(n.type))
+                if (!$a(n.type))
                     if (n.start <= t) t = Math.max(t, n.end);
                     else {
                         this.findExonContaining({
                             start: e,
                             end: t
                         }) || this.exons.push({
                             start: e,
@@ -8488,15 +8507,15 @@
             }) || (this.exons.push({
                 start: e,
                 end: t,
                 psuedo: !0
             }), this.start = Math.min(this.start, e), this.end = Math.max(this.end, t));
             for (let e of this.parts) {
                 const t = e.type;
-                el(t) ? this.addCDS(e) : tl(t) && this.addUTR(e)
+                Wa(t) ? this.addCDS(e) : Ga(t) && this.addUTR(e)
             }
         }
         findExonContaining({
             start: e,
             end: t
         }) {
             for (let i of this.exons)
@@ -8542,149 +8561,163 @@
                     t.push("<hr/>");
                     const n = i.popupData(e);
                     for (let e of n) t.push(e)
                 } return t
         }
     }
 
-    function al(e, t) {
+    function Ja(e, t) {
         const i = t.format;
         if (e.length < 9) return;
         const n = "gff3" === i ? "=" : " ";
-        return new sl({
-            source: fl(e[1]),
+        return new Ya({
+            source: sl(e[1]),
             type: e[2],
             chr: e[0],
             start: parseInt(e[3]) - 1,
             end: parseInt(e[4]),
             score: "." === e[5] ? void 0 : Number(e[5]),
             strand: e[6],
             phase: "." === e[7] ? 0 : parseInt(e[7]),
             attributeString: e[8],
             delim: n
         })
     }
 
-    function ll(e, t) {
-        const i = al(e, t);
+    function el(e, t) {
+        const i = Ja(e, t);
         if (!i) return;
-        const n = cl(i.attributeString, i.delim);
+        const n = il(i.attributeString, i.delim);
         for (let [e, t] of n) {
             const n = e.toLowerCase();
-            "color" === n || "colour" === n ? i.color = js.createColorString(t) : "ID" === e ? i.id = t : "Parent" === e && (i.parent = t)
+            "color" === n || "colour" === n ? i.color = Ds.createColorString(t) : "ID" === e ? i.id = t : "Parent" === e && (i.parent = t)
         }
         return i
     }
 
-    function hl(e, t) {
-        const i = al(e, t);
+    function tl(e, t) {
+        const i = Ja(e, t);
         if (!i) return;
-        const n = cl(i.attributeString, i.delim);
+        const n = il(i.attributeString, i.delim);
         let r, s;
         switch (i.type) {
             case "gene":
                 r = "gene_id";
                 break;
             case "transcript":
                 r = "transcript_id", s = "gene_id";
                 break;
             default:
                 s = "transcript_id"
         }
         for (let [e, t] of n) {
             const n = e.toLowerCase();
-            "color" === n || "colour" === n ? i.color = js.createColorString(t) : e === r ? i.id = t : e === s && (i.parent = t)
+            "color" === n || "colour" === n ? i.color = Ds.createColorString(t) : e === r ? i.id = t : e === s && (i.parent = t)
         }
         return i
     }
 
-    function cl(e, t) {
-        var i = [];
-        for (let n of e.split(";")) {
-            n = n.trim();
-            const e = n.indexOf(t);
-            if (e > 0 && e < n.length - 1) {
-                const t = n.substring(0, e);
-                let r = dl(fl(n.substring(e + 1).trim()));
-                i.push([t, r])
+    function il(e, t, i = !1) {
+        var n = [];
+        for (let r of e.split(";")) {
+            r = r.trim();
+            const e = r.indexOf(t);
+            if (e > 0 && e < r.length - 1) {
+                const t = nl(sl(r.substring(0, e).trim(), i));
+                let s = nl(sl(r.substring(e + 1).trim(), i));
+                n.push([t, s])
             }
         }
-        return i
+        return n
     }
 
-    function dl(e) {
+    function nl(e) {
         return e.startsWith('"') && e.endsWith('"') && (e = e.substr(1, e.length - 2)), e
     }
-    const ul = new Map([
+    const rl = new Map([
         ["%09", "\t"],
         ["%0A", "\n"],
         ["%0D", "\r"],
         ["%25", "%"],
         ["%3B", ";"],
         ["%3D", "="],
         ["%26", "&"],
         ["%2C", ","]
     ]);
 
-    function fl(e) {
+    function sl(e, t = !1) {
         if (!e.includes("%")) return e;
-        let t = "";
-        for (let i = 0; i < e.length; i++)
-            if (37 === e.charCodeAt(i) && i < e.length - 2) {
-                const n = e.substring(i, i + 3);
-                ul.has(n) ? t += ul.get(n) : t += n, i += 2
-            } else t += e.charAt(i);
-        return t
+        if (t) return decodeURIComponent(e);
+        let i = "";
+        for (let t = 0; t < e.length; t++)
+            if (37 === e.charCodeAt(t) && t < e.length - 2) {
+                const n = e.substring(t, t + 3);
+                rl.has(n) ? i += rl.get(n) : i += n, t += 2
+            } else i += e.charAt(t);
+        return i
     }
-    class pl {
+    class ol {
         constructor(e) {
             this.message = e
         }
     }
 
-    function gl(e, t) {
+    function al(e, t) {
         if (e.length < 3) return;
         t && t.gffTags;
         const i = e[0],
             n = parseInt(e[1]),
             r = e.length > 2 ? parseInt(e[2]) : n + 1;
-        if (isNaN(n) || isNaN(r)) return new pl("Unparsable bed record.");
-        const s = new El({
+        if (isNaN(n) || isNaN(r)) return new ol("Unparsable bed record.");
+        const s = new vl({
             chr: i,
             start: n,
             end: r,
             score: 1e3
         });
         try {
             if (e.length > 3) {
                 if (e[3].indexOf(";") > 0 && e[3].indexOf("=") > 0) {
-                    const i = cl(e[3], "=");
+                    const i = il(e[3], "=", !0);
                     s.attributes = {};
                     for (let e of i) s.attributes[e[0]] = e[1], null != t.nameField && e[0] === t.nameField && (s.name = e[1])
                 }
                 s.name || (s.name = "." === e[3] ? "" : e[3])
             }
             if (e.length > 4 && (s.score = "." === e[4] ? 0 : Number(e[4]), isNaN(s.score))) return s;
             if (e.length > 5 && (s.strand = e[5], "." !== s.strand && "+" !== s.strand && "-" !== s.strand)) return s;
             if (e.length > 6 && (s.cdStart = parseInt(e[6]), isNaN(s.cdStart))) return s;
             if (e.length > 7 && (s.cdEnd = parseInt(e[7]), isNaN(s.cdEnd))) return s;
-            if (e.length > 8 && "." !== e[8] && "0" !== e[8] && (s.color = js.createColorString(e[8])), e.length > 11) {
-                const t = _l(e[9], e[10], e[11]);
-                t.length > 0 && (xl(t, s.cdStart, s.cdEnd), s.exons = t)
+            if (e.length > 8 && "." !== e[8] && "0" !== e[8] && (s.color = Ds.createColorString(e[8])), e.length > 11) {
+                const t = parseInt(e[9]);
+                if (t > 1e3) return s;
+                const i = e[10].replace(/,$/, "").split(","),
+                    r = e[11].replace(/,$/, "").split(",");
+                if (i.length !== r.length || t !== i.length) return s;
+                const o = [];
+                for (let e = 0; e < t; e++) {
+                    const t = n + parseInt(r[e]),
+                        s = t + parseInt(i[e]);
+                    o.push({
+                        start: t,
+                        end: s
+                    })
+                }
+                o.length > 0 && (pl(o, s.cdStart, s.cdEnd), s.exons = o)
             }
             if (t) {
                 let i = t.thicknessColumn,
                     n = t.colorColumn;
-                n && n < e.length && (s.color = js.createColorString(e[n])), i && i < e.length && (s.thickness = e[i])
+                n && n < e.length && (s.color = Ds.createColorString(e[n])), i && i < e.length && (s.thickness = e[i])
             }
         } catch (e) {}
         return s
     }
 
-    function ml(e, t) {
+    function ll(e, t) {
         if (e.length <= 15) return;
         return {
             swScore: Number.parseInt(e[1]),
             milliDiv: Number.parseInt(e[2]),
             milliDel: Number.parseInt(e[3]),
             milliIns: Number.parseInt(e[4]),
             chr: e[5],
@@ -8696,72 +8729,72 @@
             repFamily: e[12],
             repStart: Number.parseInt(e[13]),
             repEnd: Number.parseInt(e[14]),
             repLeft: Number.parseInt(e[15])
         }
     }
 
-    function bl(e, t) {
+    function hl(e, t) {
         var i = void 0 === t.shift ? 0 : 1;
         if (e.length <= 9 + i) return;
         const n = parseInt(e[5 + i]),
             r = parseInt(e[6 + i]);
         var s = {
             name: e[0 + i],
             chr: e[1 + i],
             strand: e[2 + i],
             start: parseInt(e[3 + i]),
             end: parseInt(e[4 + i]),
             cdStart: n,
             cdEnd: r,
             id: e[0 + i]
         };
-        const o = _l(parseInt(e[7 + i]), e[8 + i], e[9 + i]);
-        return xl(o, n, r), s.exons = o, s
+        const o = fl(parseInt(e[7 + i]), e[8 + i], e[9 + i]);
+        return pl(o, n, r), s.exons = o, s
     }
 
-    function wl(e, t) {
+    function cl(e, t) {
         var i = void 0 === t.shift ? 0 : 1;
         if (e.length <= 11 + i) return;
         const n = parseInt(e[5 + i]),
             r = parseInt(e[6 + i]),
             s = {
                 name: e[11 + i],
                 chr: e[1 + i],
                 strand: e[2 + i],
                 start: parseInt(e[3 + i]),
                 end: parseInt(e[4 + i]),
                 cdStart: n,
                 cdEnd: r,
                 id: e[0 + i]
             },
-            o = _l(parseInt(e[7 + i]), e[8 + i], e[9 + i]);
-        return xl(o, n, r), s.exons = o, s
+            o = fl(parseInt(e[7 + i]), e[8 + i], e[9 + i]);
+        return pl(o, n, r), s.exons = o, s
     }
 
-    function vl(e, t) {
+    function dl(e, t) {
         var i = void 0 === t.shift ? 0 : 1;
         if (e.length <= 10 + i) return;
         const n = parseInt(e[6 + i]),
             r = parseInt(e[7 + i]);
         var s = {
             name: e[0 + i],
             id: e[1 + i],
             chr: e[2 + i],
             strand: e[3 + i],
             start: parseInt(e[4 + i]),
             end: parseInt(e[5 + i]),
             cdStart: n,
             cdEnd: r
         };
-        const o = _l(parseInt(e[8 + i]), e[9 + i], e[10 + i]);
-        return xl(o, n, r), s.exons = o, s
+        const o = fl(parseInt(e[8 + i]), e[9 + i], e[10 + i]);
+        return pl(o, n, r), s.exons = o, s
     }
 
-    function yl(e, t) {
+    function ul(e, t) {
         if (e.length < 21) return;
         const i = e[13],
             n = parseInt(e[15]),
             r = parseInt(e[16]),
             s = e[8].charAt(0),
             o = parseInt(e[17]),
             a = [],
@@ -8771,25 +8804,25 @@
             const t = parseInt(l[e]),
                 i = t + parseInt(h[e]);
             a.push({
                 start: t,
                 end: i
             })
         }
-        return new Tl({
+        return new yl({
             chr: i,
             start: n,
             end: r,
             strand: s,
             exons: a,
             tokens: e
         })
     }
 
-    function _l(e, t, i) {
+    function fl(e, t, i) {
         const n = parseInt(e),
             r = t.replace(/,$/, "").split(","),
             s = i.replace(/,$/, "").split(","),
             o = [];
         for (let e = 0; e < n; e++) {
             const t = parseInt(r[e]),
                 i = parseInt(s[e]);
@@ -8797,53 +8830,53 @@
                 start: t,
                 end: i
             })
         }
         return o
     }
 
-    function xl(e, t, i) {
+    function pl(e, t, i) {
         for (let n of e) {
             const e = n.end,
                 r = n.start;
             e < t || r > i ? n.utr = !0 : (t >= r && t <= e && (n.cdStart = t), i >= r && i <= e && (n.cdEnd = i))
         }
     }
 
-    function kl(e, t) {
+    function gl(e, t) {
         var i, n, r, s, o, a, l;
         if (!(e.length < 9)) return i = e[0], n = parseInt(e[1]), r = parseInt(e[2]), o = e[3], a = Number(e[4]), s = e[5].trim(), l = Number(e[6]), 0 === a && (a = l), {
             chr: i,
             start: n,
             end: r,
             name: o,
             score: a,
             strand: s,
             signal: l,
             pValue: Number(e[7]),
             qValue: Number(e[8])
         }
     }
 
-    function Cl(e, t) {
+    function ml(e, t) {
         if (e.length <= 3) return;
         const i = {
             chr: e[0],
             start: parseInt(e[1]),
             end: parseInt(e[2]),
             value: Number(e[3])
         };
         if (t) {
             let n = t.colorColumn;
-            n && n < e.length && (i.color = js.createColorString(e[n]))
+            n && n < e.length && (i.color = Ds.createColorString(e[n]))
         }
         return i
     }
 
-    function Sl(e, t) {
+    function bl(e, t) {
         const i = t.wig;
         if (i && "fixedStep" === i.format) {
             const t = i.index * i.step + i.start,
                 n = t + i.span,
                 r = Number(e[0]);
             return ++i.index, isNaN(r) ? null : {
                 chr: i.chrom,
@@ -8860,40 +8893,40 @@
             return isNaN(r) ? null : {
                 chr: i.chrom,
                 start: t,
                 end: n,
                 value: r
             }
         }
-        return Cl(e)
+        return ml(e)
     }
 
-    function Al(e, t) {
+    function wl(e, t) {
         if (e.length < 6) return;
         const i = ["bin", "chr", "start", "end", "name", "score", "strand", "refNCBI", "refUCSC", "observed", "molType", "class", "valid", "avHet", "avHetSE", "func", "locType", "weight", "exceptions", "submitterCount", "submitters", "alleleFreqCount", "alleles", "alleleNs", "alleleFreqs", "bitfields"],
             n = {
                 chr: e[1],
                 start: Number.parseInt(e[2]),
                 end: Number.parseInt(e[3]),
                 name: e[4],
                 score: Number.parseInt(e[5])
             },
             r = Math.min(e.length, i.length);
         for (let t = 6; t < r; t++) n[i[t]] = e[t];
         return n
     }
-    class El {
+    class vl {
         constructor(e) {
             Object.assign(this, e)
         }
         getAttributeValue(e) {
             return this.hasOwnProperty(e) ? this[e] : this.attributes ? this.attributes[e] : void 0
         }
     }
-    class Tl {
+    class yl {
         constructor(e) {
             Object.assign(this, e)
         }
         get score() {
             const e = this.tokens,
                 t = parseInt(e[0]),
                 i = parseInt(e[2]),
@@ -8967,15 +9000,15 @@
             }, {
                 name: "T gap bases",
                 value: this.tBaseInsert
             }]
         }
     }
 
-    function Ml(e, t) {
+    function _l(e, t) {
         if (!(e.length < 7)) {
             var i = e[0],
                 n = e[1],
                 r = parseInt(e[2]),
                 s = parseInt(e[3]),
                 o = parseInt(e[4]),
                 a = parseInt(e[5]),
@@ -9003,29 +9036,29 @@
                         right: m
                     })
                 }
             return h.start = c, h.end = d, h
         }
     }
 
-    function Rl(e, t) {
+    function xl(e, t) {
         if (e.length < 7) return null;
         const i = {
             chr: e[0],
             start: parseInt(e[1]) - 1,
             end: parseInt(e[2]),
             "Strongest SNP-risk allele": e[3],
             "Disease/Phenotype": e[4],
             "P-value": e[5],
             "Odds ratio or beta": e[6]
         };
         return e.length > 6 && (i.PUBMEDID = `<a target = "blank" href = "https://www.ncbi.nlm.nih.gov/pubmed/${e[7]}">${e[7]}</a>`), i
     }
 
-    function Ll(e, t) {
+    function kl(e, t) {
         const i = t.customFormat;
         if (e.length < i.fields.length) return;
         const n = i.coords || 0,
             r = e[i.chr],
             s = parseInt(e[i.start]) - n,
             o = {
                 chr: r,
@@ -9033,42 +9066,42 @@
                 end: void 0 !== i.end ? parseInt(e[i.end]) : s + 1
             };
         return i.fields && i.fields.forEach((function(t, n) {
             n !== i.chr && n !== i.start && n !== i.end && (o[t] = e[n])
         })), o
     }
 
-    function Il(e, t) {
+    function Cl(e, t) {
         const i = t.columnNames;
         if (!i) throw Error("Sample names are not defined.   Missing column headers?");
         const n = i.length - 3,
             r = e[0],
             s = parseInt(e[1]),
             o = parseInt(e[2]),
             a = e.slice(3).map(Number);
         return a.length == n ? {
             chr: r,
             start: s,
             end: o,
             values: a
         } : void console.warn(`${r}:${s}-${o} row contains ${a.length} sample columns instead of the expected ${n} columns. Skipping...`)
     }
-    class Bl {
+    class Sl {
         constructor(e) {
             this.config = e, this.header = {}, e.nameField && (this.header.nameField = e.nameField), this.skipRows = 0, e.decode ? (this.decode = e.decode, this.delimiter = e.delimiter || "\t") : e.format && (this.header.format = e.format.toLowerCase(), this.setDecoder(this.header.format)), this.delimiter || (this.delimiter = "\t")
         }
         async parseHeader(e) {
             let t, i, n = this.header;
             for (; void 0 !== (i = await e.nextLine());)
                 if (i.startsWith("track") || i.startsWith("#track")) {
-                    let e = Nl(i);
+                    let e = Al(i);
                     Object.assign(n, e)
                 } else if (i.startsWith("browser"));
             else if (i.startsWith("#columns")) {
-                let e = Fl(i);
+                let e = El(i);
                 Object.assign(n, e)
             } else if (i.startsWith("##gff-version 3")) n.format = "gff3";
             else if (i.startsWith("#gffTags")) n.gffTags = !0;
             else {
                 if (i.startsWith("fixedStep") || i.startsWith("variableStep")) break;
                 if (i.startsWith("#")) {
                     const e = i.split(this.delimiter || "\t");
@@ -9100,118 +9133,119 @@
                 r = this.delimiter || "\t";
             let s, o = 0,
                 a = 0;
             for (; void 0 !== (s = await e.nextLine());) {
                 if (o++, o <= this.skipRows) continue;
                 if (!s || s.startsWith("track") || s.startsWith("#") || s.startsWith("browser")) continue;
                 if ("wig" === n && s.startsWith("fixedStep")) {
-                    this.header.wig = Pl(s);
+                    this.header.wig = Ml(s);
                     continue
                 }
                 if ("wig" === n && s.startsWith("variableStep")) {
-                    this.header.wig = Ol(s);
+                    this.header.wig = Tl(s);
                     continue
                 }
                 const e = s.split(r);
                 if (e.length < 1) continue;
                 const l = i(e, this.header);
-                l instanceof pl ? (a++, a > 0 && console.error(`Error parsing line '${s}': ${l.message}`)) : l && t.push(l)
+                l instanceof ol ? (a++, a > 0 && console.error(`Error parsing line '${s}': ${l.message}`)) : l && t.push(l)
             }
-            return i === $o && function(e) {
+            return i === Do && function(e) {
                 if (0 == e.length) return;
                 const t = e[0];
                 if (void 0 === t.score && void 0 !== t.name) {
                     for (let t of e)
-                        if (!Oo(t.name) && "." !== t.name) return;
+                        if (!("number" == typeof(i = t.name) ? i - i == 0 : "string" == typeof i && "" !== i.trim() && (Number.isFinite ? Number.isFinite(+i) : isFinite(+i))) && "." !== t.name) return;
                     for (let t of e) t.score = Number(t.name), delete t.name
                 }
-                const i = e.filter((e => e.chr1 !== e.chr2));
-                for (let t of i) {
+                var i;
+                const n = e.filter((e => e.chr1 !== e.chr2));
+                for (let t of n) {
                     const i = Object.assign({}, t);
                     i.dup = !0, e.push(i), t.chr = t.chr1, t.start = t.start1, t.end = t.end1, i.chr = i.chr2, i.start = i.start2, i.end = i.end2
                 }
             }(t), t
         }
         setDecoder(e) {
             switch (e) {
                 case "narrowpeak":
                 case "broadpeak":
                 case "regionpeak":
                 case "peaks":
-                    this.decode = kl, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = gl, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "bedgraph":
-                    this.decode = Cl, this.delimiter = /\s+/;
+                    this.decode = ml, this.delimiter = /\s+/;
                     break;
                 case "wig":
-                    this.decode = Sl, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = bl, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "gff3":
                 case "gff":
-                    this.decode = ll, this.delimiter = "\t";
+                    this.decode = el, this.delimiter = "\t";
                     break;
                 case "gtf":
-                    this.decode = hl, this.delimiter = "\t";
+                    this.decode = tl, this.delimiter = "\t";
                     break;
                 case "fusionjuncspan":
-                    this.decode = Ml, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = _l, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "gtexgwas":
-                    this.skipRows = 1, this.decode = Rl, this.delimiter = "\t";
+                    this.skipRows = 1, this.decode = xl, this.delimiter = "\t";
                     break;
                 case "refflat":
-                    this.decode = vl, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = dl, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "genepred":
-                    this.decode = bl, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = hl, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "genepredext":
-                    this.decode = wl, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = cl, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "ensgene":
-                    this.decode = bl, this.header.shift = 1, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = hl, this.header.shift = 1, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "refgene":
-                    this.decode = wl, this.delimiter = this.config.delimiter || /\s+/, this.header.shift = 1;
+                    this.decode = cl, this.delimiter = this.config.delimiter || /\s+/, this.header.shift = 1;
                     break;
                 case "bed":
-                    this.decode = gl, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = al, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "bedpe":
                 case "hiccups":
-                    this.decode = $o, this.delimiter = this.config.delimiter || "\t";
+                    this.decode = Do, this.delimiter = this.config.delimiter || "\t";
                     break;
                 case "bedpe-domain":
-                    this.decode = Wo, this.headerLine = !0, this.delimiter = this.config.delimiter || "\t";
+                    this.decode = zo, this.headerLine = !0, this.delimiter = this.config.delimiter || "\t";
                     break;
                 case "bedpe-loop":
-                    this.decode = $o, this.delimiter = this.config.delimiter || "\t", this.header = {
+                    this.decode = Do, this.delimiter = this.config.delimiter || "\t", this.header = {
                         colorColumn: 7
                     };
                     break;
                 case "interact":
-                    this.decode = Wa, this.delimiter = this.config.delimiter || /\s+/;
+                    this.decode = Da, this.delimiter = this.config.delimiter || /\s+/;
                     break;
                 case "snp":
-                    this.decode = Al, this.delimiter = "\t";
+                    this.decode = wl, this.delimiter = "\t";
                     break;
                 case "rmsk":
-                    this.decode = ml, this.delimiter = "\t";
+                    this.decode = ll, this.delimiter = "\t";
                     break;
                 case "gcnv":
-                    this.decode = Il, this.delimiter = "\t";
+                    this.decode = Cl, this.delimiter = "\t";
                     break;
                 default:
-                    const t = Qo(e);
-                    void 0 !== t ? (this.decode = Ll, this.header.customFormat = t, this.delimiter = t.delimiter || "\t") : (this.decode = gl, this.delimiter = this.config.delimiter || /\s+/)
+                    const t = Uo(e);
+                    void 0 !== t ? (this.decode = kl, this.header.customFormat = t, this.delimiter = t.delimiter || "\t") : (this.decode = al, this.delimiter = this.config.delimiter || /\s+/)
             }
         }
     }
 
-    function Nl(e) {
+    function Al(e) {
         const t = {},
             i = e.split(/(?:")([^"]+)(?:")|([^\s"]+)(?=\s+|$)/g);
         let n;
         const r = [];
         for (let e of i) e && 0 !== e.trim().length && (e.endsWith("=") ? n = e : n ? (r.push(n + e), n = void 0) : r.push(e));
         for (let e of r) {
             if (!e) return;
@@ -9224,53 +9258,66 @@
                     Array.isArray(n) ? n.push(i) : t[e] = [n, i]
                 } else t[e] = i
             }
         }
         return "interact" == t.type ? t.format = "interact" : "gcnv" === t.type && (t.format = "gcnv"), t
     }
 
-    function Fl(e) {
+    function El(e) {
         let t = {},
             i = e.split(/\s+/);
         if (2 === i.length) {
             i[1].split(";").forEach((function(e) {
                 let i = e.split("=");
                 "color" === i[0] ? t.colorColumn = Number.parseInt(i[1]) - 1 : "thickness" === i[0] && (t.thicknessColumn = Number.parseInt(i[1]) - 1)
             }))
         }
         return t
     }
 
-    function Pl(e) {
+    function Ml(e) {
         const t = e.split(/\s+/);
         return {
             format: "fixedStep",
             chrom: t[1].split("=")[1],
             start: parseInt(t[2].split("=")[1], 10) - 1,
             step: parseInt(t[3].split("=")[1], 10),
             span: t.length > 4 ? parseInt(t[4].split("=")[1], 10) : 1,
             index: 0
         }
     }
 
-    function Ol(e) {
+    function Tl(e) {
         const t = e.split(/\s+/);
         return {
             format: "variableStep",
             chrom: t[1].split("=")[1],
             span: t.length > 2 ? parseInt(t[2].split("=")[1], 10) : 1
         }
     }
-    const Dl = e => Qt(e) && e.indexOf(",") > 0 && !e.startsWith("rgb(") && !e.startsWith("rgba(") ? `rgb(${e})` : e;
-    class zl {
+    class Rl {
+        static defaults = {
+            height: 50,
+            color: "rgb(0, 0, 150)",
+            altColor: "rgb(0, 0, 150)",
+            autoHeight: !1,
+            visibilityWindow: void 0,
+            supportHiDPI: !0
+        };
         constructor(e, t) {
             this.browser = t, this.init(e)
         }
         init(e) {
-            e.displayMode && (e.displayMode = e.displayMode.toUpperCase()), this.config = e, this.url = e.url, this.type = e.type, this.supportHiDPI = void 0 === e.supportHiDPI || e.supportHiDPI, e.name || e.label ? this.name = e.name || e.label : ti(e.url) ? this.name = e.url.name : Qt(e.url) && !e.url.startsWith("data:") && (this.name = ei(e.url)), this.id = void 0 === this.config.id ? this.name : this.config.id, this.order = e.order, e.color && (this.color = Dl(e.color)), e.altColor && (this.altColor = Dl(e.altColor)), "civic-ws" === e.sourceType ? this.defaultColor = "rgb(155,20,20)" : this.defaultColor = "rgb(0,0,150)", this.autoscaleGroup = e.autoscaleGroup, this.removable = void 0 === e.removable || e.removable, this.height = e.height || 100, this.autoHeight = e.autoHeight, this.minHeight = e.minHeight || Math.min(25, this.height), this.maxHeight = e.maxHeight || Math.max(1e3, this.height), this.visibilityWindow = e.visibilityWindow, e.onclick && (this.onclick = e.onclick, e.onclick = void 0), e.description && ("function" == typeof e.description ? this.description = e.description : this.description = () => e.description), e.hoverTextFields ? this.hoverText = Hl.bind(this) : "function" == typeof this.config.hoverText && (this.hoverText = this.config.hoverText)
+            this.config = e, e.displayMode && (e.displayMode = e.displayMode.toUpperCase());
+            const t = Object.assign({}, Rl.defaults);
+            if (this.constructor.defaults)
+                for (let e of Object.keys(this.constructor.defaults)) t[e] = this.constructor.defaults[e];
+            for (let n of Object.keys(t)) this[n] = e.hasOwnProperty(n) ? e[n] : t[n], "color" !== n && "altColor" !== n || (this[n] = Qt(i = this[n]) && i.indexOf(",") > 0 && !i.startsWith("rgb(") && !i.startsWith("rgba(") ? `rgb(${i})` : i);
+            var i;
+            e.name || e.label ? this.name = e.name || e.label : ti(e.url) ? this.name = e.url.name : Qt(e.url) && !e.url.startsWith("data:") && (this.name = ei(e.url)), this.url = e.url, this.config.type && (this.type = this.config.type), this.id = void 0 === this.config.id ? this.name : this.config.id, this.order = e.order, this.autoscaleGroup = e.autoscaleGroup, this.removable = void 0 === e.removable || e.removable, this.minHeight = e.minHeight || Math.min(25, this.height), this.maxHeight = e.maxHeight || Math.max(1e3, this.height), e.onclick && (this.onclick = e.onclick, e.onclick = void 0), e.description && ("function" == typeof e.description ? this.description = e.description : this.description = () => e.description), e.hoverTextFields ? this.hoverText = Ll.bind(this) : "function" == typeof this.config.hoverText && (this.hoverText = this.config.hoverText)
         }
         get name() {
             return this._name
         }
         set name(e) {
             this._name = e, this.trackView && this.trackView.setTrackLabelName(e)
         }
@@ -9281,31 +9328,26 @@
             this.trackView && this.trackView.clearCachedFeatures()
         }
         updateViews() {
             this.trackView && this.trackView.updateViews()
         }
         getState() {
             const e = {};
-            for (let t of Object.keys(this.config)) t.startsWith("_") || "function" == typeof this.config[t] || void 0 === this.config[t] || (e[t] = this.config[t]);
+            for (let i of Object.keys(this.config)) i.startsWith("_") || (void 0 === (t = this.config[i]) || "function" == typeof t || t instanceof File || t instanceof Promise) || (e[i] = this.config[i]);
+            var t;
             for (let t of Object.keys(e)) {
                 if (t.startsWith("_")) continue;
                 const i = this[t];
-                i && (Bo(i) || "boolean" == typeof i || "metadata" === t) && (e[t] = i)
-            }
-            this.color && (e.color = this.color), this.altColor && (e.altColor = this.altColor), !this.autoscale && this.dataRange && (e.min = this.dataRange.min, e.max = this.dataRange.max);
-            for (let t of Object.keys(e)) {
-                const i = e[t];
-                if ("function" == typeof i) throw Error(`Property '${t}' of track '${this.name} is a function. Functions cannot be saved in sessions.`);
-                if (i instanceof File) {
-                    const e = `Track ${this.name} is a local file. Sessions cannot be saved with local file references.`;
-                    throw Error(e)
-                }
-                if (i instanceof Promise) throw Error(`Property '${t}' of track '${this.name} is a Promise. Promises cannot be saved in sessions.`)
+                i && (Eo(i) || "boolean" == typeof i || "metadata" === t) && (e[t] = i)
             }
-            return e
+            const i = Rl.defaults;
+            if (this.constructor.defaults)
+                for (let e of Object.keys(this.constructor.defaults)) i[e] = this.constructor.defaults[e];
+            for (let t of Object.keys(i)) void 0 !== this[t] && i[t] !== this[t] && (e[t] = this[t]);
+            return !this.autoscale && this.dataRange && (e.min = this.dataRange.min, e.max = this.dataRange.max), e
         }
         get supportsWholeGenome() {
             return !0 === this.config.supportsWholeGenome
         }
         hasSamples() {
             return !1
         }
@@ -9351,25 +9393,25 @@
                 case "viewlimits":
                     if (!this.config.autoscale) {
                         i = e[n].split(":");
                         let r, s = 0;
                         1 == i.length ? r = Number(i[0]) : 2 == i.length && (s = Number(i[0]), r = Number(i[1])), t.autoscale = !1, t.dataRange = {
                             min: s,
                             max: r
-                        }
+                        }, this.viewLimitMin = s, this.viewLimitMax = r
                     }
                 case "name":
                     t[n] = e[n];
                     break;
                 case "url":
                     t.infoURL = e[n];
                     break;
                 case "type":
                     const r = e[n];
-                    Vl.has(r) ? t[n] = Vl.get(r) : t[n] = r;
+                    Il.has(r) ? t[n] = Il.get(r) : t[n] = r;
                     break;
                 case "graphtype":
                     t.graphType = e[n];
                     break;
                 default:
                     t[n] = e[n]
             }
@@ -9385,22 +9427,22 @@
                 }
         }
         clickedFeatures(e) {
             const t = e.viewport.cachedFeatures;
             if (!t || !Array.isArray(t) || 0 === t.length) return [];
             const i = e.genomicLocation,
                 n = e.referenceFrame.bpPerPixel > .2 ? 3 * e.referenceFrame.bpPerPixel : .2;
-            return xo(t, i - n, i + n)
+            return mo(t, i - n, i + n)
         }
         extractPopupData(e, t) {
             const i = new Set(["row", "color", "chr", "start", "end", "cdStart", "cdEnd", "strand", "alpha"]),
                 n = [];
             let r, s;
             for (let t in e)
-                if (e.hasOwnProperty(t) && !i.has(t) && Bo(e[t])) {
+                if (e.hasOwnProperty(t) && !i.has(t) && Eo(e[t])) {
                     let i = e[t];
                     n.push({
                         name: Jt(t),
                         value: i
                     }), "alleles" === t ? r = e[t] : "alleleFreqs" === t && (s = e[t])
                 } if (r && s) {
                 r.endsWith(",") && (r = r.substr(0, r.length - 1)), s.endsWith(",") && (s = s.substr(0, s.length - 1));
@@ -9417,15 +9459,15 @@
                     }));
                     let s = r[r.length - 1].a;
                     if (1 === s.length)
                         for (let i = r.length - 2; i >= 0; i--) {
                             let o = r[i].a;
                             if (1 === o.length) {
                                 t || (t = this.getGenomeId());
-                                const i = zl.getCravatLink(e.chr, e.start + 1, s, o, t);
+                                const i = Rl.getCravatLink(e.chr, e.start + 1, s, o, t);
                                 console.log(i), i && (n.push("<hr/>"), n.push({
                                     html: i
                                 }), n.push("<hr/>"))
                             }
                         }
                 }
             }
@@ -9449,35 +9491,35 @@
                         t += e(i, this.config.metadata[i])
                     }
                 for (let i of Object.keys(this.config)) {
                     if (i.startsWith("_")) continue;
                     let n = i.substr(0, 1);
                     if (n !== n.toLowerCase()) {
                         const n = this.config[i];
-                        n && Bo(n) && (t += e(i, n))
+                        n && Eo(n) && (t += e(i, n))
                     }
                 }
             }
             return t += "</div>", t
         }
         getColorForFeature(e) {
-            return "function" == typeof this.color ? this.color(feature) : this.color || "rgb(150,150,150)"
+            return "function" == typeof this.color ? this.color(feature) : this.color
         }
         dispose() {
             this.disposed = !0;
             for (let e of Object.keys(this)) this[e] = void 0
         }
         static getCravatLink(e, t, i, n, r) {
             if ("hg38" === r || "GRCh38" === r) {
                 return `<a target="_blank" href="https://run.opencravat.org/result/nocache/variant.html?chrom=${e.startsWith("chr")?e:"chr"+e}&pos=${t}&ref_base=${i}&alt_base=${n}"><b>Cravat ${i}->${n}</b></a>`
             }
         }
     }
 
-    function Hl(e) {
+    function Ll(e) {
         if (!this.hoverTextFields) return;
         const t = this.clickedFeatures(e);
         if (t && t.length > 0) {
             let e = "";
             for (let i = 0; i < t.length; i++) {
                 if (10 === i) {
                     e += "; ...";
@@ -9487,21 +9529,21 @@
                 const n = t[i]._f || t[i];
                 e.length > 0 && (e += "\n"), e = "";
                 for (let t of this.hoverTextFields) e.length > 0 && (e += "\n"), n.hasOwnProperty(t) ? e += n[t] : "function" == typeof n.getAttribute && (e += n.getAttribute(t))
             }
             return e
         }
     }
-    const Vl = new Map([
+    const Il = new Map([
         ["wiggle_0", "wig"],
         ["bed", "bed"],
         ["bigBed", "bigBed"],
         ["bigWig", "bigWig"]
     ]);
-    class Ul {
+    class Bl {
         constructor(e) {
             switch (this.type = e || "seg", this.type) {
                 case "mut":
                     this.sampleColumn = 3, this.chrColumn = 0, this.startColumn = 1, this.endColumn = 2, this.dataColumn = 4;
                     break;
                 case "maf":
                     this.sampleColumn = 15, this.chrColumn = 4, this.startColumn = 5, this.endColumn = 6, this.dataColumn = 8;
@@ -9527,15 +9569,15 @@
             this.header || (this.header = await this.parseHeader(e)), "seg" === this.type && (this.dataColumn = this.header.headings.length - 1), this.header.headings.length > 5 && (i = this.extractExtraColumns(this.header.headings));
             const n = this.header.headings[this.dataColumn];
             let r;
             for (; void 0 !== (r = await e.nextLine());) {
                 const e = r.split("\t"),
                     s = "seg" === this.type ? Number(e[this.dataColumn]) : e[this.dataColumn];
                 if (e.length > this.dataColumn) {
-                    const r = new ql({
+                    const r = new Fl({
                         sample: e[this.sampleColumn],
                         chr: e[this.chrColumn],
                         start: parseInt(e[this.startColumn]) - 1,
                         end: parseInt(e[this.endColumn]),
                         value: s,
                         valueColumnName: n
                     });
@@ -9553,15 +9595,15 @@
         }
         extractExtraColumns(e) {
             const t = [];
             for (let i = 0; i < e.length; i++) i !== this.chrColumn && i !== this.startColumn && i !== this.endColumn && i !== this.sampleColumn && t.push(e[i]);
             return t
         }
     }
-    class ql {
+    class Fl {
         constructor({
             sample: e,
             chr: t,
             start: i,
             end: n,
             value: r,
             valueColumnName: s
@@ -9606,30 +9648,30 @@
                 });
             return r
         }
         extractCravatLink(e) {
             let t, i;
             if (this.attributeNames && this.attributeNames.length > 0)
                 for (let n = 0; n < this.attributeNames.length; n++)
-                    if (t || "Reference_Allele" !== this.attributeNames[n] || (t = this.attributeValues[n]), !i && this.attributeNames[n].startsWith("Tumor_Seq_Allele") && this.attributeValues[n] !== t && (i = this.attributeValues[n]), t && i) return zl.getCravatLink(this.chr, this.start + 1, t, i, e)
+                    if (t || "Reference_Allele" !== this.attributeNames[n] || (t = this.attributeValues[n]), !i && this.attributeNames[n].startsWith("Tumor_Seq_Allele") && this.attributeValues[n] !== t && (i = this.attributeValues[n]), t && i) return Rl.getCravatLink(this.chr, this.start + 1, t, i, e)
         }
     }
 
-    function jl(e) {
-        const t = new $l;
+    function Nl(e) {
+        const t = new Ol;
         t.chr = e[0], t.pos = parseInt(e[1]), t.names = e[2], t.referenceBases = e[3], t.alternateBases = e[4], t.quality = e[5], t.filter = e[6], t.info = {};
         const i = e[7];
         if (i)
             for (let e of i.split(";")) {
                 var n = e.split("=");
                 t.info[n[0]] = n[1]
             }
         return t.init(), t
     }
-    class $l {
+    class Ol {
         init() {
             const e = this.referenceBases,
                 t = this.alternateBases;
             if (this.info && (this.info.VT ? this.type = this.info.VT : this.info.SVTYPE ? this.type = "SV" : this.info.PERIOD && (this.type = "STR")), void 0 === this.type && (this.type = function(e, t) {
                     const i = e.length;
                     if (void 0 === t) return "UNKNOWN";
                     if (0 === t.trim().length || "<NON_REF>" === t || "<*>" === t || "." === t) return "NONVARIANT"; {
@@ -9643,15 +9685,15 @@
                     }
                 }(e, t)), "NONVARIANT" === this.type && (this.heterozygosity = 0), this.info.END) this.start = this.pos - 1, this.info.CHR2 && this.info.CHR2 !== this.chr ? this.end = this.start + 1 : this.end = Number.parseInt(this.info.END);
             else if ("NONVARIANT" === this.type) this.start = this.pos - 1, this.end = this.start + e.length;
             else {
                 const i = t.split(",").filter((e => e.length > 0));
                 this.alleles = [], this.start = void 0, this.end = void 0;
                 for (let t of i)
-                    if (this.alleles.push(t), "SV" !== this.type && Gl(t)) {
+                    if (this.alleles.push(t), "SV" !== this.type && Dl(t)) {
                         let i = t.length,
                             n = e.length;
                         const r = Math.min(i, n);
                         let s = 0;
                         for (; s < r && e.charCodeAt(s) === t.charCodeAt(s);) s++, i--, n--;
                         for (; i > 0 && n > 0;) {
                             const r = s + i - 1,
@@ -9701,15 +9743,15 @@
                 }];
             if ("SNP" === this.type) {
                 let e = this.referenceBases;
                 if (1 === e.length) {
                     let i = this.alternateBases.split(",");
                     for (let n of i)
                         if (1 === n.length) {
-                            let i = zl.getCravatLink(this.chr, this.pos, e, n, t);
+                            let i = Rl.getCravatLink(this.chr, this.pos, e, n, t);
                             i && (r.push("<hr/>"), r.push({
                                 html: i
                             }))
                         }
                 }
             }
             if (this.hasOwnProperty("heterozygosity") && r.push({
@@ -9717,38 +9759,38 @@
                     value: this.heterozygosity
                 }), this.info) {
                 r.push({
                     html: '<hr style="border-top: dotted 1px;border-color: #c9c3ba" />'
                 });
                 for (let e of Object.keys(this.info)) r.push({
                     name: e,
-                    value: Zl(decodeURIComponent(this.info[e]))
+                    value: zl(decodeURIComponent(this.info[e]))
                 })
             }
             return r
         }
         getInfo(e) {
             return this.info ? this.info[e] : void 0
         }
         isRefBlock() {
             return "NONVARIANT" === this.type
         }
     }
-    const Wl = new Set(["A", "C", "T", "G"].map((e => e.charCodeAt(0))));
+    const Pl = new Set(["A", "C", "T", "G"].map((e => e.charCodeAt(0))));
 
-    function Gl(e) {
+    function Dl(e) {
         for (let t = 0; t < e.length; t++)
-            if (!Wl.has(e.charCodeAt(t))) return !1;
+            if (!Pl.has(e.charCodeAt(t))) return !1;
         return !0
     }
 
-    function Zl(e, t) {
+    function zl(e, t) {
         return void 0 === t && (t = ","), Array.isArray(e) ? e.join(t) : e
     }
-    class Ql {
+    class Hl {
         construtor() {}
         async parseHeader(e, t) {
             const i = {};
             i.chrAliasTable = new Map;
             let n = await e.nextLine();
             if (!n.startsWith("##fileformat")) throw new Error("Invalid VCF file: missing fileformat line");
             for (i.version = n.substr(13); void 0 !== (n = await e.nextLine()) && n.startsWith("#");) {
@@ -9795,17 +9837,17 @@
                 i = this.header.callSets,
                 n = 8 + (i ? i.length + 1 : 0);
             let r;
             for (; void 0 !== (r = await e.nextLine());)
                 if (r && !r.startsWith("#")) {
                     const e = r.split("\t");
                     if (e.length === n) {
-                        const n = jl(e);
+                        const n = Nl(e);
                         if (n.header = this.header, t.push(n), e.length > 9) {
-                            const t = Xl(e[8].split(":"));
+                            const t = Vl(e[8].split(":"));
                             n.calls = {};
                             for (let r = 9; r < e.length; r++) {
                                 const s = e[r],
                                     o = i[r - 9],
                                     a = {
                                         callSetName: o.name,
                                         info: {}
@@ -9814,40 +9856,40 @@
                                     if (i === t.genotypeIndex) a.genotype = [], e.split(/[\|\/]/).forEach((function(e) {
                                         a.genotype.push("." === e ? e : parseInt(e))
                                     }));
                                     else a.info[t.fields[i]] = e
                                 }))
                             }
                         }
-                        n.info && n.info.CHR2 && n.info.END && t.push(Yl(n))
+                        n.info && n.info.CHR2 && n.info.END && t.push(Ul(n))
                     }
                 } return t
         }
     }
 
-    function Xl(e) {
+    function Vl(e) {
         const t = {
             genotypeIndex: -1,
             fields: e
         };
         for (let i = 0; i < e.length; i++) "GT" === e[i] && (t.genotypeIndex = i);
         return t
     }
 
-    function Yl(e) {
+    function Ul(e) {
         const t = e.info.CHR2,
             i = Number.parseInt(e.info.END);
         return {
             chr: t,
             start: i - 1,
             end: i,
             _f: e
         }
     }
-    class Kl {
+    class ql {
         constructor(e) {
             if (this.config = e, e.columns) {
                 if (void 0 === e.columns.chromosome || void 0 === e.columns.position || void 0 === e.columns.value) throw Error("columns property must define chrCol, posCol, and valueCol");
                 this.posCol = e.columns.position - 1, this.chrCol = e.columns.chromosome - 1, this.valueCol = e.columns.value - 1
             } else this.posCol = 2, this.chrCol = 1, this.valueCol = 3
         }
         async parseHeader(e) {
@@ -9886,28 +9928,28 @@
             for (this.columns || this.parseHeaderLine(i); void 0 !== (n = e.nextLine());) {
                 const e = n.split(/\t/);
                 if (e.length === this.columns.length) {
                     const i = e[this.chrCol],
                         r = parseInt(e[this.posCol]) - 1,
                         s = r + 1,
                         o = Number(e[this.valueCol]);
-                    t.push(new Jl({
+                    t.push(new jl({
                         chr: i,
                         start: r,
                         end: s,
                         value: o,
                         line: n,
                         columns: this.columns
                     }))
                 }
             }
             return t
         }
     }
-    class Jl {
+    class jl {
         constructor({
             chr: e,
             start: t,
             end: i,
             value: n,
             line: r,
             columns: s
@@ -9925,45 +9967,45 @@
         }
         getAttribute(e) {
             const t = this.line.split(/\t/);
             for (let i = 0; i < this.columns.length; i++)
                 if (this.columns[i] === e) return t[i]
         }
     }
-    var eh = new RegExp("([^:]*)\\(([^)]*)\\)"),
-        th = new RegExp("([^:]*):([^(]*)\\(([^)]*)\\)");
-    class ih {
+    var $l = new RegExp("([^:]*)\\(([^)]*)\\)"),
+        Wl = new RegExp("([^:]*):([^(]*)\\(([^)]*)\\)");
+    class Gl {
         constructor(e) {
             const t = e ? e.decode : void 0;
-            this.nameField = e ? e.nameField : void 0, this.skipRows = 0, this.decode = t || lh, this.delimiter = "\t"
+            this.nameField = e ? e.nameField : void 0, this.skipRows = 0, this.decode = t || Jl, this.delimiter = "\t"
         }
         async parseHeader(e) {
             let t, i;
             for (;
                 (t = await e.nextLine()) && (t.startsWith("track") || t.startsWith("#") || t.startsWith("browser"));)
                 if (t.startsWith("track") || t.startsWith("#track")) {
-                    let e = sh(t);
+                    let e = Xl(t);
                     i ? Object.assign(i, e) : i = e
                 } else if (t.startsWith("#columns")) {
-                let e = oh(t);
+                let e = Yl(t);
                 i ? Object.assign(i, e) : i = e
             } else t.startsWith("##gff-version 3") && (this.format = "gff3", i || (i = {}), i.format = "gff3");
             return this.header = i, i
         }
         async parseFeatures(e) {
             const t = [],
                 i = this.decode,
                 n = this.delimiter || "\t";
             let r, s = 0;
             for (; void 0 !== (r = e.nextLine());) {
                 if (s++, s <= this.skipRows || r.startsWith("track") || r.startsWith("#") || r.startsWith("browser")) continue;
                 let e = o();
                 if (e.length < 1) continue;
                 if (!this.aed) {
-                    this.aed = rh(e);
+                    this.aed = Ql(e);
                     continue
                 }
                 const n = i.call(this, e, undefined);
                 n && t.push(n)
             }
             return t;
 
@@ -9974,39 +10016,39 @@
                     s += "\n", r = nextLine()
                 }
                 return i.push(s), i
             }
         }
     }
 
-    function nh(e) {
-        var t = th.exec(e);
+    function Zl(e) {
+        var t = Wl.exec(e);
         if (t) return {
             namespace: t[1],
             name: t[2],
             type: t[3]
         };
-        if (t = eh.exec(e)) return {
+        if (t = $l.exec(e)) return {
             namespace: "?",
             name: t[1],
             type: t[2]
         };
         throw new Error("Error parsing the header row of AED file - column not in ns:name(ns:type) format")
     }
 
-    function rh(e) {
+    function Ql(e) {
         var t, i, n;
         for (t = {
                 columns: [],
                 metadata: {}
-            }, i = 0; i < e.length; i++) n = nh(e[i]), t.columns.push(n);
+            }, i = 0; i < e.length; i++) n = Zl(e[i]), t.columns.push(n);
         return t
     }
 
-    function sh(e) {
+    function Xl(e) {
         const t = {},
             i = e.split(/(?:")([^"]+)(?:")|([^\s"]+)(?=\s+|$)/g);
         let n;
         const r = [];
         for (let e of i) e && 0 !== e.trim().length && (e.endsWith("=") > 0 ? n = e : n ? (r.push(n + e), n = void 0) : r.push(e));
         for (let e of r) {
             if (!e) return;
@@ -10016,65 +10058,65 @@
                     i = s[1].trim();
                 t[e] = i
             }
         }
         return t
     }
 
-    function oh(e) {
+    function Yl(e) {
         let t = {},
             i = e.split(/\s+/);
         if (2 === i.length) {
             i[1].split(";").forEach((function(e) {
                 let i = e.split("=");
                 "color" === i[0] ? t.colorColumn = Number.parseInt(i[1]) - 1 : "thickness" === i[0] && (t.thicknessColumn = Number.parseInt(i[1]) - 1)
             }))
         }
         return t
     }
 
-    function ah(e, t) {
+    function Kl(e, t) {
         var i, n, r = e.columns;
         this.aed = e, this.allColumns = t, this.chr = null, this.start = null, this.end = null, this.score = 1e3, this.strand = ".", this.cdStart = null, this.cdEnd = null, this.name = null, this.color = null;
         for (let e = 0; e < t.length; e++)
             if (i = t[e]) {
                 "aed:Integer" === (n = r[e]).type && (i = parseInt(i));
                 var s = [];
                 if (n.namespace.length > 0)
                     for (let e = 0; e < n.namespace.length; e++) s.push(n.namespace.charCodeAt(e));
-                "bio" === n.namespace.trim() ? "sequence" === n.name ? this.chr = i : "start" === n.name ? this.start = i : "end" === n.name ? this.end = i : "cdsMin" === n.name ? this.cdStart = i : "cdsMax" === n.name ? this.cdEnd = i : "strand" === n.name && (this.strand = i) : "aed" === n.namespace ? "name" === n.name && (this.name = i) : "style" === n.namespace && "color" === n.name && (this.color = js.createColorString(i))
+                "bio" === n.namespace.trim() ? "sequence" === n.name ? this.chr = i : "start" === n.name ? this.start = i : "end" === n.name ? this.end = i : "cdsMin" === n.name ? this.cdStart = i : "cdsMax" === n.name ? this.cdEnd = i : "strand" === n.name && (this.strand = i) : "aed" === n.namespace ? "name" === n.name && (this.name = i) : "style" === n.namespace && "color" === n.name && (this.color = Ds.createColorString(i))
             }
     }
 
-    function lh(e, t) {
+    function Jl(e, t) {
         var i, n, r, s, o, a, l = 0,
             h = this.aed.columns;
         if (e.length === h.length) {
             for (a = 0; a < e.length; a++) s = h[a], "" !== (r = e[a]) && l++, "name" === s.name && "aed" === s.namespace ? i = r : "value" === s.name && "aed" === s.namespace && (n = r);
-            if (2 === l && i && n) return o = nh(i), this.aed.metadata[o.namespace] || (this.aed.metadata[o.namespace] = {}), void(this.aed.metadata[o.namespace][o.name] || (this.aed.metadata[o.namespace][o.name] = {
+            if (2 === l && i && n) return o = Zl(i), this.aed.metadata[o.namespace] || (this.aed.metadata[o.namespace] = {}), void(this.aed.metadata[o.namespace][o.name] || (this.aed.metadata[o.namespace][o.name] = {
                 type: o.type,
                 value: n
             }));
-            var c = new ah(this.aed, e);
+            var c = new Kl(this.aed, e);
             if (c.chr && (c.start || 0 === c.start) && c.end) return c;
             console.log("Cannot parse feature: " + e.join(","))
         } else console.log("Corrupted AED file row: " + e.join(","))
     }
-    ah.prototype.popupData = function() {
+    Kl.prototype.popupData = function() {
         for (var e = [], t = this.aed, i = 0; i < this.allColumns.length; i++) {
             var n = this.allColumns[i],
                 r = t.columns[i].name;
             "sequence" !== r && "color" !== r && n && e.push({
                 name: r,
                 value: n
             })
         }
         return e
     };
-    class hh {
+    class eh {
         constructor(e, t) {
             this.littleEndian = void 0 === t || t, this.position = 0, this.view = e, this.length = e.byteLength
         }
         available() {
             return this.length - this.position
         }
         remLength() {
@@ -10138,18 +10180,18 @@
         skip(e) {
             return this.position += e, this.position
         }
         getVPointer() {
             var e = this.position,
                 t = this.view.getUint8(e + 1) << 8 | this.view.getUint8(e),
                 i = 4294967296 * (255 & this.view.getUint8(e + 6)) + 16777216 * (255 & this.view.getUint8(e + 5)) + 65536 * (255 & this.view.getUint8(e + 4)) + 256 * (255 & this.view.getUint8(e + 3)) + (255 & this.view.getUint8(e + 2));
-            return this.position += 8, new ch(i, t)
+            return this.position += 8, new th(i, t)
         }
     }
-    class ch {
+    class th {
         constructor(e, t) {
             this.block = e, this.offset = t
         }
         isLessThan(e) {
             return this.block < e.block || this.block === e.block && this.offset < e.offset
         }
         isGreaterThan(e) {
@@ -10159,38 +10201,37 @@
             return this.block === e.block && this.offset === e.offset
         }
         print() {
             return this.block + ":" + this.offset
         }
     }
 
-    function dh(e, t) {
+    function ih(e, t) {
         if (0 === e.length) return e;
         if (e.sort((function(e, t) {
                 const i = e.minv.block - t.minv.block;
                 return 0 !== i ? i : e.minv.offset - t.minv.offset
             })), e.length <= 1) return e;
         t && (e = e.filter((e => e.maxv.isGreaterThan(t))));
         const i = [];
         let n;
-        for (let t of e) n && uh(n, t) ? t.maxv.isGreaterThan(n.maxv) && (n.maxv = t.maxv) : (i.push(t), n = t);
+        for (let t of e) n && nh(n, t) ? t.maxv.isGreaterThan(n.maxv) && (n.maxv = t.maxv) : (i.push(t), n = t);
         return i
     }
 
-    function uh(e, t) {
-        const i = t.minv.block - e.maxv.block,
-            n = e.maxv.block - e.minv.block;
-        return i < 65e3 && n < 5e6
+    function nh(e, t) {
+        t.minv.block, e.maxv.block;
+        return e.maxv.block - e.minv.block < 5e6
     }
-    class fh {
+    class rh {
         constructor(e) {
             this.tabix = !0
         }
         parse(e, t) {
-            const i = new hh(new DataView(e)),
+            const i = new eh(new DataView(e)),
                 n = i.getInt();
             if (21582659 !== n) throw 38359875 === n ? Error("CSI version 2 is not supported.  Please enter an issue at https://github.com/igvteam/igv.js") : Error("Not a CSI index");
             this.indices = [], this.blockMin = Number.MAX_SAFE_INTEGER, this.lastBlockPosition = [], this.sequenceIndexMap = {}, this.minShift = i.getInt(), this.depth = i.getInt();
             const r = [];
             let s = 0;
             if (i.getInt() >= 28) {
                 i.getInt(), i.getInt(), i.getInt(), i.getInt(), i.getInt(), i.getInt();
@@ -10246,15 +10287,15 @@
                                     n = i[1];
                                 r.push({
                                     minv: t,
                                     maxv: n,
                                     bin: e
                                 })
                             }
-                        } return dh(r, n.loffset[e[0]])
+                        } return ih(r, n.loffset[e[0]])
             }
             return []
         }
         reg2bins(e, t) {
             (e -= 1) < 1 && (e = 1), t > 2 ** 34 && (t = 2 ** 34), t -= 1;
             let i = 0,
                 n = 0,
@@ -10267,21 +10308,21 @@
             }
             return s
         }
         bin_limit() {
             return ((1 << 3 * (this.depth + 1)) - 1) / 7
         }
     }
-    class ph {
+    class sh {
         constructor() {}
         async parse(e, t, i) {
             const n = [];
             let r = Number.MAX_SAFE_INTEGER,
                 s = 0;
-            const o = new hh(new DataView(e)),
+            const o = new eh(new DataView(e)),
                 a = o.getInt(),
                 l = {};
             if (!(21578050 === a || t && 21578324 === a)) throw new Error(indexURL + " is not a " + (t ? "tabix" : "bai") + " file"); {
                 const e = o.getInt();
                 if (t) {
                     o.getInt(), o.getInt(), o.getInt(), o.getInt(), o.getInt(), o.getInt(), o.getInt();
                     for (let t = 0; t < e; t++) {
@@ -10350,25 +10391,25 @@
                 for (let e = a; e <= l; e++) {
                     const t = n.linearIndex[e];
                     if (t) {
                         o = t;
                         break
                     }
                 }
-                return dh(r, o)
+                return ih(r, o)
             }
             return []
         }
     }
-    class gh {
+    class oh {
         constructor() {}
         async parse(e, t) {
             let i = 0;
             this.chrIndex = {}, this.lastBlockPosition = [];
-            const n = new hh(new DataView(e));
+            const n = new eh(new DataView(e));
             ! function(e) {
                 e.getInt(), e.getInt();
                 const t = e.getInt();
                 if (e.getString(), e.getLong(), e.getLong(), e.getString(), e.getInt(), t >= 3) {
                     let t = e.getInt();
                     for (; t-- > 0;) e.getString(), e.getString()
                 }
@@ -10425,85 +10466,80 @@
                             offset: 0
                         }
                     }]
                 }
             }
         }
     }
-    const mh = 21582659,
-        bh = 38359875,
-        wh = 21578050,
-        vh = 21578324,
-        yh = 1480870228;
-    async function _h(e, t, i) {
-        let n = await lo.loadArrayBuffer(e, No(t)),
+    async function ah(e, t, i) {
+        let n = await io.loadArrayBuffer(e, Mo(t)),
             r = new DataView(n);
         if (31 === r.getUint8(0) && 139 === r.getUint8(1)) {
-            n = Fs(n).buffer, r = new DataView(n)
+            n = Ts(n).buffer, r = new DataView(n)
         }
         switch (r.getInt32(0, !0)) {
-            case wh:
+            case 21578050:
                 return async function(e, t) {
-                    const i = new ph;
+                    const i = new sh;
                     return await i.parse(e, !1, t), i
                 }(n, i);
-            case vh:
+            case 21578324:
                 return async function(e, t) {
-                    const i = new ph;
+                    const i = new sh;
                     return await i.parse(e, !0, t), i
                 }(n, i);
-            case mh:
+            case 21582659:
                 return async function(e, t) {
-                    const i = new fh;
+                    const i = new rh;
                     return i.parse(e, t), i
                 }(n, i);
-            case yh:
+            case 1480870228:
                 return async function(e, t) {
-                    const i = new gh;
+                    const i = new oh;
                     return i.parse(e, t), i
                 }(n, i);
-            case bh:
+            case 38359875:
                 throw Error("CSI version 2 is not supported.");
             default:
                 throw Error(`Unrecognized index type: ${e}`)
         }
     }
 
-    function xh(e) {
-        return "string" == typeof e || e instanceof String ? new kh(e) : new Ch(e)
+    function lh(e) {
+        return "string" == typeof e || e instanceof String ? new hh(e) : new ch(e)
     }
-    class kh {
+    class hh {
         constructor(e) {
             this.data = e, this.ptr = 0
         }
         nextLine() {
             var e = this.ptr,
                 t = this.data.indexOf("\n", e),
                 i = this.data;
             if (t > 0) return this.ptr = t + 1, t > e && "\r" === i.charAt(t - 1) ? i.substring(e, t - 1) : i.substring(e, t);
             var n = i.length;
             return this.ptr = n, e >= n ? void 0 : i.substring(e)
         }
     }
-    class Ch {
+    class ch {
         constructor(e) {
             this.data = e, this.length = this.data.length, this.ptr = 0
         }
         nextLine() {
             var e, t;
             if (t = "", !(this.ptr >= this.length)) {
                 for (var i = this.ptr; i < this.length; i++)
                     if ("\r" !== (e = String.fromCharCode(this.data[i]))) {
                         if ("\n" === e) break;
                         t += e
                     } return this.ptr = i + 1, t
             }
         }
     }
-    class Sh {
+    class dh {
         constructor(e) {
             this.config = e, this.filePtr = 0, this.bufferPtr = 0, this.buffer
         }
         async nextLine() {
             let e;
             try {
                 for (;;) {
@@ -10519,39 +10555,39 @@
                     await this.readNextBlock()
                 }
             } catch (t) {
                 return console.warn(t), this.eof = !0, e
             }
         }
         async readNextBlock() {
-            const e = No(this.config, {
+            const e = Mo(this.config, {
                     range: {
                         start: this.filePtr,
                         size: 26
                     }
                 }),
-                t = Ps(await lo.loadArrayBuffer(this.config.url, e));
+                t = Rs(await io.loadArrayBuffer(this.config.url, e));
             if (0 === t) this.eof = !0, this.buffer = void 0;
             else {
-                const e = No(this.config, {
+                const e = Mo(this.config, {
                         range: {
                             start: this.filePtr,
                             size: t
                         }
                     }),
-                    i = await lo.loadArrayBuffer(this.config.url, e);
-                i.byteLength < t && (this.eof = !0), this.buffer = Fs(i), 0 == this.buffer.byteLength && (this.eof = !0), this.bufferPtr = 0, this.filePtr += i.byteLength
+                    i = await io.loadArrayBuffer(this.config.url, e);
+                i.byteLength < t && (this.eof = !0), this.buffer = Ts(i), 0 == this.buffer.byteLength && (this.eof = !0), this.bufferPtr = 0, this.filePtr += i.byteLength
             }
         }
     }
-    const Ah = e => {
+    const uh = e => {
         const t = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
         return 1 + (t[17] << 8 | t[16])
     };
-    class Eh {
+    class fh {
         constructor(e) {
             this.config = e, this.cacheBlocks = 0 != e.cacheBlocks, this.cache = void 0
         }
         async getData(e, t) {
             const i = e.block,
                 n = t.block,
                 r = 0 === t.offset,
@@ -10564,18 +10600,17 @@
             for (const e of s) a.set(e, l), l += e.byteLength;
             return a
         }
         async getInflatedBlocks(e, t, i) {
             if (this.cacheBlocks) {
                 const n = this.cache;
                 if (n && n.startBlock <= e && (n.endBlock >= t || i && n.nextEndBlock === t)) {
-                    console.log("Complete overlap");
                     const i = e - n.startBlock,
                         r = t - n.startBlock;
-                    return Mh(n.buffer, i, r)
+                    return gh(n.buffer, i, r)
                 } {
                     let r;
                     if (!n || n.startBlock > t || n.endBlock < e) r = await this.loadBLockData(e, t, {
                         skipEnd: i
                     });
                     else {
                         const s = [];
@@ -10588,15 +10623,15 @@
                         let o;
                         if (e <= n.startBlock && t >= n.endBlock) o = n.buffer;
                         else {
                             const i = Math.max(0, e - n.startBlock);
                             let r;
                             if (t >= n.endBlock) r = n.buffer.byteLength;
                             else {
-                                const e = Th(n.buffer);
+                                const e = ph(n.buffer);
                                 for (let i = 0; i < e.length - 1; i++)
                                     if (n.startBlock + e[i] === t) {
                                         r = e[i + 1];
                                         break
                                     }
                             }
                             o = n.buffer.slice(i, r)
@@ -10616,100 +10651,100 @@
                             let n = 0;
                             for (const t of e) i.set(new Uint8Array(t), n), n += t.byteLength;
                             return i.buffer
                         }(s)
                     }
                     let s = t;
                     if (i) {
-                        const e = Th(r);
+                        const e = ph(r);
                         t = e[e.length - 1]
                     }
                     return this.cache = {
                         startBlock: e,
                         endBlock: t,
                         nextEndBlock: s,
                         buffer: r
-                    }, Mh(r)
+                    }, gh(r)
                 }
             }
-            return Mh(await this.loadBLockData(e, t, {
+            return gh(await this.loadBLockData(e, t, {
                 skipEnd: i
             }))
         }
         async loadBLockData(e, t, i) {
             const n = this.config,
                 r = i && i.skipStart;
             let s = 0;
             if (!(i && i.skipEnd)) {
-                const e = No(n, {
+                const e = Mo(n, {
                         range: {
                             start: t,
                             size: 26
                         }
                     }),
-                    i = await lo.loadArrayBuffer(n.url, e);
-                s = Ah(i)
+                    i = await io.loadArrayBuffer(n.url, e);
+                s = uh(i)
             }
             if (r) {
-                const t = No(n, {
+                const t = Mo(n, {
                         range: {
                             start: e,
                             size: 26
                         }
                     }),
-                    i = await lo.loadArrayBuffer(n.url, t);
-                e += Ah(i)
+                    i = await io.loadArrayBuffer(n.url, t);
+                e += uh(i)
             }
-            const o = No(n, {
+            const o = Mo(n, {
                 range: {
                     start: e,
                     size: t + s - e
                 }
             });
-            return lo.loadArrayBuffer(n.url, o)
+            return io.loadArrayBuffer(n.url, o)
         }
     }
 
-    function Th(e) {
+    function ph(e) {
         const t = e.byteLength;
         let i = 0;
         const n = [0];
         for (; i < t;) {
             const r = new Uint8Array(e, i);
             i += 1 + (r[17] << 8 | r[16]), i < t && n.push(i)
         }
         return n
     }
 
-    function Mh(e, t, i) {
+    function gh(e, t, i) {
         const n = [];
         let r = t = t || 0;
         const s = e.byteLength - 18;
         for (; r < s;) try {
             const t = new Uint8Array(e, r, 18),
                 s = t[11] << 8 | t[10],
                 o = t[17] << 8 | t[16],
                 a = 12 + s + r,
                 l = e.byteLength - a,
                 h = o - s - 18;
             if (l < h || h <= 0) break;
             const c = new Uint8Array(e, a, h),
-                d = Is(c);
+                d = As(c);
             if (n.push(d), i === r) break;
             r += o + 1
         } catch (e) {
             console.error(e);
             break
         }
         return n
     }
-    class Rh {
+    class mh {
         constructor(e, t) {
             var i;
-            this.config = e || {}, this.genome = t, this.indexURL = e.indexURL, this.indexed = e.indexed, ti(this.config.url) ? this.filename = this.config.url.name : Ho(this.config.url) ? (this.indexed = !1, this.dataURI = e.url) : (i = ri(this.config.url), this.filename = e.filename || i.file), this.parser = this.getParser(this.config), "vcf" !== this.config.format || this.config.indexURL || console.warn("Warning: index file not specified.  The entire vcf file will be loaded.")
+            this.config = e || {}, this.genome = t, this.indexURL = e.indexURL, this.indexed = e.indexed || void 0 !== this.indexURL, this.queryable = this.indexed, ti(this.config.url) ? this.filename = this.config.url.name : Bo(this.config.url) ? (this.indexed = !1, this.dataURI = e.url) : (i = ni(this.config.url), this.filename = e.filename || i.file), this.parser = this.getParser(this.config), "vcf" !== this.config.format || this.config.indexURL || console.warn("Warning: index file not specified.  The entire vcf file will be loaded.")
         }
         async defaultVisibilityWindow() {
             if (this.config.indexURL) {
                 const e = await this.getIndex();
                 if (e && e.lastBlockPosition) {
                     let t = 0;
                     const i = 1e4;
@@ -10726,64 +10761,64 @@
         }
         async readHeader() {
             if (this.dataURI) return await this.loadFeaturesFromDataURI(this.dataURI), this.header;
             if (this.config.indexURL) {
                 const e = await this.getIndex();
                 if (!e) throw new Error("Unable to load index: " + this.config.indexURL);
                 let t;
-                if (e.tabix) this._blockLoader = new Eh(this.config), t = new Sh(this.config);
+                if (e.tabix) this._blockLoader = new fh(this.config), t = new dh(this.config);
                 else {
                     const i = Object.values(e.chrIndex).flatMap((e => e.blocks)).map((e => e.max)).reduce(((e, t) => Math.min(e, t)), Number.MAX_SAFE_INTEGER),
-                        n = No(this.config, {
+                        n = Mo(this.config, {
                             bgz: e.tabix,
                             range: {
                                 start: 0,
                                 size: i
                             }
                         });
-                    t = xh(await lo.loadString(this.config.url, n))
+                    t = lh(await io.loadString(this.config.url, n))
                 }
                 return this.header = await this.parser.parseHeader(t), this.header
             } {
-                const e = No(this.config),
-                    t = await lo.loadString(this.config.url, e);
-                let i = xh(t);
-                return this.header = await this.parser.parseHeader(i), i = xh(t), this.features = await this.parser.parseFeatures(i), this.header
+                const e = Mo(this.config),
+                    t = await io.loadString(this.config.url, e);
+                let i = lh(t);
+                return this.header = await this.parser.parseHeader(i), i = lh(t), this.features = await this.parser.parseFeatures(i), this.header
             }
         }
         getParser(e) {
             switch (e.format) {
                 case "vcf":
-                    return new Ql(e);
+                    return new Hl(e);
                 case "seg":
-                    return new Ul("seg");
+                    return new Bl("seg");
                 case "mut":
-                    return new Ul("mut");
+                    return new Bl("mut");
                 case "maf":
-                    return new Ul("maf");
+                    return new Bl("maf");
                 case "gwas":
-                    return new Kl(e);
+                    return new ql(e);
                 case "aed":
-                    return new ih(e);
+                    return new Gl(e);
                 default:
-                    return new Bl(e)
+                    return new Sl(e)
             }
         }
         async loadFeaturesNoIndex() {
             if (this.features) {
                 const e = this.features;
                 return delete this.features, e
             } {
-                const e = No(this.config),
-                    t = await lo.loadString(this.config.url, e);
+                const e = Mo(this.config),
+                    t = await io.loadString(this.config.url, e);
                 if (!this.header) {
-                    const e = xh(t);
+                    const e = lh(t);
                     this.header = await this.parser.parseHeader(e)
                 }
-                const i = xh(t);
+                const i = lh(t);
                 return await this.parser.parseFeatures(i)
             }
         }
         async loadFeaturesWithIndex(e, t, i) {
             this.dataURI || this.header || await this.readHeader();
             const n = this.config,
                 r = this.parser,
@@ -10794,23 +10829,23 @@
                 l = this.index.chunksForRange(o, t, i);
             if (l && 0 !== l.length) {
                 const o = [];
                 for (let h of l) {
                     let l;
                     if (s) l = await this._blockLoader.getData(h.minv, h.maxv);
                     else {
-                        const e = No(n, {
+                        const e = Mo(n, {
                             range: {
                                 start: h.minv.block,
                                 size: h.maxv.block - h.minv.block + 1
                             }
                         });
-                        l = await lo.loadString(n.url, e)
+                        l = await io.loadString(n.url, e)
                     }
-                    const c = xh(h.minv.offset ? l.slice(h.minv.offset) : l);
+                    const c = lh(h.minv.offset ? l.slice(h.minv.offset) : l);
                     let d = await r.parseFeatures(c);
                     d = d.filter((e => void 0 === e._f));
                     let u = !1;
                     for (let n = 0; n < d.length; n++) {
                         const r = d[n];
                         if ((a ? a.getChromosomeName(r.chr) : r.chr) !== e) {
                             if (0 === o.length) continue;
@@ -10829,29 +10864,29 @@
             }
             return []
         }
         async getIndex() {
             return this.index ? this.index : this.config.indexURL ? (this.index = await this.loadIndex(), this.index) : void 0
         }
         async loadIndex() {
-            return _h(this.config.indexURL, this.config, this.genome)
+            return ah(this.config.indexURL, this.config, this.genome)
         }
         async loadFeaturesFromDataURI() {
             if (this.features) {
                 const e = this.features;
                 return delete this.features, e
             } {
-                const e = Hs(this.dataURI);
-                let t = xh(e);
-                return this.header = await this.parser.parseHeader(t), this.header instanceof String && this.header.startsWith("##gff-version 3") && (this.format = "gff3"), t = xh(e), this.features = await this.parser.parseFeatures(t), this.features
+                const e = Fs(this.dataURI);
+                let t = lh(e);
+                return this.header = await this.parser.parseHeader(t), this.header instanceof String && this.header.startsWith("##gff-version 3") && (this.format = "gff3"), t = lh(e), this.features = await this.parser.parseFeatures(t), this.features
             }
         }
     }
-    const Lh = Qt;
-    class Ih {
+    const bh = Qt;
+    class wh {
         constructor(e) {
             this.config = e
         }
         async readFeatures(e, t, i) {
             let n;
             n = "function" == typeof this.config.url ? this.config.url({
                 chr: e,
@@ -10860,35 +10895,35 @@
             }) : this.config.url.replace("$CHR", e).replace("$START", t).replace("$END", i);
             let r, s = Object.assign({}, this.config);
             void 0 !== this.config.body && ("function" == typeof this.config.body ? s.body = this.config.body({
                 chr: e,
                 start: t,
                 end: i
             }) : s.body = this.config.body.replace("$CHR", e).replace("$START", t).replace("$END", i));
-            const o = await lo.load(n, s);
-            if (o && (r = "function" == typeof this.config.parser ? this.config.parser(o) : Lh(o) ? JSON.parse(o) : o), this.config.mappings) {
+            const o = await io.load(n, s);
+            if (o && (r = "function" == typeof this.config.parser ? this.config.parser(o) : bh(o) ? JSON.parse(o) : o), this.config.mappings) {
                 let e = Object.keys(this.config.mappings);
                 for (let t of r)
                     for (let i of e) t[i] = t[this.config.mappings[i]]
             }
             return r
         }
     }
-    const Bh = function(e, t) {
+    const vh = function(e, t) {
         this.config = e, this.genome = t, this.expandQueryInterval = !1
     };
-    Bh.prototype.readFeatures = function(e, t, i) {
+    vh.prototype.readFeatures = function(e, t, i) {
         const n = Math.max(0, Math.floor(t));
         let r = Math.ceil(i);
         if (this.genome) {
             const t = this.genome.getChromosome(e);
             t && r > t.bpLength && (r = t.bpLength)
         }
         const s = this.config.url + "?db=" + this.config.db + "&table=" + this.config.tableName + "&chr=" + e + "&start=" + n + "&end=" + r;
-        return lo.loadJson(s, this.config).then((function(e) {
+        return io.loadJson(s, this.config).then((function(e) {
             return e ? (e.forEach((function(e) {
                 e.hasOwnProperty("exonStarts") && e.hasOwnProperty("exonEnds") && e.hasOwnProperty("exonCount") && e.hasOwnProperty("cdsStart") && e.hasOwnProperty("cdsEnd") && function(e) {
                     var t, i, n, r, s, o;
                     t = e.exonCount, i = e.exonStarts.split(","), n = e.exonEnds.split(","), r = [];
                     for (var a = 0; a < t; a++) {
                         var l = {
                             start: s = parseInt(i[a]),
@@ -10897,16 +10932,16 @@
                         (e.cdsStart > o || e.cdsEnd < e.cdsStart) && (l.utr = !0), e.cdsStart >= s && e.cdsStart <= o && (l.cdStart = e.cdsStart), e.cdsEnd >= s && e.cdsEnd <= o && (l.cdEnd = e.cdsEnd), r.push(l)
                     }
                     e.exons = r
                 }(e)
             })), e) : null
         }))
     };
-    const Nh = ["Name", "gene_name", "gene", "gene_id", "alias", "locus", "name"];
-    class Fh {
+    const yh = ["Name", "gene_name", "gene", "gene_id", "alias", "locus", "name"];
+    class _h {
         constructor(e) {
             this.format = e.format, this.nameField = e.nameField, this.filterTypes = void 0 === e.filterTypes ? new Set(["chromosome"]) : new Set(e.filterTypes)
         }
         combineFeatures(e, t) {
             let i;
             const n = this.filterTypes;
             if (e = e.filter((e => void 0 === n || !n.has(e.type))), "gff3" === this.format) {
@@ -10917,15 +10952,15 @@
                 return e.start - t.start
             })), this.numberExons(i, t), this.nameFeatures(i), i
         }
         combineFeaturesById(e) {
             const t = new Map,
                 i = [];
             for (let n of e)
-                if (nl(n.type) || il(n.type) || !n.id) i.push(n);
+                if (Qa(n.type) || Za(n.type) || !n.id) i.push(n);
                 else {
                     let e = t.get(n.chr);
                     e || (e = new Map, t.set(n.chr, e));
                     let i = e.get(n.id);
                     i ? i.push(n) : e.set(n.id, [n])
                 } for (let e of t.values())
                 for (let t of e.values())
@@ -10946,36 +10981,36 @@
             for (let e of t) i[e.id] = e;
             const n = Object.create(null),
                 r = [],
                 s = new Set,
                 o = this.filterTypes;
             e = e.filter((e => void 0 === o || !o.has(e.type)));
             for (let t of e)
-                if ("biological_region" === t.type && console.log(), il(t.type)) {
+                if ("biological_region" === t.type && console.log(), Za(t.type)) {
                     const e = t.id;
                     if (void 0 !== e) {
-                        const o = new ol(t);
+                        const o = new Ka(t);
                         n[e] = o, r.push(o), s.add(t);
                         const a = i[t.parent];
                         a && (o.geneObject = a, s.add(a))
                     }
                 } for (let t of e)
-                if (nl(t.type)) {
+                if (Qa(t.type)) {
                     const e = h(t);
                     if (e)
                         for (let i of e) {
                             let o = n[i];
                             if (!o && "gtf" === this.format) {
                                 const e = Object.assign({}, t);
-                                e.type = "transcript", o = new ol(e), n[i] = o, r.push(o)
+                                e.type = "transcript", o = new Ka(e), n[i] = o, r.push(o)
                             }
                             if (void 0 !== o) {
-                                if (a = t.type, Ya.has(a))
+                                if (a = t.type, qa.has(a))
                                     if (e.length > 1) {
-                                        const e = new sl(t);
+                                        const e = new Ya(t);
                                         o.addExon(e)
                                     } else o.addExon(t);
                                 else o.addPart(t);
                                 s.add(t)
                             }
                         }
                 } var a;
@@ -10997,82 +11032,82 @@
                         i.exons[e].number = "-" === i.strand ? i.exons.length - e : e + 1
                     }
         }
         nameFeatures(e) {
             for (let t of e)
                 if (t.attributeString) {
                     const e = "gff3" === this.format ? "=" : " ",
-                        i = cl(t.attributeString, e),
+                        i = il(t.attributeString, e),
                         n = new Map(i);
                     if (this.nameField) t.name = n.get(this.nameField);
                     else
-                        for (let e of Nh)
+                        for (let e of yh)
                             if (n.has(e)) {
                                 t.name = n.get(e);
                                 break
                             }
                 }
         }
     }
-    const Ph = function(e) {
+    const xh = function(e) {
         this.config = e, this.url = e.url, this.tissueId = e.tissueSiteDetailId, this.indexed = !0, this.datasetId = e.datasetId || "gtex_v8"
     };
-    Ph.prototype.readFeatures = async function(e, t, i) {
+    xh.prototype.readFeatures = async function(e, t, i) {
         let n = e.startsWith("chr") ? e : "chr" + e,
             r = Math.floor(t),
             s = Math.ceil(i),
             o = this.datasetId,
             a = this.url + "?chromosome=" + n + "&start=" + r + "&end=" + s + "&tissueSiteDetailId=" + this.tissueId + "&datasetId=" + o;
-        const l = await lo.loadJson(a, {
+        const l = await io.loadJson(a, {
             withCredentials: this.config.withCredentials
         });
         return l && l.singleTissueEqtl ? (l.singleTissueEqtl.forEach((function(e) {
             e.chr = e.chromosome, e.position = e.pos, e.start = e.pos - 1, e.end = e.start + 1, e.snp = e.snpId, e.geneName = e.geneSymbol, e.geneId = e.gencodeId
         })), l.singleTissueEqtl) : void 0
     };
-    const Oh = function(e) {
+    const kh = function(e) {
         this.config = e, this.url = e.url, this.cellConditionId = e.cellConditionId, this.valueThreshold = e.valueThreshold ? e.valueThreshold : .05
     };
-    Oh.prototype.readFeatures = function(e, t, i) {
+    kh.prototype.readFeatures = function(e, t, i) {
         var n = this,
             r = this.url + "?chromosome=" + e + "&start=" + t + "&end=" + i + "&cell_condition_id=" + this.cellConditionId;
         return new Promise((function(e, t) {
-            lo.loadJson(r, {
+            io.loadJson(r, {
                 withCredentials: n.config.withCredentials
             }).then((function(t) {
                 t ? (t.eqtls.forEach((function(e) {
                     e.chr = e.chromosome, e.start = e.position, e.end = e.position + 1
                 })), e(t.eqtls)) : e(null)
             })).catch((function(e) {
                 t(e)
             }))
         }))
     };
-    const Dh = lo.apiKey;
+    const Ch = io.apiKey;
 
-    function zh(e) {
+    function Sh(e) {
         var t = e.url + "/" + e.entity + "/" + e.entityId;
         return e.headers = {
             "Cache-Control": "no-cache"
-        }, lo.loadJson(t, e)
+        }, io.loadJson(t, e)
     }
 
-    function Hh(e) {
+    function Ah(e) {
         return new Promise((function(t, i) {
             var n = e.results ? e.results : [],
                 r = e.url,
                 s = e.body,
                 o = e.decode,
                 a = "?",
                 l = e.fields;
-            return Dh && (r = r + a + "key=" + Dh, a = "&"), l && (r = r + a + "fields=" + l),
+            return Ch && (r = r + a + "key=" + Ch, a = "&"), l && (r = r + a + "fields=" + l),
                 function e(a) {
                     a ? s.pageToken = a : void 0 !== s.pageToken && delete s.pageToken;
                     var l = JSON.stringify(s);
-                    lo.loadJson(r, {
+                    io.loadJson(r, {
                         sendData: l,
                         contentType: "application/json",
                         headers: {
                             "Cache-Control": "no-cache"
                         }
                     }).then((function(i) {
                         var r, s;
@@ -11081,20 +11116,20 @@
                         })), (r = i.nextPageToken) ? e(r) : t(n)) : t(n)
                     })).catch((function(e) {
                         i(e)
                     }))
                 }()
         }))
     }
-    const Vh = function(e, t) {
+    const Eh = function(e, t) {
         this.config = e, this.genome = t, this.url = e.url, this.variantSetId = e.variantSetId, this.callSetIds = e.callSetIds, this.includeCalls = void 0 === e.includeCalls || e.includeCalls
     };
-    Vh.prototype.readHeader = function() {
+    Eh.prototype.readHeader = function() {
         var e = this;
-        return e.header ? Promise.resolve(e.header) : (e.header = {}, !1 === e.includeCalls ? Promise.resolve(e.header) : Hh({
+        return e.header ? Promise.resolve(e.header) : (e.header = {}, !1 === e.includeCalls ? Promise.resolve(e.header) : Ah({
             url: e.url + "/callsets/search",
             fields: "nextPageToken,callSets(id,name)",
             body: {
                 variantSetIds: Array.isArray(e.variantSetId) ? e.variantSetId : [e.variantSetId],
                 pageSize: "10000"
             },
             decode: function(t) {
@@ -11108,79 +11143,79 @@
                     })), i
                 }
                 return t.callSets
             }
         }).then((function(t) {
             return e.header.callSets = t, e.header
         })))
-    }, Vh.prototype.readFeatures = function(e, t, i) {
+    }, Eh.prototype.readFeatures = function(e, t, i) {
         const n = this,
             r = this.genome;
         return n.readHeader().then((function(e) {
             return new Promise((function(e, t) {
                 n.chrAliasTable ? e(n.chrAliasTable) : n.readMetadata().then((function(t) {
                     n.metadata = t.metadata, n.chrAliasTable = {}, t.referenceBounds && r && t.referenceBounds.forEach((function(e) {
                         var t = e.referenceName,
                             i = r.getChromosomeName(t);
                         n.chrAliasTable[i] = t
                     })), e(n.chrAliasTable)
                 }))
             }))
         })).then((function(r) {
             var s = r.hasOwnProperty(e) ? r[e] : e;
-            return Hh({
+            return Ah({
                 url: n.url + "/variants/search",
                 fields: n.includeCalls ? void 0 : "nextPageToken,variants(id,variantSetId,names,referenceName,start,end,referenceBases,alternateBases,quality,filter,info)",
                 body: {
                     variantSetIds: Array.isArray(n.variantSetId) ? n.variantSetId : [n.variantSetId],
                     callSetIds: n.callSetIds ? n.callSetIds : void 0,
                     referenceName: s,
                     start: t.toString(),
                     end: i.toString(),
                     pageSize: "10000"
                 },
                 decode: function(e) {
                     var t, i = [];
                     return e.variants.forEach((function(e) {
                         t = function(e) {
-                            var t, i = new $l;
-                            return i.chr = e.referenceName, i.start = parseInt(e.start), i.end = parseInt(e.end), i.pos = i.start + 1, i.names = Zl(e.names, "; "), i.referenceBases = e.referenceBases, i.alternateBases = Zl(e.alternateBases), i.quality = e.quality, i.filter = Zl(e.filter), i.info = {}, e.info && Object.keys(e.info).forEach((function(t) {
+                            var t, i = new Ol;
+                            return i.chr = e.referenceName, i.start = parseInt(e.start), i.end = parseInt(e.end), i.pos = i.start + 1, i.names = zl(e.names, "; "), i.referenceBases = e.referenceBases, i.alternateBases = zl(e.alternateBases), i.quality = e.quality, i.filter = zl(e.filter), i.info = {}, e.info && Object.keys(e.info).forEach((function(t) {
                                 var n, r = e.info[t];
                                 n = Array.isArray(r) ? r.join(",") : r, i.info[t] = n
                             })), i.calls = {}, e.calls && e.calls.forEach((function(e) {
                                 t = e.callSetId, i.calls[t] = e
                             })), init(i), i
                         }(e), t.isRefBlock() || i.push(t)
                     })), i
                 }
             })
         }))
-    }, Vh.prototype.readMetadata = function() {
-        return zh({
+    }, Eh.prototype.readMetadata = function() {
+        return Sh({
             url: this.url,
             entity: "variantsets",
             entityId: this.variantSetId
         })
     };
-    class Uh {
+    class Mh {
         constructor(e) {
             this.config = e
         }
         async readFeatures(e, t, i) {
-            const n = (await lo.loadJson(this.config.url + "/variants/?count=50000")).records,
+            const n = (await io.loadJson(this.config.url + "/variants/?count=50000")).records,
                 r = [];
             for (let e of n)
                 if (e.coordinates) {
                     e.id;
                     const t = e.coordinates;
-                    t.chromosome && r.push(new qh(t.chromosome, t.start - 1, t.stop, e)), t.chromosome2 && r.push(new qh(t.chromosome2, t.start2 - 1, t.stop2, e))
+                    t.chromosome && r.push(new Th(t.chromosome, t.start - 1, t.stop, e)), t.chromosome2 && r.push(new Th(t.chromosome2, t.start2 - 1, t.stop2, e))
                 } return r
         }
     }
-    class qh {
+    class Th {
         constructor(e, t, i, n) {
             if (this.chr = e, this.start = t, this.end = i, this.id = n.id, this.entrezName = n.entrez_name, this.name = n.name, this.actionabilityScore = n.civic_actionability_score, n.coordinates.reference_bases && (this.refBases = n.coordinates.reference_bases), n.coordinates.variant_bases && (this.altBases = n.coordinates.variant_bases), n.variant_types && (this.variant_types = n.variant_types), this.locationString = this.chr + ":" + Xt(this.start + 1) + "-" + Xt(this.end), void 0 !== this.actionabilityScore) {
                 let e;
                 if (this.actionabilityScore <= 10) e = .2;
                 else {
                     const t = Math.min(30, this.actionabilityScore);
                     e = .2 + .8 * Math.log10((t - 10) / 2)
@@ -11216,98 +11251,98 @@
             }), t;
 
             function i(e, t) {
                 return "<a target='_blank' href='" + t + "'>" + e + "</a>"
             }
         }
     }
-    class jh {
+    class Rh {
         constructor(e, t) {
             if (this.config = e, this.genome = t, this.format = e.format ? e.format.toUpperCase() : "BAM", "BAM" !== this.format && "VCF" !== this.format) throw Error(`htsget format ${e.format} is not supported`)
         }
         async readHeaderData() {
-            const e = `${$h(this.config)}?class=header&format=${this.format}`,
-                t = await lo.loadJson(e, No(this.config));
+            const e = `${Lh(this.config)}?class=header&format=${this.format}`,
+                t = await io.loadJson(e, Mo(this.config));
             return await this.loadUrls(t.htsget.urls)
         }
         async readData(e, t, i) {
-            const n = `${$h(this.config)}?format=${this.format}&referenceName=${e}&start=${Math.floor(t)}&end=${Math.ceil(i)}`,
-                r = await lo.loadJson(n, No(this.config));
+            const n = `${Lh(this.config)}?format=${this.format}&referenceName=${e}&start=${Math.floor(t)}&end=${Math.ceil(i)}`,
+                r = await io.loadJson(n, Mo(this.config));
             return this.loadUrls(r.htsget.urls)
         }
         async loadUrls(e) {
             const t = [];
             for (let i of e)
-                if (i.url.startsWith("data:")) t.push(Promise.resolve(Wh(i.url)));
+                if (i.url.startsWith("data:")) t.push(Promise.resolve(Ih(i.url)));
                 else {
-                    const e = No(this.config || {});
-                    i.headers && (e.headers = Object.assign(e.headers || {}, i.headers)), t.push(lo.loadArrayBuffer(i.url, e))
+                    const e = Mo(this.config || {});
+                    i.headers && (e.headers = Object.assign(e.headers || {}, i.headers)), t.push(io.loadArrayBuffer(i.url, e))
                 } return function(e) {
                 let t = 0;
                 for (let i of e) t += i.byteLength;
                 let i = 0;
                 const n = new Uint8Array(t);
                 for (let t of e) {
                     const e = new Uint8Array(t);
                     n.set(e, i), i += e.length
                 }
                 return n
             }(await Promise.all(t))
         }
         static async inferFormat(e) {
             try {
-                const t = $h(e),
+                const t = Lh(e),
                     i = `${t}${t.includes("?")?"&":"?"}class=header`,
-                    n = await lo.loadJson(i, No(e));
+                    n = await io.loadJson(i, Mo(e));
                 if (n.htsget) {
                     const t = n.htsget.format;
                     if ("BAM" !== t && "VCF" !== t) throw Error(`htsget format ${t} is not supported`);
-                    e.format = t.toLowerCase(), e.sourceType = "htsget", e.name || (e.name = await Do(e.url))
+                    e.format = t.toLowerCase(), e.sourceType = "htsget", e.name || (e.name = await Lo(e.url))
                 }
             } catch (e) {}
         }
     }
 
-    function $h(e) {
+    function Lh(e) {
         if (e.url && e.endpoint && e.id) return e.url + e.endpoint + e.id;
         if (e.endpoint && e.id) return e.endpoint + e.id;
         if (e.url) return e.url.startsWith("htsget://") ? e.url.replace("htsget://", "https://") : e.url;
         throw Error("Must specify either 'url', or 'endpoint' and 'id")
     }
 
-    function Wh(e) {
+    function Ih(e) {
         const t = e.split(","),
             i = t[0].split(":")[1];
         let n = t[1];
         n = i.indexOf("base64") >= 0 ? atob(n) : decodeURI(n);
         const r = new Uint8Array(n.length);
         for (var s = 0; s < n.length; s++) r[s] = n.charCodeAt(s);
         return r
     }
-    class Gh extends jh {
+    class Bh extends Rh {
         constructor(e, t) {
-            super(e, t), this.parser = new Ql
+            super(e, t), this.parser = new Hl
         }
         async readHeader() {
             if (!this.header) {
-                const e = xh(await this.readHeaderData());
+                const e = lh(await this.readHeaderData());
                 this.header = await this.parser.parseHeader(e, this.genome), this.chrAliasTable = this.header.chrAliasTable
             }
             return this.header
         }
         async readFeatures(e, t, i) {
             if (this.config.format && "VCF" !== this.config.format.toUpperCase()) throw Error(`htsget format ${this.config.format} is not supported`);
             this.chrAliasTable || await this.readHeader();
             let n = this.chrAliasTable.has(e) ? this.chrAliasTable.get(e) : e;
-            const r = xh(await this.readData(n, t, i));
+            const r = lh(await this.readData(n, t, i));
             return this.parser.parseFeatures(r)
         }
     }
 
-    function Zh(e, t) {
+    function Fh(e, t) {
         t = t || Number.MAX_SAFE_INTEGER;
         const i = [];
         e.sort((function(e, t) {
             return e.start - t.start
         })), i.push(-1e3);
         for (let n of e) {
             let e = 0;
@@ -11315,18 +11350,17 @@
             for (e = 0; e < r; e++)
                 if (n.start >= i[e]) {
                     n.row = e, i[e] = n.end;
                     break
                 } n.row = e, i[e] = n.end
         }
     }
-    const Qh = 1e4;
 
-    function Xh(e, t, i) {
-        const n = i || Qh,
+    function Nh(e, t, i) {
+        const n = i || 1e4,
             r = e => {
                 const i = Object.assign({}, e);
                 return i.chr = "all", i.start = t.getGenomeCoordinate(e.chr, e.start), i.end = t.getGenomeCoordinate(e.chr, e.end), i._f = e, i.exons && delete i.exons, i
             },
             s = new Set(t.wgChromosomeNames),
             o = [];
         let a = 0;
@@ -11354,30 +11388,30 @@
                 }
         }
         return o.sort((function(e, t) {
             return e.start - t.start
         })), o
     }
 
-    function Yh(e, t) {
+    function Oh(e, t) {
         if (t = t || 1e3, null == e || 0 === e.length) return;
         const i = {},
             n = [];
         for (let t of e) {
             const e = t.chr;
             let r = i[e];
             r || (r = [], i[e] = r, n.push(e)), r.push(t)
         }
-        for (let e of n) Zh(i[e], t)
+        for (let e of n) Fh(i[e], t)
     }
-    class Kh {
+    class Ph {
         constructor(e, t) {
             this.config = e || {}, this.genome = t, this.sourceType = void 0 === e.sourceType ? "file" : e.sourceType, this.maxWGCount = e.maxWGCount || 1e4;
             const i = new Set(["bigwig", "bw", "bigbed", "bb", "biginteract", "biggenepred", "bignarrowpeak", "tdf"]);
-            e.reader ? (this.reader = e.reader, this.queryable = !1 !== e.queryable) : "ga4gh" === e.sourceType ? (this.reader = new Vh(e, t), this.queryable = !0) : "immvar" === e.sourceType ? (this.reader = new Oh(e), this.queryable = !0) : "eqtl" === e.type && "gtex-ws" === e.sourceType ? (this.reader = new Ph(e), this.queryable = !0) : "htsget" === e.sourceType ? this.reader = new Gh(e, t) : "ucscservice" === e.sourceType ? (this.reader = new Bh(e.source), this.queryable = !0) : "custom" === e.sourceType ? (this.reader = new Ih(e.source), this.queryable = !1 !== e.source.queryable) : "civic-ws" === e.sourceType ? (this.reader = new Uh(e), this.queryable = !1) : (this.reader = new Rh(e, t), void 0 !== e.queryable ? this.queryable = e.queryable : (i.has(e.format) || this.reader.indexed) && (this.queryable = !0))
+            this.queryable = e.indexURL || !0 === e.queryable, e.reader ? (this.reader = e.reader, this.queryable = !1 !== e.queryable) : "ga4gh" === e.sourceType ? (this.reader = new Eh(e, t), this.queryable = !0) : "immvar" === e.sourceType ? (this.reader = new kh(e), this.queryable = !0) : "eqtl" === e.type && "gtex-ws" === e.sourceType ? (this.reader = new xh(e), this.queryable = !0) : "htsget" === e.sourceType ? this.reader = new Bh(e, t) : "ucscservice" === e.sourceType ? (this.reader = new vh(e.source), this.queryable = !0) : "custom" === e.sourceType ? (this.reader = new wh(e.source), this.queryable = !1 !== e.source.queryable) : "civic-ws" === e.sourceType ? (this.reader = new Mh(e), this.queryable = !1) : (this.reader = new mh(e, t), void 0 !== e.queryable ? this.queryable = e.queryable : (i.has(e.format) || this.reader.indexed) && (this.queryable = !0)), this.searchable = !0 === e.searchable || e.searchableFields || !1 !== e.searchable && !this.queryable
         }
         async defaultVisibilityWindow() {
             if (this.reader && "function" == typeof this.reader.defaultVisibilityWindow) return this.reader.defaultVisibilityWindow()
         }
         async trackType() {
             const e = await this.getHeader();
             return e ? e.type : void 0
@@ -11396,15 +11430,15 @@
             end: i,
             bpPerPixel: n,
             visibilityWindow: r
         }) {
             const s = this.genome,
                 o = s ? s.getChromosomeName(e) : e,
                 a = "all" === o.toLowerCase();
-            return (a && !this.wgFeatures && this.supportsWholeGenome() || this.config.disableCache || !this.featureCache || !this.featureCache.containsRange(new ha(o, t, i))) && await this.loadFeatures(o, t, i, r), a ? (this.wgFeatures || (this.supportsWholeGenome() ? this.wgFeatures = Xh(this.featureCache.getAllFeatures(), this.genome, this.maxWGCount) : this.wgFeatures = []), this.wgFeatures) : this.featureCache.queryFeatures(o, t, i)
+            return (a && !this.wgFeatures && this.supportsWholeGenome() || this.config.disableCache || !this.featureCache || !this.featureCache.containsRange(new ia(o, t, i))) && await this.loadFeatures(o, t, i, r), a ? (this.wgFeatures || (this.supportsWholeGenome() ? this.wgFeatures = Nh(this.featureCache.getAllFeatures(), this.genome, this.maxWGCount) : this.wgFeatures = []), this.wgFeatures) : this.featureCache.queryFeatures(o, t, i)
         }
         supportsWholeGenome() {
             return !this.queryable
         }
         getAllFeatures() {
             return this.queryable || !this.featureCache ? [] : this.featureCache.getAllFeatures()
         }
@@ -11417,60 +11451,64 @@
                 s = 0, o = Math.max(t ? t.bpLength : Number.MAX_SAFE_INTEGER, i)
             } else if (n > i - t && !1 !== this.config.expandQuery) {
                 const e = Math.min(4.1 * (i - t), n);
                 s = Math.max(0, (t + i) / 2 - e), o = t + e
             }
             let a = await r.readFeatures(e, s, o);
             void 0 === this.queryable && (this.queryable = r.indexed);
-            const l = this.queryable ? new ha(e, s, o) : void 0;
+            const l = this.queryable ? new ia(e, s, o) : void 0;
             if (a) {
-                if (!1 === this.config.assembleGFF || "gtf" !== this.config.format && "gff3" !== this.config.format && "gff" !== this.config.format || (a = new Fh(this.config).combineFeatures(a, l)), "wig" !== this.config.format && "junctions" !== this.config.type) {
-                    Yh(a, this.config.maxRows || Number.MAX_SAFE_INTEGER)
+                if (!1 === this.config.assembleGFF || "gtf" !== this.config.format && "gff3" !== this.config.format && "gff" !== this.config.format || (a = new _h(this.config).combineFeatures(a, l)), "wig" !== this.config.format && "junctions" !== this.config.type) {
+                    Oh(a, this.config.maxRows || Number.MAX_SAFE_INTEGER)
                 }
-                this.featureCache = new vo(a, this.genome, l), (this.config.searchable || this.config.searchableFields) && this.addFeaturesToDB(a)
-            } else this.featureCache = new vo([], l)
-        }
-        addFeaturesToDB(e) {
-            for (let t of e)
-                if (t.name && (this.genome.featureDB[t.name.toUpperCase()] = t), t.gene && t.gene.name && (this.genome.featureDB[t.gene.name.toUpperCase()] = t), this.config.searchableFields)
-                    for (let e of this.config.searchableFields) {
-                        const i = t.getAttributeValue(e);
-                        i && (i.indexOf(" ") > 0 ? (this.genome.featureDB[i.replaceAll(" ", "+").toUpperCase()] = t, this.genome.featureDB[i.replaceAll(" ", "%20").toUpperCase()] = t) : this.genome.featureDB[i.toUpperCase()] = t)
-                    }
+                this.featureCache = new fo(a, this.genome, l), this.searchable && this.genome.addFeaturesToDB(a, this.config)
+            } else this.featureCache = new fo([], l)
         }
     }
-    class Jh {
+    class Dh {
         constructor(e, t, i) {
             this.path = e.url, this.bufferSize = i || 512e3, this.range = {
                 start: -1,
                 size: -1
             }, this.config = e
         }
-        async dataViewForRange(e, t) {
-            if (!(this.data && this.range.start <= e.start && this.range.start + this.range.size >= e.start + e.size)) {
-                let t;
-                t = e.size ? Math.max(this.bufferSize, e.size) : this.bufferSize;
-                const i = {
-                        start: e.start,
-                        size: t
-                    },
-                    n = await lo.loadArrayBuffer(this.path, No(this.config, {
-                        range: i
-                    }));
-                this.data = n, this.range = i
+        async dataViewForRange(e, t, i = 0) {
+            try {
+                console.log(`buffered reader ${e}`);
+                if (!(this.data && this.range.start <= e.start && this.range.start + this.range.size >= e.start + e.size)) {
+                    let t;
+                    t = e.size ? Math.max(this.bufferSize, e.size) : this.bufferSize, this.contentLength && (t = Math.min(t, this.contentLength - e.start));
+                    const i = {
+                            start: e.start,
+                            size: t
+                        },
+                        n = await io.loadArrayBuffer(this.path, Mo(this.config, {
+                            range: i
+                        }));
+                    this.data = n, this.range = i
+                }
+                const i = this.data.byteLength,
+                    n = e.start - this.range.start;
+                return t ? new Uint8Array(this.data, n, i - n) : new DataView(this.data, n, i - n)
+            } catch (n) {
+                if (0 === i && n.message && n.message.startsWith("416")) {
+                    try {
+                        return this.contentLength = await io.getContentLength(this.path, Mo(this.config)), this.dataViewForRange(e, t, ++i)
+                    } catch (e) {
+                        console.error(e)
+                    }
+                    throw n
+                }
             }
-            const i = this.data.byteLength,
-                n = e.start - this.range.start;
-            return t ? new Uint8Array(this.data, n, i - n) : new DataView(this.data, n, i - n)
         }
     }
-    let ec = 512e3;
-    class tc {
+    let zh = 512e3;
+    class Hh {
         constructor(e, t) {
-            this.path = e.url, this.format = e.format || "bigwig", this.genome = t, this.rpTreeCache = {}, this.config = e, this.loader = Ho(this.path) ? new uc(this.path) : lo
+            this.path = e.url, this.format = e.format || "bigwig", this.genome = t, this.rpTreeCache = {}, this.config = e, this.loader = Bo(this.path) ? new Yh(this.path) : io
         }
         async readWGFeatures(e, t) {
             await this.loadHeader();
             const i = this.chromTree.idToChrom.length - 1,
                 n = this.chromTree.idToChrom[0],
                 r = this.chromTree.idToChrom[i];
             return this.readFeatures(n, 0, r, Number.MAX_VALUE, e, t)
@@ -11490,54 +11528,54 @@
                         if (r.reductionLevel < e) {
                             i = r;
                             break
                         }
                     }
                     return i
                 }(r, e) : void 0;
-                t ? (l = t.indexOffset, h = dc) : (l = this.header.fullIndexOffset, h = hc)
-            } else l = this.header.fullIndexOffset, h = cc.call(this);
+                t ? (l = t.indexOffset, h = Xh) : (l = this.header.fullIndexOffset, h = Zh)
+            } else l = this.header.fullIndexOffset, h = Qh.call(this);
             const c = await this.loadRPTree(l),
                 d = await c.findLeafItemsOverlapping(o, t, a, n);
             if (d && 0 !== d.length) {
                 let e = Number.MAX_VALUE,
                     i = 0;
                 for (let t of d) e = Math.min(e, t.dataOffset), i = Math.max(i, t.dataOffset + t.dataSize);
                 const r = i - e,
-                    l = await this.loader.loadArrayBuffer(this.config.url, No(this.config, {
+                    l = await this.loader.loadArrayBuffer(this.config.url, Mo(this.config, {
                         range: {
                             start: e,
                             size: r
                         }
                     })),
                     c = [];
                 for (let i of d) {
                     const r = new Uint8Array(l, i.dataOffset - e, i.dataSize);
                     let d;
-                    d = this.header.uncompressBuffSize > 0 ? Ls(r) : r, h.call(this, new DataView(d.buffer), o, t, a, n, c, this.chromTree.idToChrom, s)
+                    d = this.header.uncompressBuffSize > 0 ? Ss(r) : r, h.call(this, new DataView(d.buffer), o, t, a, n, c, this.chromTree.idToChrom, s)
                 }
                 return c.sort((function(e, t) {
                     return e.start - t.start
                 })), c
             }
             return []
         }
         async getZoomHeaders() {
             return this.zoomLevelHeaders || await this.loadHeader(), this.zoomLevelHeaders
         }
         async loadHeader() {
             if (this.header) return this.header; {
-                let e, t = await this.loader.loadArrayBuffer(this.path, No(this.config, {
+                let e, t = await this.loader.loadArrayBuffer(this.path, Mo(this.config, {
                     range: {
                         start: 0,
                         size: 64
                     }
                 }));
                 this.littleEndian = !0;
-                let i = new hh(new DataView(t)),
+                let i = new eh(new DataView(t)),
                     n = i.getUInt();
                 if (2291137574 === n) this.type = "bigwig";
                 else if (2273964779 === n) this.type = "bigbed";
                 else {
                     this.littleEndian = !1, i.littleEndian = !1, i.position = 0;
                     let e = i.getUInt();
                     654085990 === e ? this.type = "bigwig" : 3958540679 === e && (this.type = "bigbed")
@@ -11556,22 +11594,22 @@
                     extensionOffset: i.getLong()
                 };
                 const r = 64;
                 let s = {
                     start: r,
                     size: e.fullDataOffset - r + 5
                 };
-                t = await this.loader.loadArrayBuffer(this.path, No(this.config, {
+                t = await this.loader.loadArrayBuffer(this.path, Mo(this.config, {
                     range: s
                 }));
                 const o = e.nZoomLevels;
-                i = new hh(new DataView(t)), this.zoomLevelHeaders = [], this.firstZoomDataOffset = Number.MAX_SAFE_INTEGER;
+                i = new eh(new DataView(t)), this.zoomLevelHeaders = [], this.firstZoomDataOffset = Number.MAX_SAFE_INTEGER;
                 for (let e = 1; e <= o; e++) {
                     const t = o - e,
-                        n = new ic(t, i);
+                        n = new Vh(t, i);
                     this.firstZoomDataOffset = Math.min(n.dataOffset, this.firstZoomDataOffset), this.zoomLevelHeaders[t] = n
                 }
                 if (e.autoSqlOffset > 0) {
                     i.position = e.autoSqlOffset - r;
                     const t = i.getString();
                     t && (this.autoSql = function(e) {
                         let t;
@@ -11594,21 +11632,21 @@
                         }
                         return {
                             table: t,
                             fields: i
                         }
                     }(t))
                 }
-                if (e.totalSummaryOffset > 0 && (i.position = e.totalSummaryOffset - r, this.totalSummary = new ac(i)), !(e.chromTreeOffset > 0)) throw "BigWig chromosome tree offset <= 0";
-                return i.position = e.chromTreeOffset - r, this.chromTree = new sc(i, r, this.genome), i.position = e.fullDataOffset - r, e.dataCount = i.getInt(), this.setDefaultVisibilityWindow(e), this.header = e, this.header
+                if (e.totalSummaryOffset > 0 && (i.position = e.totalSummaryOffset - r, this.totalSummary = new Wh(i)), !(e.chromTreeOffset > 0)) throw "BigWig chromosome tree offset <= 0";
+                return i.position = e.chromTreeOffset - r, this.chromTree = new jh(i, r, this.genome), i.position = e.fullDataOffset - r, e.dataCount = i.getInt(), this.setDefaultVisibilityWindow(e), this.header = e, this.header
             }
         }
         async loadRPTree(e) {
             let t = this.rpTreeCache[e];
-            return t || (t = new nc(e, this.config, this.littleEndian, this.loader), await t.load(), this.rpTreeCache[e] = t, t)
+            return t || (t = new Uh(e, this.config, this.littleEndian, this.loader), await t.load(), this.rpTreeCache[e] = t, t)
         }
         async getType() {
             return await this.loadHeader(), this.type
         }
         async getTrackType() {
             return await this.loadHeader(), "bigwig" === this.type ? "wig" : this.autoSql && "chromatinInteract" === this.autoSql.table ? "interact" : "annotation"
         }
@@ -11616,104 +11654,104 @@
             if ("bigwig" === this.type) this.visibilityWindow = -1;
             else {
                 let t = this.genome ? this.genome.getGenomeLength() : 3088286401;
                 this.visibilityWindow = e.dataCount < 1e3 ? -1 : t / e.dataCount * 1e3
             }
         }
     }
-    class ic {
+    class Vh {
         constructor(e, t) {
             this.index = e, this.reductionLevel = t.getInt(), this.reserved = t.getInt(), this.dataOffset = t.getLong(), this.indexOffset = t.getLong()
         }
     }
-    class nc {
+    class Uh {
         constructor(e, t, i, n) {
             this.config = t, this.loader = n, this.fileOffset = e, this.path = t.url, this.littleEndian = i
         }
         async load() {
             const e = this.fileOffset + 48,
-                t = Ho(this.path) ? this.loader : new Jh(this.config, ec);
+                t = Bo(this.path) ? this.loader : new Dh(this.config, zh);
             return this.rootNode = await this.readNode(e, t), this
         }
         async readNode(e, t) {
             let i = await t.dataViewForRange({
                     start: e,
                     size: 4
                 }, !1),
-                n = new hh(i, this.littleEndian);
+                n = new eh(i, this.littleEndian);
             const r = 1 === n.getByte();
             n.getByte();
             const s = n.getUShort();
             let o = {
                 start: e += 4,
                 size: s * (r ? 32 : 24)
             };
             i = await t.dataViewForRange(o, !1);
             const a = new Array(s);
-            if (n = new hh(i), r) {
+            if (n = new eh(i), r) {
                 for (let e = 0; e < s; e++) {
                     let t = {
                         isLeaf: !0,
                         startChrom: n.getInt(),
                         startBase: n.getInt(),
                         endChrom: n.getInt(),
                         endBase: n.getInt(),
                         dataOffset: n.getLong(),
                         dataSize: n.getLong()
                     };
                     a[e] = t
                 }
-                return new rc(a)
+                return new qh(a)
             }
             for (let e = 0; e < s; e++) {
                 let t = {
                     isLeaf: !1,
                     startChrom: n.getInt(),
                     startBase: n.getInt(),
                     endChrom: n.getInt(),
                     endBase: n.getInt(),
                     childOffset: n.getLong()
                 };
                 a[e] = t
             }
-            return new rc(a)
+            return new qh(a)
         }
         async findLeafItemsOverlapping(e, t, i, n) {
             let r = this;
             return new Promise((function(s, o) {
                 let a = [],
                     l = new Set,
-                    h = Ho(r.path) ? r.loader : new Jh(r.config, ec);
+                    h = Bo(r.path) ? r.loader : new Dh(r.config, zh);
                 l.add(0),
                     function c(d, u) {
-                        if (oc(d, e, t, i, n)) {
+                        if ($h(d, e, t, i, n)) {
                             d.items.forEach((function(s) {
-                                oc(s, e, t, i, n) && (s.isLeaf ? a.push(s) : s.childNode ? c(s.childNode) : (l.add(s.childOffset), r.readNode(s.childOffset, h).then((function(e) {
+                                $h(s, e, t, i, n) && (s.isLeaf ? a.push(s) : s.childNode ? c(s.childNode) : (l.add(s.childOffset), r.readNode(s.childOffset, h).then((function(e) {
                                     s.childNode = e, c(e, s.childOffset)
                                 })).catch(o)))
                             }))
                         }
                         void 0 !== u && l.delete(u);
                         0 === l.size && s(a)
                     }(r.rootNode, 0)
             }))
         }
     }
-    class rc {
+    class qh {
         constructor(e) {
             this.items = e;
             let t, i, n = Number.MAX_SAFE_INTEGER,
                 r = 0,
                 s = Number.MAX_SAFE_INTEGER,
                 o = 0;
             for (t = 0; t < e.length; t++) i = e[t], n = Math.min(n, i.startChrom), r = Math.max(r, i.endChrom), s = Math.min(s, i.startBase), o = Math.max(o, i.endBase);
             this.startChrom = n, this.endChrom = r, this.startBase = s, this.endBase = o
         }
     }
-    class sc {
+    class jh {
         constructor(e, t, i) {
             let n = e.getInt(),
                 r = e.getInt(),
                 s = e.getInt(),
                 o = e.getInt(),
                 a = e.getLong(),
                 l = e.getLong(),
@@ -11736,83 +11774,86 @@
                         for (a = 0; a < g; a++) l = n.getFixedLengthTrimmedString(s), d = n.getInt(), n.getInt(), i && (l = i.getChromosomeName(l)), h[l] = d, c[d] = l;
                     else
                         for (a = 0; a < g; a++) l = n.getFixedLengthTrimmedString(s), u = n.getLong(), f = u - t, p = n.position, e(n, f), n.position = p
                 }(e, -1)
         }
     }
 
-    function oc(e, t, i, n, r) {
+    function $h(e, t, i, n, r) {
         return e ? (n > e.startChrom || n === e.startChrom && r >= e.startBase) && (t < e.endChrom || t === e.endChrom && i <= e.endBase) : (console.log("null item for " + t + " " + i + " " + r), !1)
     }
-    class ac {
+    class Wh {
         constructor(e) {
-            e ? (this.basesCovered = e.getLong(), this.minVal = e.getDouble(), this.maxVal = e.getDouble(), this.sumData = e.getDouble(), this.sumSquares = e.getDouble(), lc.call(this)) : (this.basesCovered = 0, this.minVal = 0, this.maxVal = 0, this.sumData = 0, this.sumSquares = 0, this.mean = 0, this.stddev = 0)
+            e ? (this.basesCovered = e.getLong(), this.minVal = e.getDouble(), this.maxVal = e.getDouble(), this.sumData = e.getDouble(), this.sumSquares = e.getDouble(), Gh.call(this)) : (this.basesCovered = 0, this.minVal = 0, this.maxVal = 0, this.sumData = 0, this.sumSquares = 0, this.mean = 0, this.stddev = 0)
         }
     }
 
-    function lc() {
+    function Gh() {
         let e = this.basesCovered;
         if (e > 0) {
             this.mean = this.sumData / e, this.stddev = Math.sqrt(this.sumSquares / (e - 1));
             let t = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,
                 i = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;
             this.defaultRange = {
                 min: t,
                 max: i
             }
         }
     }
 
-    function hc(e, t, i, n, r, s, o) {
-        const a = new hh(e),
-            l = a.getInt();
-        let h = a.getInt(),
-            c = a.getInt();
-        const d = a.getInt(),
-            u = a.getInt(),
-            f = a.getByte();
+    function Zh(e, t, i, n, r, s, o) {
+        const a = new eh(e),
+            l = a.getInt(),
+            h = a.getInt();
+        let c = h,
+            d = a.getInt();
+        const u = a.getInt(),
+            f = a.getInt(),
+            p = a.getByte();
         a.getByte();
-        let p = a.getUShort();
-        if (l >= t && l <= n)
-            for (; p-- > 0;) {
-                let e;
-                switch (f) {
+        let g = a.getUShort();
+        if (l >= t && l <= n) {
+            let e = 0;
+            for (; g-- > 0;) {
+                let g;
+                switch (p) {
                     case 1:
-                        h = a.getInt(), c = a.getInt(), e = a.getFloat();
+                        c = a.getInt(), d = a.getInt(), g = a.getFloat();
                         break;
                     case 2:
-                        h = a.getInt(), e = a.getFloat(), c = h + u;
+                        c = a.getInt(), g = a.getFloat(), d = c + f;
                         break;
                     case 3:
-                        e = a.getFloat(), c = h + u, h += d
+                        g = a.getFloat(), c = h + e * u, d = c + f, e++
                 }
-                if (!(l < t || l === t && c < i)) {
-                    if (l > n || l === n && h >= r) break;
-                    if (Number.isFinite(e)) {
-                        const t = o[l];
+                if (!(l < t || l === t && d < i)) {
+                    if (l > n || l === n && c >= r) break;
+                    if (Number.isFinite(g)) {
+                        const e = o[l];
                         s.push({
-                            chr: t,
-                            start: h,
-                            end: c,
-                            value: e
+                            chr: e,
+                            start: c,
+                            end: d,
+                            value: g
                         })
                     }
                 }
             }
+        }
     }
 
-    function cc() {
+    function Qh() {
         const e = function(e, t, i, n) {
             if ("biginteract" === n || i && "chromatinInteract" === i.table || "interact" === i.table) return function(e, t) {
                 return e.chr1 = t[5], e.start1 = Number.parseInt(t[6]), e.end1 = Number.parseInt(t[7]), e.chr2 = t[10], e.start2 = Number.parseInt(t[11]), e.end2 = Number.parseInt(t[12]), e.name = t[0], e.score = Number(t[1]), e.value = Number(t[2]), e.color = "." === t[4] ? void 0 : "0" === t[4] ? "rgb(0,0,0)" : t[4], e
             }; {
                 const n = e - 3;
                 return function(r, s) {
                     if (n > 0 && (r.name = s[0]), n > 1 && (r.score = Number(s[1])), n > 2 && (r.strand = s[2]), n > 3 && (r.cdStart = parseInt(s[3])), n > 4 && (r.cdEnd = parseInt(s[4])), n > 5 && "." !== s[5] && "0" !== s[5] && "-1" !== s[5]) {
-                        const e = js.createColorString(s[5]);
+                        const e = Ds.createColorString(s[5]);
                         r.color = e.startsWith("rgb") ? e : void 0
                     }
                     if (n > 8) {
                         const e = parseInt(s[6]),
                             t = s[7].split(","),
                             i = s[8].split(","),
                             n = [];
@@ -11838,15 +11879,15 @@
                                     t = s[n - 3];
                                 r[e] = t
                             }
                 }
             }
         }(this.header.definedFieldCount, this.header.fieldCount, this.autoSql, this.format);
         return function(t, i, n, r, s, o, a) {
-            const l = new hh(t);
+            const l = new eh(t);
             for (; l.remLength() >= 13;) {
                 const t = l.getInt(),
                     h = a[t],
                     c = l.getInt(),
                     d = l.getInt(),
                     u = l.getString();
                 if (!(t < i || t === i && d < n)) {
@@ -11862,16 +11903,16 @@
                         e(t, i)
                     }
                 }
             }
         }
     }
 
-    function dc(e, t, i, n, r, s, o, a) {
-        const l = new hh(e);
+    function Xh(e, t, i, n, r, s, o, a) {
+        const l = new eh(e);
         for (; l.remLength() >= 32;) {
             const e = l.getInt(),
                 h = o[e],
                 c = l.getInt(),
                 d = l.getInt(),
                 u = l.getInt(),
                 f = l.getFloat(),
@@ -11895,41 +11936,41 @@
                     start: c,
                     end: d,
                     value: m
                 })
             }
         }
     }
-    class uc {
+    class Yh {
         constructor(e) {
-            this.data = Hs(e).buffer
+            this.data = Fs(e).buffer
         }
         loadArrayBuffer(e, t) {
             const i = t.range;
             return i ? this.data.slice(i.start, i.start + i.size) : this.data
         }
         async dataViewForRange(e, t) {
             const i = Math.min(this.data.byteLength - e.start, e.size);
             return t ? new Uint8Array(this.data, e.start, i) : new DataView(this.data, e.start, i)
         }
     }
-    class fc {
+    class Kh {
         constructor(e, t) {
-            this.reader = new tc(e, t), this.genome = t, this.format = e.format || "bigwig", this.wgValues = {}
+            this.reader = new Hh(e, t), this.genome = t, this.format = e.format || "bigwig", this.wgValues = {}, this.queryable = !0
         }
         async getFeatures({
             chr: e,
             start: t,
             end: i,
             bpPerPixel: n,
             windowFunction: r
         }) {
             const s = "bigwig" === this.reader.type,
                 o = "all" === e.toLowerCase() ? s ? await this.getWGValues(r) : [] : await this.reader.readFeatures(e, t, e, i, n, r);
-            return s || Zh(o), o
+            return s || Fh(o), o
         }
         async getHeader() {
             return this.reader.loadHeader()
         }
         getDefaultRange() {
             return void 0 !== this.reader.totalSummary ? this.reader.totalSummary.defaultRange : void 0
         }
@@ -11954,40 +11995,40 @@
         supportsWholeGenome() {
             return "bigwig" === this.reader.type
         }
         async trackType() {
             return this.reader.getTrackType()
         }
     }
-    class pc {
+    class Jh {
         constructor(e, t) {
             this.config = e, this.genome = t, this.path = e.url, this.groupCache = {}, this.datasetCache = {}
         }
         async readHeader() {
             if (void 0 !== this.magic) return this;
-            let e = await lo.loadArrayBuffer(this.path, No(this.config, {
+            let e = await io.loadArrayBuffer(this.path, Mo(this.config, {
                     range: {
                         start: 0,
                         size: 64e3
                     }
                 })),
-                t = new hh(new DataView(e));
+                t = new eh(new DataView(e));
             if (this.magic = t.getInt(), this.version = t.getInt(), this.indexPos = t.getLong(), this.indexSize = t.getInt(), t.getInt(), this.version >= 2) {
                 let e = t.getInt();
                 for (this.windowFunctions = []; e-- > 0;) this.windowFunctions.push(t.getString())
             }
             this.trackType = t.getString(), this.trackLine = t.getString();
             let i = t.getInt();
             for (this.trackNames = []; i-- > 0;) this.trackNames.push(t.getString());
-            this.genomeID = t.getString(), this.flags = t.getInt(), this.compressed = 0 != (1 & this.flags), e = await lo.loadArrayBuffer(this.path, No(this.config, {
+            this.genomeID = t.getString(), this.flags = t.getInt(), this.compressed = 0 != (1 & this.flags), e = await io.loadArrayBuffer(this.path, Mo(this.config, {
                 range: {
                     start: this.indexPos,
                     size: this.indexSize
                 }
-            })), t = new hh(new DataView(e)), this.datasetIndex = {};
+            })), t = new eh(new DataView(e)), this.datasetIndex = {};
             let n = t.getInt();
             for (; n-- > 0;) {
                 const e = t.getString(),
                     i = t.getLong(),
                     n = t.getInt();
                 this.datasetIndex[e] = {
                     position: i,
@@ -12011,22 +12052,22 @@
                 await this.readHeader();
                 const r = this.version < 2 ? "" : "/" + t,
                     s = "all" === e.toLowerCase() || void 0 === i ? "0" : i.toString();
                 let o;
                 o = "raw" === t ? "/" + e + "/raw" : "/" + e + "/z" + s + r;
                 const a = this.datasetIndex[o];
                 if (void 0 === a) return;
-                const l = await lo.loadArrayBuffer(this.path, No(this.config, {
+                const l = await io.loadArrayBuffer(this.path, Mo(this.config, {
                     range: {
                         start: a.position,
                         size: a.size
                     }
                 }));
                 if (!l) return;
-                const h = new hh(new DataView(l));
+                const h = new eh(new DataView(l));
                 let c = h.getInt();
                 const d = {};
                 for (; c-- > 0;) d[h.getString()] = h.getString();
                 const u = h.getString(),
                     f = h.getFloat();
                 let p = h.getInt();
                 const g = [];
@@ -12063,22 +12104,22 @@
         }
         async readGroup(e) {
             const t = this.groupCache[e];
             if (t) return t; {
                 await this.readHeader();
                 const t = this.groupIndex[e];
                 if (void 0 === t) return;
-                const i = await lo.loadArrayBuffer(this.path, No(this.config, {
+                const i = await io.loadArrayBuffer(this.path, Mo(this.config, {
                     range: {
                         start: t.position,
                         size: t.size
                     }
                 }));
                 if (!i) return;
-                const n = new hh(new DataView(i)),
+                const n = new eh(new DataView(i)),
                     r = {
                         name: e
                     };
                 let s = n.getInt();
                 for (; s-- > 0;) {
                     const e = n.getString(),
                         t = n.getString();
@@ -12093,78 +12134,78 @@
                 })), 0 === (e = e.filter((function(e) {
                     return e.size > 0
                 }))).length) return Promise.resolve([]);
             const i = e[0],
                 n = e[e.length - 1],
                 r = i.position,
                 s = n.position + n.size - r,
-                o = await lo.loadArrayBuffer(this.path, No(this.config, {
+                o = await io.loadArrayBuffer(this.path, Mo(this.config, {
                     range: {
                         start: r,
                         size: s
                     }
                 })),
                 a = [];
             for (let i of e) {
                 const e = i.position - r,
                     n = i.size;
                 if (n > 0) {
                     let i;
                     if (this.compressed) {
-                        i = Ls(o.slice(e, e + n)).buffer
+                        i = Ss(o.slice(e, e + n)).buffer
                     } else i = o.slice(e, e + n);
-                    const r = new hh(new DataView(i)),
+                    const r = new eh(new DataView(i)),
                         s = r.getString();
                     let l;
                     switch (s) {
                         case "fixedStep":
-                            l = gc(r, t);
+                            l = ec(r, t);
                             break;
                         case "variableStep":
-                            l = mc(r, t);
+                            l = tc(r, t);
                             break;
                         case "bed":
                         case "bedWithName":
-                            l = bc(r, t, s);
+                            l = ic(r, t, s);
                             break;
                         default:
                             throw "Unknown tile type: " + s
                     }
                     a.push(l)
                 }
             }
             return a
         }
         async readTile(e, t) {
-            let i = await lo.loadArrayBuffer(this.path, No(this.config, {
+            let i = await io.loadArrayBuffer(this.path, Mo(this.config, {
                 range: {
                     start: e.position,
                     size: e.size
                 }
             }));
             if (this.compressed) {
-                i = Ls(i).buffer
+                i = Ss(i).buffer
             }
-            const n = new hh(new DataView(i)),
+            const n = new eh(new DataView(i)),
                 r = n.getString();
             switch (r) {
                 case "fixedStep":
-                    return gc(n, t);
+                    return ec(n, t);
                 case "variableStep":
-                    return mc(n, t);
+                    return tc(n, t);
                 case "bed":
                 case "bedWithName":
-                    return bc(n, t, r);
+                    return ic(n, t, r);
                 default:
                     throw "Unknown tile type: " + r
             }
         }
     }
 
-    function gc(e, t) {
+    function ec(e, t) {
         const i = e.getInt(),
             n = e.getInt(),
             r = e.getFloat(),
             s = [];
         let o = t;
         for (; o-- > 0;) {
             let t = i;
@@ -12178,15 +12219,15 @@
             span: r,
             data: s,
             nTracks: t,
             nPositions: i
         }
     }
 
-    function mc(e, t) {
+    function tc(e, t) {
         const i = e.getInt(),
             n = e.getFloat(),
             r = e.getInt(),
             s = [];
         let o = r;
         for (; o-- > 0;) s.push(e.getInt());
         e.getInt();
@@ -12205,15 +12246,15 @@
             start: s,
             data: a,
             nTracks: t,
             nPositions: r
         }
     }
 
-    function bc(e, t, i) {
+    function ic(e, t, i) {
         const n = e.getInt();
         let r = n;
         const s = [];
         for (; r-- > 0;) s.push(e.getInt());
         r = n;
         const o = [];
         for (; r-- > 0;) o.push(e.getInt());
@@ -12236,17 +12277,17 @@
             start: s,
             end: o,
             data: a,
             nTracks: t,
             nPositions: n
         }
     }
-    class wc {
+    class nc {
         constructor(e, t) {
-            this.genome = t, this.windowFunction = e.windowFunction || "mean", this.reader = new pc(e, t)
+            this.genome = t, this.windowFunction = e.windowFunction || "mean", this.reader = new Jh(e, t), this.queryable = !0
         }
         async getFeatures({
             chr: e,
             start: t,
             end: i,
             bpPerPixel: n
         }) {
@@ -12265,59 +12306,59 @@
                             }
                     }
                 return e
             }
             return this._getFeatures(e, t, i, n)
         }
         async _getFeatures(e, t, i, n) {
-            const r = new ha(e, t, i),
+            const r = new ia(e, t, i),
                 s = this.genome;
             if (!this.rootGroup && (this.rootGroup = await this.reader.readRootGroup(), !this.normalizationFactor)) {
                 const e = this.rootGroup.totalCount;
                 e && (this.normalizationFactor = 1e6 / e)
             }
             r.bpPerPixel = n;
             const o = function(e, t, i) {
                 var n = i.getChromosome(e).bpLength;
-                return Math.ceil(Math.log(Math.max(0, n / (700 * t))) / xc)
+                return Math.ceil(Math.log(Math.max(0, n / (700 * t))) / ac)
             }(e, n, s);
             let a = this.reader.chrAliasTable[e],
                 l = this.reader.maxZoom;
             void 0 === a && (a = e), void 0 === l && (l = -1);
             const h = o > l ? "raw" : this.windowFunction,
                 c = await this.reader.readDataset(a, h, o);
             if (null == c) return [];
             const d = c.tileWidth,
                 u = Math.floor(t / d),
                 f = Math.floor(i / d),
                 p = await this.reader.readTiles(c.tiles.slice(u, f + 1), 1),
                 g = [];
             for (let r of p) switch (r.type) {
                 case "bed":
-                    vc(r, e, t, i, n, g);
+                    rc(r, e, t, i, n, g);
                     break;
                 case "variableStep":
-                    yc(r, e, t, i, n, g);
+                    sc(r, e, t, i, n, g);
                     break;
                 case "fixedStep":
-                    _c(r, e, t, i, n, g);
+                    oc(r, e, t, i, n, g);
                     break;
                 default:
                     throw "Unknown tile type: " + r.type
             }
             return g.sort((function(e, t) {
                 return e.start - t.start
             })), g
         }
         get supportsWholeGenome() {
             return !0
         }
     }
 
-    function vc(e, t, i, n, r, s) {
+    function rc(e, t, i, n, r, s) {
         const o = e.nPositions,
             a = e.start,
             l = e.end,
             h = e.data[0];
         for (let e = 0; e < o; e++) {
             const r = a[e],
                 o = l[e];
@@ -12329,15 +12370,15 @@
                     end: o,
                     value: h[e]
                 })
             }
         }
     }
 
-    function yc(e, t, i, n, r, s) {
+    function sc(e, t, i, n, r, s) {
         const o = e.nPositions,
             a = e.start,
             l = e.span,
             h = e.data[0];
         for (let e = 0; e < o; e++) {
             const r = a[e],
                 o = r + l;
@@ -12349,15 +12390,15 @@
                     end: o,
                     value: h[e]
                 })
             }
         }
     }
 
-    function _c(e, t, i, n, r, s) {
+    function oc(e, t, i, n, r, s) {
         const o = e.nPositions;
         let a = e.start;
         const l = e.span,
             h = e.data[0];
         for (let e = 0; e < o; e++) {
             const r = a + l;
             if (a > n) break;
@@ -12365,77 +12406,77 @@
                 chr: t,
                 start: a,
                 end: r,
                 value: h[e]
             })), a = r
         }
     }
-    var xc = Math.log(2);
-    class kc {
+    var ac = Math.log(2);
+    class lc {
         constructor(e, t) {
-            this.config = e, this.genome = t, this.queryable = !1, this.updateFeatures(e.features)
+            this.config = e, this.genome = t, this.queryable = !1, this.searchable = !1 !== e.searchable, this.updateFeatures(e.features)
         }
         updateFeatures(e) {
-            Yh(e = function(e, t) {
+            Oh(e = function(e, t) {
                 if (t)
                     for (let i of e) i.chr = t.getChromosomeName(i.chr);
                 return e
             }(e, this.genome)), this.config.mappings && function(e, t) {
                 let i = Object.keys(t);
                 e.forEach((function(e) {
                     i.forEach((function(i) {
                         e[i] = e[t[i]]
                     }))
                 }))
-            }(e, this.config.mappings), this.featureCache = new vo(e, this.genome)
+            }(e, this.config.mappings), this.featureCache = new fo(e, this.genome), (this.searchable || this.config.searchableFields) && this.genome.addFeaturesToDB(e, this.config)
         }
         async getFeatures({
             chr: e,
             start: t,
             end: i,
             bpPerPixel: n,
             visibilityWindow: r
         }) {
             const s = this.genome,
                 o = s ? s.getChromosomeName(e) : e;
-            return "all" === o.toLowerCase() ? Xh(this.featureCache.getAllFeatures(), this.genome, this.maxWGCount) : this.featureCache.queryFeatures(o, t, i)
+            return "all" === o.toLowerCase() ? Nh(this.featureCache.getAllFeatures(), this.genome, this.maxWGCount) : this.featureCache.queryFeatures(o, t, i)
         }
         getAllFeatures() {
             return this.featureCache.getAllFeatures()
         }
         supportsWholeGenome() {
             return !0
         }
     }
-    const Cc = new Set(["bigwig", "bw", "bigbed", "bb", "biginteract", "biggenepred", "bignarrowpeak"]);
+    const hc = new Set(["bigwig", "bw", "bigbed", "bb", "biginteract", "biggenepred", "bignarrowpeak"]);
 
-    function Sc(e, t) {
+    function cc(e, t) {
         const i = e.format ? e.format.toLowerCase() : void 0;
-        return e.features ? new kc(e, t) : Cc.has(i) ? new fc(e, t) : "tdf" === i ? new wc(e, t) : new Kh(e, t)
+        return e.features ? new lc(e, t) : hc.has(i) ? new Kh(e, t) : "tdf" === i ? new nc(e, t) : new Ph(e, t)
     }
-    const Ac = function(e, t) {
+    const dc = function(e, t) {
             const {
                 r: i,
                 g: n,
                 b: r
-            } = ko[e];
+            } = bo[e];
             return `rgba(${i},${n},${r},${t})`
         }("nickel", 2 / 16),
-        Ec = Ac;
-    class Tc {
+        uc = dc;
+    class fc {
         constructor(e, t) {
-            if (this.url = e.url, e.name ? this.name = e.name : e.url && ti(e.url) ? this.name = e.url.name : e.url && Qt(e.url) && !e.url.startsWith("data:") && (this.name = ei(e.url)), this.isUserDefined = e.isUserDefined, e.features) this.featureSource = new Lc(e.features, t);
+            if (this.url = e.url, e.name ? this.name = e.name : e.url && ti(e.url) ? this.name = e.url.name : e.url && Qt(e.url) && !e.url.startsWith("data:") && (this.name = ei(e.url)), this.isUserDefined = e.isUserDefined, e.features) this.featureSource = new gc(e.features, t);
             else {
                 if (e.format) e.format = e.format.toLowerCase();
                 else {
                     const t = ei(e.url);
-                    e.format = Xo(t)
+                    e.format = qo(t)
                 }
-                this.featureSource = e.featureSource || Sc(e, t)
-            }!0 === this.isUserDefined ? (this.color = e.color || Ec, this.headerColor = "rgba(155,185,129)") : (this.color = e.color || Ac, this.headerColor = "rgb(190,190,190)")
+                this.featureSource = e.featureSource || cc(e, t)
+            }!0 === this.isUserDefined ? (this.color = e.color || uc, this.headerColor = "rgba(155,185,129)") : (this.color = e.color || dc, this.headerColor = "rgb(190,190,190)")
         }
         async getFeatures(e, t, i) {
             return this.featureSource.getFeatures({
                 chr: e,
                 start: t,
                 end: i
             })
@@ -12468,40 +12509,39 @@
                 }
             }
         }
         dispose() {
             for (let e of Object.keys(this)) this[e] = void 0
         }
     }
-    const Mc = 3;
 
-    function Rc(e, t, i, n) {
+    function pc(e, t, i, n) {
         let r = Math.round((e - i) / n);
         let s = Math.round((t - i) / n) - r;
-        return s < Mc && (s = Mc, r -= 1), {
+        return s < 3 && (s = 3, r -= 1), {
             x: r,
             width: s
         }
     }
-    class Lc {
+    class gc {
         constructor(e, t) {
             this.featureMap = {}, this.genome = t;
             for (let i of e) {
                 const e = t ? t.getChromosomeName(i.chr) : i.chr;
                 let n = this.featureMap[e];
                 n || (n = [], this.featureMap[e] = n), n.push(i)
             }
             for (let e of Object.keys(this.featureMap)) this.featureMap[e].sort(((e, t) => e.start - t.start))
         }
         getFeatures({
             chr: e,
             start: t,
             end: i
         }) {
-            if ("all" === e.toLowerCase()) return Xh(this.featureMap, this.genome); {
+            if ("all" === e.toLowerCase()) return Nh(this.featureMap, this.genome); {
                 const n = this.featureMap[e];
                 return n ? n.filter((e => e.end > t && e.start < i)) : []
             }
         }
         getAllFeatures() {
             return this.featureMap
         }
@@ -12519,69 +12559,68 @@
         }) {
             if (this.featureMap[e]) {
                 const n = `${e}-${t}-${i}`;
                 this.featureMap[e] = this.featureMap[e].filter((e => n !== `${e.chr}-${e.start}-${e.end}`))
             }
         }
     }
-    class Ic {
+    class mc {
         constructor(e, t, i, n) {
             this.rulerViewport = e, this.rulerSweeper = _t.div({
                 class: "igv-ruler-sweeper"
             }), t.appendChild(this.rulerSweeper), this.browser = i, this.referenceFrame = n, this.isMouseHandlers = void 0, this.addBrowserObserver()
         }
         addBrowserObserver() {
             this.boundObserverHandler = (() => {
-                this.referenceFrame && (za.isWholeGenomeView(this.referenceFrame.chr) ? this.removeMouseHandlers() : this.addMouseHandlers())
+                this.referenceFrame && (La.isWholeGenomeView(this.referenceFrame.chr) ? this.removeMouseHandlers() : this.addMouseHandlers())
             }).bind(this), this.browser.on("locuschange", this.boundObserverHandler)
         }
         removeBrowserObserver() {
             this.browser.off("locuschange", this.boundObserverHandler)
         }
         addMouseHandlers() {
             if (!0 === this.isMouseHandlers) return;
-            const e = 1;
-            let t, i, n, r, s, o;
-            this.boundContentMouseDownHandler = function(o) {
-                t = !0, i = !0;
+            let e, t, i, n, r, s;
+            this.boundContentMouseDownHandler = function(s) {
+                e = !0, t = !0;
                 const {
-                    x: a
-                } = _t.translateMouseCoordinates(o, this.rulerViewport.contentDiv);
-                r = n = a, s = e, this.rulerSweeper.style.display = "block", this.rulerSweeper.style.backgroundColor = !0 === o.shiftKey ? Ec : "rgba(68, 134, 247, 0.25)", this.rulerSweeper.style.left = `${r}px`, this.rulerSweeper.style.width = `${s}px`
-            }.bind(this), this.rulerViewport.contentDiv.addEventListener("mousedown", this.boundContentMouseDownHandler), this.boundDocumentMouseMoveHandler = function(e) {
+                    x: o
+                } = _t.translateMouseCoordinates(s, this.rulerViewport.contentDiv);
+                n = i = o, r = 1, this.rulerSweeper.style.display = "block", this.rulerSweeper.style.backgroundColor = !0 === s.shiftKey ? uc : "rgba(68, 134, 247, 0.25)", this.rulerSweeper.style.left = `${n}px`, this.rulerSweeper.style.width = `${r}px`
+            }.bind(this), this.rulerViewport.contentDiv.addEventListener("mousedown", this.boundContentMouseDownHandler), this.boundDocumentMouseMoveHandler = function(o) {
                 let a;
-                if (t && i) {
+                if (e && t) {
                     const {
-                        x: t
-                    } = _t.translateMouseCoordinates(e, this.rulerViewport.contentDiv);
-                    a = Math.max(Math.min(t, this.rulerViewport.contentDiv.clientWidth), 0), o = a - n, s = Math.abs(o), this.rulerSweeper.style.width = `${s}px`, o < 0 && (r = n + o, this.rulerSweeper.style.left = `${r}px`)
-                }
-            }.bind(this), document.addEventListener("mousemove", this.boundDocumentMouseMoveHandler), this.boundDocumentMouseUpHandler = function(n) {
-                let o;
-                if (!0 === t && !0 === i && (t = i = void 0, this.rulerSweeper.style.display = "none", s > e)) {
-                    o = {
-                        start: Math.floor(this.referenceFrame.calculateEnd(r)),
-                        end: Math.floor(this.referenceFrame.calculateEnd(r + s))
+                        x: e
+                    } = _t.translateMouseCoordinates(o, this.rulerViewport.contentDiv);
+                    a = Math.max(Math.min(e, this.rulerViewport.contentDiv.clientWidth), 0), s = a - i, r = Math.abs(s), this.rulerSweeper.style.width = `${r}px`, s < 0 && (n = i + s, this.rulerSweeper.style.left = `${n}px`)
+                }
+            }.bind(this), document.addEventListener("mousemove", this.boundDocumentMouseMoveHandler), this.boundDocumentMouseUpHandler = function(i) {
+                let s;
+                if (!0 === e && !0 === t && (e = t = void 0, this.rulerSweeper.style.display = "none", r > 1)) {
+                    s = {
+                        start: Math.floor(this.referenceFrame.calculateEnd(n)),
+                        end: Math.floor(this.referenceFrame.calculateEnd(n + r))
                     };
-                    !0 === n.shiftKey ? this.browser.roiManager.updateUserDefinedROISet(Object.assign({
+                    !0 === i.shiftKey ? this.browser.roiManager.updateUserDefinedROISet(Object.assign({
                         chr: this.referenceFrame.chr
-                    }, o)) : (Po(this.browser.genome.getChromosome(this.referenceFrame.chr).bpLength, o, this.browser.minimumBases()), function(e, t, i) {
+                    }, s)) : (Ro(this.browser.genome.getChromosome(this.referenceFrame.chr).bpLength, s, this.browser.minimumBases()), function(e, t, i) {
                         e.start = Math.round(t.start), e.end = Math.round(t.end), e.bpPerPixel = (e.end - e.start) / i
-                    }(this.referenceFrame, o, this.rulerViewport.contentDiv.clientWidth), this.browser.updateViews(this.referenceFrame))
+                    }(this.referenceFrame, s, this.rulerViewport.contentDiv.clientWidth), this.browser.updateViews(this.referenceFrame))
                 }
             }.bind(this), document.addEventListener("mouseup", this.boundDocumentMouseUpHandler), this.isMouseHandlers = !0
         }
         removeMouseHandlers() {
             this.rulerViewport.contentDiv.removeEventListener("mousedown", this.boundContentMouseDownHandler), document.removeEventListener("mousemove", this.boundDocumentMouseMoveHandler), document.removeEventListener("mouseup", this.boundDocumentMouseUpHandler), this.isMouseHandlers = !1
         }
         dispose() {
             this.removeBrowserObserver(), this.removeMouseHandlers(), this.rulerSweeper.remove()
         }
     }
-    class Bc {
+    class bc {
         constructor(e) {
             this.paired = !0, this.firstAlignment = e, this.chr = e.chr, this.readName = e.readName, e.start < e.mate.position ? (this.start = e.start, this.scStart = e.scStart, this.connectingStart = e.start + e.lengthOnRef, this.connectingEnd = e.mate.position) : (this.start = e.mate.position, this.scStart = this.start, this.connectingStart = e.mate.position, this.connectingEnd = e.start), this.end = Math.max(e.mate.position, e.start + e.lengthOnRef), this.lengthOnRef = this.end - this.start;
             let t = Math.max(this.end, e.scStart + e.scLengthOnRef);
             this.scLengthOnRef = t - this.scStart
         }
         setSecondAlignment(e) {
             this.secondAlignment = e;
@@ -12617,15 +12656,15 @@
         firstOfPairStrand() {
             return this.firstAlignment.isFirstOfPair() ? this.firstAlignment.strand : this.secondAlignment && this.secondAlignment.isFirstOfPair() ? this.secondAlignment.strand : this.firstAlignment.mate.strand
         }
         hasTag(e) {
             return this.firstAlignment.hasTag(e) || this.secondAlignment && this.secondAlignment.hasTag(e)
         }
     }
-    class Nc {
+    class wc {
         constructor() {
             this.alignments = [], this.score = void 0
         }
         findAlignment(e) {
             const t = (e, t) => t >= e.start && t < e.start + e.lengthOnRef;
             let i;
             for (let n = 0; n < this.alignments.length; n++) {
@@ -12693,72 +12732,71 @@
                 case "ALIGNED_READ_LENGTH":
                     return -r.lengthOnRef;
                 default:
                     return Number.MAX_VALUE
             }
         }
     }
-    const Fc = 2;
 
-    function Pc(e) {
+    function vc(e) {
         return e.isPaired() && e.mate && e.isMateMapped() && e.chr === e.mate.chr && (e.isFirstOfPair() || e.isSecondOfPair()) && !(e.isSecondary() || e.isSupplementary())
     }
 
-    function Oc(e) {
+    function yc(e) {
         const t = [];
         for (let i of e)
-            for (let e of i.alignments) e instanceof Bc ? (e.firstAlignment && t.push(e.firstAlignment), e.secondAlignment && t.push(e.secondAlignment)) : t.push(e);
+            for (let e of i.alignments) e instanceof bc ? (e.firstAlignment && t.push(e.firstAlignment), e.secondAlignment && t.push(e.secondAlignment)) : t.push(e);
         return t
     }
 
-    function Dc(e, t, i, n) {
+    function _c(e, t, i, n) {
         if (e) {
             if (0 === e.length) return []; {
                 e.sort((function(e, t) {
                     return n ? e.scStart - t.scStart : e.start - t.start
                 }));
                 const t = [];
                 let i, r = 0,
                     s = 0;
                 const o = new Set,
                     a = () => {
-                        i = new Nc, t.push(i), r = 0, s = 0, o.clear()
+                        i = new wc, t.push(i), r = 0, s = 0, o.clear()
                     };
                 for (a(); e.length > 0;)
                     if (s >= 0 && s < e.length) {
                         const t = e[s];
-                        o.add(t), i.alignments.push(t), r = n ? t.scStart + t.scLengthOnRef + Fc : t.start + t.lengthOnRef + Fc, s = zc(e, (e => (n ? e.scStart : e.start) > r), s)
+                        o.add(t), i.alignments.push(t), r = n ? t.scStart + t.scLengthOnRef + 2 : t.start + t.lengthOnRef + 2, s = xc(e, (e => (n ? e.scStart : e.start) > r), s)
                     } else e = e.filter((e => !o.has(e))), a();
                 return t
             }
         }
     }
 
-    function zc(e, t, i) {
+    function xc(e, t, i) {
         let n = i - 1,
             r = e.length;
         for (; 1 + n < r;) {
             const i = n + (r - n >> 1);
             t(e[i]) ? r = i : n = i
         }
         return r
     }
-    class Hc {
+    class kc {
         constructor(e, t, i, {
             samplingWindowSize: n,
             samplingDepth: r,
             pairsSupported: s,
             alleleFreqThreshold: o
         }) {
-            this.chr = e, this.start = Math.floor(t), this.end = Math.ceil(i), this.length = i - t, this.alleleFreqThreshold = void 0 === o ? .2 : o, this.coverageMap = new Uc(e, t, i, this.alleleFreqThreshold), this.alignments = [], this.downsampledIntervals = [], this.samplingWindowSize = void 0 === n ? 100 : n, this.samplingDepth = void 0 === r ? 1e3 : r, this.pairsSupported = void 0 === s || s, this.paired = !1, this.pairsCache = {}, this.downsampledReads = new Set, this.currentBucket = new Vc(this.start, this.start + this.samplingWindowSize, this), this.filter = function(e) {
+            this.chr = e, this.start = Math.floor(t), this.end = Math.ceil(i), this.length = i - t, this.alleleFreqThreshold = void 0 === o ? .2 : o, this.coverageMap = new Sc(e, t, i, this.alleleFreqThreshold), this.alignments = [], this.downsampledIntervals = [], this.samplingWindowSize = void 0 === n ? 100 : n, this.samplingDepth = void 0 === r ? 1e3 : r, this.pairsSupported = void 0 === s || s, this.paired = !1, this.pairsCache = {}, this.downsampledReads = new Set, this.currentBucket = new Cc(this.start, this.start + this.samplingWindowSize, this), this.filter = function(e) {
                 return e.isMapped() && !e.isFailsVendorQualityCheck()
             }
         }
         push(e) {
-            !1 !== this.filter(e) && (this.coverageMap.incCounts(e), this.pairsSupported && this.downsampledReads.has(e.readName) || (e.start >= this.currentBucket.end && (this.finishBucket(), this.currentBucket = new Vc(e.start, e.start + this.samplingWindowSize, this)), this.currentBucket.addAlignment(e)))
+            !1 !== this.filter(e) && (this.coverageMap.incCounts(e), this.pairsSupported && this.downsampledReads.has(e.readName) || (e.start >= this.currentBucket.end && (this.finishBucket(), this.currentBucket = new Cc(e.start, e.start + this.samplingWindowSize, this)), this.currentBucket.addAlignment(e)))
         }
         forEach(e) {
             this.alignments.forEach(e)
         }
         finish() {
             void 0 !== this.currentBucket && this.finishBucket(), this.alignments.sort((function(e, t) {
                 return e.start - t.start
@@ -12767,37 +12805,37 @@
         contains(e, t, i) {
             return this.chr === e && this.start <= t && this.end >= i
         }
         hasDownsampledIntervals() {
             return this.downsampledIntervals && this.downsampledIntervals.length > 0
         }
         finishBucket() {
-            this.alignments = this.alignments.concat(this.currentBucket.alignments), this.currentBucket.downsampledCount > 0 && this.downsampledIntervals.push(new jc(this.currentBucket.start, this.currentBucket.end, this.currentBucket.downsampledCount)), this.paired = this.paired || this.currentBucket.paired
+            this.alignments = this.alignments.concat(this.currentBucket.alignments), this.currentBucket.downsampledCount > 0 && this.downsampledIntervals.push(new Ec(this.currentBucket.start, this.currentBucket.end, this.currentBucket.downsampledCount)), this.paired = this.paired || this.currentBucket.paired
         }
         setViewAsPairs(e) {
             let t;
             t = e ? function(e) {
                 const t = {},
                     i = [];
                 for (let n of e)
                     for (let e of n.alignments)
-                        if (Pc(e)) {
+                        if (vc(e)) {
                             let n = t[e.readName];
-                            n ? (n.setSecondAlignment(e), t[e.readName] = void 0) : (n = new Bc(e), t[e.readName] = n, i.push(n))
+                            n ? (n.setSecondAlignment(e), t[e.readName] = void 0) : (n = new bc(e), t[e.readName] = n, i.push(n))
                         } else i.push(e);
                 return i
-            }(this.packedAlignmentRows) : Oc(this.packedAlignmentRows), this.packedAlignmentRows = Dc(t, this.start, this.end)
+            }(this.packedAlignmentRows) : yc(this.packedAlignmentRows), this.packedAlignmentRows = _c(t, this.start, this.end)
         }
         setShowSoftClips(e) {
             const t = this.allAlignments();
-            this.packedAlignmentRows = Dc(t, this.start, this.end, e)
+            this.packedAlignmentRows = _c(t, this.start, this.end, e)
         }
         repack(e, t) {
             const i = this.allAlignments();
-            this.packedAlignmentRows = Dc(i, this.start, this.end, t)
+            this.packedAlignmentRows = _c(i, this.start, this.end, t)
         }
         allAlignments() {
             const e = [];
             for (let t of this.packedAlignmentRows)
                 for (let i of t.alignments) e.push(i);
             return e
         }
@@ -12819,25 +12857,25 @@
                 const o = r > s ? 1 : r < s ? -1 : 0;
                 return !0 === n ? o : -o
             }));
             for (let e of i) t.push(e);
             this.packedAlignmentRows = t
         }
     }
-    class Vc {
+    class Cc {
         constructor(e, t, i) {
             this.start = e, this.end = t, this.alignments = [], this.downsampledCount = 0, this.samplingDepth = i.samplingDepth, this.pairsSupported = i.pairsSupported, this.downsampledReads = i.downsampledReads, this.pairsCache = i.pairsCache
         }
         addAlignment(e) {
             var t, i, n;
-            if (this.pairsSupported && Pc(e) && (n = this.pairsCache[e.readName])) return n.setSecondAlignment(e), void(this.pairsCache[e.readName] = void 0);
-            this.alignments.length < this.samplingDepth ? this.pairsSupported && Pc(e) ? (n = new Bc(e), this.paired = !0, this.pairsCache[e.readName] = n, this.alignments.push(n)) : this.alignments.push(e) : ((t = Math.floor(Math.random() * (this.samplingDepth + this.downsampledCount - 1))) < this.samplingDepth ? (i = this.alignments[t], this.pairsSupported && Pc(e) ? (void 0 !== this.pairsCache[i.readName] && (this.pairsCache[i.readName] = void 0), n = new Bc(e), this.paired = !0, this.pairsCache[e.readName] = n, this.alignments[t] = n) : this.alignments[t] = e, this.downsampledReads.add(i.readName)) : this.downsampledReads.add(e.readName), this.downsampledCount++)
+            if (this.pairsSupported && vc(e) && (n = this.pairsCache[e.readName])) return n.setSecondAlignment(e), void(this.pairsCache[e.readName] = void 0);
+            this.alignments.length < this.samplingDepth ? this.pairsSupported && vc(e) ? (n = new bc(e), this.paired = !0, this.pairsCache[e.readName] = n, this.alignments.push(n)) : this.alignments.push(e) : ((t = Math.floor(Math.random() * (this.samplingDepth + this.downsampledCount - 1))) < this.samplingDepth ? (i = this.alignments[t], this.pairsSupported && vc(e) ? (void 0 !== this.pairsCache[i.readName] && (this.pairsCache[i.readName] = void 0), n = new bc(e), this.paired = !0, this.pairsCache[e.readName] = n, this.alignments[t] = n) : this.alignments[t] = e, this.downsampledReads.add(i.readName)) : this.downsampledReads.add(e.readName), this.downsampledCount++)
         }
     }
-    class Uc {
+    class Sc {
         constructor(e, t, i, n) {
             this.chr = e, this.bpStart = t, this.length = i - t, this.coverage = new Array(this.length), this.maximum = 0, this.threshold = n, this.qualityWeight = !0
         }
         getMax(e, t) {
             let i = 0;
             const n = this.coverage.length;
             for (let r = 0; r < n; r++) {
@@ -12852,37 +12890,37 @@
             var t = this;
             if (void 0 === e.blocks ? i(e) : e.blocks.forEach((function(e) {
                     i(e)
                 })), e.gaps)
                 for (let i of e.gaps)
                     if ("D" === i.type) {
                         const e = i.start - t.bpStart;
-                        for (let n = e; n < e + i.len; n++) n < 0 || (this.coverage[n] || (this.coverage[n] = new qc(t.threshold)), this.coverage[n].del++)
+                        for (let n = e; n < e + i.len; n++) n < 0 || (this.coverage[n] || (this.coverage[n] = new Ac(t.threshold)), this.coverage[n].del++)
                     } if (e.insertions)
                 for (let i of e.insertions) {
                     const e = i.start - this.bpStart;
-                    e < 0 || (this.coverage[e] || (this.coverage[e] = new qc(t.threshold)), this.coverage[e].ins++)
+                    e < 0 || (this.coverage[e] || (this.coverage[e] = new Ac(t.threshold)), this.coverage[e].ins++)
                 }
 
             function i(i) {
                 if ("S" === i.type) return;
                 const n = e.seq,
                     r = e.qual,
                     s = i.seqOffset;
                 for (let o = i.start - t.bpStart, a = 0; a < i.len; o++, a++) {
-                    t.coverage[o] || (t.coverage[o] = new qc(t.threshold));
+                    t.coverage[o] || (t.coverage[o] = new Ac(t.threshold));
                     const i = null == n ? "N" : n.charAt(s + a),
                         l = e.strand ? "pos" + i : "neg" + i,
                         h = r && s + a < r.length ? r[s + a] : 30;
                     t.coverage[o][l] += 1, t.coverage[o]["qual" + i] += h, t.coverage[o].total += 1, t.coverage[o].qual += h, t.maximum = Math.max(t.coverage[o].total, t.maximum)
                 }
             }
         }
     }
-    class qc {
+    class Ac {
         constructor(e) {
             this.qualityWeight = !0, this.posA = 0, this.negA = 0, this.posT = 0, this.negT = 0, this.posC = 0, this.negC = 0, this.posG = 0, this.negG = 0, this.posN = 0, this.negN = 0, this.pos = 0, this.neg = 0, this.qualA = 0, this.qualT = 0, this.qualC = 0, this.qualG = 0, this.qualN = 0, this.qual = 0, this.total = 0, this.del = 0, this.ins = 0, this.threshold = e
         }
         hoverText() {
             const e = this.posA + this.posT + this.posC + this.posG + this.posN,
                 t = this.negA + this.negT + this.negC + this.negG + this.negN;
             return `${this.total} (${e}+, ${t}-)`
@@ -12890,15 +12928,15 @@
         isMismatch(e) {
             const t = this.threshold * (this.qualityWeight && this.qual ? this.qual : this.total);
             let i = 0;
             for (let t of ["A", "T", "C", "G"]) t !== e && (i += this.qualityWeight && this.qual ? this["qual" + t] : this["pos" + t] + this["neg" + t]);
             return i >= t
         }
     }
-    class jc {
+    class Ec {
         constructor(e, t, i) {
             this.start = e, this.end = t, this.counts = i
         }
         popupData(e) {
             return [{
                 name: "start",
                 value: this.start + 1
@@ -12907,37 +12945,37 @@
                 value: this.end
             }, {
                 name: "# downsampled:",
                 value: this.counts
             }]
         }
     }
-    class $c {
+    class Mc {
         constructor(e) {
             const t = e.split(",");
-            this.chr = t[0], this.start = parseInt(t[1]), this.strand = t[2].charAt(0), this.mapQ = parseInt(t[4]), this.numMismatches = parseInt(t[5]), this.lenOnRef = ld.computeLengthOnReference(t[3])
+            this.chr = t[0], this.start = parseInt(t[1]), this.strand = t[2].charAt(0), this.mapQ = parseInt(t[4]), this.numMismatches = parseInt(t[5]), this.lenOnRef = $c.computeLengthOnReference(t[3])
         }
         printString() {
             return this.chr + ":" + Xt(this.start) + "-" + Xt(this.start + this.lenOnRef) + " (" + this.strand + ") = " + Xt(this.lenOnRef) + "bp @MAPQ: " + this.mapQ + " NM: " + this.numMismatches
         }
     }
 
-    function Wc(e) {
-        return e.split(";").filter((e => e.length > 0)).map((e => new $c(e)))
+    function Tc(e) {
+        return e.split(";").filter((e => e.length > 0)).map((e => new Mc(e)))
     }
-    const Gc = {
+    const Rc = {
         c: 1,
         C: 1,
         s: 2,
         S: 2,
         i: 4,
         I: 4,
         f: 4
     };
-    class Zc {
+    class Lc {
         constructor() {
             this.hidden = !1
         }
         isMapped() {
             return 0 == (4 & this.flags)
         }
         isPaired() {
@@ -12970,18 +13008,18 @@
         isNegativeStrand() {
             return 0 != (16 & this.flags)
         }
         isMateNegativeStrand() {
             return 0 != (32 & this.flags)
         }
         hasTag(e) {
-            return (this.tagDict || Xc(this.tagBA)).hasOwnProperty(e)
+            return (this.tagDict || Bc(this.tagBA)).hasOwnProperty(e)
         }
         tags() {
-            return this.tagDict || (this.tagBA ? (this.tagDict = Xc(this.tagBA), this.tagBA = void 0) : this.tagDict = {}), this.tagDict
+            return this.tagDict || (this.tagBA ? (this.tagDict = Bc(this.tagBA), this.tagBA = void 0) : this.tagDict = {}), this.tagDict
         }
         containsLocation(e, t) {
             const i = t ? this.scStart : this.start,
                 n = t ? this.scLengthOnRef : this.lengthOnRef;
             return e >= i && e <= i + n
         }
         popupData(e) {
@@ -13059,15 +13097,15 @@
             })));
             const r = this.tags();
             if (r.hasOwnProperty("SA")) {
                 t.push("<hr/>"), t.push({
                     name: "Supplementary Alignments",
                     value: ""
                 });
-                const e = Wc(r.SA);
+                const e = Tc(r.SA);
                 if (e) {
                     t.push("<ul>");
                     for (let i of e) t.push(`<li>${i.printString()}</li>`);
                     t.push("</ul>")
                 }
             }
             const s = new Set(["SA", "MD"]);
@@ -13091,24 +13129,24 @@
             }), t;
 
             function o(e) {
                 return e ? "Yes" : "No"
             }
         }
         readBaseAt(e) {
-            const t = Qc(this.blocks, e);
+            const t = Ic(this.blocks, e);
             if (t) {
                 if ("*" === this.seq) return "*"; {
                     const i = t.seqIndexAt(e);
                     return this.seq[i]
                 }
             }
         }
         readBaseQualityAt(e) {
-            const t = Qc(this.blocks, e);
+            const t = Ic(this.blocks, e);
             if (t) {
                 if ("*" === this.qual) return 30; {
                     const i = t.seqIndexAt(e);
                     return i >= 0 && this.qual && i < this.qual.length ? this.qual[i] : 30
                 }
             }
         }
@@ -13124,88 +13162,88 @@
             return {
                 left: e,
                 right: t
             }
         }
     }
 
-    function Qc(e, t) {
+    function Ic(e, t) {
         for (let i = 0; i < e.length; i++) {
             const n = e[i];
             if (t >= n.start && t < n.start + n.len) return n
         }
     }
 
-    function Xc(e) {
+    function Bc(e) {
         let t = 0;
         const i = e.length,
             n = {};
         for (; t < i;) {
             const i = String.fromCharCode(e[t]) + String.fromCharCode(e[t + 1]);
             t += 2;
             const s = String.fromCharCode(e[t++]);
             let o;
             if ("A" === s) o = String.fromCharCode(e[t]), t++;
-            else if ("i" === s || "I" === s) o = Yc(e, t), t += 4;
-            else if ("c" === s) o = ed(e, t), t++;
-            else if ("C" === s) o = td(e, t), t++;
-            else if ("s" === s || "S" === s) o = Kc(e, t), t += 2;
-            else if ("f" === s) o = Jc(e, t), t += 4;
+            else if ("i" === s || "I" === s) o = Fc(e, t), t += 4;
+            else if ("c" === s) o = Pc(e, t), t++;
+            else if ("C" === s) o = Dc(e, t), t++;
+            else if ("s" === s || "S" === s) o = Nc(e, t), t += 2;
+            else if ("f" === s) o = Oc(e, t), t += 4;
             else if ("Z" === s)
                 for (o = "";;) {
                     var r = e[t++];
                     if (0 === r) break;
                     o += String.fromCharCode(r)
                 } else {
                     if ("B" !== s) {
                         o = "Error unknown type: " + s, n[i] = o;
                         break
                     } {
                         const r = String.fromCharCode(e[t++]);
-                        let s = Gc[r];
+                        let s = Rc[r];
                         if (void 0 === s) {
                             n[i] = `Error: unknown element type '${r}'`;
                             break
                         }
-                        t += 4 + Yc(e, t) * s, o = "[not shown]"
+                        t += 4 + Fc(e, t) * s, o = "[not shown]"
                     }
                 }
             n[i] = o
         }
         return n
     }
 
-    function Yc(e, t) {
+    function Fc(e, t) {
         return e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
     }
 
-    function Kc(e, t) {
+    function Nc(e, t) {
         return e[t + 1] << 8 | e[t]
     }
 
-    function Jc(e, t) {
+    function Oc(e, t) {
         return new DataView(e.buffer).getFloat32(t)
     }
 
-    function ed(e, t) {
+    function Pc(e, t) {
         return new DataView(e.buffer).getInt8(t)
     }
 
-    function td(e, t) {
+    function Dc(e, t) {
         return new DataView(e.buffer).getUint8(t)
     }
-    class id {
+    class zc {
         constructor(e) {
             e && Object.assign(this, e)
         }
         seqIndexAt(e) {
             return Math.floor(e) - this.start + this.seqOffset
         }
     }
-    class nd {
+    class Hc {
         constructor(e) {
             e || (e = {}), this.vendorFailed = void 0 === e.vendorFailed || e.vendorFailed, this.duplicates = void 0 === e.duplicates || e.duplicates, this.secondary = e.secondary || !1, this.supplementary = e.supplementary || !1, this.mqThreshold = void 0 === e.mqThreshold ? 0 : e.mqThreshold, e.readgroups && (this.readgroups = new Set(e.readgroups))
         }
         pass(e) {
             if (this.vendorFailed && e.isFailsVendorQualityCheck()) return !1;
             if (this.duplicates && e.isDuplicate()) return !1;
             if (this.secondary && e.isSecondary()) return !1;
@@ -13214,35 +13252,35 @@
             if (this.readgroups) {
                 var t = e.tags().RG;
                 return this.readgroups.has(t)
             }
             return !0
         }
     }
-    const rd = ["=", "A", "C", "x", "G", "x", "x", "x", "T", "x", "x", "x", "x", "x", "x", "N"],
-        sd = ["M", "I", "D", "N", "S", "H", "P", "=", "X", "?", "?", "?", "?", "?", "?", "?"],
-        od = cd(new Uint8Array([66, 65, 77, 1]), 0),
-        ad = 1e4,
-        ld = {
+    const Vc = ["=", "A", "C", "x", "G", "x", "x", "x", "T", "x", "x", "x", "x", "x", "x", "N"],
+        Uc = ["M", "I", "D", "N", "S", "H", "P", "=", "X", "?", "?", "?", "?", "?", "?", "?"],
+        qc = Gc(new Uint8Array([66, 65, 77, 1]), 0),
+        jc = 1e4,
+        $c = {
             readHeader: function(e, t, i) {
-                return lo.loadArrayBuffer(e, t).then((function(e) {
+                return io.loadArrayBuffer(e, t).then((function(e) {
                     var t;
-                    return t = Fs(e), ld.decodeBamHeader(t, i)
+                    return t = Ts(e), $c.decodeBamHeader(t, i)
                 }))
             },
             decodeBamHeader: function(e, t) {
                 var i, n, r, s, o;
-                if ((i = cd(e, 0)) !== od) throw new Error("BAM header errror: bad magic number.  This could be caused by either a corrupt or missing file.");
-                n = cd(e, 4);
+                if ((i = Gc(e, 0)) !== qc) throw new Error("BAM header errror: bad magic number.  This could be caused by either a corrupt or missing file.");
+                n = Gc(e, 4);
                 for (var a = 0; a < n; ++a) String.fromCharCode(e[a + 8]);
-                var l = cd(e, n + 8),
+                var l = Gc(e, n + 8),
                     h = n + 12;
                 for (r = {}, s = [], o = {}, a = 0; a < l; ++a) {
-                    for (var c = cd(e, h), d = "", u = 0; u < c - 1; ++u) d += String.fromCharCode(e[h + 4 + u]);
-                    cd(e, h + c + 4), r[d] = a, s[a] = d, t && (o[t.getChromosomeName(d)] = d), h = h + 8 + c
+                    for (var c = Gc(e, h), d = "", u = 0; u < c - 1; ++u) d += String.fromCharCode(e[h + 4 + u]);
+                    Gc(e, h + c + 4), r[d] = a, s[a] = d, t && (o[t.getChromosomeName(d)] = d), h = h + 8 + c
                 }
                 return {
                     magicNumber: i,
                     size: h,
                     chrNames: s,
                     chrToIndex: r,
                     chrAliasTable: o
@@ -13252,122 +13290,122 @@
                 function o(e) {
                     return "C" === e || "c" === e || "A" === e ? 1 : "S" === e || "s" === e ? 2 : "I" === e || "i" === e || "f" === e ? 4 : 0
                 }
                 if (1 !== s.length || r.start < 0) return !1;
                 for (var a = i + (n + 1 >> 1) + n; a + 4 < t;) {
                     if ("CG" === String.fromCharCode(e[a]) + String.fromCharCode(e[a + 1])) break;
                     var l = String.fromCharCode(e[a + 2]);
-                    if ("B" === l) a += 8 + o(l = String.fromCharCode(e[a + 3])) * cd(e, a + 4);
+                    if ("B" === l) a += 8 + o(l = String.fromCharCode(e[a + 3])) * Gc(e, a + 4);
                     else if ("Z" === l || "H" === l)
                         for (a += 3; 0 !== e[a++];);
                     else a += 3 + o(l)
                 }
                 if (a >= t) return !1;
                 if ("B" !== String.fromCharCode(e[a + 2]) || "I" !== String.fromCharCode(e[a + 3])) return !1;
-                var h = cd(e, a + 4),
+                var h = Gc(e, a + 4),
                     c = a + 8;
                 if (c + 4 * h > t) return !1;
                 var d = "",
                     u = 0;
                 s.length = 0, a = c;
                 for (var f = 0; f < h; ++f, a += 4) {
-                    var p = cd(e, a),
+                    var p = Gc(e, a),
                         g = p >> 4,
-                        m = sd[15 & p];
+                        m = Uc[15 & p];
                     "M" !== m && "EQ" !== m && "X" !== m && "D" !== m && "N" !== m && "=" !== m || (u += g), d = d + g + m, s.push({
                         len: g,
                         ltr: m
                     })
                 }
                 return r.cigar = d, r.lengthOnRef = u, !0
             },
             decodeBamRecords: function(e, t, i, n, r, s, o, a) {
                 for (; t < e.length;) {
-                    const u = t + cd(e, t) + 4,
-                        f = new Zc,
-                        p = cd(e, t + 4),
-                        g = cd(e, t + 8);
+                    const u = t + Gc(e, t) + 4,
+                        f = new Lc,
+                        p = Gc(e, t + 4),
+                        g = Gc(e, t + 8);
                     if (u > e.length) return;
                     if (p < 0) {
                         t = u;
                         continue
                     }
                     if (void 0 !== r && (p > r || g > o)) return !0;
                     if (void 0 !== r && p < r) {
                         t = u;
                         continue
                     }
-                    const m = cd(e, t + 12),
+                    const m = Gc(e, t + 12),
                         b = (65280 & m) >> 8,
                         w = 255 & m,
-                        v = cd(e, t + 16),
+                        v = Gc(e, t + 16),
                         y = (4294901760 & v) >> 16,
                         _ = 65535 & v,
-                        x = cd(e, t + 20),
-                        k = cd(e, t + 24),
-                        C = cd(e, t + 28),
-                        S = cd(e, t + 32);
+                        x = Gc(e, t + 20),
+                        k = Gc(e, t + 24),
+                        C = Gc(e, t + 28),
+                        S = Gc(e, t + 32);
                     let A = [];
                     for (let i = 0; i < w - 1; ++i) A.push(String.fromCharCode(e[t + 36 + i]));
                     A = A.join("");
                     let E = 0,
-                        T = "",
-                        M = t + 36 + w;
+                        M = "",
+                        T = t + 36 + w;
                     const R = [];
                     let L;
                     for (let t = 0; t < _; ++t) {
-                        var l = cd(e, M),
+                        var l = Gc(e, T),
                             h = l >> 4,
-                            c = sd[15 & l];
-                        "M" !== c && "EQ" !== c && "X" !== c && "D" !== c && "N" !== c && "=" !== c || (E += h), T = T + h + c, M += 4, L = {
+                            c = Uc[15 & l];
+                        "M" !== c && "EQ" !== c && "X" !== c && "D" !== c && "N" !== c && "=" !== c || (E += h), M = M + h + c, T += 4, L = {
                             len: h,
                             ltr: c
                         }, R.push(L)
                     }
-                    if (f.chr = n[p], f.start = g, f.flags = y, f.strand = !(16 & y), f.readName = A, f.cigar = T, f.lengthOnRef = E, f.fragmentLength = S, f.mq = b, ld.bam_tag2cigar(e, u, M, x, f, R), f.end = f.start + f.lengthOnRef, f.end < s) {
+                    if (f.chr = n[p], f.start = g, f.flags = y, f.strand = !(16 & y), f.readName = A, f.cigar = M, f.lengthOnRef = E, f.fragmentLength = S, f.mq = b, $c.bam_tag2cigar(e, u, T, x, f, R), f.end = f.start + f.lengthOnRef, f.end < s) {
                         t = u;
                         continue
                     }
                     let I = [];
                     const B = x + 1 >> 1;
                     for (let t = 0; t < B; ++t) {
-                        var d = e[M + t];
-                        I.push(rd[(240 & d) >> 4]), I.push(rd[15 & d])
+                        var d = e[T + t];
+                        I.push(Vc[(240 & d) >> 4]), I.push(Vc[15 & d])
                     }
-                    I = I.slice(0, x).join(""), M += B;
-                    const N = [];
-                    for (let t = 0; t < x; ++t) N.push(e[M + t]);
-                    M += x, k >= 0 && (f.mate = {
+                    I = I.slice(0, x).join(""), T += B;
+                    const F = [];
+                    for (let t = 0; t < x; ++t) F.push(e[T + t]);
+                    T += x, k >= 0 && (f.mate = {
                         chr: n[k],
                         position: C,
                         strand: !(32 & y)
-                    }), f.seq = I, f.qual = N, f.tagBA = new Uint8Array(e.buffer.slice(M, u)), this.setPairOrientation(f), (void 0 === a || a.pass(f)) && (hd(f, R), i.push(f)), t = u
+                    }), f.seq = I, f.qual = F, f.tagBA = new Uint8Array(e.buffer.slice(T, u)), this.setPairOrientation(f), (void 0 === a || a.pass(f)) && (Wc(f, R), i.push(f)), t = u
                 }
             },
             decodeSamRecords: function(e, t, i, n, r, s) {
                 var o, a, l, h, c, d, u, f, p, g;
                 for (h = (o = Yt(e)).length, !1, a = 0; a < h; a++)
-                    if (c = o[a].split("\t"), (p = new Zc).chr = c[2], p.start = Number.parseInt(c[3]) - 1, p.flags = Number.parseInt(c[1]), p.readName = c[0], p.strand = !(16 & p.flags), p.mq = Number.parseInt(c[4]), p.cigar = c[5], p.fragmentLength = Number.parseInt(c[8]), p.seq = c[9], "*" !== p.chr && p.isMapped() && p.chr === i) {
+                    if (c = o[a].split("\t"), (p = new Lc).chr = c[2], p.start = Number.parseInt(c[3]) - 1, p.flags = Number.parseInt(c[1]), p.readName = c[0], p.strand = !(16 & p.flags), p.mq = Number.parseInt(c[4]), p.cigar = c[5], p.fragmentLength = Number.parseInt(c[8]), p.seq = c[9], "*" !== p.chr && p.isMapped() && p.chr === i) {
                         if (p.start > r) break;
-                        if (f = 0, (g = dd(p.cigar)).forEach((function(e) {
+                        if (f = 0, (g = Zc(p.cigar)).forEach((function(e) {
                                 var t = e.len,
                                     i = e.ltr;
                                 "M" !== i && "EQ" !== i && "X" !== i && "D" !== i && "N" !== i && "=" !== i || (f += t)
                             })), p.lengthOnRef = f, !(p.start + f < n)) {
                             for (d = c[10], p.qual = [], l = 0; l < d.length; l++) p.qual[l] = d.charCodeAt(l) - 33;
-                            p.tagDict = c.length < 11 ? {} : ud(c.slice(11)), p.isMateMapped() && (u = c[6], p.mate = {
+                            p.tagDict = c.length < 11 ? {} : Qc(c.slice(11)), p.isMateMapped() && (u = c[6], p.mate = {
                                 chr: "=" === u ? p.chr : u,
                                 position: Number.parseInt(c[7]),
                                 strand: !(32 & p.flags)
-                            }), this.setPairOrientation(p), (void 0 === s || s.pass(p)) && (hd(p, g), t.push(p))
+                            }), this.setPairOrientation(p), (void 0 === s || s.pass(p)) && (Wc(p, g), t.push(p))
                         }
                     }
             },
             setReaderDefaults: function(e, t) {
-                e.filter = new nd(t.filter), t.readgroup && (e.filter.readgroups = new Set([t.readgroup])), e.alleleFreqThreshold = void 0 === t.alleleFreqThreshold ? .2 : t.alleleFreqThreshold, e.samplingWindowSize = void 0 === t.samplingWindowSize ? 100 : t.samplingWindowSize, e.samplingDepth = void 0 === t.samplingDepth ? 500 : t.samplingDepth, e.samplingDepth > ad && (console.log("Warning: attempt to set sampling depth > maximum value of " + ad), e.samplingDepth = ad), t.viewAsPairs ? e.pairsSupported = !0 : e.pairsSupported = void 0 === t.pairsSupported || t.pairsSupported
+                e.filter = new Hc(t.filter), t.readgroup && (e.filter.readgroups = new Set([t.readgroup])), e.alleleFreqThreshold = void 0 === t.alleleFreqThreshold ? .2 : t.alleleFreqThreshold, e.samplingWindowSize = void 0 === t.samplingWindowSize ? 100 : t.samplingWindowSize, e.samplingDepth = void 0 === t.samplingDepth ? 500 : t.samplingDepth, e.samplingDepth > jc && (console.log("Warning: attempt to set sampling depth > maximum value of " + jc), e.samplingDepth = jc), t.viewAsPairs ? e.pairsSupported = !0 : e.pairsSupported = void 0 === t.pairsSupported || t.pairsSupported
             },
             setPairOrientation: function(e) {
                 if (e.isMapped() && e.mate && e.isMateMapped() && e.mate.chr === e.chr) {
                     var t = e.strand ? "F" : "R",
                         i = e.mate,
                         n = i.strand ? "F" : "R",
                         r = " ",
@@ -13398,27 +13436,27 @@
                         i = ""
                     }
                 }
                 return t
             }
         };
 
-    function hd(e, t) {
+    function Wc(e, t) {
         const i = [];
         let n, r, s = 0,
             o = e.start;
         e.scStart = e.start, e.scLengthOnRef = e.lengthOnRef;
         for (let a of t) {
             let t;
             switch (a.ltr) {
                 case "H":
                 case "P":
                     break;
                 case "S":
-                    t = o, e.scLengthOnRef += a.len, 0 === i.length && (e.scStart -= a.len, t -= a.len), i.push(new id({
+                    t = o, e.scLengthOnRef += a.len, 0 === i.length && (e.scStart -= a.len, t -= a.len), i.push(new zc({
                         start: t,
                         seqOffset: s,
                         len: a.len,
                         type: "S"
                     })), s += a.len;
                     break;
                 case "N":
@@ -13426,221 +13464,221 @@
                     void 0 === r && (r = []), r.push({
                         start: o,
                         len: a.len,
                         type: a.ltr
                     }), o += a.len;
                     break;
                 case "I":
-                    void 0 === n && (n = []), n.push(new id({
+                    void 0 === n && (n = []), n.push(new zc({
                         start: o,
                         len: a.len,
                         seqOffset: s,
                         type: "I"
                     })), s += a.len;
                     break;
                 case "M":
                 case "EQ":
                 case "=":
                 case "X":
-                    i.push(new id({
+                    i.push(new zc({
                         start: o,
                         seqOffset: s,
                         len: a.len,
                         type: "M"
                     })), s += a.len, o += a.len;
                     break;
                 default:
                     console.log("Error processing cigar element: " + a.len + a.ltr)
             }
         }
         e.blocks = i, e.insertions = n, e.gaps = r
     }
 
-    function cd(e, t) {
+    function Gc(e, t) {
         return e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
     }
 
-    function dd(e) {
+    function Zc(e) {
         var t, i, n, r, s, o, a, l, h;
         for (t = [], i = [], s = null, r = e.length, n = 0; n < r; n++) o = e.charAt(n), h = void 0, (h = o.charCodeAt(0)) >= 48 && h <= 57 ? i.push(o) : (a = o, l = Number.parseInt(i.join("")), i = [], null !== s && s.ltr === a ? s.len += l : (s = {
             len: l,
             ltr: a
         }, t.push(s)));
         return t
     }
 
-    function ud(e) {
+    function Qc(e) {
         var t = {};
         return e.forEach((function(e) {
             var i = e.split(":");
             t[i[0]] = i[2]
         })), t
     }
-    class fd {
+    class Xc {
         constructor(e, t) {
-            this.config = e, this.genome = t, this.bamPath = e.url, this.isDataUri = Ho(e.url), ld.setReaderDefaults(this, e)
+            this.config = e, this.genome = t, this.bamPath = e.url, this.isDataUri = Bo(e.url), $c.setReaderDefaults(this, e)
         }
         async readAlignments(e, t, i) {
             if (this.alignmentCache) {
                 const n = this.header,
                     r = n.chrAliasTable.hasOwnProperty(e) ? n.chrAliasTable[e] : e,
                     s = this.alignmentCache.queryFeatures(r, t, i),
-                    o = new Hc(e, t, i, this.config);
+                    o = new kc(e, t, i, this.config);
                 for (let e of s) o.push(e);
                 return o.finish(), o
             }
             if (this.isDataUri) {
-                const n = Fs(function(e) {
+                const n = Ts(function(e) {
                     const t = e.split(","),
                         i = t[0].split(":")[1];
                     let n = t[1];
                     n = i.indexOf("base64") >= 0 ? atob(n) : decodeURI(n);
                     const r = new Uint8Array(n.length);
                     for (var s = 0; s < n.length; s++) r[s] = n.charCodeAt(s);
                     return r
                 }(this.bamPath).buffer);
                 return this.parseAlignments(n), this.fetchAlignments(e, t, i)
             } {
-                const n = Fs(await lo.loadArrayBuffer(this.bamPath, No(this.config)));
+                const n = Ts(await io.loadArrayBuffer(this.bamPath, Mo(this.config)));
                 return this.parseAlignments(n), this.fetchAlignments(e, t, i)
             }
         }
         parseAlignments(e) {
             const t = [];
-            this.header = ld.decodeBamHeader(e), ld.decodeBamRecords(e, this.header.size, t, this.header.chrNames), this.alignmentCache = new vo(t, this.genome)
+            this.header = $c.decodeBamHeader(e), $c.decodeBamRecords(e, this.header.size, t, this.header.chrNames), this.alignmentCache = new fo(t, this.genome)
         }
         fetchAlignments(e, t, i) {
             const n = this.header.chrAliasTable.hasOwnProperty(e) ? this.header.chrAliasTable[e] : e,
                 r = this.alignmentCache.queryFeatures(n, t, i),
-                s = new Hc(e, t, i, this.config);
+                s = new kc(e, t, i, this.config);
             for (let e of r) s.push(e);
             return s.finish(), s
         }
     }
-    class pd {
+    class Yc {
         constructor(e, t) {
-            this.config = e, this.genome = t, this.bamPath = e.url, this.baiPath = e.indexURL, ld.setReaderDefaults(this, e), this._blockLoader = new Eh(e)
+            this.config = e, this.genome = t, this.bamPath = e.url, this.baiPath = e.indexURL, $c.setReaderDefaults(this, e), this._blockLoader = new fh(e)
         }
         async readAlignments(e, t, i) {
             const n = (await this.getChrIndex())[this.chrAliasTable.hasOwnProperty(e) ? this.chrAliasTable[e] : e],
-                r = new Hc(e, t, i, this.config);
+                r = new kc(e, t, i, this.config);
             if (void 0 === n) return r; {
                 const e = (await this.getIndex()).chunksForRange(n, t, i);
                 if (!e || 0 === e.length) return r;
                 for (let s of e) {
                     const e = await this._blockLoader.getData(s.minv, s.maxv);
-                    if (ld.decodeBamRecords(e, s.minv.offset, r, this.indexToChr, n, t, i, this.filter)) break
+                    if ($c.decodeBamRecords(e, s.minv.offset, r, this.indexToChr, n, t, i, this.filter)) break
                 }
                 return r.finish(), r
             }
         }
         async getHeader() {
             if (!this.header) {
                 const e = this.genome,
                     t = await this.getIndex();
                 let i;
                 if (t.firstBlockPosition) {
-                    const e = No(this.config, {
+                    const e = Mo(this.config, {
                             range: {
                                 start: t.firstBlockPosition,
                                 size: 26
                             }
                         }),
-                        n = Ps(await lo.loadArrayBuffer(this.bamPath, e));
+                        n = Rs(await io.loadArrayBuffer(this.bamPath, e));
                     i = t.firstBlockPosition + n
                 } else i = 64e3;
-                const n = No(this.config, {
+                const n = Mo(this.config, {
                     range: {
                         start: 0,
                         size: i
                     }
                 });
-                this.header = await ld.readHeader(this.bamPath, n, e)
+                this.header = await $c.readHeader(this.bamPath, n, e)
             }
             return this.header
         }
         async getIndex() {
             const e = this.genome;
-            return this.index || (this.index = await _h(this.baiPath, this.config, e)), this.index
+            return this.index || (this.index = await ah(this.baiPath, this.config, e)), this.index
         }
         async getChrIndex() {
             if (this.chrToIndex) return this.chrToIndex; {
                 const e = await this.getHeader();
                 return this.chrToIndex = e.chrToIndex, this.indexToChr = e.chrNames, this.chrAliasTable = e.chrAliasTable, this.chrToIndex
             }
         }
     }
-    class gd {
+    class Kc {
         constructor(e, t) {
             this.config = e, this.genome = t;
             const i = {};
             e.sources.sequences.forEach((function(n) {
                 const r = t ? t.getChromosomeName(n) : n;
                 i[r] = function(e, t, i) {
                     const n = {
                         url: e.sources.url.replace("$CHR", i)
                     };
                     e.sources.indexURL && (n.indexURL = e.sources.indexURL.replace("$CHR", i));
                     const r = Object.assign(e, n);
-                    return new pd(r, t)
+                    return new Yc(r, t)
                 }(e, t, n)
-            })), this.bamReaders = i, ld.setReaderDefaults(this, e)
+            })), this.bamReaders = i, $c.setReaderDefaults(this, e)
         }
         async readAlignments(e, t, i) {
             if (this.bamReaders.hasOwnProperty(e)) {
                 let n = this.bamReaders[e];
                 return await n.readAlignments(e, t, i)
             }
-            return new Hc(e, t, i, this.config)
+            return new kc(e, t, i, this.config)
         }
     }
-    const md = function(e, t) {
-        this.config = e, this.genome = t, ld.setReaderDefaults(this, e)
+    const Jc = function(e, t) {
+        this.config = e, this.genome = t, $c.setReaderDefaults(this, e)
     };
 
-    function bd() {
+    function ed() {
         const e = this,
             t = this.genome;
         if (this.header) return Promise.resolve(this.header); {
             const i = this.config.url + "?file=" + this.config.alignmentFile + "&options=-b,-H",
-                n = No(this.config);
-            return ld.readHeader(i, n, t).then((function(t) {
+                n = Mo(this.config);
+            return $c.readHeader(i, n, t).then((function(t) {
                 return e.header = t, t
             }))
         }
     }
-    md.prototype.readAlignments = function(e, t, i) {
+    Jc.prototype.readAlignments = function(e, t, i) {
         var n = this;
-        return bd.call(n).then((function(r) {
+        return ed.call(n).then((function(r) {
             var s, o;
-            return s = r.chrAliasTable.hasOwnProperty(e) ? r.chrAliasTable[e] : e, o = n.config.url + "?reference=" + n.config.referenceFile + "&file=" + n.config.alignmentFile + "&region=" + s + ":" + t + "-" + i, lo.loadString(o, No(n.config)).then((function(o) {
+            return s = r.chrAliasTable.hasOwnProperty(e) ? r.chrAliasTable[e] : e, o = n.config.url + "?reference=" + n.config.referenceFile + "&file=" + n.config.alignmentFile + "&region=" + s + ":" + t + "-" + i, io.loadString(o, Mo(n.config)).then((function(o) {
                 var a;
-                return r.chrToIndex[s], a = new Hc(e, t, i, n.config), ld.decodeSamRecords(o, a, s, t, i, n.filter), a
+                return r.chrToIndex[s], a = new kc(e, t, i, n.config), $c.decodeSamRecords(o, a, s, t, i, n.filter), a
             }))
         }))
     };
-    class wd extends jh {
+    class td extends Rh {
         constructor(e, t) {
-            super(e, t), ld.setReaderDefaults(this, e)
+            super(e, t), $c.setReaderDefaults(this, e)
         }
         async readAlignments(e, t, i) {
             if (!this.header) {
-                const e = Fs((await this.readHeaderData()).buffer);
-                this.header = ld.decodeBamHeader(e, this.genome), this.chrAliasTable = new Map;
+                const e = Ts((await this.readHeaderData()).buffer);
+                this.header = $c.decodeBamHeader(e, this.genome), this.chrAliasTable = new Map;
                 for (let e of Object.keys(this.header.chrAliasTable)) this.chrAliasTable.set(e, this.header.chrAliasTable[e])
             }
             let n = this.chrAliasTable.has(e) ? this.chrAliasTable.get(e) : e;
-            const r = Fs((await this.readData(n, t, i)).buffer),
+            const r = Ts((await this.readData(n, t, i)).buffer),
                 s = this.header.chrToIndex[e],
-                o = new Hc(e, t, i, this.config);
-            return ld.decodeBamRecords(r, this.header.size, o, this.header.chrNames, s, t, i), o.finish(), o
+                o = new kc(e, t, i, this.config);
+            return $c.decodeBamRecords(r, this.header.size, o, this.header.chrNames, s, t, i), o.finish(), o
         }
     }
     /*! For license information please see cram-bundle.js.LICENSE.txt */
-    const vd = (() => {
+    const id = (() => {
         var e = {
                 368: function(e, t, i) {
                     var n = this && this.__awaiter || function(e, t, i, n) {
                             return new(i || (i = Promise))((function(r, s) {
                                 function o(e) {
                                     try {
                                         l(n.next(e))
@@ -15036,28 +15074,28 @@
                                 o = n.substr(0, 2),
                                 a = n.substr(2, 1),
                                 l = i.getCodecForTag(n);
                             if (!l) throw new s.CramMalformedError(`no codec defined for auxiliary tag ${n}`);
                             const u = l.decode(e, r, c, d);
                             S[o] = h(a, u)
                         }
-                        let T, M, R, L, I;
+                        let M, T, R, L, I;
                         if (o.BamFlagsDecoder.isSegmentUnmapped(p))
                             if (o.CramFlagsDecoder.isDecodeSequenceAsStar(g)) I = null, L = null;
                             else {
                                 const e = new Array(b);
                                 for (let i = 0; i < e.length; i += 1) e[i] = t("BA");
                                 if (I = String.fromCharCode(...e), o.CramFlagsDecoder.isPreservingQualityScores(g)) {
                                     L = new Array(b);
                                     for (let i = 0; i < e.length; i += 1) L[i] = t("QS")
                                 }
                             }
                         else {
                             const e = t("FN");
-                            if (e && (T = function(e, t, i, n, r) {
+                            if (e && (M = function(e, t, i, n, r) {
                                     let o = 0,
                                         a = e - 1;
                                     const l = new Array(t);
 
                                     function h([e, t]) {
                                         const n = i(t);
                                         if ("character" === e) return String.fromCharCode(n);
@@ -15098,21 +15136,21 @@
                                             code: t,
                                             pos: f,
                                             refPos: p,
                                             data: d
                                         }
                                     }
                                     return l
-                                }(w, e, t, 0, u)), M = b, T)
+                                }(w, e, t, 0, u)), T = b, M)
                                 for (const {
                                         code: e,
                                         data: t
                                     }
-                                    of T) "D" === e || "N" === e ? M += t : "I" === e || "S" === e ? M -= t.length : "i" === e && (M -= 1);
-                            if (Number.isNaN(M) && (console.warn(`${y||`${m}:${w}`} record has invalid read features`), M = b), R = t("MQ"), o.CramFlagsDecoder.isPreservingQualityScores(g)) {
+                                    of M) "D" === e || "N" === e ? T += t : "I" === e || "S" === e ? T -= t.length : "i" === e && (T -= 1);
+                            if (Number.isNaN(T) && (console.warn(`${y||`${m}:${w}`} record has invalid read features`), T = b), R = t("MQ"), o.CramFlagsDecoder.isPreservingQualityScores(g)) {
                                 L = new Array(b);
                                 for (let e = 0; e < L.length; e++) L[e] = t("QS")
                             }
                         }
                         return {
                             readLength: b,
                             sequenceId: m,
@@ -15120,16 +15158,16 @@
                             flags: p,
                             alignmentStart: w,
                             readGroupId: v,
                             readName: y,
                             mateToUse: _,
                             templateSize: x,
                             mateRecordNumber: k,
-                            readFeatures: T,
-                            lengthOnRef: M,
+                            readFeatures: M,
+                            lengthOnRef: T,
                             mappingQuality: R,
                             qualityScores: L,
                             readBases: I,
                             tags: S
                         }
                     }
                 },
@@ -16857,19 +16895,19 @@
                                         o[0].sbits > 0 && v.ModelEncode(e, y, x);
                                         var k = d[x],
                                             C = i[Math.min(i.length - 1, _++)];
                                         o[k].fixed_len ? o[k].fixed_len > 0 && (w[0].ModelEncode(e, y, 255 & C), w[1].ModelEncode(e, y, C >> 8 & 255), w[2].ModelEncode(e, y, C >> 16 & 255), w[3].ModelEncode(e, y, C >> 24 & 255), o[k].fixed_len = -1) : (w[0].ModelEncode(e, y, 255 & C), w[1].ModelEncode(e, y, C >> 8 & 255), w[2].ModelEncode(e, y, C >> 16 & 255), w[3].ModelEncode(e, y, C >> 24 & 255)), o[k].do_dedup && process.exit(1), g = C;
                                         var S = 0,
                                             A = o[k].context,
                                             E = 0,
-                                            T = 0
+                                            M = 0
                                     }
-                                    var M = t[b++],
-                                        R = a[k][M];
-                                    m[A].ModelEncode(e, y, R), E = (E << o[k].qshift) + l[k][R], A = o[k].context, A += (E & (1 << o[k].qbits) - 1) << o[k].qloc, o[k].pbits > 0 && (A += h[k][Math.min(g, 1023)] << o[k].ploc), o[k].dbits > 0 && (A += c[k][Math.min(S, 255)] << o[k].dloc, S += T != R ? 1 : 0, T = R), o[k].do_sel && (A += x << o[k].sloc), A &= 65535, g--
+                                    var T = t[b++],
+                                        R = a[k][T];
+                                    m[A].ModelEncode(e, y, R), E = (E << o[k].qshift) + l[k][R], A = o[k].context, A += (E & (1 << o[k].qbits) - 1) << o[k].qloc, o[k].pbits > 0 && (A += h[k][Math.min(g, 1023)] << o[k].ploc), o[k].dbits > 0 && (A += c[k][Math.min(S, 255)] << o[k].dloc, S += M != R ? 1 : 0, M = R), o[k].do_sel && (A += x << o[k].sloc), A &= 65535, g--
                                 }
                                 return y.RangeFinishEncode(e), e.buf.slice(0, e.pos)
                             }(p, e, t, i, f, o, a, l, h, d)
                         }
                     }
                 },
                 3498: (e, t, i) => {
@@ -18329,18 +18367,18 @@
                         for (e || (e = "utf8");;) switch (e) {
                             case "hex":
                                 return R(this, t, i);
                             case "utf8":
                             case "utf-8":
                                 return A(this, t, i);
                             case "ascii":
-                                return T(this, t, i);
+                                return M(this, t, i);
                             case "latin1":
                             case "binary":
-                                return M(this, t, i);
+                                return T(this, t, i);
                             case "base64":
                                 return S(this, t, i);
                             case "ucs2":
                             case "ucs-2":
                             case "utf16le":
                             case "utf-16le":
                                 return L(this, t, i);
@@ -18640,22 +18678,22 @@
                         return {
                             type: "Buffer",
                             data: Array.prototype.slice.call(this._arr || this, 0)
                         }
                     };
                     const E = 4096;
 
-                    function T(e, t, i) {
+                    function M(e, t, i) {
                         let n = "";
                         i = Math.min(e.length, i);
                         for (let r = t; r < i; ++r) n += String.fromCharCode(127 & e[r]);
                         return n
                     }
 
-                    function M(e, t, i) {
+                    function T(e, t, i) {
                         let n = "";
                         i = Math.min(e.length, i);
                         for (let r = t; r < i; ++r) n += String.fromCharCode(e[r]);
                         return n
                     }
 
                     function R(e, t, i) {
@@ -18680,41 +18718,41 @@
 
                     function B(e, t, i, n, r, s) {
                         if (!l.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                         if (t > r || t < s) throw new RangeError('"value" argument is out of bounds');
                         if (i + n > e.length) throw new RangeError("Index out of range")
                     }
 
-                    function N(e, t, i, n, r) {
+                    function F(e, t, i, n, r) {
                         U(t, n, r, e, i, 7);
                         let s = Number(t & BigInt(4294967295));
                         e[i++] = s, s >>= 8, e[i++] = s, s >>= 8, e[i++] = s, s >>= 8, e[i++] = s;
                         let o = Number(t >> BigInt(32) & BigInt(4294967295));
                         return e[i++] = o, o >>= 8, e[i++] = o, o >>= 8, e[i++] = o, o >>= 8, e[i++] = o, i
                     }
 
-                    function F(e, t, i, n, r) {
+                    function N(e, t, i, n, r) {
                         U(t, n, r, e, i, 7);
                         let s = Number(t & BigInt(4294967295));
                         e[i + 7] = s, s >>= 8, e[i + 6] = s, s >>= 8, e[i + 5] = s, s >>= 8, e[i + 4] = s;
                         let o = Number(t >> BigInt(32) & BigInt(4294967295));
                         return e[i + 3] = o, o >>= 8, e[i + 2] = o, o >>= 8, e[i + 1] = o, o >>= 8, e[i] = o, i + 8
                     }
 
-                    function P(e, t, i, n, r, s) {
+                    function O(e, t, i, n, r, s) {
                         if (i + n > e.length) throw new RangeError("Index out of range");
                         if (i < 0) throw new RangeError("Index out of range")
                     }
 
-                    function O(e, t, i, n, s) {
-                        return t = +t, i >>>= 0, s || P(e, 0, i, 4), r.write(e, t, i, n, 23, 4), i + 4
+                    function P(e, t, i, n, s) {
+                        return t = +t, i >>>= 0, s || O(e, 0, i, 4), r.write(e, t, i, n, 23, 4), i + 4
                     }
 
                     function D(e, t, i, n, s) {
-                        return t = +t, i >>>= 0, s || P(e, 0, i, 8), r.write(e, t, i, n, 52, 8), i + 8
+                        return t = +t, i >>>= 0, s || O(e, 0, i, 8), r.write(e, t, i, n, 52, 8), i + 8
                     }
                     l.prototype.slice = function(e, t) {
                         const i = this.length;
                         (e = ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i), (t = void 0 === t ? i : ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i), t < e && (t = e);
                         const n = this.subarray(e, t);
                         return Object.setPrototypeOf(n, l.prototype), n
                     }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e, t, i) {
@@ -18825,17 +18863,17 @@
                     }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e, t, i) {
                         return e = +e, t >>>= 0, i || B(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                     }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e, t, i) {
                         return e = +e, t >>>= 0, i || B(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
                     }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e, t, i) {
                         return e = +e, t >>>= 0, i || B(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                     }, l.prototype.writeBigUInt64LE = K((function(e, t = 0) {
-                        return N(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
-                    })), l.prototype.writeBigUInt64BE = K((function(e, t = 0) {
                         return F(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
+                    })), l.prototype.writeBigUInt64BE = K((function(e, t = 0) {
+                        return N(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
                     })), l.prototype.writeIntLE = function(e, t, i, n) {
                         if (e = +e, t >>>= 0, !n) {
                             const n = Math.pow(2, 8 * i - 1);
                             B(this, e, t, i, n - 1, -n)
                         }
                         let r = 0,
                             s = 1,
@@ -18859,21 +18897,21 @@
                     }, l.prototype.writeInt16BE = function(e, t, i) {
                         return e = +e, t >>>= 0, i || B(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                     }, l.prototype.writeInt32LE = function(e, t, i) {
                         return e = +e, t >>>= 0, i || B(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
                     }, l.prototype.writeInt32BE = function(e, t, i) {
                         return e = +e, t >>>= 0, i || B(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                     }, l.prototype.writeBigInt64LE = K((function(e, t = 0) {
-                        return N(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
-                    })), l.prototype.writeBigInt64BE = K((function(e, t = 0) {
                         return F(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
+                    })), l.prototype.writeBigInt64BE = K((function(e, t = 0) {
+                        return N(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                     })), l.prototype.writeFloatLE = function(e, t, i) {
-                        return O(this, e, t, !0, i)
+                        return P(this, e, t, !0, i)
                     }, l.prototype.writeFloatBE = function(e, t, i) {
-                        return O(this, e, t, !1, i)
+                        return P(this, e, t, !1, i)
                     }, l.prototype.writeDoubleLE = function(e, t, i) {
                         return D(this, e, t, !0, i)
                     }, l.prototype.writeDoubleBE = function(e, t, i) {
                         return D(this, e, t, !1, i)
                     }, l.prototype.copy = function(e, t, i, n) {
                         if (!l.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                         if (i || (i = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < i && (n = i), n === i) return 0;
@@ -19134,52 +19172,52 @@
                                 for (s = v; s <= y; s++)
                                     for (a = 0; a < b; a++) x[a] == s && (_.permute[A++] = a);
                                 for (s = v; s <= y; s++) k[s] = S[s] = 0;
                                 for (s = 0; s < b; s++) k[x[s]]++;
                                 for (A = a = 0, s = v; s < y; s++) A += k[s], S[s] = A - 1, A <<= 1, C[s + 1] = A - (a += k[s]);
                                 S[y] = A + k[y] - 1, C[v] = 0
                             }
-                            var E, T, M, R = new Uint32Array(256);
+                            var E, M, T, R = new Uint32Array(256);
                             for (s = 0; s < 256; s++) f[s] = s;
-                            E = T = b = M = 0;
+                            E = M = b = T = 0;
                             for (var L = new Uint32Array(n);;) {
                                 if (!b--) {
-                                    if (b = 49, M >= u) throw "meow i'm a kitty, that's an error";
-                                    C = (_ = w[p[M++]]).base.subarray(1), S = _.limit.subarray(1)
+                                    if (b = 49, T >= u) throw "meow i'm a kitty, that's an error";
+                                    C = (_ = w[p[T++]]).base.subarray(1), S = _.limit.subarray(1)
                                 }
                                 for (g = e(s = _.minLen);;) {
                                     if (s > _.maxLen) throw "rawr i'm a dinosaur";
                                     if (g <= S[s]) break;
                                     s++, g = g << 1 | e(1)
                                 }
                                 if ((g -= C[s]) < 0 || g >= 258) throw "moo i'm a cow";
                                 var I = _.permute[g];
                                 if (0 != I && 1 != I) {
                                     if (E) {
-                                        if (E = 0, T + a >= n) throw "Boom.";
-                                        for (R[m = l[f[0]]] += a; a--;) L[T++] = m
+                                        if (E = 0, M + a >= n) throw "Boom.";
+                                        for (R[m = l[f[0]]] += a; a--;) L[M++] = m
                                     }
                                     if (I > h) break;
-                                    if (T >= n) throw "I can't think of anything. Error";
-                                    m = f[s = I - 1], f.splice(s, 1), f.splice(0, 0, m), R[m = l[m]]++, L[T++] = m
+                                    if (M >= n) throw "I can't think of anything. Error";
+                                    m = f[s = I - 1], f.splice(s, 1), f.splice(0, 0, m), R[m = l[m]]++, L[M++] = m
                                 } else E || (E = 1, a = 0), a += 0 == I ? E : 2 * E, E <<= 1
                             }
-                            if (o < 0 || o >= T) throw "I'm a monkey and I'm throwing something at someone, namely you";
+                            if (o < 0 || o >= M) throw "I'm a monkey and I'm throwing something at someone, namely you";
                             for (g = 0, s = 0; s < 256; s++) c = g + R[s], R[s] = g, g = c;
-                            for (s = 0; s < T; s++) L[R[m = 255 & L[s]]] |= s << 8, R[m]++;
+                            for (s = 0; s < M; s++) L[R[m = 255 & L[s]]] |= s << 8, R[m]++;
                             var B = 0,
-                                N = 0,
-                                F = 0;
-                            T && (N = 255 & (B = L[o]), B >>= 8, F = -1);
-                            var P, O, D, z = new Uint8Array(n),
+                                F = 0,
+                                N = 0;
+                            M && (F = 255 & (B = L[o]), B >>= 8, N = -1);
+                            var O, P, D, z = new Uint8Array(n),
                                 H = 0;
-                            for (i || (i = 1 / 0); T;) {
-                                for (T--, O = N, N = 255 & (B = L[B]), B >>= 8, 3 == F++ ? (P = N, D = O, N = -1) : (P = 1, D = N); P--;)
+                            for (i || (i = 1 / 0); M;) {
+                                for (M--, P = F, F = 255 & (B = L[B]), B >>= 8, 3 == N++ ? (O = F, D = P, F = -1) : (O = 1, D = F); O--;)
                                     if (z[H++] = D, !--i) return z;
-                                N != O && (F = 0)
+                                F != P && (N = 0)
                             }
                             return z.subarray(0, H)
                         }
                     };
                     e.exports = t
                 },
                 487: e => {
@@ -20150,34 +20188,34 @@
                         return e.match_available && (n = s._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, 4 === t ? (v(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (v(e, !1), 0 === e.strm.avail_out) ? 1 : 2
                     }
 
                     function E(e, t, i, n, r) {
                         this.good_length = e, this.max_lazy = t, this.nice_length = i, this.max_chain = n, this.func = r
                     }
 
-                    function T() {
+                    function M() {
                         this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new r.Buf16(1146), this.dyn_dtree = new r.Buf16(122), this.bl_tree = new r.Buf16(78), b(this.dyn_ltree), b(this.dyn_dtree), b(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new r.Buf16(16), this.heap = new r.Buf16(573), b(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new r.Buf16(573), b(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
                     }
 
-                    function M(e) {
+                    function T(e) {
                         var t;
                         return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = 2, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? 42 : f, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = 0, s._tr_init(t), 0) : g(e, h)
                     }
 
                     function R(e) {
-                        var t, i = M(e);
+                        var t, i = T(e);
                         return 0 === i && ((t = e.state).window_size = 2 * t.w_size, b(t.head), t.max_lazy_match = n[t.level].max_lazy, t.good_match = n[t.level].good_length, t.nice_match = n[t.level].nice_length, t.max_chain_length = n[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = 2, t.match_available = 0, t.ins_h = 0), i
                     }
 
                     function L(e, t, i, n, s, o) {
                         if (!e) return h;
                         var a = 1;
                         if (-1 === t && (t = 6), n < 0 ? (a = 0, n = -n) : n > 15 && (a = 2, n -= 16), s < 1 || s > 9 || 8 !== i || n < 8 || n > 15 || t < 0 || t > 9 || o < 0 || o > 4) return g(e, h);
                         8 === n && (n = 9);
-                        var l = new T;
+                        var l = new M;
                         return e.state = l, l.strm = e, l.wrap = a, l.gzhead = null, l.w_bits = n, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = s + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + 3 - 1) / 3), l.window = new r.Buf8(2 * l.w_size), l.head = new r.Buf16(l.hash_size), l.prev = new r.Buf16(l.w_size), l.lit_bufsize = 1 << s + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new r.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = t, l.strategy = o, l.method = i, R(e)
                     }
                     n = [new E(0, 0, 0, 0, (function(e, t) {
                         var i = 65535;
                         for (i > e.pending_buf_size - 5 && (i = e.pending_buf_size - 5);;) {
                             if (e.lookahead <= 1) {
                                 if (C(e), 0 === e.lookahead && 0 === t) return 1;
@@ -20187,15 +20225,15 @@
                             var n = e.block_start + i;
                             if ((0 === e.strstart || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, v(e, !1), 0 === e.strm.avail_out)) return 1;
                             if (e.strstart - e.block_start >= e.w_size - d && (v(e, !1), 0 === e.strm.avail_out)) return 1
                         }
                         return e.insert = 0, 4 === t ? (v(e, !0), 0 === e.strm.avail_out ? 3 : 4) : (e.strstart > e.block_start && (v(e, !1), e.strm.avail_out), 1)
                     })), new E(4, 4, 8, 4, S), new E(4, 5, 16, 8, S), new E(4, 6, 32, 32, S), new E(4, 4, 16, 16, A), new E(8, 16, 32, 32, A), new E(8, 16, 128, 128, A), new E(8, 32, 128, 256, A), new E(32, 128, 258, 1024, A), new E(32, 258, 258, 4096, A)], t.deflateInit = function(e, t) {
                         return L(e, t, 8, 15, 8, 0)
-                    }, t.deflateInit2 = L, t.deflateReset = R, t.deflateResetKeep = M, t.deflateSetHeader = function(e, t) {
+                    }, t.deflateInit2 = L, t.deflateReset = R, t.deflateResetKeep = T, t.deflateSetHeader = function(e, t) {
                         return e && e.state ? 2 !== e.state.wrap ? h : (e.state.gzhead = t, 0) : h
                     }, t.deflate = function(e, t) {
                         var i, r, o, l;
                         if (!e || !e.state || t > 5 || t < 0) return e ? g(e, h) : h;
                         if (r = e.state, !e.output || !e.input && 0 !== e.avail_in || r.status === p && 4 !== t) return g(e, 0 === e.avail_out ? -5 : h);
                         if (r.strm = e, i = r.last_flush, r.last_flush = t, 42 === r.status)
                             if (2 === r.wrap) e.adler = 0, y(r, 31), y(r, 139), y(r, 8), r.gzhead ? (y(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), y(r, 255 & r.gzhead.time), y(r, r.gzhead.time >> 8 & 255), y(r, r.gzhead.time >> 16 & 255), y(r, r.gzhead.time >> 24 & 255), y(r, 9 === r.level ? 2 : r.strategy >= 2 || r.level < 2 ? 4 : 0), y(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (y(r, 255 & r.gzhead.extra.length), y(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = a(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = 69) : (y(r, 0), y(r, 0), y(r, 0), y(r, 0), y(r, 0), y(r, 9 === r.level ? 2 : r.strategy >= 2 || r.level < 2 ? 4 : 0), y(r, 3), r.status = f);
@@ -20432,19 +20470,19 @@
                     function _(e, t, i, r) {
                         var s, o = e.state;
                         return null === o.window && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new n.Buf8(o.wsize)), r >= o.wsize ? (n.arraySet(o.window, t, i - o.wsize, o.wsize, 0), o.wnext = 0, o.whave = o.wsize) : ((s = o.wsize - o.wnext) > r && (s = r), n.arraySet(o.window, t, i - r, s, o.wnext), (r -= s) ? (n.arraySet(o.window, t, i - r, r, 0), o.wnext = r, o.whave = o.wsize) : (o.wnext += s, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += s))), 0
                     }
                     t.inflateReset = p, t.inflateReset2 = g, t.inflateResetKeep = f, t.inflateInit = function(e) {
                         return m(e, 15)
                     }, t.inflateInit2 = m, t.inflate = function(e, t) {
-                        var i, u, f, p, g, m, b, w, v, x, k, C, S, A, E, T, M, R, L, I, B, N, F, P, O = 0,
+                        var i, u, f, p, g, m, b, w, v, x, k, C, S, A, E, M, T, R, L, I, B, F, N, O, P = 0,
                             D = new n.Buf8(4),
                             z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                         if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return l;
-                        (i = e.state).mode === h && (i.mode = 13), g = e.next_out, f = e.output, b = e.avail_out, p = e.next_in, u = e.input, m = e.avail_in, w = i.hold, v = i.bits, x = m, k = b, N = 0;
+                        (i = e.state).mode === h && (i.mode = 13), g = e.next_out, f = e.output, b = e.avail_out, p = e.next_in, u = e.input, m = e.avail_in, w = i.hold, v = i.bits, x = m, k = b, F = 0;
                         e: for (;;) switch (i.mode) {
                             case 1:
                                 if (0 === i.wrap) {
                                     i.mode = 13;
                                     break
                                 }
                                 for (; v < 16;) {
@@ -20615,47 +20653,47 @@
                                     for (; v < 3;) {
                                         if (0 === m) break e;
                                         m--, w += u[p++] << v, v += 8
                                     }
                                     i.lens[z[i.have++]] = 7 & w, w >>>= 3, v -= 3
                                 }
                                 for (; i.have < 19;) i.lens[z[i.have++]] = 0;
-                                if (i.lencode = i.lendyn, i.lenbits = 7, F = {
+                                if (i.lencode = i.lendyn, i.lenbits = 7, N = {
                                         bits: i.lenbits
-                                    }, N = a(0, i.lens, 0, 19, i.lencode, 0, i.work, F), i.lenbits = F.bits, N) {
+                                    }, F = a(0, i.lens, 0, 19, i.lencode, 0, i.work, N), i.lenbits = N.bits, F) {
                                     e.msg = "invalid code lengths set", i.mode = c;
                                     break
                                 }
                                 i.have = 0, i.mode = 19;
                             case 19:
                                 for (; i.have < i.nlen + i.ndist;) {
-                                    for (; T = (O = i.lencode[w & (1 << i.lenbits) - 1]) >>> 16 & 255, M = 65535 & O, !((E = O >>> 24) <= v);) {
+                                    for (; M = (P = i.lencode[w & (1 << i.lenbits) - 1]) >>> 16 & 255, T = 65535 & P, !((E = P >>> 24) <= v);) {
                                         if (0 === m) break e;
                                         m--, w += u[p++] << v, v += 8
                                     }
-                                    if (M < 16) w >>>= E, v -= E, i.lens[i.have++] = M;
+                                    if (T < 16) w >>>= E, v -= E, i.lens[i.have++] = T;
                                     else {
-                                        if (16 === M) {
-                                            for (P = E + 2; v < P;) {
+                                        if (16 === T) {
+                                            for (O = E + 2; v < O;) {
                                                 if (0 === m) break e;
                                                 m--, w += u[p++] << v, v += 8
                                             }
                                             if (w >>>= E, v -= E, 0 === i.have) {
                                                 e.msg = "invalid bit length repeat", i.mode = c;
                                                 break
                                             }
                                             B = i.lens[i.have - 1], C = 3 + (3 & w), w >>>= 2, v -= 2
-                                        } else if (17 === M) {
-                                            for (P = E + 3; v < P;) {
+                                        } else if (17 === T) {
+                                            for (O = E + 3; v < O;) {
                                                 if (0 === m) break e;
                                                 m--, w += u[p++] << v, v += 8
                                             }
                                             v -= E, B = 0, C = 3 + (7 & (w >>>= E)), w >>>= 3, v -= 3
                                         } else {
-                                            for (P = E + 7; v < P;) {
+                                            for (O = E + 7; v < O;) {
                                                 if (0 === m) break e;
                                                 m--, w += u[p++] << v, v += 8
                                             }
                                             v -= E, B = 0, C = 11 + (127 & (w >>>= E)), w >>>= 7, v -= 7
                                         }
                                         if (i.have + C > i.nlen + i.ndist) {
                                             e.msg = "invalid bit length repeat", i.mode = c;
@@ -20665,87 +20703,87 @@
                                     }
                                 }
                                 if (i.mode === c) break;
                                 if (0 === i.lens[256]) {
                                     e.msg = "invalid code -- missing end-of-block", i.mode = c;
                                     break
                                 }
-                                if (i.lenbits = 9, F = {
+                                if (i.lenbits = 9, N = {
                                         bits: i.lenbits
-                                    }, N = a(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, F), i.lenbits = F.bits, N) {
+                                    }, F = a(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, N), i.lenbits = N.bits, F) {
                                     e.msg = "invalid literal/lengths set", i.mode = c;
                                     break
                                 }
-                                if (i.distbits = 6, i.distcode = i.distdyn, F = {
+                                if (i.distbits = 6, i.distcode = i.distdyn, N = {
                                         bits: i.distbits
-                                    }, N = a(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, F), i.distbits = F.bits, N) {
+                                    }, F = a(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, N), i.distbits = N.bits, F) {
                                     e.msg = "invalid distances set", i.mode = c;
                                     break
                                 }
                                 if (i.mode = 20, 6 === t) break e;
                             case 20:
                                 i.mode = 21;
                             case 21:
                                 if (m >= 6 && b >= 258) {
                                     e.next_out = g, e.avail_out = b, e.next_in = p, e.avail_in = m, i.hold = w, i.bits = v, o(e, k), g = e.next_out, f = e.output, b = e.avail_out, p = e.next_in, u = e.input, m = e.avail_in, w = i.hold, v = i.bits, i.mode === h && (i.back = -1);
                                     break
                                 }
-                                for (i.back = 0; T = (O = i.lencode[w & (1 << i.lenbits) - 1]) >>> 16 & 255, M = 65535 & O, !((E = O >>> 24) <= v);) {
+                                for (i.back = 0; M = (P = i.lencode[w & (1 << i.lenbits) - 1]) >>> 16 & 255, T = 65535 & P, !((E = P >>> 24) <= v);) {
                                     if (0 === m) break e;
                                     m--, w += u[p++] << v, v += 8
                                 }
-                                if (T && 0 == (240 & T)) {
-                                    for (R = E, L = T, I = M; T = (O = i.lencode[I + ((w & (1 << R + L) - 1) >> R)]) >>> 16 & 255, M = 65535 & O, !(R + (E = O >>> 24) <= v);) {
+                                if (M && 0 == (240 & M)) {
+                                    for (R = E, L = M, I = T; M = (P = i.lencode[I + ((w & (1 << R + L) - 1) >> R)]) >>> 16 & 255, T = 65535 & P, !(R + (E = P >>> 24) <= v);) {
                                         if (0 === m) break e;
                                         m--, w += u[p++] << v, v += 8
                                     }
                                     w >>>= R, v -= R, i.back += R
                                 }
-                                if (w >>>= E, v -= E, i.back += E, i.length = M, 0 === T) {
+                                if (w >>>= E, v -= E, i.back += E, i.length = T, 0 === M) {
                                     i.mode = 26;
                                     break
                                 }
-                                if (32 & T) {
+                                if (32 & M) {
                                     i.back = -1, i.mode = h;
                                     break
                                 }
-                                if (64 & T) {
+                                if (64 & M) {
                                     e.msg = "invalid literal/length code", i.mode = c;
                                     break
                                 }
-                                i.extra = 15 & T, i.mode = 22;
+                                i.extra = 15 & M, i.mode = 22;
                             case 22:
                                 if (i.extra) {
-                                    for (P = i.extra; v < P;) {
+                                    for (O = i.extra; v < O;) {
                                         if (0 === m) break e;
                                         m--, w += u[p++] << v, v += 8
                                     }
                                     i.length += w & (1 << i.extra) - 1, w >>>= i.extra, v -= i.extra, i.back += i.extra
                                 }
                                 i.was = i.length, i.mode = 23;
                             case 23:
-                                for (; T = (O = i.distcode[w & (1 << i.distbits) - 1]) >>> 16 & 255, M = 65535 & O, !((E = O >>> 24) <= v);) {
+                                for (; M = (P = i.distcode[w & (1 << i.distbits) - 1]) >>> 16 & 255, T = 65535 & P, !((E = P >>> 24) <= v);) {
                                     if (0 === m) break e;
                                     m--, w += u[p++] << v, v += 8
                                 }
-                                if (0 == (240 & T)) {
-                                    for (R = E, L = T, I = M; T = (O = i.distcode[I + ((w & (1 << R + L) - 1) >> R)]) >>> 16 & 255, M = 65535 & O, !(R + (E = O >>> 24) <= v);) {
+                                if (0 == (240 & M)) {
+                                    for (R = E, L = M, I = T; M = (P = i.distcode[I + ((w & (1 << R + L) - 1) >> R)]) >>> 16 & 255, T = 65535 & P, !(R + (E = P >>> 24) <= v);) {
                                         if (0 === m) break e;
                                         m--, w += u[p++] << v, v += 8
                                     }
                                     w >>>= R, v -= R, i.back += R
                                 }
-                                if (w >>>= E, v -= E, i.back += E, 64 & T) {
+                                if (w >>>= E, v -= E, i.back += E, 64 & M) {
                                     e.msg = "invalid distance code", i.mode = c;
                                     break
                                 }
-                                i.offset = M, i.extra = 15 & T, i.mode = 24;
+                                i.offset = T, i.extra = 15 & M, i.mode = 24;
                             case 24:
                                 if (i.extra) {
-                                    for (P = i.extra; v < P;) {
+                                    for (O = i.extra; v < O;) {
                                         if (0 === m) break e;
                                         m--, w += u[p++] << v, v += 8
                                     }
                                     i.offset += w & (1 << i.extra) - 1, w >>>= i.extra, v -= i.extra, i.back += i.extra
                                 }
                                 if (i.offset > i.dmax) {
                                     e.msg = "invalid distance too far back", i.mode = c;
@@ -20794,25 +20832,25 @@
                                         e.msg = "incorrect length check", i.mode = c;
                                         break
                                     }
                                     w = 0, v = 0
                                 }
                                 i.mode = 29;
                             case 29:
-                                N = 1;
+                                F = 1;
                                 break e;
                             case c:
-                                N = -3;
+                                F = -3;
                                 break e;
                             case 31:
                                 return -4;
                             default:
                                 return l
                         }
-                        return e.next_out = g, e.avail_out = b, e.next_in = p, e.avail_in = m, i.hold = w, i.bits = v, (i.wsize || k !== e.avail_out && i.mode < c && (i.mode < 27 || 4 !== t)) && _(e, e.output, e.next_out, k - e.avail_out) ? (i.mode = 31, -4) : (x -= e.avail_in, k -= e.avail_out, e.total_in += x, e.total_out += k, i.total += k, i.wrap && k && (e.adler = i.check = i.flags ? s(i.check, f, k, e.next_out - k) : r(i.check, f, k, e.next_out - k)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === h ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0), (0 === x && 0 === k || 4 === t) && 0 === N && (N = -5), N)
+                        return e.next_out = g, e.avail_out = b, e.next_in = p, e.avail_in = m, i.hold = w, i.bits = v, (i.wsize || k !== e.avail_out && i.mode < c && (i.mode < 27 || 4 !== t)) && _(e, e.output, e.next_out, k - e.avail_out) ? (i.mode = 31, -4) : (x -= e.avail_in, k -= e.avail_out, e.total_in += x, e.total_out += k, i.total += k, i.wrap && k && (e.adler = i.check = i.flags ? s(i.check, f, k, e.next_out - k) : r(i.check, f, k, e.next_out - k)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === h ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0), (0 === x && 0 === k || 4 === t) && 0 === F && (F = -5), F)
                     }, t.inflateEnd = function(e) {
                         if (!e || !e.state) return l;
                         var t = e.state;
                         return t.window && (t.window = null), e.state = null, 0
                     }, t.inflateGetHeader = function(e, t) {
                         var i;
                         return e && e.state ? 0 == (2 & (i = e.state).wrap) ? l : (i.head = t, t.done = !1, 0) : l
@@ -20830,53 +20868,53 @@
                     e.exports = function(e, t, i, l, h, c, d, u) {
                         var f, p, g, m, b, w, v, y, _, x = u.bits,
                             k = 0,
                             C = 0,
                             S = 0,
                             A = 0,
                             E = 0,
-                            T = 0,
                             M = 0,
+                            T = 0,
                             R = 0,
                             L = 0,
                             I = 0,
                             B = null,
-                            N = 0,
-                            F = new n.Buf16(16),
-                            P = new n.Buf16(16),
-                            O = null,
+                            F = 0,
+                            N = new n.Buf16(16),
+                            O = new n.Buf16(16),
+                            P = null,
                             D = 0;
-                        for (k = 0; k <= 15; k++) F[k] = 0;
-                        for (C = 0; C < l; C++) F[t[i + C]]++;
-                        for (E = x, A = 15; A >= 1 && 0 === F[A]; A--);
+                        for (k = 0; k <= 15; k++) N[k] = 0;
+                        for (C = 0; C < l; C++) N[t[i + C]]++;
+                        for (E = x, A = 15; A >= 1 && 0 === N[A]; A--);
                         if (E > A && (E = A), 0 === A) return h[c++] = 20971520, h[c++] = 20971520, u.bits = 1, 0;
-                        for (S = 1; S < A && 0 === F[S]; S++);
+                        for (S = 1; S < A && 0 === N[S]; S++);
                         for (E < S && (E = S), R = 1, k = 1; k <= 15; k++)
-                            if (R <<= 1, (R -= F[k]) < 0) return -1;
+                            if (R <<= 1, (R -= N[k]) < 0) return -1;
                         if (R > 0 && (0 === e || 1 !== A)) return -1;
-                        for (P[1] = 0, k = 1; k < 15; k++) P[k + 1] = P[k] + F[k];
-                        for (C = 0; C < l; C++) 0 !== t[i + C] && (d[P[t[i + C]]++] = C);
-                        if (0 === e ? (B = O = d, w = 19) : 1 === e ? (B = r, N -= 257, O = s, D -= 257, w = 256) : (B = o, O = a, w = -1), I = 0, C = 0, k = S, b = c, T = E, M = 0, g = -1, m = (L = 1 << E) - 1, 1 === e && L > 852 || 2 === e && L > 592) return 1;
+                        for (O[1] = 0, k = 1; k < 15; k++) O[k + 1] = O[k] + N[k];
+                        for (C = 0; C < l; C++) 0 !== t[i + C] && (d[O[t[i + C]]++] = C);
+                        if (0 === e ? (B = P = d, w = 19) : 1 === e ? (B = r, F -= 257, P = s, D -= 257, w = 256) : (B = o, P = a, w = -1), I = 0, C = 0, k = S, b = c, M = E, T = 0, g = -1, m = (L = 1 << E) - 1, 1 === e && L > 852 || 2 === e && L > 592) return 1;
                         for (;;) {
-                            v = k - M, d[C] < w ? (y = 0, _ = d[C]) : d[C] > w ? (y = O[D + d[C]], _ = B[N + d[C]]) : (y = 96, _ = 0), f = 1 << k - M, S = p = 1 << T;
+                            v = k - T, d[C] < w ? (y = 0, _ = d[C]) : d[C] > w ? (y = P[D + d[C]], _ = B[F + d[C]]) : (y = 96, _ = 0), f = 1 << k - T, S = p = 1 << M;
                             do {
-                                h[b + (I >> M) + (p -= f)] = v << 24 | y << 16 | _ | 0
+                                h[b + (I >> T) + (p -= f)] = v << 24 | y << 16 | _ | 0
                             } while (0 !== p);
                             for (f = 1 << k - 1; I & f;) f >>= 1;
-                            if (0 !== f ? (I &= f - 1, I += f) : I = 0, C++, 0 == --F[k]) {
+                            if (0 !== f ? (I &= f - 1, I += f) : I = 0, C++, 0 == --N[k]) {
                                 if (k === A) break;
                                 k = t[i + d[C]]
                             }
                             if (k > E && (I & m) !== g) {
-                                for (0 === M && (M = E), b += S, R = 1 << (T = k - M); T + M < A && !((R -= F[T + M]) <= 0);) T++, R <<= 1;
-                                if (L += 1 << T, 1 === e && L > 852 || 2 === e && L > 592) return 1;
-                                h[g = I & m] = E << 24 | T << 16 | b - c | 0
+                                for (0 === T && (T = E), b += S, R = 1 << (M = k - T); M + T < A && !((R -= N[M + T]) <= 0);) M++, R <<= 1;
+                                if (L += 1 << M, 1 === e && L > 852 || 2 === e && L > 592) return 1;
+                                h[g = I & m] = E << 24 | M << 16 | b - c | 0
                             }
                         }
-                        return 0 !== I && (h[b + I] = k - M << 24 | 64 << 16 | 0), u.bits = E, 0
+                        return 0 !== I && (h[b + I] = k - T << 24 | 64 << 16 | 0), u.bits = E, 0
                     }
                 },
                 8898: e => {
                     e.exports = {
                         2: "need dictionary",
                         1: "stream end",
                         0: "",
@@ -20960,22 +20998,22 @@
                         e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0
                     }
 
                     function E(e) {
                         e.bi_valid > 8 ? _(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0
                     }
 
-                    function T(e, t, i, n) {
+                    function M(e, t, i, n) {
                         var r = 2 * t,
                             s = 2 * i;
                         return e[r] < e[s] || e[r] === e[s] && n[t] <= n[i]
                     }
 
-                    function M(e, t, i) {
-                        for (var n = e.heap[i], r = i << 1; r <= e.heap_len && (r < e.heap_len && T(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !T(t, n, e.heap[r], e.depth));) e.heap[i] = e.heap[r], i = r, r <<= 1;
+                    function T(e, t, i) {
+                        for (var n = e.heap[i], r = i << 1; r <= e.heap_len && (r < e.heap_len && M(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !M(t, n, e.heap[r], e.depth));) e.heap[i] = e.heap[r], i = r, r <<= 1;
                         e.heap[i] = n
                     }
 
                     function R(e, t, i) {
                         var n, r, a, l, h = 0;
                         if (0 !== e.last_lit)
                             do {
@@ -20988,18 +21026,18 @@
                         var i, n, r, s = t.dyn_tree,
                             o = t.stat_desc.static_tree,
                             a = t.stat_desc.has_stree,
                             l = t.stat_desc.elems,
                             h = -1;
                         for (e.heap_len = 0, e.heap_max = 573, i = 0; i < l; i++) 0 !== s[2 * i] ? (e.heap[++e.heap_len] = h = i, e.depth[i] = 0) : s[2 * i + 1] = 0;
                         for (; e.heap_len < 2;) s[2 * (r = e.heap[++e.heap_len] = h < 2 ? ++h : 0)] = 1, e.depth[r] = 0, e.opt_len--, a && (e.static_len -= o[2 * r + 1]);
-                        for (t.max_code = h, i = e.heap_len >> 1; i >= 1; i--) M(e, s, i);
+                        for (t.max_code = h, i = e.heap_len >> 1; i >= 1; i--) T(e, s, i);
                         r = l;
                         do {
-                            i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], M(e, s, 1), n = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = n, s[2 * r] = s[2 * i] + s[2 * n], e.depth[r] = (e.depth[i] >= e.depth[n] ? e.depth[i] : e.depth[n]) + 1, s[2 * i + 1] = s[2 * n + 1] = r, e.heap[1] = r++, M(e, s, 1)
+                            i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], T(e, s, 1), n = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = n, s[2 * r] = s[2 * i] + s[2 * n], e.depth[r] = (e.depth[i] >= e.depth[n] ? e.depth[i] : e.depth[n]) + 1, s[2 * i + 1] = s[2 * n + 1] = r, e.heap[1] = r++, T(e, s, 1)
                         } while (e.heap_len >= 2);
                         e.heap[--e.heap_max] = e.heap[1],
                             function(e, t) {
                                 var i, n, r, s, o, a, l = t.dyn_tree,
                                     h = t.max_code,
                                     c = t.stat_desc.static_tree,
                                     d = t.stat_desc.has_stree,
@@ -21042,54 +21080,54 @@
                                         k(e, r, e.bl_tree)
                                     } while (0 != --a);
                                 else 0 !== r ? (r !== s && (k(e, r, e.bl_tree), a--), k(e, 16, e.bl_tree), x(e, a - 3, 2)) : a <= 10 ? (k(e, 17, e.bl_tree), x(e, a - 3, 3)) : (k(e, 18, e.bl_tree), x(e, a - 11, 7));
                                 a = 0, s = r, 0 === o ? (l = 138, h = 3) : r === o ? (l = 6, h = 3) : (l = 7, h = 4)
                             }
                     }
                     r(b);
-                    var N = !1;
+                    var F = !1;
 
-                    function F(e, t, i, r) {
+                    function N(e, t, i, r) {
                         x(e, 0 + (r ? 1 : 0), 3),
                             function(e, t, i, r) {
                                 E(e), _(e, i), _(e, ~i), n.arraySet(e.pending_buf, e.window, t, i, e.pending), e.pending += i
                             }(e, t, i)
                     }
                     t._tr_init = function(e) {
-                        N || (function() {
+                        F || (function() {
                             var e, t, i, n, r, l = new Array(16);
                             for (i = 0, n = 0; n < 28; n++)
                                 for (f[n] = i, e = 0; e < 1 << s[n]; e++) u[i++] = n;
                             for (u[i - 1] = n, r = 0, n = 0; n < 16; n++)
                                 for (b[n] = r, e = 0; e < 1 << o[n]; e++) d[r++] = n;
                             for (r >>= 7; n < 30; n++)
                                 for (b[n] = r << 7, e = 0; e < 1 << o[n] - 7; e++) d[256 + r++] = n;
                             for (t = 0; t <= 15; t++) l[t] = 0;
                             for (e = 0; e <= 143;) h[2 * e + 1] = 8, e++, l[8]++;
                             for (; e <= 255;) h[2 * e + 1] = 9, e++, l[9]++;
                             for (; e <= 279;) h[2 * e + 1] = 7, e++, l[7]++;
                             for (; e <= 287;) h[2 * e + 1] = 8, e++, l[8]++;
                             for (S(h, 287, l), e = 0; e < 30; e++) c[2 * e + 1] = 5, c[2 * e] = C(e, 5);
                             p = new w(h, s, 257, 286, 15), g = new w(c, o, 0, 30, 15), m = new w(new Array(0), a, 0, 19, 7)
-                        }(), N = !0), e.l_desc = new v(e.dyn_ltree, p), e.d_desc = new v(e.dyn_dtree, g), e.bl_desc = new v(e.bl_tree, m), e.bi_buf = 0, e.bi_valid = 0, A(e)
-                    }, t._tr_stored_block = F, t._tr_flush_block = function(e, t, i, n) {
+                        }(), F = !0), e.l_desc = new v(e.dyn_ltree, p), e.d_desc = new v(e.dyn_dtree, g), e.bl_desc = new v(e.bl_tree, m), e.bi_buf = 0, e.bi_valid = 0, A(e)
+                    }, t._tr_stored_block = N, t._tr_flush_block = function(e, t, i, n) {
                         var r, s, o = 0;
                         e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = function(e) {
                             var t, i = 4093624447;
                             for (t = 0; t <= 31; t++, i >>>= 1)
                                 if (1 & i && 0 !== e.dyn_ltree[2 * t]) return 0;
                             if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1;
                             for (t = 32; t < 256; t++)
                                 if (0 !== e.dyn_ltree[2 * t]) return 1;
                             return 0
                         }(e)), L(e, e.l_desc), L(e, e.d_desc), o = function(e) {
                             var t;
                             for (I(e, e.dyn_ltree, e.l_desc.max_code), I(e, e.dyn_dtree, e.d_desc.max_code), L(e, e.bl_desc), t = 18; t >= 3 && 0 === e.bl_tree[2 * l[t] + 1]; t--);
                             return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t
-                        }(e), r = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= r && (r = s)) : r = s = i + 5, i + 4 <= r && -1 !== t ? F(e, t, i, n) : 4 === e.strategy || s === r ? (x(e, 2 + (n ? 1 : 0), 3), R(e, h, c)) : (x(e, 4 + (n ? 1 : 0), 3), function(e, t, i, n) {
+                        }(e), r = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= r && (r = s)) : r = s = i + 5, i + 4 <= r && -1 !== t ? N(e, t, i, n) : 4 === e.strategy || s === r ? (x(e, 2 + (n ? 1 : 0), 3), R(e, h, c)) : (x(e, 4 + (n ? 1 : 0), 3), function(e, t, i, n) {
                             var r;
                             for (x(e, t - 257, 5), x(e, i - 1, 5), x(e, n - 4, 4), r = 0; r < n; r++) x(e, e.bl_tree[2 * l[r] + 1], 3);
                             B(e, e.dyn_ltree, t - 1), B(e, e.dyn_dtree, i - 1)
                         }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1), R(e, e.dyn_ltree, e.dyn_dtree)), A(e), n && E(e)
                     }, t._tr_tally = function(e, t, i) {
                         return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & i, e.last_lit++, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * (u[i] + 256 + 1)]++, e.dyn_dtree[2 * y(t)]++), e.last_lit === e.lit_bufsize - 1
                     }, t._tr_align = function(e) {
@@ -21375,37 +21413,37 @@
                             this.protocol = x, v = v.substr(_.length)
                         }
                         if (i || _ || v.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                             var k = "//" === v.substr(0, 2);
                             !k || _ && m[_] || (v = v.substr(2), this.slashes = !0)
                         }
                         if (!m[_] && (k || _ && !b[_])) {
-                            for (var C, S, A = -1, E = 0; E < u.length; E++) - 1 !== (T = v.indexOf(u[E])) && (-1 === A || T < A) && (A = T);
+                            for (var C, S, A = -1, E = 0; E < u.length; E++) - 1 !== (M = v.indexOf(u[E])) && (-1 === A || M < A) && (A = M);
                             for (-1 !== (S = -1 === A ? v.lastIndexOf("@") : v.lastIndexOf("@", A)) && (C = v.slice(0, S), v = v.slice(S + 1), this.auth = decodeURIComponent(C)), A = -1, E = 0; E < d.length; E++) {
-                                var T; - 1 !== (T = v.indexOf(d[E])) && (-1 === A || T < A) && (A = T)
+                                var M; - 1 !== (M = v.indexOf(d[E])) && (-1 === A || M < A) && (A = M)
                             } - 1 === A && (A = v.length), this.host = v.slice(0, A), v = v.slice(A), this.parseHost(), this.hostname = this.hostname || "";
-                            var M = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
-                            if (!M)
+                            var T = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
+                            if (!T)
                                 for (var R = this.hostname.split(/\./), L = (E = 0, R.length); E < L; E++) {
                                     var I = R[E];
                                     if (I && !I.match(f)) {
-                                        for (var B = "", N = 0, F = I.length; N < F; N++) I.charCodeAt(N) > 127 ? B += "x" : B += I[N];
+                                        for (var B = "", F = 0, N = I.length; F < N; F++) I.charCodeAt(F) > 127 ? B += "x" : B += I[F];
                                         if (!B.match(f)) {
-                                            var P = R.slice(0, E),
-                                                O = R.slice(E + 1),
+                                            var O = R.slice(0, E),
+                                                P = R.slice(E + 1),
                                                 D = I.match(p);
-                                            D && (P.push(D[1]), O.unshift(D[2])), O.length && (v = "/" + O.join(".") + v), this.hostname = P.join(".");
+                                            D && (O.push(D[1]), P.unshift(D[2])), P.length && (v = "/" + P.join(".") + v), this.hostname = O.join(".");
                                             break
                                         }
                                     }
                                 }
-                            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), M || (this.hostname = n.toASCII(this.hostname));
+                            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), T || (this.hostname = n.toASCII(this.hostname));
                             var z = this.port ? ":" + this.port : "",
                                 H = this.hostname || "";
-                            this.host = H + z, this.href += this.host, M && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v[0] && (v = "/" + v))
+                            this.host = H + z, this.href += this.host, T && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v[0] && (v = "/" + v))
                         }
                         if (!g[x])
                             for (E = 0, L = c.length; E < L; E++) {
                                 var V = c[E];
                                 if (-1 !== v.indexOf(V)) {
                                     var U = encodeURIComponent(V);
                                     U === V && (U = escape(V)), v = v.split(V).join(U)
@@ -21475,22 +21513,22 @@
                             y = e.host || e.pathname && "/" === e.pathname.charAt(0),
                             _ = y || v || i.host && e.pathname,
                             x = _,
                             k = i.pathname && i.pathname.split("/") || [],
                             C = (p = e.pathname && e.pathname.split("/") || [], i.protocol && !b[i.protocol]);
                         if (C && (i.hostname = "", i.port = null, i.host && ("" === k[0] ? k[0] = i.host : k.unshift(i.host)), i.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === p[0] ? p[0] = e.host : p.unshift(e.host)), e.host = null), _ = _ && ("" === p[0] || "" === k[0])), y) i.host = e.host || "" === e.host ? e.host : i.host, i.hostname = e.hostname || "" === e.hostname ? e.hostname : i.hostname, i.search = e.search, i.query = e.query, k = p;
                         else if (p.length) k || (k = []), k.pop(), k = k.concat(p), i.search = e.search, i.query = e.query;
-                        else if (!r.isNullOrUndefined(e.search)) return C && (i.hostname = i.host = k.shift(), (M = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = M.shift(), i.host = i.hostname = M.shift())), i.search = e.search, i.query = e.query, r.isNull(i.pathname) && r.isNull(i.search) || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.href = i.format(), i;
+                        else if (!r.isNullOrUndefined(e.search)) return C && (i.hostname = i.host = k.shift(), (T = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = T.shift(), i.host = i.hostname = T.shift())), i.search = e.search, i.query = e.query, r.isNull(i.pathname) && r.isNull(i.search) || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.href = i.format(), i;
                         if (!k.length) return i.pathname = null, i.search ? i.path = "/" + i.search : i.path = null, i.href = i.format(), i;
-                        for (var S = k.slice(-1)[0], A = (i.host || e.host || k.length > 1) && ("." === S || ".." === S) || "" === S, E = 0, T = k.length; T >= 0; T--) "." === (S = k[T]) ? k.splice(T, 1) : ".." === S ? (k.splice(T, 1), E++) : E && (k.splice(T, 1), E--);
+                        for (var S = k.slice(-1)[0], A = (i.host || e.host || k.length > 1) && ("." === S || ".." === S) || "" === S, E = 0, M = k.length; M >= 0; M--) "." === (S = k[M]) ? k.splice(M, 1) : ".." === S ? (k.splice(M, 1), E++) : E && (k.splice(M, 1), E--);
                         if (!_ && !x)
                             for (; E--; E) k.unshift("..");
                         !_ || "" === k[0] || k[0] && "/" === k[0].charAt(0) || k.unshift(""), A && "/" !== k.join("/").substr(-1) && k.push("");
-                        var M, R = "" === k[0] || k[0] && "/" === k[0].charAt(0);
-                        return C && (i.hostname = i.host = R ? "" : k.length ? k.shift() : "", (M = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = M.shift(), i.host = i.hostname = M.shift())), (_ = _ || i.host && k.length) && !R && k.unshift(""), k.length ? i.pathname = k.join("/") : (i.pathname = null, i.path = null), r.isNull(i.pathname) && r.isNull(i.search) || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.auth = e.auth || i.auth, i.slashes = i.slashes || e.slashes, i.href = i.format(), i
+                        var T, R = "" === k[0] || k[0] && "/" === k[0].charAt(0);
+                        return C && (i.hostname = i.host = R ? "" : k.length ? k.shift() : "", (T = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = T.shift(), i.host = i.hostname = T.shift())), (_ = _ || i.host && k.length) && !R && k.unshift(""), k.length ? i.pathname = k.join("/") : (i.pathname = null, i.path = null), r.isNull(i.pathname) && r.isNull(i.search) || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.auth = e.auth || i.auth, i.slashes = i.slashes || e.slashes, i.href = i.format(), i
                     }, s.prototype.parseHost = function() {
                         var e = this.host,
                             t = a.exec(e);
                         t && (":" !== (t = t[0]) && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
                     }
                 },
                 2502: e => {
@@ -21544,36 +21582,36 @@
             "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                 value: "Module"
             }), Object.defineProperty(e, "__esModule", {
                 value: !0
             })
         }, i.nmd = e => (e.paths = [], e.children || (e.children = []), e), i(5590)
     })();
-    class yd {
+    class nd {
         constructor(e, t, i) {
-            this.config = e, this.browser = i, this.genome = t, this.cramFile = new vd.CramFile({
-                filehandle: new _d(e.url, e),
+            this.config = e, this.browser = i, this.genome = t, this.cramFile = new id.CramFile({
+                filehandle: new rd(e.url, e),
                 seqFetch: e.seqFetch || function(e, t, i) {
                     const n = this.genome.sequence,
                         r = this.genome;
                     return this.getHeader().then((function(s) {
                         const o = r.getChromosomeName(s.chrNames[e]);
                         return n.getSequence(o, t - 1, i)
                     }))
                 }.bind(this),
                 checkSequenceMD5: void 0 === e.checkSequenceMD5 || e.checkSequenceMD5
             });
-            const n = new _d(e.indexURL, e);
-            this.indexedCramFile = new vd.IndexedCramFile({
+            const n = new rd(e.indexURL, e);
+            this.indexedCramFile = new id.IndexedCramFile({
                 cram: this.cramFile,
-                index: new vd.CraiIndex({
+                index: new id.CraiIndex({
                     filehandle: n
                 }),
                 fetchSizeLimit: 3e7
-            }), ld.setReaderDefaults(this, e)
+            }), $c.setReaderDefaults(this, e)
         }
         async getHeader() {
             if (!this.header) {
                 const e = this.genome,
                     t = await this.cramFile.getSamHeader(),
                     i = {},
                     n = [],
@@ -21600,15 +21638,15 @@
             return this.header
         }
         async readAlignments(e, t, i) {
             this.browser;
             const n = await this.getHeader(),
                 r = n.chrAliasTable.hasOwnProperty(e) ? n.chrAliasTable[e] : e,
                 s = n.chrToIndex[r],
-                o = new Hc(e, t, i, this.config);
+                o = new kc(e, t, i, this.config);
             if (void 0 === s) return o;
             try {
                 const e = await this.indexedCramFile.getRecordsForRange(s, t, i);
                 for (let r of e) {
                     const e = r.sequenceId,
                         l = r.alignmentStart,
                         h = l + r.lengthOnRef;
@@ -21622,15 +21660,15 @@
                 return o.finish(), o
             } catch (e) {
                 let t = e.message;
                 throw t && t.indexOf("MD5") >= 0 && (t = "Sequence mismatch. Is this the correct genome for the loaded CRAM?"), this.browser.alert.present(new Error(t)), e
             }
 
             function a(e, t) {
-                const i = new Zc;
+                const i = new Lc;
                 if (i.chr = t[e.sequenceId], i.start = e.alignmentStart - 1, i.lengthOnRef = e.lengthOnRef, i.flags = e.flags, i.strand = !(16 & e.flags), i.fragmentLength = e.templateLength || e.templateSize, i.mq = e.mappingQuality, i.end = e.alignmentStart + e.lengthOnRef, i.readGroupId = e.readGroupId, e.mate && void 0 !== e.mate.sequenceId) {
                     const n = void 0 !== e.mate.flags ? !(1 & e.mate.flags) : !(32 & e.flags);
                     i.mate = {
                         chr: t[e.mate.sequenceId],
                         position: e.mate.alignmentStart,
                         strand: n
                     }
@@ -21650,35 +21688,35 @@
                                     case "S":
                                     case "I":
                                     case "i":
                                     case "N":
                                     case "D":
                                         if (h > s) {
                                             const e = h - s;
-                                            i.push(new id({
+                                            i.push(new zc({
                                                 start: c - e,
                                                 seqOffset: s,
                                                 len: e,
                                                 type: "M"
                                             })), s += e, o += e + "M"
                                         }
                                         if ("S" === e) {
                                             let n = c;
                                             t.scLengthOnRef += l.length, 0 === h && (t.scStart -= l.length, n -= l.length);
                                             const r = l.length;
-                                            i.push(new id({
+                                            i.push(new zc({
                                                 start: n,
                                                 seqOffset: s,
                                                 len: r,
                                                 type: "S"
                                             })), s += r, o += r + e
                                         } else if ("I" === e || "i" === e) {
                                             void 0 === n && (n = []);
                                             const t = "i" === e ? 1 : l.length;
-                                            n.push(new id({
+                                            n.push(new zc({
                                                 start: c,
                                                 len: t,
                                                 seqOffset: s,
                                                 type: "I"
                                             })), s += t, o += t + e
                                         } else "D" !== e && "N" !== e || (r || (r = []), r.push({
                                             start: c,
@@ -21688,67 +21726,67 @@
                                         break;
                                     case "H":
                                     case "P":
                                         o += l + e
                                 }
                             }
                         const a = e.readLength - s;
-                        a > 0 && (i.push(new id({
+                        a > 0 && (i.push(new zc({
                             start: e.alignmentStart + e.lengthOnRef - a - 1,
                             seqOffset: s,
                             len: a,
                             type: "M"
                         })), o += a + "M");
                         t.blocks = i, t.insertions = n, t.gaps = r, t.cigar = o
-                    }(e, i), i.mate && i.start > i.mate.position && i.fragmentLength > 0 && (i.fragmentLength = -i.fragmentLength), ld.setPairOrientation(i), i
+                    }(e, i), i.mate && i.start > i.mate.position && i.fragmentLength > 0 && (i.fragmentLength = -i.fragmentLength), $c.setPairOrientation(i), i
             }
         }
     }
-    class _d {
+    class rd {
         constructor(e, t) {
-            this.position = 0, this.url = e, this.config = t, this.cache = new xd({
+            this.position = 0, this.url = e, this.config = t, this.cache = new sd({
                 fetch: (e, t) => this._fetch(e, t)
             })
         }
         async _fetch(e, t) {
             const i = {
                 start: e,
                 size: t
             };
             this._stat = {
                 size: void 0
             };
-            const n = await lo.loadArrayBuffer(this.url, No(this.config, {
+            const n = await io.loadArrayBuffer(this.url, Mo(this.config, {
                 range: i
             }));
             return Buffer.from(n)
         }
         async read(e, t = 0, i = 1 / 0, n = 0) {
             let r = n;
             return null === n && (r = this.position, this.position += i), this.cache.get(e, t, i, n)
         }
         async readFile() {
-            const e = await lo.loadArrayBuffer(this.url, No(this.config));
+            const e = await io.loadArrayBuffer(this.url, Mo(this.config));
             return Buffer.from(e)
         }
         async stat() {
             if (!this._stat) {
                 const e = Buffer.allocUnsafe(10);
                 if (await this.read(e, 0, 10, 0), !this._stat) throw new Error(`unable to determine size of file at ${this.url}`)
             }
             return this._stat
         }
     }
-    class xd {
+    class sd {
         constructor({
             fetch: e,
             size: t = 1e7,
             chunkSize: i = 32768
         }) {
-            this.fetch = e, this.chunkSize = i, this.lruCache = new kd({
+            this.fetch = e, this.chunkSize = i, this.lruCache = new od({
                 maxSize: Math.floor(t / i)
             })
         }
         async get(e, t, i, n) {
             if (e.length < t + i) throw new Error("output buffer not big enough for request");
             const r = Math.floor(n / this.chunkSize),
                 s = Math.floor((n + i) / this.chunkSize),
@@ -21773,15 +21811,15 @@
         _getChunk(e) {
             const t = this.lruCache.get(e);
             if (t) return t;
             const i = this.fetch(e * this.chunkSize, this.chunkSize);
             return this.lruCache.set(e, i), i
         }
     }
-    class kd {
+    class od {
         constructor(e = {}) {
             if (!(e.maxSize && e.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
             this.maxSize = e.maxSize, this.cache = new Map, this.oldCache = new Map, this._size = 0
         }
         _set(e, t) {
             this.cache.set(e, t), this._size++, this._size >= this.maxSize && (this._size = 0, this.oldCache = this.cache, this.cache = new Map)
         }
@@ -21820,35 +21858,35 @@
         }
         get size() {
             let e = 0;
             for (const t of this.oldCache.keys()) this.cache.has(t) || e++;
             return this._size + e
         }
     }
-    var Cd = {
+    var ad = {
         ALIGNMENT_MATCH: "M",
         INSERT: "I",
         DELETE: "D",
         SKIP: "N",
         CLIP_SOFT: "S",
         CLIP_HARD: "H",
         PAD: "P",
         SEQUENCE_MATCH: "=",
         SEQUENCE_MISMATCH: "X"
     };
-    const Sd = function(e, t) {
-        this.config = e, this.genome = t, this.url = e.url, this.filter = new nd(e.filter), this.readGroupSetIds = e.readGroupSetIds, this.authKey = e.authKey, this.samplingWindowSize = void 0 === e.samplingWindowSize ? 100 : e.samplingWindowSize, this.samplingDepth = void 0 === e.samplingDepth ? 1e3 : e.samplingDepth, e.viewAsPairs ? this.pairsSupported = !0 : this.pairsSupported = void 0 === e.pairsSupported || e.pairsSupported
+    const ld = function(e, t) {
+        this.config = e, this.genome = t, this.url = e.url, this.filter = new Hc(e.filter), this.readGroupSetIds = e.readGroupSetIds, this.authKey = e.authKey, this.samplingWindowSize = void 0 === e.samplingWindowSize ? 100 : e.samplingWindowSize, this.samplingDepth = void 0 === e.samplingDepth ? 1e3 : e.samplingDepth, e.viewAsPairs ? this.pairsSupported = !0 : this.pairsSupported = void 0 === e.pairsSupported || e.pairsSupported
     };
-    Sd.prototype.readAlignments = function(e, t, i) {
+    ld.prototype.readAlignments = function(e, t, i) {
         const n = this.genome,
             r = this;
         return (r.chrAliasTable ? Promise.resolve(r.chrAliasTable) : r.readMetadata().then((function(e) {
             if (r.chrAliasTable = {}, n && e.readGroups && e.readGroups.length > 0) {
                 var t = e.readGroups[0].referenceSetId;
-                return t ? Hh({
+                return t ? Ah({
                     url: r.url + "/references/search",
                     body: {
                         referenceSetId: t
                     },
                     decode: function(e) {
                         return e.references
                     }
@@ -21865,55 +21903,55 @@
                         e.chrX = "X", e.chrY = "Y", e.chrM = "MT"
                     }
                 }(r.chrAliasTable, r.config.datasetId), r.chrAliasTable)
             }
             return r.chrAliasTable
         }))).then((function(n) {
             var o = n.hasOwnProperty(e) ? n[e] : e;
-            return Hh({
+            return Ah({
                 url: r.url + "/reads/search",
                 body: {
                     readGroupSetIds: [r.readGroupSetIds],
                     referenceName: o,
                     start: t,
                     end: i,
                     pageSize: "10000"
                 },
                 decode: s,
-                results: new Hc(e, t, i, r.config)
+                results: new kc(e, t, i, r.config)
             })
         }));
 
         function s(e) {
             var t, i, s, o, a, l = e.alignments,
                 h = l.length,
                 c = [];
             for (t = 0; t < h; t++) {
                 let e = l[t];
-                (i = new Zc).readName = e.fragmentName, i.properPlacement = e.properPlacement, i.duplicateFragment = e.duplicateFragment, i.numberReads = e.numberReads, i.fragmentLength = e.fragmentLength, i.readNumber = e.readNumber, i.failedVendorQualityChecks = e.failedVendorQualityChecks, i.secondaryAlignment = e.secondaryAlignment, i.supplementaryAlignment = e.supplementaryAlignment, i.seq = e.alignedSequence, i.qual = e.alignedQuality, i.matePos = e.nextMatePosition, i.tagDict = e.info, i.flags = 0, e.alignment ? (i.mapped = !0, i.chr = e.alignment.position.referenceName, n && (i.chr = n.getChromosomeName(i.chr)), i.start = parseInt(e.alignment.position.position), i.strand = !e.alignment.position.reverseStrand, i.mq = e.alignment.mappingQuality, i.cigar = d(e.alignment.cigar), s = u(e.alignment.cigar), i.lengthOnRef = s.lengthOnRef, a = f(i, s.array), i.blocks = a.blocks, i.insertions = a.insertions) : i.mapped = !1, (o = e.nextMatePosition) && (i.mate = {
+                (i = new Lc).readName = e.fragmentName, i.properPlacement = e.properPlacement, i.duplicateFragment = e.duplicateFragment, i.numberReads = e.numberReads, i.fragmentLength = e.fragmentLength, i.readNumber = e.readNumber, i.failedVendorQualityChecks = e.failedVendorQualityChecks, i.secondaryAlignment = e.secondaryAlignment, i.supplementaryAlignment = e.supplementaryAlignment, i.seq = e.alignedSequence, i.qual = e.alignedQuality, i.matePos = e.nextMatePosition, i.tagDict = e.info, i.flags = 0, e.alignment ? (i.mapped = !0, i.chr = e.alignment.position.referenceName, n && (i.chr = n.getChromosomeName(i.chr)), i.start = parseInt(e.alignment.position.position), i.strand = !e.alignment.position.reverseStrand, i.mq = e.alignment.mappingQuality, i.cigar = d(e.alignment.cigar), s = u(e.alignment.cigar), i.lengthOnRef = s.lengthOnRef, a = f(i, s.array), i.blocks = a.blocks, i.insertions = a.insertions) : i.mapped = !1, (o = e.nextMatePosition) && (i.mate = {
                     chr: o.referenceFrame,
                     position: parseInt(o.position),
                     strand: !o.reverseStrand
                 }), r.filter.pass(i) && c.push(i)
             }
             return c;
 
             function d(e) {
                 var t = "";
                 return e.forEach((function(e) {
-                    var i = Cd[e.operation],
+                    var i = ad[e.operation],
                         n = e.operationLength;
                     t += n + i
                 })), t
             }
 
             function u(e) {
                 var t, i, n, r, s = 0,
                     o = [];
-                for (r = 0; r < e.length; r++) t = e[r], n = Cd[t.operation], i = parseInt(t.operationLength), "M" !== n && "EQ" !== n && "X" !== n && "D" !== n && "N" !== n && "=" !== n || (s += i), o.push({
+                for (r = 0; r < e.length; r++) t = e[r], n = ad[t.operation], i = parseInt(t.operationLength), "M" !== n && "EQ" !== n && "X" !== n && "D" !== n && "N" !== n && "=" !== n || (s += i), o.push({
                     len: i,
                     ltr: n
                 });
                 return {
                     lengthOnRef: s,
                     array: o
                 }
@@ -21934,25 +21972,25 @@
                             void 0 === i && (i = []), i.push({
                                 start: a,
                                 len: c.len,
                                 type: c.ltr
                             }), a += c.len;
                             break;
                         case "I":
-                            void 0 === n && (n = []), n.push(new id({
+                            void 0 === n && (n = []), n.push(new zc({
                                 start: a,
                                 len: c.len,
                                 seqOffset: o
                             })), o += c.len;
                             break;
                         case "M":
                         case "EQ":
                         case "=":
                         case "X":
-                            s.push(new id({
+                            s.push(new zc({
                                 start: a,
                                 len: c.len,
                                 seqOffset: o,
                                 gapType: r
                             })), o += c.len, a += c.len;
                             break;
                         default:
@@ -21962,86 +22000,86 @@
                 return {
                     blocks: s,
                     insertions: n,
                     gaps: i
                 }
             }
         }
-    }, Sd.prototype.readMetadata = function() {
-        return zh({
+    }, ld.prototype.readMetadata = function() {
+        return Sh({
             url: this.url,
             entity: "readgroupsets",
             entityId: this.readGroupSetIds
         })
     };
-    class Ad {
+    class hd {
         constructor(e, t) {
             const i = t.genome;
-            if (this.config = e, this.genome = i, Ho(e.url) && (this.config.indexed = !1), "ga4gh" === e.sourceType) this.bamReader = new Sd(e, i);
-            else if ("pysam" === e.sourceType) this.bamReader = new md(e, i);
-            else if ("htsget" === e.sourceType) this.bamReader = new wd(e, i);
-            else if ("shardedBam" === e.sourceType) this.bamReader = new gd(e, i);
-            else if ("cram" === e.format) this.bamReader = new yd(e, i, t);
+            if (this.config = e, this.genome = i, Bo(e.url) && (this.config.indexed = !1), "ga4gh" === e.sourceType) this.bamReader = new ld(e, i);
+            else if ("pysam" === e.sourceType) this.bamReader = new Jc(e, i);
+            else if ("htsget" === e.sourceType) this.bamReader = new td(e, i);
+            else if ("shardedBam" === e.sourceType) this.bamReader = new Kc(e, i);
+            else if ("cram" === e.format) this.bamReader = new nd(e, i, t);
             else {
                 if (!this.config.indexURL && !1 !== e.indexed)
                     if (Qt(this.config.url)) {
-                        const e = Yo(this.config.url, "bai");
+                        const e = jo(this.config.url, "bai");
                         e ? (console.error(`Warning: no indexURL specified for ${this.config.url}.  Guessing ${this.baiPath}`), this.config.indexURL = e) : (console.error(`Warning: no indexURL specified for ${this.config.url}.`), this.config.indexed = !1)
                     } else console.error(`Warning: no indexURL specified for ${this.config.name}.`), this.config.indexed = !1;
-                !1 !== this.config.indexed ? this.bamReader = new pd(e, i) : this.bamReader = new fd(e, i)
+                !1 !== this.config.indexed ? this.bamReader = new Yc(e, i) : this.bamReader = new Xc(e, i)
             }
             this.viewAsPairs = e.viewAsPairs, this.showSoftClips = e.showSoftClips
         }
         setViewAsPairs(e) {
             this.viewAsPairs = e
         }
         setShowSoftClips(e) {
             this.showSoftClips = e
         }
         async getAlignments(e, t, i) {
             const n = this.genome,
                 r = this.showSoftClips,
                 s = await this.bamReader.readAlignments(e, t, i);
             let o = s.alignments;
-            this.viewAsPairs || (o = Oc([{
+            this.viewAsPairs || (o = yc([{
                 alignments: o
             }]));
             const a = o.length > 0;
-            if (s.packedAlignmentRows = Dc(o, s.start, s.end, r), this.alignmentContainer = s, a) {
+            if (s.packedAlignmentRows = _c(o, s.start, s.end, r), this.alignmentContainer = s, a) {
                 const t = await n.sequence.getSequence(e, s.start, s.end);
                 if (t) return s.coverageMap.refSeq = t, s.sequence = t, s;
                 console.error("No sequence for: " + e + ":" + s.start + "-" + s.end)
             }
             return s
         }
     }
 
-    function Ed(e, t, i) {
+    function cd(e, t, i) {
         var n, r, s, o, a, l, h, c = {
             font: "normal 10px Arial",
             textAlign: "right",
             strokeStyle: "black"
         };
         if (void 0 === this.dataRange || void 0 === this.dataRange.max || void 0 === this.dataRange.min) return;
         let d = void 0 !== this.flipAxis && this.flipAxis;
 
         function u(e) {
             return 0 === e ? "0" : Math.abs(e) >= 10 ? e.toFixed() : Math.abs(e) >= 1 ? e.toFixed(1) : e.toFixed(2)
         }
-        Mo.fillRect(e, 0, 0, t, i, {
+        ko.fillRect(e, 0, 0, t, i, {
             fillStyle: "rgb(255, 255, 255)"
         }), n = (h = .95 * t) - 8, a = {
             x: r = h,
             y: s = o = .01 * i
-        }, Mo.strokeLine(e, n, s, r, o, c), Mo.fillText(e, u(d ? this.dataRange.min : this.dataRange.max), n + 4, s + 12, c), l = {
+        }, ko.strokeLine(e, n, s, r, o, c), ko.fillText(e, u(d ? this.dataRange.min : this.dataRange.max), n + 4, s + 12, c), l = {
             x: r,
             y: s = o = .99 * i
-        }, Mo.strokeLine(e, n, s, r, o, c), Mo.fillText(e, u(d ? this.dataRange.max : this.dataRange.min), n + 4, s - 4, c), Mo.strokeLine(e, a.x, a.y, l.x, l.y, c)
+        }, ko.strokeLine(e, n, s, r, o, c), ko.fillText(e, u(d ? this.dataRange.max : this.dataRange.min), n + 4, s - 4, c), ko.strokeLine(e, a.x, a.y, l.x, l.y, c)
     }
-    class Td {
+    class dd {
         constructor({
             chr: e,
             start: t,
             end: i
         }) {
             this.chr = e, this.start = t, this.end = i
         }
@@ -22058,51 +22096,51 @@
             if ("all" === this.chr) return "all"; {
                 const e = Xt(Math.floor(this.start) + 1),
                     t = Xt(Math.round(this.end));
                 return `${this.chr}:${e}-${t}`
             }
         }
         static fromLocusString(e) {
-            if ("all" === e) return new Td({
+            if ("all" === e) return new dd({
                 chr: "all"
             });
             const t = e.split(":"),
                 i = t[0],
                 n = t[1].split("-"),
                 r = Number.parseInt(n[0].replace(/,/g, "")) - 1,
                 s = Number.parseInt(n[1].replace(/,/g, ""));
-            return new Td({
+            return new dd({
                 chr: i,
                 start: r,
                 end: s
             })
         }
     }
     /*!
      * vanilla-picker v2.12.1
      * https://vanilla-picker.js.org
      *
      * Copyright 2017-2021 Andreas Borgen (https://github.com/Sphinxxxx), Adam Brooks (https://github.com/dissimulate)
      * Released under the ISC license.
      */
-    var Md = function(e, t) {
+    var ud = function(e, t) {
             if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
         },
-        Rd = function() {
+        fd = function() {
             function e(e, t) {
                 for (var i = 0; i < t.length; i++) {
                     var n = t[i];
                     n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                 }
             }
             return function(t, i, n) {
                 return i && e(t.prototype, i), n && e(t, n), t
             }
         }(),
-        Ld = function(e, t) {
+        pd = function(e, t) {
             if (Array.isArray(e)) return e;
             if (Symbol.iterator in Object(e)) return function(e, t) {
                 var i = [],
                     n = !0,
                     r = !1,
                     s = void 0;
                 try {
@@ -22122,15 +22160,15 @@
         };
     String.prototype.startsWith = String.prototype.startsWith || function(e) {
         return 0 === this.indexOf(e)
     }, String.prototype.padStart = String.prototype.padStart || function(e, t) {
         for (var i = this; i.length < e;) i = t + i;
         return i
     };
-    var Id = {
+    var gd = {
         cb: "0f8ff",
         tqw: "aebd7",
         q: "-ffff",
         qmrn: "7fffd4",
         zr: "0ffff",
         bg: "5f5dc",
         bsq: "e4c4",
@@ -22266,62 +22304,62 @@
         whT: "5deb3",
         wht: "",
         hts: "5f5f5",
         w: "-",
         wgrn: "9acd32"
     };
 
-    function Bd(e) {
+    function md(e) {
         var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
         return (t > 0 ? e.toFixed(t).replace(/0+$/, "").replace(/\.$/, "") : e.toString()) || "0"
     }
-    var Nd = function() {
+    var bd = function() {
             function e(t, i, n, r) {
-                Md(this, e);
+                ud(this, e);
                 var s = this;
                 if (void 0 === t);
                 else if (Array.isArray(t)) this.rgba = t;
                 else if (void 0 === n) {
                     var o = t && "" + t;
                     o && function(t) {
                         if (t.startsWith("hsl")) {
                             var i = t.match(/([\-\d\.e]+)/g).map(Number),
-                                n = Ld(i, 4),
+                                n = pd(i, 4),
                                 r = n[0],
                                 o = n[1],
                                 a = n[2],
                                 l = n[3];
                             void 0 === l && (l = 1), r /= 360, o /= 100, a /= 100, s.hsla = [r, o, a, l]
                         } else if (t.startsWith("rgb")) {
                             var h = t.match(/([\-\d\.e]+)/g).map(Number),
-                                c = Ld(h, 4),
+                                c = pd(h, 4),
                                 d = c[0],
                                 u = c[1],
                                 f = c[2],
                                 p = c[3];
                             void 0 === p && (p = 1), s.rgba = [d, u, f, p]
                         } else t.startsWith("#") ? s.rgba = e.hexToRgb(t) : s.rgba = e.nameToRgb(t) || e.hexToRgb(t)
                     }(o.toLowerCase())
                 } else this.rgba = [t, i, n, void 0 === r ? 1 : r]
             }
-            return Rd(e, [{
+            return fd(e, [{
                 key: "printRGB",
                 value: function(e) {
                     var t = (e ? this.rgba : this.rgba.slice(0, 3)).map((function(e, t) {
-                        return Bd(e, 3 === t ? 3 : 0)
+                        return md(e, 3 === t ? 3 : 0)
                     }));
                     return e ? "rgba(" + t + ")" : "rgb(" + t + ")"
                 }
             }, {
                 key: "printHSL",
                 value: function(e) {
                     var t = [360, 100, 100, 1],
                         i = ["", "%", "%", ""],
                         n = (e ? this.hsla : this.hsla.slice(0, 3)).map((function(e, n) {
-                            return Bd(e * t[n], 3 === n ? 3 : 1) + i[n]
+                            return md(e * t[n], 3 === n ? 3 : 1) + i[n]
                         }));
                     return e ? "hsla(" + n + ")" : "hsl(" + n + ")"
                 }
             }, {
                 key: "printHex",
                 value: function(e) {
                     var t = this.hex;
@@ -22389,21 +22427,21 @@
                     }));
                     return i[3] = i[3] / 255, i
                 }
             }, {
                 key: "nameToRgb",
                 value: function(t) {
                     var i = t.toLowerCase().replace("at", "T").replace(/[aeiouyldf]/g, "").replace("ght", "L").replace("rk", "D").slice(-5, 4),
-                        n = Id[i];
+                        n = gd[i];
                     return void 0 === n ? n : e.hexToRgb(n.replace(/\-/g, "00").padStart(6, "f"))
                 }
             }, {
                 key: "rgbToHsl",
                 value: function(e) {
-                    var t = Ld(e, 4),
+                    var t = pd(e, 4),
                         i = t[0],
                         n = t[1],
                         r = t[2],
                         s = t[3];
                     i /= 255, n /= 255, r /= 255;
                     var o = Math.max(i, n, r),
                         a = Math.min(i, n, r),
@@ -22426,15 +22464,15 @@
                         l /= 6
                     }
                     return [l, h, c, s]
                 }
             }, {
                 key: "hslToRgb",
                 value: function(e) {
-                    var t = Ld(e, 4),
+                    var t = pd(e, 4),
                         i = t[0],
                         n = t[1],
                         r = t[2],
                         s = t[3],
                         o = void 0,
                         a = void 0,
                         l = void 0;
@@ -22448,19 +22486,19 @@
                         o = h(d, c, i + 1 / 3), a = h(d, c, i), l = h(d, c, i - 1 / 3)
                     }
                     var u = [255 * o, 255 * a, 255 * l].map(Math.round);
                     return u[3] = s, u
                 }
             }]), e
         }(),
-        Fd = function() {
+        wd = function() {
             function e() {
-                Md(this, e), this._events = []
+                ud(this, e), this._events = []
             }
-            return Rd(e, [{
+            return fd(e, [{
                 key: "add",
                 value: function(e, t, i) {
                     e.addEventListener(t, i, !1), this._events.push({
                         target: e,
                         type: t,
                         handler: i
                     })
@@ -22484,15 +22522,15 @@
                 key: "_doRemove",
                 value: function(e, t, i) {
                     e.removeEventListener(t, i, !1)
                 }
             }]), e
         }();
 
-    function Pd(e, t, i) {
+    function vd(e, t, i) {
         var n = !1;
 
         function r(e, t, i) {
             return Math.max(t, Math.min(e, i))
         }
 
         function s(e, s, o) {
@@ -22524,44 +22562,44 @@
             n = !1
         })), e.add(t, "touchend", (function(e) {
             n = !1
         })), e.add(t, "touchcancel", (function(e) {
             n = !1
         }))
     }
-    var Od = "keydown",
-        Dd = "mousedown",
-        zd = "focusin";
+    var yd = "keydown",
+        _d = "mousedown",
+        xd = "focusin";
 
-    function Hd(e, t) {
+    function kd(e, t) {
         return (t || document).querySelector(e)
     }
 
-    function Vd(e) {
+    function Cd(e) {
         e.preventDefault(), e.stopPropagation()
     }
 
-    function Ud(e, t, i, n, r) {
-        e.add(t, Od, (function(e) {
-            i.indexOf(e.key) >= 0 && (r && Vd(e), n(e))
+    function Sd(e, t, i, n, r) {
+        e.add(t, yd, (function(e) {
+            i.indexOf(e.key) >= 0 && (r && Cd(e), n(e))
         }))
     }
-    var qd = function() {
+    var Ad = function() {
             function e(t) {
-                Md(this, e), this.settings = {
+                ud(this, e), this.settings = {
                     popup: "right",
                     layout: "default",
                     alpha: !0,
                     editor: !0,
                     editorFormat: "hex",
                     cancelButton: !1,
                     defaultColor: "#0cf"
-                }, this._events = new Fd, this.onChange = null, this.onDone = null, this.onOpen = null, this.onClose = null, this.setOptions(t)
+                }, this._events = new wd, this.onChange = null, this.onDone = null, this.onOpen = null, this.onClose = null, this.setOptions(t)
             }
-            return Rd(e, [{
+            return fd(e, [{
                 key: "setOptions",
                 value: function(e) {
                     var t = this;
                     if (e) {
                         var i = this.settings;
                         if (e instanceof HTMLElement) i.parent = e;
                         else {
@@ -22573,41 +22611,41 @@
                             n && this._setColor(n)
                         }
                         var r = i.parent;
                         if (r && i.popup && !this._popupInited) {
                             var s = function(e) {
                                 return t.openHandler(e)
                             };
-                            this._events.add(r, "click", s), Ud(this._events, r, [" ", "Spacebar", "Enter"], s), this._popupInited = !0
+                            this._events.add(r, "click", s), Sd(this._events, r, [" ", "Spacebar", "Enter"], s), this._popupInited = !0
                         } else e.parent && !i.popup && this.show()
                     }
                 }
             }, {
                 key: "openHandler",
                 value: function(e) {
                     if (this.show()) {
                         e && e.preventDefault(), this.settings.parent.style.pointerEvents = "none";
-                        var t = e && e.type === Od ? this._domEdit : this.domElement;
+                        var t = e && e.type === yd ? this._domEdit : this.domElement;
                         setTimeout((function() {
                             return t.focus()
                         }), 100), this.onOpen && this.onOpen(this.colour)
                     }
                 }
             }, {
                 key: "closeHandler",
                 value: function(e) {
                     var t = e && e.type,
                         i = !1;
                     if (e)
-                        if (t === Dd || t === zd) {
+                        if (t === _d || t === xd) {
                             var n = (this.__containedEvent || 0) + 100;
                             e.timeStamp > n && (i = !0)
-                        } else Vd(e), i = !0;
+                        } else Cd(e), i = !0;
                     else i = !0;
-                    i && this.hide() && (this.settings.parent.style.pointerEvents = "", t !== Dd && this.settings.parent.focus(), this.onClose && this.onClose(this.colour))
+                    i && this.hide() && (this.settings.parent.style.pointerEvents = "", t !== _d && this.settings.parent.focus(), this.onClose && this.onClose(this.colour))
                 }
             }, {
                 key: "movePopup",
                 value: function(e, t) {
                     this.closeHandler(), this.setOptions(e), t && this.openHandler()
                 }
             }, {
@@ -22620,15 +22658,15 @@
             }, {
                 key: "_setColor",
                 value: function(e, t) {
                     if ("string" == typeof e && (e = e.trim()), e) {
                         t = t || {};
                         var i = void 0;
                         try {
-                            i = new Nd(e)
+                            i = new bd(e)
                         } catch (e) {
                             if (t.failSilently) return;
                             throw e
                         }
                         if (!this.settings.alpha) {
                             var n = i.hsla;
                             n[3] = 1, i.hsla = n
@@ -22649,15 +22687,15 @@
                         var e = this._toggleDOM(!0);
                         return this._setPosition(), e
                     }
                     var t = function(e) {
                         var t = document.createElement("div");
                         return t.innerHTML = e, t.firstElementChild
                     }(this.settings.template || '<div class="picker_wrapper" tabindex="-1"><div class="picker_arrow"></div><div class="picker_hue picker_slider"><div class="picker_selector"></div></div><div class="picker_sl"><div class="picker_selector"></div></div><div class="picker_alpha picker_slider"><div class="picker_selector"></div></div><div class="picker_editor"><input aria-label="Type a color name or hex value"/></div><div class="picker_sample"></div><div class="picker_done"><button>Ok</button></div><div class="picker_cancel"><button>Cancel</button></div></div>');
-                    return this.domElement = t, this._domH = Hd(".picker_hue", t), this._domSL = Hd(".picker_sl", t), this._domA = Hd(".picker_alpha", t), this._domEdit = Hd(".picker_editor input", t), this._domSample = Hd(".picker_sample", t), this._domOkay = Hd(".picker_done button", t), this._domCancel = Hd(".picker_cancel button", t), t.classList.add("layout_" + this.settings.layout), this.settings.alpha || t.classList.add("no_alpha"), this.settings.editor || t.classList.add("no_editor"), this.settings.cancelButton || t.classList.add("no_cancel"), this._ifPopup((function() {
+                    return this.domElement = t, this._domH = kd(".picker_hue", t), this._domSL = kd(".picker_sl", t), this._domA = kd(".picker_alpha", t), this._domEdit = kd(".picker_editor input", t), this._domSample = kd(".picker_sample", t), this._domOkay = kd(".picker_done button", t), this._domCancel = kd(".picker_cancel button", t), t.classList.add("layout_" + this.settings.layout), this.settings.alpha || t.classList.add("no_alpha"), this.settings.editor || t.classList.add("no_editor"), this.settings.cancelButton || t.classList.add("no_cancel"), this._ifPopup((function() {
                         return t.classList.add("popup")
                     })), this._setPosition(), this.colour ? this._updateUI() : this._setColor(this.settings.defaultColor), this._bindEvents(), !0
                 }
             }, {
                 key: "hide",
                 value: function() {
                     return this._toggleDOM(!1)
@@ -22676,19 +22714,19 @@
                         n = this._events;
 
                     function r(e, t, i) {
                         n.add(e, t, i)
                     }
                     r(i, "click", (function(e) {
                         return e.preventDefault()
-                    })), Pd(n, this._domH, (function(e, i) {
+                    })), vd(n, this._domH, (function(e, i) {
                         return t._setHSLA(e)
-                    })), Pd(n, this._domSL, (function(e, i) {
+                    })), vd(n, this._domSL, (function(e, i) {
                         return t._setHSLA(null, e, 1 - i)
-                    })), this.settings.alpha && Pd(n, this._domA, (function(e, i) {
+                    })), this.settings.alpha && vd(n, this._domA, (function(e, i) {
                         return t._setHSLA(null, null, null, 1 - i)
                     }));
                     var s = this._domEdit;
                     r(s, "input", (function(e) {
                         t._setColor(this.value, {
                             fromEditor: !0,
                             failSilently: !0
@@ -22696,26 +22734,26 @@
                     })), r(s, "focus", (function(e) {
                         var t = this;
                         t.selectionStart === t.selectionEnd && t.select()
                     })), this._ifPopup((function() {
                         var t = function(t) {
                             return e.closeHandler(t)
                         };
-                        r(window, Dd, t), r(window, zd, t), Ud(n, i, ["Esc", "Escape"], t);
+                        r(window, _d, t), r(window, xd, t), Sd(n, i, ["Esc", "Escape"], t);
                         var s = function(t) {
                             e.__containedEvent = t.timeStamp
                         };
-                        r(i, Dd, s), r(i, zd, s), r(e._domCancel, "click", t)
+                        r(i, _d, s), r(i, xd, s), r(e._domCancel, "click", t)
                     }));
                     var o = function(t) {
                         e._ifPopup((function() {
                             return e.closeHandler(t)
                         })), e.onDone && e.onDone(e.colour)
                     };
-                    r(this._domOkay, "click", o), Ud(n, i, ["Enter"], o)
+                    r(this._domOkay, "click", o), Sd(n, i, ["Enter"], o)
                 }
             }, {
                 key: "_setPosition",
                 value: function() {
                     var e = this.settings.parent,
                         t = this.domElement;
                     e !== t.parentNode && e.appendChild(t), this._ifPopup((function(i) {
@@ -22745,17 +22783,17 @@
                             i = t.hsla,
                             n = "hsl(" + 360 * i[0] + ", 100%, 50%)",
                             r = t.hslString,
                             s = t.hslaString,
                             o = this._domH,
                             a = this._domSL,
                             l = this._domA,
-                            h = Hd(".picker_selector", o),
-                            c = Hd(".picker_selector", a),
-                            d = Hd(".picker_selector", l);
+                            h = kd(".picker_selector", o),
+                            c = kd(".picker_selector", a),
+                            d = kd(".picker_selector", l);
                         w(0, h, i[0]), this._domSL.style.backgroundColor = this._domH.style.color = n, w(0, c, i[1]), v(0, c, 1 - i[2]), a.style.color = r, v(0, d, 1 - i[3]);
                         var u = r,
                             f = u.replace("hsl", "hsla").replace(")", ", 0)"),
                             p = "linear-gradient(" + [u, f] + ")";
                         if (this._domA.style.background = p + ", linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0 / 2em 2em,\n                   linear-gradient(45deg, lightgrey 25%,       white 25%,       white 75%, lightgrey 75%) 1em 1em / 2em 2em", !e.fromEditor) {
                             var g = this.settings.editorFormat,
                                 m = this.settings.alpha,
@@ -22795,29 +22833,29 @@
                     if (!t) return !1;
                     var i = e ? "" : "none",
                         n = t.style.display !== i;
                     return n && (t.style.display = i), n
                 }
             }]), e
         }(),
-        jd = document.createElement("style");
+        Ed = document.createElement("style");
 
-    function $d(e) {
-        if (Wd[e]) return Wd[e];
-        if (Wd["chr" + e]) {
-            const t = Wd["chr" + e];
-            return Wd[e] = t, t
+    function Md(e) {
+        if (Td[e]) return Td[e];
+        if (Td["chr" + e]) {
+            const t = Td["chr" + e];
+            return Td[e] = t, t
         } {
             const r = (t = Math.round(255 * Math.random()).toString(10), i = Math.round(255 * Math.random()).toString(10), n = Math.round(255 * Math.random()).toString(10), "rgb(" + t + "," + i + "," + n + ")");
-            return Wd[e] = r, r
+            return Td[e] = r, r
         }
         var t, i, n
     }
-    jd.textContent = '.picker_wrapper.no_alpha .picker_alpha{display:none}.picker_wrapper.no_editor .picker_editor{position:absolute;z-index:-1;opacity:0}.picker_wrapper.no_cancel .picker_cancel{display:none}.layout_default.picker_wrapper{display:flex;flex-flow:row wrap;justify-content:space-between;align-items:stretch;font-size:10px;width:25em;padding:.5em}.layout_default.picker_wrapper input,.layout_default.picker_wrapper button{font-size:1rem}.layout_default.picker_wrapper>*{margin:.5em}.layout_default.picker_wrapper::before{content:"";display:block;width:100%;height:0;order:1}.layout_default .picker_slider,.layout_default .picker_selector{padding:1em}.layout_default .picker_hue{width:100%}.layout_default .picker_sl{flex:1 1 auto}.layout_default .picker_sl::before{content:"";display:block;padding-bottom:100%}.layout_default .picker_editor{order:1;width:6.5rem}.layout_default .picker_editor input{width:100%;height:100%}.layout_default .picker_sample{order:1;flex:1 1 auto}.layout_default .picker_done,.layout_default .picker_cancel{order:1}.picker_wrapper{box-sizing:border-box;background:#f2f2f2;box-shadow:0 0 0 1px silver;cursor:default;font-family:sans-serif;color:#444;pointer-events:auto}.picker_wrapper:focus{outline:none}.picker_wrapper button,.picker_wrapper input{box-sizing:border-box;border:none;box-shadow:0 0 0 1px silver;outline:none}.picker_wrapper button:focus,.picker_wrapper button:active,.picker_wrapper input:focus,.picker_wrapper input:active{box-shadow:0 0 2px 1px #1e90ff}.picker_wrapper button{padding:.4em .6em;cursor:pointer;background-color:#f5f5f5;background-image:linear-gradient(0deg, gainsboro, transparent)}.picker_wrapper button:active{background-image:linear-gradient(0deg, transparent, gainsboro)}.picker_wrapper button:hover{background-color:#fff}.picker_selector{position:absolute;z-index:1;display:block;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);border:2px solid #fff;border-radius:100%;box-shadow:0 0 3px 1px #67b9ff;background:currentColor;cursor:pointer}.picker_slider .picker_selector{border-radius:2px}.picker_hue{position:relative;background-image:linear-gradient(90deg, red, yellow, lime, cyan, blue, magenta, red);box-shadow:0 0 0 1px silver}.picker_sl{position:relative;box-shadow:0 0 0 1px silver;background-image:linear-gradient(180deg, white, rgba(255, 255, 255, 0) 50%),linear-gradient(0deg, black, rgba(0, 0, 0, 0) 50%),linear-gradient(90deg, #808080, rgba(128, 128, 128, 0))}.picker_alpha,.picker_sample{position:relative;background:linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0/2em 2em,linear-gradient(45deg, lightgrey 25%, white 25%, white 75%, lightgrey 75%) 1em 1em/2em 2em;box-shadow:0 0 0 1px silver}.picker_alpha .picker_selector,.picker_sample .picker_selector{background:none}.picker_editor input{font-family:monospace;padding:.2em .4em}.picker_sample::before{content:"";position:absolute;display:block;width:100%;height:100%;background:currentColor}.picker_arrow{position:absolute;z-index:-1}.picker_wrapper.popup{position:absolute;z-index:2;margin:1.5em}.picker_wrapper.popup,.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{background:#f2f2f2;box-shadow:0 0 10px 1px rgba(0,0,0,.4)}.picker_wrapper.popup .picker_arrow{width:3em;height:3em;margin:0}.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{content:"";display:block;position:absolute;top:0;left:0;z-index:-99}.picker_wrapper.popup .picker_arrow::before{width:100%;height:100%;-webkit-transform:skew(45deg);transform:skew(45deg);-webkit-transform-origin:0 100%;transform-origin:0 100%}.picker_wrapper.popup .picker_arrow::after{width:150%;height:150%;box-shadow:none}.popup.popup_top{bottom:100%;left:0}.popup.popup_top .picker_arrow{bottom:0;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.popup.popup_bottom{top:100%;left:0}.popup.popup_bottom .picker_arrow{top:0;left:0;-webkit-transform:rotate(90deg) scale(1, -1);transform:rotate(90deg) scale(1, -1)}.popup.popup_left{top:0;right:100%}.popup.popup_left .picker_arrow{top:0;right:0;-webkit-transform:scale(-1, 1);transform:scale(-1, 1)}.popup.popup_right{top:0;left:100%}.popup.popup_right .picker_arrow{top:0;left:0}', document.documentElement.firstElementChild.appendChild(jd), qd.StyleElement = jd;
-    const Wd = {
+    Ed.textContent = '.picker_wrapper.no_alpha .picker_alpha{display:none}.picker_wrapper.no_editor .picker_editor{position:absolute;z-index:-1;opacity:0}.picker_wrapper.no_cancel .picker_cancel{display:none}.layout_default.picker_wrapper{display:flex;flex-flow:row wrap;justify-content:space-between;align-items:stretch;font-size:10px;width:25em;padding:.5em}.layout_default.picker_wrapper input,.layout_default.picker_wrapper button{font-size:1rem}.layout_default.picker_wrapper>*{margin:.5em}.layout_default.picker_wrapper::before{content:"";display:block;width:100%;height:0;order:1}.layout_default .picker_slider,.layout_default .picker_selector{padding:1em}.layout_default .picker_hue{width:100%}.layout_default .picker_sl{flex:1 1 auto}.layout_default .picker_sl::before{content:"";display:block;padding-bottom:100%}.layout_default .picker_editor{order:1;width:6.5rem}.layout_default .picker_editor input{width:100%;height:100%}.layout_default .picker_sample{order:1;flex:1 1 auto}.layout_default .picker_done,.layout_default .picker_cancel{order:1}.picker_wrapper{box-sizing:border-box;background:#f2f2f2;box-shadow:0 0 0 1px silver;cursor:default;font-family:sans-serif;color:#444;pointer-events:auto}.picker_wrapper:focus{outline:none}.picker_wrapper button,.picker_wrapper input{box-sizing:border-box;border:none;box-shadow:0 0 0 1px silver;outline:none}.picker_wrapper button:focus,.picker_wrapper button:active,.picker_wrapper input:focus,.picker_wrapper input:active{box-shadow:0 0 2px 1px #1e90ff}.picker_wrapper button{padding:.4em .6em;cursor:pointer;background-color:#f5f5f5;background-image:linear-gradient(0deg, gainsboro, transparent)}.picker_wrapper button:active{background-image:linear-gradient(0deg, transparent, gainsboro)}.picker_wrapper button:hover{background-color:#fff}.picker_selector{position:absolute;z-index:1;display:block;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);border:2px solid #fff;border-radius:100%;box-shadow:0 0 3px 1px #67b9ff;background:currentColor;cursor:pointer}.picker_slider .picker_selector{border-radius:2px}.picker_hue{position:relative;background-image:linear-gradient(90deg, red, yellow, lime, cyan, blue, magenta, red);box-shadow:0 0 0 1px silver}.picker_sl{position:relative;box-shadow:0 0 0 1px silver;background-image:linear-gradient(180deg, white, rgba(255, 255, 255, 0) 50%),linear-gradient(0deg, black, rgba(0, 0, 0, 0) 50%),linear-gradient(90deg, #808080, rgba(128, 128, 128, 0))}.picker_alpha,.picker_sample{position:relative;background:linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0/2em 2em,linear-gradient(45deg, lightgrey 25%, white 25%, white 75%, lightgrey 75%) 1em 1em/2em 2em;box-shadow:0 0 0 1px silver}.picker_alpha .picker_selector,.picker_sample .picker_selector{background:none}.picker_editor input{font-family:monospace;padding:.2em .4em}.picker_sample::before{content:"";position:absolute;display:block;width:100%;height:100%;background:currentColor}.picker_arrow{position:absolute;z-index:-1}.picker_wrapper.popup{position:absolute;z-index:2;margin:1.5em}.picker_wrapper.popup,.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{background:#f2f2f2;box-shadow:0 0 10px 1px rgba(0,0,0,.4)}.picker_wrapper.popup .picker_arrow{width:3em;height:3em;margin:0}.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{content:"";display:block;position:absolute;top:0;left:0;z-index:-99}.picker_wrapper.popup .picker_arrow::before{width:100%;height:100%;-webkit-transform:skew(45deg);transform:skew(45deg);-webkit-transform-origin:0 100%;transform-origin:0 100%}.picker_wrapper.popup .picker_arrow::after{width:150%;height:150%;box-shadow:none}.popup.popup_top{bottom:100%;left:0}.popup.popup_top .picker_arrow{bottom:0;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.popup.popup_bottom{top:100%;left:0}.popup.popup_bottom .picker_arrow{top:0;left:0;-webkit-transform:rotate(90deg) scale(1, -1);transform:rotate(90deg) scale(1, -1)}.popup.popup_left{top:0;right:100%}.popup.popup_left .picker_arrow{top:0;right:0;-webkit-transform:scale(-1, 1);transform:scale(-1, 1)}.popup.popup_right{top:0;left:100%}.popup.popup_right .picker_arrow{top:0;left:0}', document.documentElement.firstElementChild.appendChild(Ed), Ad.StyleElement = Ed;
+    const Td = {
         chrX: "rgb(204, 153, 0)",
         chrY: "rgb(153, 204, 0",
         chrUn: "rgb(50, 50, 50)",
         chr1: "rgb(80, 80, 255)",
         chrI: "rgb(139, 155, 187)",
         chr2: "rgb(206, 61, 50)",
         chrII: "rgb(206, 61, 50)",
@@ -22868,53 +22906,53 @@
         chr43: "rgb(102, 0, 153)",
         chr44: "rgb(153, 0, 128)",
         chr45: "rgb(214, 0, 71)",
         chr46: "rgb(255, 20, 99)",
         chr47: "rgb(0, 214, 143)",
         chr48: "rgb(20, 255, 177)"
     };
-    class Gd {
+    class Rd {
         constructor(e) {
             this.tracks = [], this.chordSets = []
         }
         addChordSet(e) {
             this.chordSets = this.chordSets.filter((t => t.name !== e.name)), this.chordSets.push(e);
             let t = this.tracks.find((t => e.trackName === t.name));
-            t && (t.chordSets = t.chordSets.filter((t => t.name !== e.name)), t.chordSets.push(e)), t || (t = new Zd(e), this.tracks.push(t))
+            t && (t.chordSets = t.chordSets.filter((t => t.name !== e.name)), t.chordSets.push(e)), t || (t = new Ld(e), this.tracks.push(t))
         }
         clearChords() {
             this.tracks = [], this.chordSets = []
         }
         getTrack(e) {
             return this.tracks.find((t => e === t.name))
         }
         getChordSet(e) {
             return this.chordSets.find((t => e === t.name))
         }
     }
-    class Zd {
+    class Ld {
         constructor(e) {
             this.name = e.trackName, this.color = e.trackColor, this.visible = !0, this.chordSets = [e], this.id = ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4)
         }
         get chords() {
             if (1 === this.chordSets.length) return this.chordSets[0].chords;
             const e = [];
             for (let t of this.chordSets)
                 for (let i of t.chords) e.push(i);
             return e
         }
     }
-    const Qd = Math.exp(5);
-    class Xd {
+    const Id = Math.exp(5);
+    class Bd {
         static isInstalled() {
             return void 0 !== window.JBrowseReactCircularGenomeView && void 0 !== window.React && void 0 !== window.ReactDOM
         }
         constructor(e, t) {
-            if (t = t || {}, this.config = t, Xd.isInstalled()) {
-                this.parent = e, this.groupByTrack = !0 === t.groupByTrack, this.chordManager = new Gd(t);
+            if (t = t || {}, this.config = t, Bd.isInstalled()) {
+                this.parent = e, this.groupByTrack = !0 === t.groupByTrack, this.chordManager = new Rd(t);
                 const i = document.createElement("div");
                 i.className = "igv-circview-container", e.appendChild(i), this.createControls(i), this.resetControlPanel();
                 const n = document.createElement("div");
                 n.className = "igv-circview-circular-genome-view", i.appendChild(n), this.container = n, t.assembly && this.setAssembly(t.assembly), this.width = t.width || 500, this.height = t.height || 500, this.setSize(this.width, this.height)
             } else console.error("JBrowse circular view is not installed")
         }
         createControls(e) {
@@ -22952,46 +22990,46 @@
             const t = document.createElement("div");
             this.controlPanel.appendChild(t);
             const i = document.createElement("div");
             i.className = "igv-circview-button", t.appendChild(i), i.innerText = !0 === e.visible ? "Hide" : "Show", i.addEventListener("click", (t => {
                 !0 === e.visible ? (this.hideChordSet(e.name), t.target.innerText = "Show") : (this.showChordSet(e.name), t.target.innerText = "Hide")
             }));
             const n = document.createElement("input"),
-                r = e => 200 * Math.log(e * Qd),
+                r = e => 200 * Math.log(e * Id),
                 s = document.createElement("div");
-            s.className = "igv-circview-button", s.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;", t.appendChild(s), s.style.backgroundColor = Yd(e.color, 1);
+            s.className = "igv-circview-button", s.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;", t.appendChild(s), s.style.backgroundColor = Fd(e.color, 1);
             const o = {
                     parent: s,
                     popup: "right",
                     editorFormat: "rgb",
                     color: e.color,
                     onChange: ({
                         rgbaString: t
                     }) => {
-                        s.style.backgroundColor = Yd(t, 1), this.setColor(e.name, t), n.value = r(Kd(e.color))
+                        s.style.backgroundColor = Fd(t, 1), this.setColor(e.name, t), n.value = r(Nd(e.color))
                     }
                 },
-                a = new qd(o);
-            n.setAttribute("title", "Adjust transparency of arcs"), n.type = "range", n.style.width = "100px", n.style.marginRight = "10px", n.setAttribute("class", "range"), n.setAttribute("min", "0"), n.setAttribute("max", "1000"), n.value = r(Kd(e.color)), n.oninput = () => {
-                const t = (i = n.value, Math.exp(i / 200) / Qd);
+                a = new Ad(o);
+            n.setAttribute("title", "Adjust transparency of arcs"), n.type = "range", n.style.width = "100px", n.style.marginRight = "10px", n.setAttribute("class", "range"), n.setAttribute("min", "0"), n.setAttribute("max", "1000"), n.value = r(Nd(e.color)), n.oninput = () => {
+                const t = (i = n.value, Math.exp(i / 200) / Id);
                 var i;
-                this.setColor(e.name, Yd(e.color, t)), a.setColor(e.color)
+                this.setColor(e.name, Fd(e.color, t)), a.setColor(e.color)
             }, t.appendChild(n);
             const l = document.createElement("div");
             l.style.color = "black", t.appendChild(l), l.innerText = l.title = e.name
         }
         setAssembly(e) {
-            const t = this.genomeId || tu();
+            const t = this.genomeId || Dd();
             if (this.genomeId === t) return;
-            this.chordManager.clearChords(), this.genomeId = t, this.chrNames = new Set(e.chromosomes.map((e => Jd(e.name))));
+            this.chordManager.clearChords(), this.genomeId = t, this.chrNames = new Set(e.chromosomes.map((e => Od(e.name))));
             const i = [],
                 n = [];
             for (let t of e.chromosomes) {
-                const e = Jd(t.name);
-                n.push(t.color || $d(e)), i.push({
+                const e = Od(t.name);
+                n.push(t.color || Md(e)), i.push({
                     refName: e,
                     uniqueId: e,
                     start: 0,
                     end: t.bpLength
                 })
             }
             this.assembly = {
@@ -23013,15 +23051,15 @@
                 r = {
                     name: i.replaceAll("%20", " "),
                     trackName: n,
                     chords: e,
                     color: t.color || "black",
                     trackColor: t.trackColor || t.color || "black",
                     visible: !0,
-                    id: t.id || tu()
+                    id: t.id || Dd()
                 };
             this.chordManager.addChordSet(r), this.resetControlPanel(), this.render()
         }
         setSize(e, t) {
             if (t = t || e, this.width = e, this.height = t, this.viewState) {
                 const i = this.viewState.session.view;
                 i.setWidth(e), i.setHeight(t), i.setBpPerPx(i.minBpPerPx)
@@ -23098,77 +23136,78 @@
                 assembly: this.assembly,
                 tracks: n
             });
             for (let e = 0; e < i.length; e++) this.viewState.config.tracks[e].displays[0].renderer.strokeColor.set(r[e]);
             this.element = React.createElement(t, {
                 viewState: this.viewState
             }), this.setSize(this.width, this.height), ReactDOM.render(this.element, this.container);
-            const s = this.config.onChordClick || eu;
+            const s = this.config.onChordClick || Pd;
             for (let e = 0; e < i.length; e++) this.viewState.session.view.showTrack(this.viewState.config.tracks[e].trackId), s && (this.viewState.pluginManager.jexl.addFunction("onChordClick", s), this.viewState.config.tracks[e].displays[0].onChordClick.set("jexl:onChordClick(feature, track, pluginManager)"))
         }
     }
 
-    function Yd(e, t) {
+    function Fd(e, t) {
         const [i, n, r, s] = e.split(",");
         return `${i},${n},${r},${t})`
     }
 
-    function Kd(e) {
+    function Nd(e) {
         return e.startsWith("rgba(") ? Number(e.split(",")[3].replace(")", "")) : 1
     }
 
-    function Jd(e) {
+    function Od(e) {
         return e.startsWith("chr") ? e.substring(3) : e
     }
 
-    function eu(e, t, i) {
+    function Pd(e, t, i) {
         console.log(e)
     }
 
-    function tu() {
+    function Dd() {
         return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4)
     }
     if ("undefined" != typeof document) {
-        function iw(e) {
+        function Qb(e) {
             for (let t of document.styleSheets)
                 if (t = t.href ? t.href.replace(/^.*[\\\/]/, "") : "", t === e) return !0;
             return !1
         }
-        iw("circular-view.css") || function() {
+        Qb("circular-view.css") || function() {
             const e = document.createElement("style");
             e.setAttribute("type", "text/css"), e.innerHTML = '.igv-circview-container {\n  width: fit-content;\n  height: fit-content;\n  box-sizing: content-box;\n  color: dimgray;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  background-color: white;\n  border-color: dimgray;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n\n.igv-circview-toolbar {\n  position: relative;\n  width: 100%;\n  height: 32px;\n  background-color: lightgrey;\n  border-bottom-style: solid;\n  border-bottom-color: dimgray;\n  border-bottom-width: thin;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.igv-circview-toolbar-button-container {\n  height: 100%;\n  width: fit-content;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-circview-toolbar-button-container > div {\n  margin: 4px;\n}\n\n.igv-circview-track-panel {\n  z-index: 1024;\n  position: absolute;\n  top: 33px;\n  left: 0;\n  width: 100%;\n  height: fit-content;\n  border-bottom-style: solid;\n  border-bottom-color: dimgray;\n  border-bottom-width: thin;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n.igv-circview-track-panel > div {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-circview-track-panel > div > div {\n  margin: 4px;\n}\n\n.igv-circview-swatch-button {\n  cursor: pointer;\n  padding: 5px;\n  width: 8px;\n  height: 8px;\n  border: 1px solid #8d8b8b;\n  border-radius: 16px;\n}\n\n.igv-circview-button {\n  cursor: pointer;\n  padding: 5px;\n  color: #444;\n  vertical-align: middle;\n  text-align: center;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  border: 1px solid #8d8b8b;\n  border-radius: 4px;\n  background: #efefef;\n  box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.2);\n}\n\n.igv-circview-button:hover {\n  background: #efefef;\n  box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.6);\n}\n\n.igv-circview-button:active {\n  color: #007bff;\n  box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.6);\n}\n\n/*# sourceMappingURL=circular-view.css.map */\n', document.head.insertBefore(e, document.head.childNodes[document.head.childNodes.length - 1])
         }()
     }
-    const iu = e => e.startsWith("chr") ? e.substring(3) : e;
+    const zd = e => e.startsWith("chr") ? e.substring(3) : e;
 
-    function nu(e) {
+    function Hd(e) {
         const t = [],
             i = [];
         for (let n of e.wgChromosomeNames) {
             const r = e.getChromosome(n);
-            i.push(Tu(r.name)), t.push({
+            i.push(gu(r.name)), t.push({
                 name: r.name,
                 bpLength: r.bpLength
             })
         }
         return t
     }
 
-    function ru(e, t, i, n) {
-        const r = js.addAlpha("all" === i.chr ? t.color : Tu(i.chr), n),
-            s = js.addAlpha(t.color || "rgb(0,0,255)", n),
-            o = t.name.replaceAll(" ", "%20"),
-            a = "all" === i.chr ? o : `${o}  ${i.chr}:${i.start}-${i.end}`;
+    function Vd(e, t, i, n) {
+        const r = t.color || "rgb(0,0,255)",
+            s = Ds.addAlpha("all" === i.chr ? r : gu(i.chr), n),
+            o = Ds.addAlpha(r, n),
+            a = t.name.replaceAll(" ", "%20"),
+            l = "all" === i.chr ? a : `${a}  ${i.chr}:${i.start}-${i.end}`;
         t.browser.circularView.addChords(e, {
-            track: a,
-            color: r,
-            trackColor: s
+            track: l,
+            color: s,
+            trackColor: o
         }), t.browser.circularViewVisible || (t.browser.circularViewVisible = !0)
     }
-    class su {
+    class Ud {
         constructor(e, {
             minTLENPercentile: t,
             maxTLENPercentile: i
         }) {
             this.totalCount = 0, this.frCount = 0, this.rfCount = 0, this.ffCount = 0, this.sumF = 0, this.sumF2 = 0, this.lp = void 0 === t ? .1 : t, this.up = void 0 === i ? 99.5 : i, this.isizes = [], this.compute(e)
         }
         compute(e) {
@@ -23185,105 +23224,105 @@
                         case "FR":
                             this.frCount++;
                             break;
                         case "RF":
                             this.rfCount++
                     }
                     this.totalCount++
-                } this.ffCount / this.totalCount > .9 ? this.orienation = "ff" : this.frCount / this.totalCount > .9 ? this.orienation = "fr" : this.rfCount / this.totalCount > .9 && (this.orienation = "rf"), this.minTLEN = 0 === this.lp ? 0 : ou(this.isizes, this.lp), this.maxTLEN = ou(this.isizes, this.up)
+                } this.ffCount / this.totalCount > .9 ? this.orienation = "ff" : this.frCount / this.totalCount > .9 ? this.orienation = "fr" : this.rfCount / this.totalCount > .9 && (this.orienation = "rf"), this.minTLEN = 0 === this.lp ? 0 : qd(this.isizes, this.lp), this.maxTLEN = qd(this.isizes, this.up)
         }
     }
 
-    function ou(e, t) {
+    function qd(e, t) {
         if (0 !== e.length) {
             var i = Math.floor(e.length * (t / 100));
             return e.sort((function(e, t) {
                 return e - t
             })), e[i]
         }
     }
-    const au = {
+    const jd = {
         getTissueInfo: function(e, t) {
             let i = (t = t || "https://gtexportal.org/rest/v1") + "/dataset/tissueInfo?datasetId=" + (e = e || "gtex_v8");
-            return lo.loadJson(i, {})
+            return io.loadJson(i, {})
         },
         trackConfiguration: function(e, t) {
             return {
                 type: "eqtl",
                 sourceType: "gtex-ws",
                 url: (t = t || "https://gtexportal.org/rest/v1") + "/association/singleTissueEqtlByLocation",
                 tissueSiteDetailId: e.tissueSiteDetailId,
                 name: e.tissueSiteDetailId.split("_").join(" "),
                 visibilityWindow: 25e4
             }
         }
     };
 
-    function lu(e, t, i) {
+    function $d(e, t, i) {
         let n = (e.start - t) / i,
             r = (e.end - t) / i,
             s = r - n;
         return s < 3 && (s = 3, n -= 1.5), {
             px: n,
             px1: r,
             pw: s
         }
     }
 
-    function hu(e, t, i, n, r, s) {
+    function Wd(e, t, i, n, r, s) {
         try {
-            r.save(), r.fillStyle = this.defaultColor, r.strokeStyle = this.defaultColor;
+            r.save(), r.fillStyle = this.color, r.strokeStyle = this.color;
             const n = this.getColorForFeature(e);
             let o, a;
             r.fillStyle = n, r.strokeStyle = n, "SQUISHED" === this.displayMode && void 0 !== e.row ? (o = this.featureHeight / 2, a = this.margin + this.squishedRowHeight * e.row) : "EXPANDED" === this.displayMode && void 0 !== e.row ? (o = this.featureHeight, a = this.margin + this.expandedRowHeight * e.row) : (o = this.featureHeight, a = this.margin);
             const l = s.pixelWidth,
                 h = a + o / 2,
                 c = o / 2,
                 d = h - c / 2,
                 u = e.exons ? e.exons.length : 0,
-                f = lu(e, t, i),
+                f = $d(e, t, i),
                 p = this.arrowSpacing,
                 g = "+" === e.strand ? 1 : "-" === e.strand ? -1 : 0;
             if (0 === u) {
                 const e = Math.max(0, f.px),
                     t = Math.min(l, f.px1),
                     i = t - e;
                 if (r.fillRect(e, a, i, o), 0 !== g) {
                     r.fillStyle = "white", r.strokeStyle = "white";
-                    for (let i = e + p / 2; i < t; i += p) Mo.strokeLine(r, i - 2 * g, h - 2, i, h), Mo.strokeLine(r, i - 2 * g, h + 2, i, h);
+                    for (let i = e + p / 2; i < t; i += p) ko.strokeLine(r, i - 2 * g, h - 2, i, h), ko.strokeLine(r, i - 2 * g, h + 2, i, h);
                     r.fillStyle = n, r.strokeStyle = n
                 }
             } else {
-                Mo.strokeLine(r, f.px + 1, h, f.px1 - 1, h);
+                ko.strokeLine(r, f.px + 1, h, f.px1 - 1, h);
                 const s = Math.max(0, f.px) + p / 2,
                     m = Math.min(l, f.px1);
-                for (let e = s; e < m; e += p) Mo.strokeLine(r, e - 2 * g, h - 2, e, h), Mo.strokeLine(r, e - 2 * g, h + 2, e, h);
+                for (let e = s; e < m; e += p) ko.strokeLine(r, e - 2 * g, h - 2, e, h), ko.strokeLine(r, e - 2 * g, h + 2, e, h);
                 for (let s = 0; s < u; s++) {
                     const u = e.exons[s];
                     let f, m = Math.round((u.start - t) / i),
                         b = Math.round((u.end - t) / i),
                         w = Math.max(1, b - m);
                     if (!(m + w < 0)) {
                         if (m > l) break;
                         if (u.utr) r.fillRect(m, d, w, c);
                         else if (u.cdStart && (f = Math.round((u.cdStart - t) / i), r.fillRect(m, d, f - m, c), w -= f - m, m = f), u.cdEnd && (f = Math.round((u.cdEnd - t) / i), r.fillRect(f, d, b - f, c), w -= b - f, b = f), w = Math.max(w, 1), r.fillRect(m, a, w, o), w > p + 5 && 0 !== g) {
                             r.fillStyle = "white", r.strokeStyle = "white";
-                            for (let e = m + p / 2; e < b; e += p) Mo.strokeLine(r, e - 2 * g, h - 2, e, h), Mo.strokeLine(r, e - 2 * g, h + 2, e, h);
+                            for (let e = m + p / 2; e < b; e += p) ko.strokeLine(r, e - 2 * g, h - 2, e, h), ko.strokeLine(r, e - 2 * g, h + 2, e, h);
                             r.fillStyle = n, r.strokeStyle = n
                         }
                     }
                 }
             }
-            s.drawLabel && "SQUISHED" !== this.displayMode && cu.call(this, r, e, f.px, f.px1, a, s.referenceFrame, s)
+            s.drawLabel && "SQUISHED" !== this.displayMode && Gd.call(this, r, e, f.px, f.px1, a, s.referenceFrame, s)
         } finally {
             r.restore()
         }
     }
 
-    function cu(e, t, i, n, r, s, o) {
+    function Gd(e, t, i, n, r, s, o) {
         try {
             e.save();
             let a = t.name;
             if (void 0 === a && t.gene && (a = t.gene.name), void 0 === a && (a = t.id || t.ID), !a || "." === a) return;
             let l = o.pixelXOffset || 0;
             const h = Math.max(i, -l);
             let c, d = (h + Math.min(n, -l + o.viewportWidth)) / 2;
@@ -23293,53 +23332,53 @@
                 }
             });
             const u = function(e, t) {
                 return t ? e + 20 : e + 25
             }(r, c);
             let f, p = this.getColorForFeature(t),
                 g = !1;
-            s.selection && au.gtexLoaded && (g = !0, f = s.selection.colorForGene(a));
+            s.selection && jd.gtexLoaded && (g = !0, f = s.selection.colorForGene(a));
             const m = {
                     textAlign: "SLANT" === this.labelDisplayMode ? void 0 : "center",
                     fillStyle: f || p,
                     strokeStyle: f || p
                 },
                 b = e.measureText(a),
                 w = d - b.width / 2,
                 v = d + b.width / 2,
                 y = o.rowLastLabelX[t.row] || -Number.MAX_SAFE_INTEGER;
-            (o.labelAllFeatures || w > y || g) && (o.rowLastLabelX[t.row] = v, "y" === o.axis ? (e.save(), Mo.labelTransformWithContext(e, d), Mo.fillText(e, a, d, u, m, c), e.restore()) : Mo.fillText(e, a, d, u, m, c))
+            (o.labelAllFeatures || w > y || g) && (o.rowLastLabelX[t.row] = v, "y" === o.axis ? (e.save(), ko.labelTransformWithContext(e, d), ko.fillText(e, a, d, u, m, c), e.restore()) : ko.fillText(e, a, d, u, m, c))
         } finally {
             e.restore()
         }
     }
-    const du = new Set(["nonsense", "missense", "stop-loss", "frameshift", "cds-indel"]),
-        uu = new Set(["coding-synon"]),
-        fu = new Set(["splice-3", "splice-5"]),
-        pu = new Set(["untranslated-5", "untranslated-3"]);
+    const Zd = new Set(["nonsense", "missense", "stop-loss", "frameshift", "cds-indel"]),
+        Qd = new Set(["coding-synon"]),
+        Xd = new Set(["splice-3", "splice-5"]),
+        Yd = new Set(["untranslated-5", "untranslated-3"]);
 
-    function gu(e, t, i, n, r) {
-        var s, o, a, l, h = lu(e, t, i),
+    function Kd(e, t, i, n, r) {
+        var s, o, a, l, h = $d(e, t, i),
             c = this.margin,
             d = this.snpColors.length;
         switch (s = "squished" === this.displayMode ? this.squishedRowHeight : this.expandedRowHeight, this.colorBy) {
             case "function":
                 l = e.func, o = l.split(",").map((function(e) {
-                    return du.has(e) || fu.has(e) ? d - 1 : uu.has(e) ? d - 2 : pu.has(e) ? d - 3 : 0
+                    return Zd.has(e) || Xd.has(e) ? d - 1 : Qd.has(e) ? d - 2 : Yd.has(e) ? d - 3 : 0
                 })).reduce((function(e, t) {
                     return Math.max(e, t)
                 }));
                 break;
             case "class":
                 o = "deletion" === (a = e.class) ? d - 1 : "mnp" === a ? d - 2 : "microsatellite" === a || "named" === a ? d - 3 : 0
         }
         r.fillStyle = this.snpColors[o], r.fillRect(h.px, c, h.pw, s)
     }
 
-    function mu(e, t, i, n, r) {
+    function Jd(e, t, i, n, r) {
         const s = "EXPANDED" === this.displayMode ? this.expandedRowHeight : this.squishedRowHeight;
         let o = this.margin;
         "COLLAPSED" !== this.displayMode && void 0 !== e.row && (o += e.row * s);
         const a = o + .5 * s,
             l = a - .5 * s,
             h = a + .5 * s,
             c = Math.round((e.junction_left - t) / i),
@@ -23349,30 +23388,39 @@
         for (let e = 0; e < u.length; e++) {
             const n = u[e],
                 s = Math.round((n.left - t) / i),
                 o = Math.round((n.right - t) / i);
             r.beginPath(), r.moveTo(s, a), r.bezierCurveTo(s, h, o, h, o, a), r.lineWidth = 1, r.strokeStyle = "purple", r.stroke()
         }
     }
-    class bu extends zl {
+    class eu extends Rl {
+        static defaults = {
+            type: "annotation",
+            maxRows: 1e3,
+            displayMode: "EXPANDED",
+            margin: 10,
+            featureHeight: 14,
+            autoHeight: !1,
+            useScore: !1
+        };
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.type = e.type || "annotation", this.maxRows = void 0 === e.maxRows ? 1e3 : e.maxRows, this.displayMode = e.displayMode || "EXPANDED", this.labelDisplayMode = e.labelDisplayMode, e._featureSource ? (this.featureSource = e._featureSource, delete e._featureSource) : this.featureSource = e.featureSource ? e.featureSource : Sc(e, this.browser.genome), this.autoHeight = e.autoHeight, this.margin = void 0 === e.margin ? 10 : e.margin, this.featureHeight = e.featureHeight || 14, "FusionJuncSpan" === e.type ? (this.render = e.render || mu, this.squishedRowHeight = e.squishedRowHeight || 50, this.expandedRowHeight = e.expandedRowHeight || 50, this.height = e.height || this.margin + 2 * this.expandedRowHeight) : "snp" === e.type ? (this.render = e.render || gu, this.snpColors = ["rgb(0,0,0)", "rgb(0,0,255)", "rgb(0,255,0)", "rgb(255,0,0)"], this.colorBy = "function", this.expandedRowHeight = e.expandedRowHeight || 10, this.squishedRowHeight = e.squishedRowHeight || 5, this.height = e.height || 30) : (this.render = e.render || hu, this.arrowSpacing = 30, function(e) {
+            super.init(e), this.labelDisplayMode = e.labelDisplayMode, e._featureSource ? (this.featureSource = e._featureSource, delete e._featureSource) : this.featureSource = e.featureSource ? e.featureSource : cc(e, this.browser.genome), "FusionJuncSpan" === e.type ? (this.render = e.render || Jd, this.squishedRowHeight = e.squishedRowHeight || 50, this.expandedRowHeight = e.expandedRowHeight || 50, this.height = e.height || this.margin + 2 * this.expandedRowHeight) : "snp" === e.type ? (this.render = e.render || Kd, this.snpColors = ["rgb(0,0,0)", "rgb(0,0,255)", "rgb(0,255,0)", "rgb(255,0,0)"], this.colorBy = "function", this.expandedRowHeight = e.expandedRowHeight || 10, this.squishedRowHeight = e.squishedRowHeight || 5, this.height = e.height || 30) : (this.render = e.render || Wd, this.arrowSpacing = 30, function(e) {
                 e.browser.on && (e.browser.on("trackdragend", t), e.browser.on("trackremoved", i));
 
                 function t() {
-                    e.trackView && "SQUISHED" !== e.displayMode && e.trackView.repaintViews()
+                    e.trackView && "SQUISHED" !== e.displayMode && e.trackView.updateViews()
                 }
 
                 function i(n) {
                     e.browser.un && e === n && (e.browser.un("trackdragend", t), e.browser.un("trackremoved", i))
                 }
-            }(this), this.squishedRowHeight = e.squishedRowHeight || 15, this.expandedRowHeight = e.expandedRowHeight || 30, this.height = e.height || this.margin + 2 * this.expandedRowHeight, e.colorBy && (e.colorBy.field && (e.colorTable = e.colorBy.pallete || e.colorBy.palette, e.colorBy = e.colorBy.field), this.colorBy = e.colorBy, e.colorTable ? this.colorTable = new Ao(e.colorTable) : this.colorTable = new So("Set1"))), this.useScore = e.useScore
+            }(this), this.squishedRowHeight = e.squishedRowHeight || 15, this.expandedRowHeight = e.expandedRowHeight || 30, this.height = e.height || this.margin + 2 * this.expandedRowHeight, e.colorBy && (e.colorBy.field && (e.colorTable = e.colorBy.pallete || e.colorBy.palette, e.colorBy = e.colorBy.field), this.colorBy = e.colorBy, e.colorTable ? this.colorTable = new yo(e.colorTable) : this.colorTable = new vo("Set1")))
         }
         async postInit() {
             if ("function" != typeof this.featureSource.getHeader || (this.header = await this.featureSource.getHeader(), !this.disposed)) return this.header && this.setTrackProperties(this.header), void 0 === this.visibilityWindow && "function" == typeof this.featureSource.defaultVisibilityWindow && (this.visibilityWindow = await this.featureSource.defaultVisibilityWindow()), this
         }
         get supportsWholeGenome() {
             return void 0 !== this.config.supportsWholeGenome ? this.config.supportsWholeGenome : this.featureSource && "function" == typeof this.featureSource.supportsWholeGenome ? this.featureSource.supportsWholeGenome() : !(void 0 !== this.visibilityWindow || !1 !== this.config.indexed && this.config.indexURL) || void 0
         }
@@ -23398,15 +23446,15 @@
             const t = e.features,
                 i = e.context,
                 n = e.bpPerPixel,
                 r = e.bpStart,
                 s = e.pixelWidth,
                 o = e.pixelHeight,
                 a = r + s * n + 1;
-            if (this.config.isMergedTrack || Mo.fillRect(i, 0, e.pixelTop, s, o, {
+            if (this.config.isMergedTrack || ko.fillRect(i, 0, e.pixelTop, s, o, {
                     fillStyle: "rgb(255, 255, 255)"
                 }), t) {
                 const l = [];
                 e.rowLastX = [], e.rowLastLabelX = [];
                 for (let i of t)
                     if (i.start > r && i.end < a) {
                         const t = "COLLAPSED" === this.displayMode ? 0 : i.row || 0;
@@ -23419,15 +23467,15 @@
                     const t = "COLLAPSED" === this.displayMode ? 0 : s.row;
                     e.drawLabel = e.labelAllFeatures || h > 10;
                     const l = Math.ceil((s.end - r) / n),
                         d = c[t];
                     if (!d || l > d) {
                         this.render.call(this, s, r, n, o, i, e);
                         const a = Math.floor((s.start - r) / n);
-                        d && a - d <= 0 && (i.globalAlpha = .5, Mo.strokeLine(i, a, 0, a, o, {
+                        d && a - d <= 0 && (i.globalAlpha = .5, ko.strokeLine(i, a, 0, a, o, {
                             strokeStyle: "rgb(255, 255, 255)"
                         }), i.globalAlpha = 1), c[t] = l
                     }
                 }
             } else console.log("No feature list")
         }
         clickedFeatures(e) {
@@ -23477,15 +23525,15 @@
                         }
                 }
             }
             return n
         }
         menuItemList() {
             const e = [];
-            if (this.render === gu) {
+            if (this.render === Kd) {
                 e.push("<hr/>");
                 for (let t of ["function", "class"]) e.push({
                     object: ft(jt("Color by " + t, t === this.colorBy)),
                     click: () => {
                         this.colorBy = t, this.trackView.repaintViews()
                     }
                 })
@@ -23512,123 +23560,121 @@
             t.length > 1 && t.sort(((e, t) => t.end - t.start - (e.end - e.start)));
             const i = t[0];
             if (i.end - i.start <= 1e6) {
                 const e = [{
                     label: "View feature sequence",
                     click: async () => {
                         let e = await this.browser.genome.getSequence(i.chr, i.start, i.end);
-                        e ? "-" === i.strand && (e = na(e)) : e = "Unknown sequence", this.browser.alert.present(e)
+                        e ? "-" === i.strand && (e = Xo(e)) : e = "Unknown sequence", this.browser.alert.present(e)
                     }
                 }];
-                return jo() && void 0 !== navigator.clipboard && e.push({
+                return Po() && void 0 !== navigator.clipboard && e.push({
                     label: "Copy feature sequence",
                     click: async () => {
                         let e = await this.browser.genome.getSequence(i.chr, i.start, i.end);
-                        e ? "-" === i.strand && (e = na(e)) : e = "Unknown sequence";
+                        e ? "-" === i.strand && (e = Xo(e)) : e = "Unknown sequence";
                         try {
                             await navigator.clipboard.writeText(e)
                         } catch (e) {
                             console.error(e), this.browser.alert.present(`error copying sequence to clipboard ${e}`)
                         }
                     }
                 }), e.push("<hr/>"), e
             }
         }
         description() {
-            if (gu === this.render) {
+            if (Kd === this.render) {
                 let e = "<html>" + this.name + "<hr/>";
                 return e += "<em>Color By Function:</em><br>", e += '<span style="color:red">Red</span>: Coding-Non-Synonymous, Splice Site<br>', e += '<span style="color:green">Green</span>: Coding-Synonymous<br>', e += '<span style="color:blue">Blue</span>: Untranslated<br>', e += '<span style="color:black">Black</span>: Intron, Locus, Unknown<br><br>', e += "<em>Color By Class:</em><br>", e += '<span style="color:red">Red</span>: Deletion<br>', e += '<span style="color:green">Green</span>: MNP<br>', e += '<span style="color:blue">Blue</span>: Microsatellite, Named<br>', e += '<span style="color:black">Black</span>: Indel, Insertion, SNP', e += "</html>", e
             }
             return super.description()
         }
         getColorForFeature(e) {
             let t;
             if (this.altColor && "-" === e.strand) t = "function" == typeof this.altColor ? this.altColor(e) : this.altColor;
             else if (this.color) t = "function" == typeof this.color ? this.color(e) : this.color;
             else if (this.colorBy) {
                 const i = e.getAttributeValue ? e.getAttributeValue(this.colorBy) : e[this.colorBy];
                 t = this.colorTable.getColor(i)
-            } else t = e.color ? e.color : this.defaultColor;
-            if (e.alpha && 1 !== e.alpha) t = js.addAlpha(t, e.alpha);
+            } else t = e.color ? e.color : this.color;
+            if (e.alpha && 1 !== e.alpha) t = Ds.addAlpha(t, e.alpha);
             else if (this.useScore && e.score && !Number.isNaN(e.score)) {
                 const i = function(e, t, i) {
                     const n = (t - e) / 9,
                         r = Math.floor((i - e) / n);
                     return Math.min(1, .2 + .8 * r / 9)
-                }(this.config.min ? this.config.min : 0, this.config.max ? this.config.max : 1e3, e.score);
-                e.alpha = i, t = js.addAlpha(t, i)
+                }(this.config.min ? this.config.min : this.viewLimitMin ? this.viewLimitMin : 0, this.config.max ? this.config.max : this.viewLimitMax ? this.viewLimitMax : 1e3, e.score);
+                e.alpha = i, t = Ds.addAlpha(t, i)
             }
             return t
         }
         dispose() {
             this.trackView = void 0
         }
     }
-    class wu {
+    class tu {
         constructor(e) {
-            this.config = e, this.browser = e.browser, this.container = _t.div({
+            this.config = e, this.browser = e.browser, this.columnFormat = e.columnFormat, this.tableRowSelectionList = [], this.tableDOM = _t.div({
                 class: "igv-roi-table"
-            }), e.parent.appendChild(this.container), this.headerDOM = e, this.descriptionDOM = e, this.columnTitleDOM = e.columnFormat, this.rowContainerDOM = this.container, this.footerDOM = e.gotoButtonHandler, this.columnFormat = e.columnFormat, this.tableRowSelectionList = []
+            }), e.parent.appendChild(this.tableDOM), this.headerDOM = e, this.tableColumnTitles = this.tableDOM, this.tableRowContainer = this.tableDOM, this.footerDOM = e.gotoButtonHandler
         }
         set headerDOM({
             browser: e,
             parent: t,
             headerTitle: i,
             dismissHandler: n
         }) {
             const r = _t.div();
-            this.container.appendChild(r);
+            this.tableDOM.appendChild(r);
             const s = _t.div();
-            r.appendChild(s), s.innerText = i;
+            r.appendChild(s), s.innerHTML = i;
             const o = _t.div();
             r.appendChild(o), o.appendChild(At.createIcon("times")), this.boundDismissHandler = function(e) {
                 e.stopPropagation(), n()
             }.bind(this), o.addEventListener("click", this.boundDismissHandler);
             const {
                 y: a
             } = e.root.getBoundingClientRect(), {
                 y: l
             } = t.getBoundingClientRect(), h = -(l - a);
-            Rt(this.container, r, {
+            Rt(this.tableDOM, r, {
                 minX: 0,
                 minY: h
-            }), this.container.style.display = "none", this._headerDOM = r
-        }
-        set descriptionDOM(e) {
-            const t = _t.div({
-                class: "igv-roi-table-description"
-            });
-            this.container.appendChild(t), t.innerHTML = e.description || "this is a description"
+            }), this.tableDOM.style.display = "none", this._headerDOM = r
         }
-        set columnTitleDOM(e) {
+        set tableColumnTitles(e) {
             const t = _t.div({
                 class: "igv-roi-table-column-titles"
             });
-            this.container.appendChild(t);
+            e.appendChild(t);
             for (const {
-                    label: i,
-                    width: n
+                    label: e,
+                    width: i
                 }
-                of e) {
-                const e = _t.div();
-                t.appendChild(e), e.style.width = n, e.innerText = i
+                of this.columnFormat) {
+                const n = _t.div();
+                t.appendChild(n), n.style.width = i, n.innerText = e
             }
+            this._tableColumnTitlesDOM = t
         }
-        set rowContainerDOM(e) {
+        get tableColumnTitles() {
+            return this._tableColumnTitlesDOM
+        }
+        set tableRowContainer(e) {
             const t = _t.div({
                 class: "igv-roi-table-row-container"
             });
-            e.appendChild(t), this._rowContainerDOM = t
+            e.appendChild(t), this._tableRowContainerDOM = t
         }
-        get rowContainerDOM() {
-            return this._rowContainerDOM
+        get tableRowContainer() {
+            return this._tableRowContainerDOM
         }
         set footerDOM(e) {
             const t = _t.div();
-            this.container.appendChild(t);
+            this.tableDOM.appendChild(t);
             const i = _t.div({
                 class: "igv-roi-table-button"
             });
             t.appendChild(i), i.id = "igv-roi-table-view-button", i.textContent = "Go To", i.style.pointerEvents = "none", this._footerDOM = t, this.gotoButton = i, this.boundGotoButtonHandler = e.bind(this), this.gotoButton.addEventListener("click", this.boundGotoButtonHandler)
         }
         tableRowDOMHelper(e) {
             e.addEventListener("mousedown", (t => {
@@ -23636,47 +23682,54 @@
             })), e.addEventListener("mouseover", (t => {
                 e.classList.contains("igv-roi-table-row-selected") ? e.classList.remove("igv-roi-table-row-hover") : e.classList.add("igv-roi-table-row-hover")
             })), e.addEventListener("mouseout", (t => {
                 e.classList.remove("igv-roi-table-row-hover")
             }))
         }
         clearTable() {
-            const e = this.rowContainerDOM.querySelectorAll(".igv-roi-table-row");
+            const e = this.tableRowContainer.querySelectorAll(".igv-roi-table-row");
             for (let t of e) t.remove()
         }
         setTableRowSelectionState(e) {
             e ? this.tableRowSelectionList.push(1) : this.tableRowSelectionList.pop(), this.gotoButton.style.pointerEvents = this.tableRowSelectionList.length > 0 ? "auto" : "none"
         }
         present() {
-            this.container.style.left = "0px";
+            this.tableDOM.style.left = "0px";
             const {
                 y: e
             } = this.browser.root.getBoundingClientRect(), {
                 y: t
             } = this.config.parent.getBoundingClientRect();
-            this.container.style.top = e - t + "px", this.container.style.display = "flex"
+            this.tableDOM.style.top = e - t + "px", this.tableDOM.style.display = "flex"
         }
         dismiss() {
-            this.container.style.display = "none"
+            this.tableDOM.style.display = "none"
         }
         dispose() {
-            this.container.innerHTML = "", this.container.remove();
+            this.tableDOM.innerHTML = "", this.tableDOM.remove();
             for (const e of Object.keys(this)) this[e] = void 0;
             document.removeEventListener("click", this.boundDismissHandler)
         }
     }
-    class vu extends wu {
-        set columnTitleDOM(e) {
-            const t = _t.div({
-                class: "igv-roi-table-column-titles"
-            });
-            this.container.appendChild(t);
-            for (const i of e) {
-                const e = _t.div();
-                t.appendChild(e), e.style.width = i.width || "fit-content", e.innerText = i.label
+    class iu extends tu {
+        constructor(e) {
+            super(Object.assign({
+                width: "1024px"
+            }, e)), this.descriptionDOM = e
+        }
+        set descriptionDOM(e) {
+            if (e.description) {
+                let t;
+                t = _t.div({
+                    class: "igv-roi-table-description"
+                }), this.tableDOM.insertBefore(t, this.tableColumnTitles), t.style.height = "auto", t.innerHTML = "BLAT result for query sequence:", t = _t.div({
+                    class: "igv-roi-table-description"
+                }), this.tableDOM.insertBefore(t, this.tableColumnTitles), t.style.height = "auto", t.style.maxHeight = "128px", t.innerHTML = e.description, t = _t.div({
+                    class: "igv-roi-table-goto-explainer"
+                }), this.tableDOM.insertBefore(t, this.tableColumnTitles), t.innerHTML = "Select one or more rows and click Go To to view the regions"
             }
         }
         tableRowDOM(e) {
             const t = _t.div({
                     class: "igv-roi-table-row"
                 }),
                 i = e.map((e => isFinite(e) ? Xt(e) : e));
@@ -23685,133 +23738,184 @@
                 t.appendChild(n);
                 const r = this.columnFormat[e];
                 n.style.width = r.width || "fit-content", n.innerText = i[e]
             }
             return this.tableRowDOMHelper(t), t
         }
         renderTable(e) {
-            if (Array.from(this.rowContainerDOM.querySelectorAll(".igv-roi-table-row")).forEach((e => e.remove())), e.length > 0)
+            if (Array.from(this.tableRowContainer.querySelectorAll(".igv-roi-table-row")).forEach((e => e.remove())), e.length > 0)
                 for (let t of e) {
                     const e = this.tableRowDOM(t);
-                    this.rowContainerDOM.appendChild(e)
+                    this.tableRowContainer.appendChild(e)
                 }
         }
         static getColumnFormatConfiguration() {
             return [{
                 label: "chr",
-                width: "60px"
+                width: "7%"
             }, {
                 label: "start",
-                width: "100px"
+                width: "12%"
             }, {
                 label: "end",
-                width: "100px"
+                width: "12%"
             }, {
                 label: "strand",
-                width: "50px"
+                width: "5%"
             }, {
                 label: "score",
-                width: "50px"
+                width: "5%"
             }, {
                 label: "match",
-                width: "50px"
+                width: "5%"
             }, {
                 label: "mis-match",
-                width: "70px"
+                width: "7%"
             }, {
                 label: "rep. match",
-                width: "70px"
+                width: "7%"
             }, {
                 label: "N's",
-                width: "32px"
+                width: "3%"
             }, {
                 label: "Q gap count",
-                width: "90px"
+                width: "9%"
             }, {
                 label: "Q gap bases",
-                width: "90px"
+                width: "9%"
             }, {
                 label: "T gap count",
-                width: "90px"
+                width: "9%"
             }, {
                 label: "T gap bases",
-                width: "90px"
+                width: "9%"
             }]
         }
         static gotoButtonHandler(e) {
             e.stopPropagation();
-            const t = this.container.querySelectorAll(".igv-roi-table-row-selected"),
+            const t = this.tableDOM.querySelectorAll(".igv-roi-table-row-selected"),
                 i = [];
             for (const e of t) {
                 const t = [];
                 e.querySelectorAll("div").forEach((e => t.push(e.innerText)));
                 const [n, r, s] = t;
                 i.push(`${n}:${r}-${s}`)
             }
-            for (const e of this.container.querySelectorAll(".igv-roi-table-row")) e.classList.remove("igv-roi-table-row-selected");
+            for (const e of this.tableDOM.querySelectorAll(".igv-roi-table-row")) e.classList.remove("igv-roi-table-row-selected");
             this.setTableRowSelectionState(!1), this.browser.search(i.join(" "))
         }
     }
-    class yu extends bu {
+    const nu = "https://igv.org/services/blatUCSC.php";
+    async function ru({
+        url: e,
+        userSeq: t,
+        db: i
+    }) {
+        e = e || nu;
+        const n = await async function(e = "", t, i) {
+            const n = new URLSearchParams;
+            n.append("userSeq", t), n.append("db", i);
+            const r = await fetch(e, {
+                method: "post",
+                body: n
+            });
+            return r.json()
+        }(e, t, i);
+        n.fields;
+        return n.blat.map(ul)
+    }
+    const su = 25e3;
+    class ou extends eu {
         constructor(e, t) {
             super(e, t), this.name || (this.name = "Blat Results"), this.sequence = e.sequence, this.table = void 0
         }
-        openTableView(e) {
+        openTableView() {
             if (void 0 === this.table) {
                 const e = this.config.features.map((e => [e.chr, e.start + 1, e.end, e.strand, e.score, e.matches, e.misMatches, e.repMatches, e.nCount, e.qNumInsert, e.qBaseInsert, e.tNumInsert, e.tBaseInsert])),
                     t = {
                         browser: this.browser,
                         parent: this.browser.parent,
-                        headerTitle: this.name,
-                        description: `BLAT result for query sequence:<br>${this.sequence}`,
+                        headerTitle: this.config.title,
+                        description: this.sequence,
                         dismissHandler: () => {
                             this.table.dismiss(), this.table.dispose(), this.table = void 0
                         },
-                        columnFormat: vu.getColumnFormatConfiguration(),
-                        gotoButtonHandler: vu.gotoButtonHandler
+                        columnFormat: iu.getColumnFormatConfiguration(),
+                        gotoButtonHandler: iu.gotoButtonHandler
                     };
-                this.table = new vu(t), this.table.renderTable(e)
+                this.table = new iu(t), this.table.renderTable(e)
             }
             this.table.present()
         }
         menuItemList() {
             const e = super.menuItemList();
             return e.push("<hr/>"), e.push({
                 label: "Open table view",
                 click: () => this.openTableView()
             }), e
         }
         dispose() {
             super.dispose(), this.table && this.table.popover.parentElement.removeChild(this.table.popover)
         }
     }
-    const _u = "https://igv.org/services/blat.php";
-    async function xu(e, t) {
-        const i = t.genome.id,
-            n = await async function(e, t) {
-                const i = `${_u}?userSeq=${e}&type=DNA&db=${t}&output=json`,
-                    n = await lo.loadJson(i, {});
-                return n.fields, n.blat.map(yl)
-            }(e, i), r = {
+    async function au({
+        sequence: e,
+        browser: t,
+        name: i,
+        title: n
+    }) {
+        if (e.length > su) return void t.alert.present(`Sequence size exceeds maximum allowed length (${e.length} > ${su})`);
+        const r = t.genome.id,
+            s = t.config.blatServerURL;
+        try {
+            const o = {
                 type: "blat",
-                name: "blat results",
+                name: i || "blat results",
+                title: n || "blat results",
                 sequence: e,
-                features: n
+                altColor: "rgb(176, 176, 236)",
+                color: "rgb(236, 176, 176)",
+                features: await ru({
+                    url: s,
+                    userSeq: e,
+                    db: r
+                })
             };
-        (await t.loadTrack(r)).openTableView()
+            (await t.loadTrack(o)).openTableView()
+        } catch (e) {
+            t.alert.present(`Error performing blat search:  ${e}`)
+        }
     }
-    class ku extends zl {
+    const lu = "rgb(185, 185, 185)",
+        hu = "rgb(150, 150, 150)";
+    class cu extends Rl {
+        static defaults = {
+            alleleFreqThreshold: .2,
+            visibilityWindow: 3e4,
+            showCoverage: !0,
+            showAlignments: !0,
+            viewAsPairs: !1,
+            pairsSupported: !0,
+            showSoftClips: !1,
+            showAllBases: !1,
+            showInsertions: !0,
+            showMismatches: !0,
+            color: lu,
+            coverageColor: hu,
+            height: 300,
+            coverageTrackHeight: 50
+        };
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.type = "alignment", void 0 === e.alleleFreqThreshold && (e.alleleFreqThreshold = .2), this.featureSource = new Ad(e, this.browser), this.showCoverage = void 0 === e.showCoverage || e.showCoverage, this.showAlignments = void 0 === e.showAlignments || e.showAlignments, this.coverageTrack = new Cu(e, this), this.alignmentTrack = new Su(e, this), this.alignmentTrack.setTop(this.coverageTrack, this.showCoverage), this.visibilityWindow = e.visibilityWindow || 3e4, this.viewAsPairs = e.viewAsPairs, this.pairsSupported = !1 !== e.pairsSupported, this.showSoftClips = e.showSoftClips, this.showAllBases = e.showAllBases, this.showInsertions = !1 !== e.showInsertions, this.showMismatches = !1 !== e.showMismatches, this.color = e.color, this.coverageColor = e.coverageColor, e.sort && (Array.isArray(e.sort) ? this.assignSort(e.sort[0]) : this.assignSort(e.sort)), this.height = void 0 !== e.height ? e.height : 300
+            this.type = "alignment", this.featureSource = new hd(e, this.browser), this.coverageTrack = new du(e, this), this.alignmentTrack = new uu(e, this), super.init(e), this.alignmentTrack.setTop(this.coverageTrack, this.showCoverage), e.sort && (Array.isArray(e.sort) ? this.assignSort(e.sort[0]) : this.assignSort(e.sort))
         }
         set height(e) {
-            this._height = e, this.coverageTrack && this.showAlignments && (this.alignmentTrack.height = this.showCoverage ? e - this.coverageTrack.height : e)
+            this._height = e, this.showAlignments && (this.alignmentTrack.height = this.showCoverage ? e - this.coverageTrackHeight : e)
         }
         get height() {
             return this._height
         }
         get minTemplateLength() {
             const e = void 0 !== this.config.minTLEN ? this.config.minTLEN : this.config.minFragmentLength;
             return void 0 !== e ? e : this._pairedEndStats ? this._pairedEndStats.minTLEN : 0
@@ -23842,44 +23946,44 @@
                 e.chr = t.chr, e.position = t.start
             } else e.position--;
             return e.direction = "ASC" === e.direction || !0 === e.direction, e.chr = this.browser.genome.getChromosomeName(e.chr), this.sortObject = e, this.sortObject
         }
         async getFeatures(e, t, i, n, r) {
             const s = await this.featureSource.getAlignments(e, t, i);
             if (s.paired && !this._pairedEndStats && !this.config.maxFragmentLength) {
-                const e = new su(s.alignments, this.config);
+                const e = new Ud(s.alignments, this.config);
                 e.totalCount > 99 && (this._pairedEndStats = e)
             }
             s.alignments = void 0;
             const o = this.sortObject;
             return o && o.chr === e && o.position >= t && o.position <= i && s.sortRows(o), s
         }
         computePixelHeight(e) {
-            return (this.showCoverage ? this.coverageTrack.height : 0) + (this.showAlignments ? this.alignmentTrack.computePixelHeight(e) : 0) + 15
+            return (this.showCoverage ? this.coverageTrackHeight : 0) + (this.showAlignments ? this.alignmentTrack.computePixelHeight(e) : 0)
         }
         draw(e) {
-            Mo.fillRect(e.context, 0, e.pixelTop, e.pixelWidth, e.pixelHeight, {
+            ko.fillRect(e.context, 0, e.pixelTop, e.pixelWidth, e.pixelHeight, {
                 fillStyle: "rgb(255, 255, 255)"
-            }), !0 === this.showCoverage && this.coverageTrack.height > 0 ? (this.trackView.axisCanvas.style.display = "block", this.coverageTrack.draw(e)) : this.trackView.axisCanvas.style.display = "none", !0 === this.showAlignments && (this.alignmentTrack.setTop(this.coverageTrack, this.showCoverage), this.alignmentTrack.draw(e))
+            }), !0 === this.showCoverage && this.coverageTrackHeight > 0 ? (this.trackView.axisCanvas.style.display = "block", this.coverageTrack.draw(e)) : this.trackView.axisCanvas.style.display = "none", !0 === this.showAlignments && (this.alignmentTrack.setTop(this.coverageTrack, this.showCoverage), this.alignmentTrack.draw(e))
         }
         paintAxis(e, t, i) {
-            this.coverageTrack.paintAxis(e, t, this.coverageTrack.height)
+            this.coverageTrack.paintAxis(e, t, this.coverageTrackHeight)
         }
         contextMenuItemList(e) {
             return this.alignmentTrack.contextMenuItemList(e)
         }
         popupData(e) {
-            return !0 === this.showCoverage && e.y >= this.coverageTrack.top && e.y < this.coverageTrack.height ? this.coverageTrack.popupData(e) : this.alignmentTrack.popupData(e)
+            return !0 === this.showCoverage && e.y >= this.coverageTrack.top && e.y < this.coverageTrackHeight ? this.coverageTrack.popupData(e) : this.alignmentTrack.popupData(e)
         }
         clickedFeatures(e) {
             let t;
-            return t = !0 === this.showCoverage && e.y >= this.coverageTrack.top && e.y < this.coverageTrack.height ? this.coverageTrack.getClickedObject(e) : this.alignmentTrack.getClickedObject(e), t ? [t] : void 0
+            return t = !0 === this.showCoverage && e.y >= this.coverageTrack.top && e.y < this.coverageTrackHeight ? this.coverageTrack.getClickedObject(e) : this.alignmentTrack.getClickedObject(e), t ? [t] : void 0
         }
         hoverText(e) {
-            if (!0 === this.showCoverage && e.y >= this.coverageTrack.top && e.y < this.coverageTrack.height) {
+            if (!0 === this.showCoverage && e.y >= this.coverageTrack.top && e.y < this.coverageTrackHeight) {
                 const t = this.coverageTrack.getClickedObject(e);
                 if (t) return t.hoverText()
             }
         }
         menuItemList() {
             let e = [];
             e = e.concat($t.numericDataMenuItems(this.trackView)), e.push("<hr/>");
@@ -23914,15 +24018,15 @@
             });
             for (let t of i) {
                 const i = this.alignmentTrack.colorBy === t.key;
                 e.push(this.colorByCB(t, i))
             }
             const r = () => {
                 if (!this.autoHeight) {
-                    const e = 15 + (this.showCoverage ? this.coverageTrack.height : 0) + (this.showAlignments ? this.alignmentTrack.height : 0);
+                    const e = (this.showCoverage ? this.coverageTrackHeight : 0) + (this.showAlignments ? this.alignmentTrack.height : 0);
                     this.trackView.setTrackHeight(e)
                 }
             };
             e.push("<hr/>"), e.push({
                 object: ft(jt("Show Coverage", this.showCoverage)),
                 click: () => {
                     this.showCoverage = !this.showCoverage, r(), this.trackView.checkContentHeight(), this.trackView.repaintViews()
@@ -23997,15 +24101,15 @@
                 name: void 0,
                 object: ft(jt(e.label, t)),
                 click: t => {
                     "tag" !== e.key ? e.key === this.alignmentTrack.colorBy ? (this.alignmentTrack.colorBy = "none", this.config.colorBy = "none", this.trackView.repaintViews()) : (this.alignmentTrack.colorBy = e.key, this.config.colorBy = e.key, this.trackView.repaintViews()) : this.browser.inputDialog.present({
                         label: "Tag Name",
                         value: this.alignmentTrack.colorByTag ? this.alignmentTrack.colorByTag : "",
                         callback: e => {
-                            e ? (this.alignmentTrack.colorBy = "tag", this.alignmentTrack.colorByTag = e, this.alignmentTrack.tagColors || (this.alignmentTrack.tagColors = new So("Set1"))) : (this.alignmentTrack.colorBy = "none", this.alignmentTrack.colorByTag = ""), this.trackView.repaintViews()
+                            e ? (this.alignmentTrack.colorBy = "tag", this.alignmentTrack.colorByTag = e, this.alignmentTrack.tagColors || (this.alignmentTrack.tagColors = new vo("Set1"))) : (this.alignmentTrack.colorBy = "none", this.alignmentTrack.colorByTag = ""), this.trackView.repaintViews()
                         }
                     }, t)
                 },
                 init: void 0
             }
         }
         getState() {
@@ -24039,130 +24143,133 @@
             this.coverageTrack.autoscale = e
         }
         addPairedChordsForViewport(e) {
             const t = this.maxTemplateLength,
                 i = [],
                 n = e.referenceFrame;
             for (let r of e.cachedFeatures.allAlignments()) r.end >= n.start && r.start <= n.end && (r.paired ? r.end - r.start > t && i.push(r) : r.mate && r.mate.chr && (r.mate.chr !== r.chr || Math.max(r.fragmentLength) > t) && i.push(r));
-            ru((e => {
+            Vd((e => {
                 const t = [];
                 for (let i of e)
                     if (i.paired) i.firstAlignment && i.secondAlignment && t.push({
                         uniqueId: i.readName,
-                        refName: iu(i.firstAlignment.chr),
+                        refName: zd(i.firstAlignment.chr),
                         start: i.firstAlignment.start,
                         end: i.firstAlignment.end,
                         mate: {
-                            refName: iu(i.secondAlignment.chr),
+                            refName: zd(i.secondAlignment.chr),
                             start: i.secondAlignment.start,
                             end: i.secondAlignment.end
                         }
                     });
                     else {
                         const e = i.mate;
                         e && e.chr && e.position && t.push({
                             uniqueId: i.readName,
-                            refName: iu(i.chr),
+                            refName: zd(i.chr),
                             start: i.start,
                             end: i.end,
                             mate: {
-                                refName: iu(e.chr),
+                                refName: zd(e.chr),
                                 start: e.position - 1,
                                 end: e.position
                             }
                         })
                     } return t
             })(i), this, n, .02)
         }
         addSplitChordsForViewport(e) {
             const t = [],
                 i = e.referenceFrame;
             for (let n of e.cachedFeatures.allAlignments()) {
                 const e = n.hasTag("SA");
                 n.end >= i.start && n.start <= i.end && e && t.push(n)
             }
-            ru((e => {
+            Vd((e => {
                 const t = e => {
-                        const t = Wc(e.tags().SA);
+                        const t = Tc(e.tags().SA);
                         let n = 0;
                         for (let r of t) r.start !== e.start && i.push({
                             uniqueId: `${e.readName}_${n++}`,
-                            refName: iu(e.chr),
+                            refName: zd(e.chr),
                             start: e.start,
                             end: e.end,
                             mate: {
-                                refName: iu(r.chr),
+                                refName: zd(r.chr),
                                 start: r.start,
                                 end: r.start + r.lenOnRef
                             }
                         })
                     },
                     i = [];
                 for (let i of e) i.paired ? (t(i.firstAlignment), i.secondAlignment && t(i.secondAlignment)) : t(i);
                 return i
             })(t), this, i, .02)
         }
     }
-    class Cu {
+    class du {
         constructor(e, t) {
-            this.parent = t, this.featureSource = t.featureSource, this.height = void 0 !== e.coverageTrackHeight ? e.coverageTrackHeight : 50, this.paintAxis = Ed, this.top = 0, this.autoscale = e.autoscale || void 0 === e.max, this.autoscale || (this.dataRange = {
+            this.parent = t, this.featureSource = t.featureSource, this.paintAxis = cd, this.top = 0, this.autoscale = e.autoscale || void 0 === e.max, this.autoscale || (this.dataRange = {
                 min: e.min || 0,
                 max: e.max
             })
         }
+        get height() {
+            return this.parent.coverageTrackHeight
+        }
         draw(e) {
             const t = e.pixelTop;
             e.pixelHeight;
             const i = this.parent.browser.nucleotideColors;
             if (t > this.height) return;
             const n = e.context,
                 r = e.features.coverageMap;
             let s;
             r.refSeq && (s = r.refSeq.toUpperCase());
             const o = e.bpPerPixel,
                 a = e.bpStart,
                 l = a + e.pixelWidth * o + 1;
             let h;
-            h = this.parent.coverageColor ? this.parent.coverageColor : void 0 !== this.parent.color && "function" != typeof this.parent.color ? js.darkenLighten(this.parent.color, -35) : "rgb(150, 150, 150)", Mo.setProperties(n, {
+            h = this.parent.coverageColor ? this.parent.coverageColor : void 0 !== this.parent.color && "function" != typeof this.parent.color ? Ds.darkenLighten(this.parent.color, -35) : hu, ko.setProperties(n, {
                 fillStyle: h,
                 strokeStyle: h
             });
             const c = Math.max(1, Math.ceil(1 / o));
             for (let e = 0, t = r.coverage.length; e < t; e++) {
                 const t = r.bpStart + e;
                 if (t < a) continue;
                 if (t > l) break;
                 const i = r.coverage[e];
                 if (!i) continue;
                 const s = Math.round(i.total / this.dataRange.max * this.height),
                     h = this.height - s,
                     d = Math.floor((t - a) / o);
-                Mo.fillRect(n, d, h, c, s)
+                ko.fillRect(n, d, h, c, s)
             }
             if (s)
                 for (let e = 0, t = r.coverage.length; e < t; e++) {
                     const t = r.bpStart + e;
                     if (t < a) continue;
                     if (t > l) break;
                     const h = r.coverage[e];
                     if (!h) continue;
                     const d = h.total / this.dataRange.max * this.height;
                     let u = this.height - d;
                     const f = Math.floor((t - a) / o),
                         p = s[e];
                     if (h.isMismatch(p)) {
-                        Mo.setProperties(n, {
+                        ko.setProperties(n, {
                             fillStyle: i[p]
-                        }), Mo.fillRect(n, f, u, c, d);
+                        }), ko.fillRect(n, f, u, c, d);
                         let e = 0;
                         for (let t of ["A", "C", "T", "G"]) {
                             const r = (h["pos" + t] + h["neg" + t]) / this.dataRange.max * this.height;
-                            u = this.height - r - e, e += r, Mo.setProperties(n, {
+                            u = this.height - r - e, e += r, ko.setProperties(n, {
                                 fillStyle: i[t]
-                            }), Mo.fillRect(n, f, u, c, r)
+                            }), ko.fillRect(n, f, u, c, r)
                         }
                     }
                 }
         }
         getClickedObject(e) {
             let t = e.viewport.cachedFeatures;
             if (!t || 0 === t.length) return;
@@ -24204,15 +24311,15 @@
                     name: "INS",
                     value: i.ins.toString()
                 })
             }
             return t
         }
     }
-    class Su {
+    class uu {
         constructor(e, t) {
             this.parent = t, this.browser = t.browser, this.featureSource = t.featureSource, this.top = 0 === e.coverageTrackHeight ? 0 : e.coverageTrackHeight + 5, this.displayMode = e.displayMode || "EXPANDED", this.alignmentRowHeight = e.alignmentRowHeight || 14, this.squishedRowHeight = e.squishedRowHeight || 3, this.negStrandColor = e.negStrandColor || "rgba(150, 150, 230, 0.75)", this.posStrandColor = e.posStrandColor || "rgba(230, 150, 150, 0.75)", this.insertionColor = e.insertionColor || "rgb(138, 94, 161)", this.insertionTextColor = e.insertionTextColor || "white", this.showInsertionText = void 0 !== e.showInsertionText && !!e.showInsertionText, this.deletionColor = e.deletionColor || "black", this.deletionTextColor = e.deletionTextColor || "black", this.showDeletionText = void 0 !== e.showDeletionText && !!e.showDeletionText, this.skippedColor = e.skippedColor || "rgb(150, 170, 170)", this.pairConnectorColor = e.pairConnectorColor, this.smallTLENColor = e.smallTLENColor || e.smallFragmentLengthColor || "rgb(0, 0, 150)", this.largeTLENColor = e.largeTLENColor || e.largeFragmentLengthColor || "rgb(200, 0, 0)", this.pairOrientation = e.pairOrienation || "fr", this.pairColors = {}, this.pairColors.RL = e.rlColor || "rgb(0, 150, 0)", this.pairColors.RR = e.rrColor || "rgb(20, 50, 200)", this.pairColors.LL = e.llColor || "rgb(0, 150, 150)", this.colorBy = e.colorBy || "unexpectedPair", this.colorByTag = e.colorByTag ? e.colorByTag.toUpperCase() : void 0, this.bamColorTag = void 0 === e.bamColorTag ? "YC" : e.bamColorTag, this.hideSmallIndels = e.hideSmallIndels, this.indelSizeThreshold = e.indelSizeThreshold || 1, this.hasPairs = !1, this.hasSupplemental = !1
         }
         setTop(e, t) {
             this.top = 0 === e.height || !1 === t ? 0 : 5 + e.height
         }
         computePixelHeight(e) {
@@ -24238,15 +24345,15 @@
             let u = 0,
                 f = e.pixelTop;
             this.top && i.translate(0, this.top);
             const p = f + e.pixelHeight;
             t.hasDownsampledIntervals() ? (u = 10, t.downsampledIntervals.forEach((function(e) {
                 var t = (e.start - r) / n,
                     s = (e.end - r) / n;
-                s - t > 5 && (t += 1, s -= 1), Mo.fillRect(i, t, 2, s - t, 3, {
+                s - t > 5 && (t += 1, s -= 1), ko.fillRect(i, t, 2, s - t, 3, {
                     fillStyle: "black"
                 })
             }))) : u = 0, this.alignmentsYOffset = u;
             const g = "SQUISHED" === this.displayMode ? this.squishedRowHeight : this.alignmentRowHeight;
             if (c) {
                 const e = c.length;
                 for (let t = 0; t < e; t++) {
@@ -24254,36 +24361,36 @@
                         i = u + g * t,
                         n = g <= 4 ? g : g - 2;
                     if (i > p) break;
                     if (!(i + n < f))
                         for (let t of e.alignments)
                             if (this.hasPairs = this.hasPairs || t.isPaired(), this.browser.circularView && (this.hasSupplemental = this.hasSupplemental || t.hasTag("SA")), !(t.start + t.lengthOnRef < r)) {
                                 if (t.start > o) break;
-                                !0 !== t.hidden && (t instanceof Bc ? (m.call(this, t, i, n), b.call(this, t.firstAlignment, i, n), t.secondAlignment && b.call(this, t.secondAlignment, i, n)) : b.call(this, t, i, n))
+                                !0 !== t.hidden && (t instanceof bc ? (m.call(this, t, i, n), b.call(this, t.firstAlignment, i, n), t.secondAlignment && b.call(this, t.secondAlignment, i, n)) : b.call(this, t, i, n))
                             }
                 }
             }
 
             function m(e, t, s) {
                 var a = this.getConnectorColor(e.firstAlignment),
                     l = (e.connectingStart - r) / n,
                     h = (e.connectingEnd - r) / n,
                     c = t + s / 2;
-                e.connectingEnd < r || e.connectingStart > o || (e.mq <= 0 && (a = js.addAlpha(a, .15)), Mo.setProperties(i, {
+                e.connectingEnd < r || e.connectingStart > o || (e.mq <= 0 && (a = Ds.addAlpha(a, .15)), ko.setProperties(i, {
                     fillStyle: a,
                     strokeStyle: a
-                }), Mo.strokeLine(i, l, c, h, c))
+                }), ko.strokeLine(i, l, c, h, c))
             }
 
             function b(e, c, u) {
                 if (e.start + e.lengthOnRef < r || e.start > o) return;
                 const f = a ? e.blocks : e.blocks.filter((e => "S" !== e.type));
                 let p = this.getAlignmentColor(e);
                 const m = p;
-                e.mq <= 0 && (p = js.addAlpha(p, .15)), Mo.setProperties(i, {
+                e.mq <= 0 && (p = Ds.addAlpha(p, .15)), ko.setProperties(i, {
                     fillStyle: p,
                     strokeStyle: m
                 });
                 const b = [];
                 for (let e = 0; e < f.length; e++) {
                     const t = f[e];
                     if (!(e !== f.length - 1 && f[e + 1].start < r) && (b.push(...w.call(this, t, e)), t.start + t.len > o)) break
@@ -24294,22 +24401,22 @@
                         const e = (s.start - r) / n,
                             o = (s.start + s.len - r) / n,
                             a = o - e,
                             l = s.len.toString(),
                             h = 6 * l.length,
                             d = e + a / 2,
                             u = "D" === s.type ? this.deletionColor : this.skippedColor;
-                        if (Mo.strokeLine(i, e, t, o, t, {
+                        if (ko.strokeLine(i, e, t, o, t, {
                                 strokeStyle: u,
                                 lineWidth: 2
                             }), this.showDeletionText && s.len > 1 && a >= h + 8) {
                             const e = d - h / 2;
-                            Mo.fillRect(i, e - 1, c - 1, h + 2, 12, {
+                            ko.fillRect(i, e - 1, c - 1, h + 2, 12, {
                                 fillStyle: "white"
-                            }), Mo.fillText(i, l, e, c + 10, {
+                            }), ko.fillText(i, l, e, c + 10, {
                                 font: "normal 10px monospace",
                                 fillStyle: this.deletionTextColor
                             })
                         }
                     }
                 }
                 if (e.insertions && this.parent.showInsertions) {
@@ -24324,15 +24431,15 @@
                             h = this.showInsertionText && 1 !== s.len ? Math.round(s.len / n) : 2,
                             d = Math.max(Math.min(l, h), 2),
                             f = e / n - d / 2;
                         if (f - t > 2) {
                             const e = {
                                 fillStyle: this.insertionColor
                             };
-                            Mo.fillRect(i, f - 2, c, d + 4, 2, e), Mo.fillRect(i, f, c + 2, d, u - 4, e), Mo.fillRect(i, f - 2, c + u - 2, d + 4, 2, e), this.showInsertionText && s.len > 1 && h > l && Mo.fillText(i, a, f + 1, c + 10, {
+                            ko.fillRect(i, f - 2, c, d + 4, 2, e), ko.fillRect(i, f, c + 2, d, u - 4, e), ko.fillRect(i, f - 2, c + u - 2, d + 4, 2, e), this.showInsertionText && s.len > 1 && h > l && ko.fillText(i, a, f + 1, c + 10, {
                                 font: "normal 10px monospace",
                                 fillStyle: this.insertionTextColor
                             }), t = f
                         }
                     }
                 }
 
@@ -24345,23 +24452,23 @@
                         x = 100 / n,
                         k = Math.min(g / 2, x / 6),
                         C = "S" === o.type,
                         S = e.mq <= 0 || this.highlightedAlignmentReadNamed === e.readName || C;
                     let A = m;
                     this.highlightedAlignmentReadNamed === e.readName ? A = "red" : C && (A = "rgb(50,50,50)");
                     const E = !0 === e.strand && a === f.length - 1,
-                        T = !1 === e.strand && 0 === a;
-                    if (E | T) {
+                        M = !1 === e.strand && 0 === a;
+                    if (E | M) {
                         let e, t;
-                        E ? (e = [v, y, y + k, y, v, v], t = [c, c, c + u / 2, c + u, c + u, c]) : T && (e = [y, v, v - k, v, y, y], t = [c, c, c + u / 2, c + u, c + u, c]), Mo.fillPolygon(i, e, t, {
+                        E ? (e = [v, y, y + k, y, v, v], t = [c, c, c + u / 2, c + u, c + u, c]) : M && (e = [y, v, v - k, v, y, y], t = [c, c, c + u / 2, c + u, c + u, c]), ko.fillPolygon(i, e, t, {
                             fillStyle: p
-                        }), S && Mo.strokePolygon(i, e, t, {
+                        }), S && ko.strokePolygon(i, e, t, {
                             strokeStyle: A
                         })
-                    } else Mo.fillRect(i, v, c, _, u, {
+                    } else ko.fillRect(i, v, c, _, u, {
                         fillStyle: p
                     }), S && (i.save(), i.strokeStyle = A, i.strokeRect(v, c, _, u), i.restore());
                     if (C || l || this.parent.showMismatches && d && e.seq && "*" !== e.seq) {
                         const t = e.seq ? e.seq.toUpperCase() : void 0,
                             i = e.qual,
                             a = o.seqOffset,
                             f = Math.max(1, 1 / n);
@@ -24370,15 +24477,15 @@
                             if (p + f < 0) continue;
                             if (p > s) break;
                             let g = t ? t.charAt(a + e) : "";
                             const m = w + e >= 0 ? d.charAt(w + e) : "";
                             if ("=" === g && (g = m), "X" === g || m !== g || C || l) {
                                 let t;
                                 if (!C && void 0 !== i && i.length > a + e) {
-                                    t = Au(i[a + e], h[g])
+                                    t = fu(i[a + e], h[g])
                                 } else t = h[g];
                                 t && b.push({
                                     bbox: {
                                         x: p,
                                         y: c,
                                         width: f,
                                         height: u
@@ -24396,18 +24503,18 @@
                     baseColor: t,
                     readChar: r
                 }) => {
                     ! function(e, t, i, n, r) {
                         var s;
                         if (t <= .1 && i.height >= 8) {
                             const t = Math.min(10, i.height);
-                            e.font = t + "px sans-serif", s = i.x + i.width / 2, Mo.strokeText(e, r, s - e.measureText(r).width / 2, t - 1 + i.y, {
+                            e.font = t + "px sans-serif", s = i.x + i.width / 2, ko.strokeText(e, r, s - e.measureText(r).width / 2, t - 1 + i.y, {
                                 strokeStyle: n
                             })
-                        } else Mo.fillRect(e, i.x, i.y, i.width, i.height, {
+                        } else ko.fillRect(e, i.x, i.y, i.width, i.height, {
                             fillStyle: n
                         })
                     }(i, n, e, t, r)
                 }))
             }
             i.restore()
         }
@@ -24499,45 +24606,69 @@
                         init: void 0
                     }), i.push({
                         label: "View read sequence",
                         click: () => {
                             const e = n.seq;
                             e && "*" !== e ? this.browser.alert.present(e) : this.browser.alert.present("Read sequence: *")
                         }
-                    }), jo() && i.push({
+                    }), Po() && i.push({
                         label: "Copy read sequence",
                         click: async () => {
                             const e = n.seq;
                             try {
                                 await navigator.clipboard.writeText(e)
                             } catch (e) {
                                 console.error(e), this.browser.alert.present(`error copying sequence to clipboard ${e}`)
                             }
                         }
                     });
                     const t = n.seq;
                     if (t && "*" != t) {
-                        i.push({
+                        t.length < su && i.push({
                             label: "BLAT read sequence",
                             click: () => {
-                                xu(n.isNegativeStrand() ? na(t) : t, this.browser)
+                                const e = n.isNegativeStrand() ? Xo(t) : t,
+                                    i = `${n.readName} - blat`,
+                                    r = `${this.parent.name} - ${i}`;
+                                au({
+                                    sequence: e,
+                                    browser: this.browser,
+                                    name: i,
+                                    title: r
+                                })
                             }
                         });
                         const e = n.softClippedBlocks();
-                        e.left && e.left.len > 20 && i.push({
+                        e.left && e.left.len > 20 && e.left.len < su && i.push({
                             label: "BLAT left soft-clipped sequence",
                             click: () => {
-                                const i = t.substr(e.left.seqOffset, e.left.len);
-                                xu(n.isNegativeStrand() ? na(i) : i, this.browser)
+                                const i = t.substr(e.left.seqOffset, e.left.len),
+                                    r = n.isNegativeStrand() ? Xo(i) : i,
+                                    s = `${n.readName} - blat left clip`,
+                                    o = `${this.parent.name} - ${s}`;
+                                au({
+                                    sequence: r,
+                                    browser: this.browser,
+                                    name: s,
+                                    title: o
+                                })
                             }
-                        }), e.right && e.right.length > 20 && i.push({
+                        }), e.right && e.right.len > 20 && e.right.len < su && i.push({
                             label: "BLAT right soft-clipped sequence",
                             click: () => {
-                                const i = t.substr(e.right.seqOffset, e.right.len);
-                                xu(n.isNegativeStrand() ? na(i) : i, this.browser)
+                                const i = t.substr(e.right.seqOffset, e.right.len),
+                                    r = n.isNegativeStrand() ? Xo(i) : i,
+                                    s = `${n.readName} - blat right clip`,
+                                    o = `${this.parent.name} - ${s}`;
+                                au({
+                                    sequence: r,
+                                    browser: this.browser,
+                                    name: s,
+                                    title: o
+                                })
                             }
                         })
                     }
                     i.push("<hr/>")
                 }
             }
             return this.browser.circularView && (this.hasPairs || this.hasSupplemental) && (this.hasPairs && i.push({
@@ -24580,54 +24711,54 @@
                 case "tag":
                     return this.parent.color ? "function" == typeof this.parent.color ? this.parent.color(e) : this.parent.color : "rgb(200, 200, 200)";
                 default:
                     return this.getAlignmentColor(e)
             }
         }
         getAlignmentColor(e) {
-            let t = "rgb(185, 185, 185)";
+            let t = lu;
             this.parent.color && (t = "function" == typeof this.parent.color ? this.parent.color(e) : this.parent.color);
             const i = this.colorBy;
             switch (i) {
                 case "strand":
                     t = e.strand ? this.posStrandColor : this.negStrandColor;
                     break;
                 case "firstOfPairStrand":
-                    e instanceof Bc ? t = e.firstOfPairStrand() ? this.posStrandColor : this.negStrandColor : e.isPaired() && (e.isFirstOfPair() ? t = e.strand ? this.posStrandColor : this.negStrandColor : e.isSecondOfPair() ? t = e.strand ? this.negStrandColor : this.posStrandColor : console.error("ERROR. Paired alignments are either first or second."));
+                    e instanceof bc ? t = e.firstOfPairStrand() ? this.posStrandColor : this.negStrandColor : e.isPaired() && (e.isFirstOfPair() ? t = e.strand ? this.posStrandColor : this.negStrandColor : e.isSecondOfPair() ? t = e.strand ? this.negStrandColor : this.posStrandColor : console.error("ERROR. Paired alignments are either first or second."));
                     break;
                 case "unexpectedPair":
                 case "pairOrientation":
                     if (this.pairOrientation && e.pairOrientation) {
-                        const i = Eu[this.pairOrientation];
+                        const i = pu[this.pairOrientation];
                         if (i) {
                             const n = this.pairColors[i[e.pairOrientation]];
                             if (n) {
                                 t = n;
                                 break
                             }
                         }
                     }
                     if ("pairOrientation" === i) break;
                 case "tlen":
                 case "fragmentLength":
-                    e.mate && e.isMateMapped() && (e.mate.chr !== e.chr ? t = Tu(e.mate.chr) : this.parent.minTemplateLength && Math.abs(e.fragmentLength) < this.parent.minTemplateLength ? t = this.smallTLENColor : this.parent.maxTemplateLength && Math.abs(e.fragmentLength) > this.parent.maxTemplateLength && (t = this.largeTLENColor));
+                    e.mate && e.isMateMapped() && (e.mate.chr !== e.chr ? t = gu(e.mate.chr) : this.parent.minTemplateLength && Math.abs(e.fragmentLength) < this.parent.minTemplateLength ? t = this.smallTLENColor : this.parent.maxTemplateLength && Math.abs(e.fragmentLength) > this.parent.maxTemplateLength && (t = this.largeTLENColor));
                     break;
                 case "tag":
                     const n = e.tags()[this.colorByTag];
-                    void 0 !== n && (this.bamColorTag === this.colorByTag ? t = "rgb(" + n + ")" : (this.tagColors || (this.tagColors = new So("Set1")), t = this.tagColors.getColor(n)))
+                    void 0 !== n && (this.bamColorTag === this.colorByTag ? t = "rgb(" + n + ")" : (this.tagColors || (this.tagColors = new vo("Set1")), t = this.tagColors.getColor(n)))
             }
             return t
         }
     }
 
-    function Au(e, t) {
+    function fu(e, t) {
         let i;
-        return i = e < 5 ? .1 : Math.max(.1, Math.min(1, .1 + .9 * (e - 5) / 15)), i = Math.round(10 * i) / 10, i < 1 && (t = js.addAlpha(t, i)), t
+        return i = e < 5 ? .1 : Math.max(.1, Math.min(1, .1 + .9 * (e - 5) / 15)), i = Math.round(10 * i) / 10, i < 1 && (t = Ds.addAlpha(t, i)), t
     }
-    const Eu = {
+    const pu = {
         fr: {
             F1R2: "LR",
             F2R1: "LR",
             F1F2: "LL",
             F2F1: "LL",
             R1R2: "RR",
             R2R1: "RR",
@@ -24652,25 +24783,25 @@
             R2F1: "RR",
             F1R2: "RR",
             R2R1: "RL",
             F1F2: "RL"
         }
     };
 
-    function Tu(e) {
-        if (Mu[e]) return Mu[e];
-        if (Mu["chr" + e]) {
-            const t = Mu["chr" + e];
-            return Mu[e] = t, t
+    function gu(e) {
+        if (mu[e]) return mu[e];
+        if (mu["chr" + e]) {
+            const t = mu["chr" + e];
+            return mu[e] = t, t
         } {
-            const t = js.randomRGB(0, 255);
-            return Mu[e] = t, t
+            const t = Ds.randomRGB(0, 255);
+            return mu[e] = t, t
         }
     }
-    const Mu = {
+    const mu = {
         chrX: "rgb(204, 153, 0)",
         chrY: "rgb(153, 204, 0)",
         chrUn: "rgb(50, 50, 50)",
         chr1: "rgb(80, 80, 255)",
         chrI: "rgb(139, 155, 187)",
         chr2: "rgb(206, 61, 50)",
         chrII: "rgb(206, 61, 50)",
@@ -24721,16 +24852,16 @@
         chr43: "rgb(102, 0, 153)",
         chr44: "rgb(153, 0, 128)",
         chr45: "rgb(214, 0, 71)",
         chr46: "rgb(255, 20, 99)",
         chr47: "rgb(0, 214, 143)",
         chr48: "rgb(20, 255, 177)"
     };
-    let Ru, Lu;
-    class Iu extends ja {
+    let bu, wu;
+    class vu extends Oa {
         constructor(e, t, i, n) {
             super(e, t, i, n)
         }
         get contentDiv() {
             return this.$viewport.get(0)
         }
         initializationHelper() {
@@ -24741,27 +24872,27 @@
                 this.browser.removeMultiLocusPanel(this.referenceFrame)
             })), this.$rulerLabel = ft("<div>", {
                 class: "igv-multi-locus-ruler-label"
             }), this.$viewport.append(this.$rulerLabel), e = document.createElement("div"), this.$rulerLabel.append(ft(e)), this.$rulerLabel.get(0).addEventListener("click", (async e => {
                 e.stopPropagation(), await this.browser.gotoMultilocusPanel(this.referenceFrame)
             })), this.$tooltip = ft("<div>", {
                 class: "igv-ruler-tooltip"
-            }), this.$tooltip.height(this.$viewport.height()), this.$viewport.append(this.$tooltip), this.$tooltipContent = ft("<div>"), this.$tooltip.append(this.$tooltipContent), this.rulerSweeper = new Ic(this, this.$viewport.get(0).parentElement, this.browser, this.referenceFrame), this.attachMouseHandlers(za.isWholeGenomeView(this.referenceFrame.chr)), this.$tooltip.hide(), this.dismissLocusLabel()
+            }), this.$tooltip.height(this.$viewport.height()), this.$viewport.append(this.$tooltip), this.$tooltipContent = ft("<div>"), this.$tooltip.append(this.$tooltipContent), this.rulerSweeper = new mc(this, this.$viewport.get(0).parentElement, this.browser, this.referenceFrame), this.attachMouseHandlers(La.isWholeGenomeView(this.referenceFrame.chr)), this.$tooltip.hide(), this.dismissLocusLabel()
         }
         presentLocusLabel(e) {
-            this.$multiLocusCloseButton.show(), this.$rulerLabel.show(), this.$rulerLabel.get(0).style.backgroundColor = Tu(this.referenceFrame.chr);
+            this.$multiLocusCloseButton.show(), this.$rulerLabel.show(), this.$rulerLabel.get(0).style.backgroundColor = gu(this.referenceFrame.chr);
             const t = this.$rulerLabel.get(0).querySelector("div"),
                 {
                     width: i
                 } = this.$rulerLabel.get(0).getBoundingClientRect();
             t.innerHTML = `${this.referenceFrame.getMultiLocusLabel(e)}`;
             const {
                 width: n
             } = t.getBoundingClientRect();
-            n / i > .5 && (t.innerHTML = `${this.referenceFrame.getMultiLocusLabelBPLengthOnly(e)}`), console.log(`${Date.now()} textDiv ${Xt(Math.floor(n))}`)
+            n / i > .5 && (t.innerHTML = `${this.referenceFrame.getMultiLocusLabelBPLengthOnly(e)}`)
         }
         dismissLocusLabel() {
             this.$rulerLabel.hide(), this.$multiLocusCloseButton.hide()
         }
         attachMouseHandlers(e) {
             if (this.namespace = `.ruler_track_viewport_${this.browser.referenceFrameList.indexOf(this.referenceFrame)}`, this.$viewport.off(this.namespace), !0 === e) {
                 const e = this.browser.referenceFrameList.indexOf(this.referenceFrame),
@@ -24783,42 +24914,42 @@
                     }
                     this.browser.search(r)
                 })), this.$viewport.get(0).style.cursor = "pointer"
             } else this.$viewport.get(0).style.cursor = "default"
         }
         mouseMove(e) {
             if (!0 === this.browser.cursorGuideVisible) {
-                void 0 === Lu ? (Lu = this, this.$tooltip.show()) : Lu.guid !== this.guid ? (Lu.$tooltip && Lu.$tooltip.hide(), this.$tooltip.show(), Lu = this) : this.$tooltip.show();
-                if (this.browser.isMultiLocusWholeGenomeView() || za.isWholeGenomeView(this.referenceFrame.chr)) return void this.$tooltip.hide();
+                void 0 === wu ? (wu = this, this.$tooltip.show()) : wu.guid !== this.guid ? (wu.$tooltip && wu.$tooltip.hide(), this.$tooltip.show(), wu = this) : this.$tooltip.show();
+                if (this.browser.isMultiLocusWholeGenomeView() || La.isWholeGenomeView(this.referenceFrame.chr)) return void this.$tooltip.hide();
                 const {
                     x: t
                 } = _t.translateMouseCoordinates(e, this.$viewport.get(0)), {
                     start: i,
                     bpPerPixel: n
                 } = this.referenceFrame, r = Math.round(.5 + i + Math.max(0, t) * n);
                 this.$tooltipContent.text(Xt(r));
                 const {
                     width: s
                 } = this.$tooltipContent.get(0).getBoundingClientRect(), {
                     width: o
                 } = this.$viewport.get(0).getBoundingClientRect();
                 this.$tooltip.css({
-                    left: `${Vs.clamp(t,0,o-s)}px`
-                }), clearTimeout(Ru), Ru = setTimeout((() => {
+                    left: `${Ns.clamp(t,0,o-s)}px`
+                }), clearTimeout(bu), bu = setTimeout((() => {
                     this.$tooltip && this.$tooltip.hide()
                 }), 1e4)
             }
         }
         startSpinner() {}
         stopSpinner() {}
         dispose() {
             this.rulerSweeper.dispose(), super.dispose()
         }
     }
-    class Bu extends ja {
+    class yu extends Oa {
         constructor(e, t, i, n) {
             super(e, t, i, n)
         }
         initializationHelper() {
             this.canvas = document.createElement("canvas"), this.canvas.className = "igv-ideogram-canvas", this.$viewport.append(ft(this.canvas)), this.ideogram_ctx = this.canvas.getContext("2d"), this.addMouseHandlers()
         }
         addMouseHandlers() {
@@ -24855,38 +24986,37 @@
             this.draw({
                 referenceFrame: this.referenceFrame
             })
         }
         draw({
             referenceFrame: e
         }) {
-            Mo.configureHighDPICanvas(this.ideogram_ctx, this.$viewport.width(), this.$viewport.height()), this.trackView.track.draw({
+            ko.configureHighDPICanvas(this.ideogram_ctx, this.$viewport.width(), this.$viewport.height()), this.trackView.track.draw({
                 context: this.ideogram_ctx,
                 referenceFrame: e,
                 pixelWidth: this.$viewport.width(),
                 pixelHeight: this.$viewport.height()
             })
         }
         startSpinner() {}
         stopSpinner() {}
     }
 
-    function Nu(e, t, i, n) {
-        if ("ruler" === e.track.type) return new Iu(e, t, i, n);
-        if ("ideogram" === e.track.id) return new Bu(e, t, i, n);
-        return new ja(e, t, i, n)
-    }
-    const Fu = 10,
-        Pu = {
-            textAlign: "start",
-            textBaseline: "bottom",
-            strokeStyle: "black",
-            fillStyle: "black"
-        };
-    class Ou {
+    function _u(e, t, i, n) {
+        if ("ruler" === e.track.type) return new vu(e, t, i, n);
+        if ("ideogram" === e.track.id) return new yu(e, t, i, n);
+        return new Oa(e, t, i, n)
+    }
+    const xu = {
+        textAlign: "start",
+        textBaseline: "bottom",
+        strokeStyle: "black",
+        fillStyle: "black"
+    };
+    class ku {
         constructor(e, t, i, n) {
             this.guid = _t.guid(), this.trackView = e, this.browser = e.browser, this.viewport = _t.div({
                 class: "igv-viewport"
             }), t.appendChild(this.viewport), e.track.height && (this.viewport.style.height = `${e.track.height}px`), this.canvas = document.createElement("canvas"), this.viewport.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.trackScrollDelta = 0, this.contentTop = 0, this.setWidth(n), !1 === this.browser.showSampleNames && this.hide(), this.addMouseHandlers()
         }
         checkCanvas() {
             const e = window.devicePixelRatio,
@@ -24926,32 +25056,32 @@
             if (!t || 0 === t.names.length) return;
             ! function(e, {
                 textAlign: t,
                 textBaseline: i,
                 strokeStyle: n,
                 fillStyle: r
             }, s) {
-                const o = Math.min(s, Fu);
+                const o = Math.min(s, 10);
                 e.font = `${o}px sans-serif`, e.textAlign = t, e.textBaseline = i, e.fillStyle = r
-            }(e, Pu, t.height);
+            }(e, xu, t.height);
             e.clearRect(0, 0, e.canvas.width, e.canvas.height), e.fillStyle = function(e) {
                 const {
                     r: t,
                     g: i,
                     b: n
-                } = ko[e];
+                } = bo[e];
                 return `rgb(${t},${i},${n})`
             }("lead");
             const i = this.viewport.getBoundingClientRect().height;
             let n = (t.yOffset || 0) + this.contentTop;
             for (let r of t.names) {
                 if (n > i) break;
                 if (n + t.height > 0) {
                     const i = r,
-                        s = Du(e, i, n, t.height);
+                        s = Cu(e, i, n, t.height);
                     e.fillText(i, 4, s)
                 }
                 n += t.height
             }
         }
         renderSVGContext(e, {
             deltaX: t,
@@ -24999,51 +25129,51 @@
             e.removeEventListener("contextmenu", this.boundContextMenuHandler)
         }
         dispose() {
             this.removeMouseHandlers(), this.viewport.remove()
         }
     }
 
-    function Du(e, t, i, n) {
+    function Cu(e, t, i, n) {
         return i + n - function(e, t, i) {
             const {
                 actualBoundingBoxAscent: n,
                 actualBoundingBoxDescent: r
             } = e.measureText(t);
             return (i - (n + r)) / 2
         }(e, t, n)
     }
-    const zu = function(e) {
+    const Su = function(e) {
         this.popover = _t.div({
             class: "igv-menu-popup"
         }), e.appendChild(this.popover);
         const t = _t.div({
             class: "igv-menu-popup-header"
         });
-        this.popover.appendChild(t), Tt.attachDialogCloseHandlerWithParent(t, (() => this.hide())), this.popoverContent = _t.div(), this.popover.appendChild(this.popoverContent), Rt(this.popover, t), t.addEventListener("click", (e => {
+        this.popover.appendChild(t), Mt.attachDialogCloseHandlerWithParent(t, (() => this.hide())), this.popoverContent = _t.div(), this.popover.appendChild(this.popoverContent), Rt(this.popover, t), t.addEventListener("click", (e => {
             e.stopPropagation(), e.preventDefault()
         })), this.hide()
     };
-    zu.prototype.hide = function() {
+    Su.prototype.hide = function() {
         this.popover.style.display = "none"
-    }, zu.prototype.presentMenuList = function(e) {
-        if (Hu(), e.length > 0) {
+    }, Su.prototype.presentMenuList = function(e) {
+        if (Au(), e.length > 0) {
             this.popoverContent.innerHTML = "", e = $t.trackMenuItemListHelper(e, this);
             for (let t of e) {
                 t.init && t.init();
                 let i = t.object;
                 0 === e.indexOf(t) && i.removeClass("igv-track-menu-border-top"), i.hasClass("igv-track-menu-border-top") || i.hasClass("igv-menu-popup-check-container") || i.is("div") && i.addClass("igv-menu-popup-shim"), this.popoverContent.appendChild(i.get(0))
             }
             this.popover.style.display = "flex";
             const {
                 width: t
             } = this.popover.getBoundingClientRect();
             this.popover.style.left = -t + "px", this.popover.style.top = "0px"
         }
-    }, zu.prototype.presentTrackContextMenu = function(e, t) {
+    }, Su.prototype.presentTrackContextMenu = function(e, t) {
         this.popoverContent.innerHTML = "";
         const i = (n = t, r = this.popover, n.map((e => {
             let t;
             if ("string" == typeof e && "<hr/>" === e) t = document.createElement("hr");
             else if ("string" == typeof e) t = _t.div({
                 class: "context-menu"
             }), t.innerHTML = e;
@@ -25096,44 +25226,44 @@
             } = _t.translateMouseCoordinates(e, t.parentNode), {
                 width: r
             } = t.getBoundingClientRect(), s = i + r, {
                 width: o
             } = t.parentNode.getBoundingClientRect();
             t.style.left = `${s>o?i-(s-o):i}px`, t.style.top = `${n}px`
         }(e, this.popover)
-    }, zu.prototype.dispose = function() {
+    }, Su.prototype.dispose = function() {
         this.popoverContent.innerHTML = "", this.popover.innerHTML = "", Object.keys(this).forEach((function(e) {
             this[e] = void 0
         }))
     };
-    const Hu = () => {
+    const Au = () => {
             const e = document.querySelectorAll(".igv-menu-popup");
             for (let t = 0; t < e.length; t++) e[t].style.display = "none"
         },
-        Vu = new Set(["ruler", "ideogram"]),
-        Uu = new Set(["ruler", "sequence", "ideogram"]);
-    class qu {
+        Eu = new Set(["ruler", "ideogram"]),
+        Mu = new Set(["ruler", "sequence", "ideogram"]);
+    class Tu {
         constructor(e, t, i) {
             this.browser = e, this.track = i, i.trackView = this, this.addDOMToColumnContainer(e, t, e.referenceFrameList)
         }
         startSpinner() {
             this.viewports && this.viewports.length > 0 && this.viewports[0].startSpinner()
         }
         stopSpinner() {
             this.viewports && this.viewports.length > 0 && this.viewports[0].stopSpinner()
         }
         addDOMToColumnContainer(e, t, i) {
             this.axis = this.createAxis(e, this.track), this.viewports = [];
             const n = e.calculateViewportWidth(i.length),
                 r = t.querySelectorAll(".igv-column");
             for (let e = 0; e < r.length; e++) {
-                const t = Nu(this, r[e], i[e], n);
+                const t = _u(this, r[e], i[e], n);
                 this.viewports.push(t)
             }
-            this.sampleNameViewport = new Ou(this, e.columnContainer.querySelector(".igv-sample-name-column"), void 0, e.sampleNameViewportWidth), this.createTrackScrollbar(e), this.createTrackDragHandle(e), this.createTrackGearPopup(e)
+            this.sampleNameViewport = new ku(this, e.columnContainer.querySelector(".igv-sample-name-column"), void 0, e.sampleNameViewportWidth), this.createTrackScrollbar(e), this.createTrackDragHandle(e), this.createTrackGearPopup(e)
         }
         createAxis(e, t) {
             const i = _t.div();
             if (e.columnContainer.querySelector(".igv-axis-column").appendChild(i), i.style.height = `${t.height}px`, "function" == typeof t.paintAxis) {
                 t.dataRange && i.addEventListener("click", (() => {
                     e.dataRangeDialog.configure(this), e.dataRangeDialog.present(ft(e.columnContainer))
                 }));
@@ -25187,19 +25317,19 @@
         dataRange() {
             return this.track.dataRange ? this.track.dataRange : void 0
         }
         setDataRange(e, t) {
             void 0 !== e && (this.track.dataRange.min = e), void 0 !== t && (this.track.dataRange.max = t), this.track.autoscale = !1, this.repaintViews()
         }
         presentColorPicker(e) {
-            if (!1 === Uu.has(this.track.type)) {
+            if (!1 === Mu.has(this.track.type)) {
                 const t = [],
                     i = this.track.color || this.track.defaultColor;
                 Qt(i) && t.push(i), this.track.altColor && Qt(this.track.altColor) && t.push(this.track.altColor);
-                const n = t.map((e => e.startsWith("#") ? e : e.startsWith("rgb(") ? js.rgbToHex(e) : js.colorNameToHex(e))),
+                const n = t.map((e => e.startsWith("#") ? e : e.startsWith("rgb(") ? Ds.rgbToHex(e) : Ds.colorNameToHex(e))),
                     r = {
                         color: e => {
                             this.track.color = e, this.repaintViews()
                         },
                         altColor: e => {
                             this.track.altColor = e, this.repaintViews()
                         }
@@ -25211,15 +25341,15 @@
             t || (this.track.minHeight && (e = Math.max(this.track.minHeight, e)), this.track.maxHeight && (e = Math.min(this.track.maxHeight, e))), this.track.height = e, this.resizeAxisCanvas(this.axis.clientWidth, this.track.height), "function" == typeof this.track.paintAxis && this.paintAxis();
             for (let {
                     $viewport: t
                 }
                 of this.viewports) t.height(e);
             if (this.sampleNameViewport.viewport.style.height = `${e}px`, "function" != typeof this.track.computePixelHeight)
                 for (let t of this.viewports) t.setContentHeight(e);
-            this.repaintViews(), !1 === Vu.has(this.track.type) && this.updateScrollbar(), this.dragHandle.style.height = `${e}px`, this.gearContainer.style.height = `${e}px`
+            this.repaintViews(), !1 === Eu.has(this.track.type) && this.updateScrollbar(), this.dragHandle.style.height = `${e}px`, this.gearContainer.style.height = `${e}px`
         }
         updateScrollbar() {
             const e = this.viewports[0].$viewport.height();
             this.outerScroll.style.height = `${e}px`;
             const t = this.maxViewportContentHeight(),
                 i = Math.round(e / t * e);
             t > e ? (this.innerScroll.style.display = "block", this.innerScroll.style.height = `${i}px`) : this.innerScroll.style.display = "none"
@@ -25278,19 +25408,19 @@
                     if (i.featureCache && i.featureCache.features)
                         if ("function" == typeof i.featureCache.features.getMax) {
                             const e = i.featureCache.features.getMax(n, r);
                             t.push({
                                 value: e
                             })
                         } else {
-                            const e = xo(i.featureCache.features, n, r);
+                            const e = mo(i.featureCache.features, n, r);
                             for (let i of e) t.push(i)
                         }
                 }
-                "function" == typeof this.track.doAutoscale ? this.track.dataRange = this.track.doAutoscale(t) : this.track.dataRange = Fo(t)
+                "function" == typeof this.track.doAutoscale ? this.track.dataRange = this.track.doAutoscale(t) : this.track.dataRange = To(t)
             }
             const n = this.track.autoscale || this.track.autoscaleGroup || "ruler" === this.track.type;
             for (let i of e) t.includes(i) ? i.repaint() : n && i.refresh();
             this.adjustTrackHeight(), this.repaintSamples(), this.updateRulerViewportLabels()
         }
         clearCachedFeatures() {
             for (let e of this.viewports) e.clearCache()
@@ -25314,50 +25444,50 @@
                 if ((!i.featureCache || !i.featureCache.containsRange(n, r, o, s)) && await i.loadFeatures(), i.featureCache && i.featureCache.features)
                     if ("function" == typeof i.featureCache.features.getMax) {
                         const t = i.featureCache.features.getMax(r, o);
                         e.push({
                             value: t
                         })
                     } else {
-                        const t = "function" == typeof i.featureCache.queryFeatures ? i.featureCache.queryFeatures(n, r, o) : xo(i.featureCache.features, r, o);
+                        const t = "function" == typeof i.featureCache.queryFeatures ? i.featureCache.queryFeatures(n, r, o) : mo(i.featureCache.features, r, o);
                         e = e.concat(t)
                     }
             }
             return e
         }
         checkContentHeight() {
             for (let e of this.viewports) e.checkContentHeight();
             this.adjustTrackHeight()
         }
         adjustTrackHeight() {
             var e = this.maxViewportContentHeight();
-            if (this.track.autoHeight ? this.setTrackHeight(e, !1) : this.track.paintAxis && this.paintAxis(), !1 === Vu.has(this.track.type)) {
+            if (this.track.autoHeight ? this.setTrackHeight(e, !1) : this.track.paintAxis && this.paintAxis(), !1 === Eu.has(this.track.type)) {
                 const t = this.viewports[0].getContentTop(),
                     i = this.viewports[0].$viewport.height(),
                     n = Math.min(0, i - e);
                 if (t < n)
                     for (let e of this.viewports) e.setTop(n);
                 this.updateScrollbar()
             }
         }
         createTrackScrollbar(e) {
             const t = _t.div();
-            if (e.columnContainer.querySelector(".igv-scrollbar-column").appendChild(t), t.style.height = `${this.track.height}px`, this.outerScroll = t, !1 === Vu.has(this.track.type)) {
+            if (e.columnContainer.querySelector(".igv-scrollbar-column").appendChild(t), t.style.height = `${this.track.height}px`, this.outerScroll = t, !1 === Eu.has(this.track.type)) {
                 const i = _t.div();
                 t.appendChild(i), this.innerScroll = i, this.addTrackScrollMouseHandlers(e)
             }
         }
         createTrackDragHandle(e) {
             const t = "ideogram" === this.track.type || "ruler" === this.track.type ? "igv-track-drag-shim" : "igv-track-drag-handle";
             this.dragHandle = _t.div({
                 class: t
             }), e.columnContainer.querySelector(".igv-track-drag-column").appendChild(this.dragHandle), this.dragHandle.style.height = `${this.track.height}px`, this.addTrackDragMouseHandlers(e)
         }
         createTrackGearPopup(e) {
-            this.gearContainer = _t.div(), e.columnContainer.querySelector(".igv-gear-menu-column").appendChild(this.gearContainer), this.gearContainer.style.height = `${this.track.height}px`, !0 === this.track.ignoreTrackMenu || (this.gear = _t.div(), this.gearContainer.appendChild(this.gear), this.gear.appendChild(At.createIcon("cog")), this.trackGearPopup = new zu(this.gear), this.addTrackGearMouseHandlers())
+            this.gearContainer = _t.div(), e.columnContainer.querySelector(".igv-gear-menu-column").appendChild(this.gearContainer), this.gearContainer.style.height = `${this.track.height}px`, !0 === this.track.ignoreTrackMenu || (this.gear = _t.div(), this.gearContainer.appendChild(this.gear), this.gear.appendChild(At.createIcon("cog")), this.trackGearPopup = new Su(this.gear), this.addTrackGearMouseHandlers())
         }
         addAxisEventListener(e) {
             this.boundAxisClickHander = function(e) {
                 this.browser.dataRangeDialog.configure(this), this.browser.dataRangeDialog.present(ft(this.browser.columnContainer))
             }.bind(this), e.addEventListener("click", this.boundAxisClickHander)
         }
         removeAxisEventListener(e) {
@@ -25377,15 +25507,15 @@
                     this.moveScroller(t - parseInt(ft(this.innerScroll).data("yDown"))), ft(this.innerScroll).data("yDown", t.toString())
                 }.bind(this), e.columnContainer.addEventListener("mousemove", this.boundColumnContainerMouseMoveHandler)
             }.bind(this), this.innerScroll.addEventListener("mousedown", this.boundTrackScrollMouseDownHandler), this.boundColumnContainerMouseUpHandler = function(t) {
                 e.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler)
             }.bind(this), e.columnContainer.addEventListener("mouseup", this.boundColumnContainerMouseUpHandler)
         }
         removeTrackScrollMouseHandlers() {
-            !1 === Vu.has(this.track.type) && (this.innerScroll.removeEventListener("mousedown", this.boundTrackScrollMouseDownHandler), this.browser.columnContainer.removeEventListener("mouseup", this.boundColumnContainerMouseUpHandler), this.browser.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler))
+            !1 === Eu.has(this.track.type) && (this.innerScroll.removeEventListener("mousedown", this.boundTrackScrollMouseDownHandler), this.browser.columnContainer.removeEventListener("mouseup", this.boundColumnContainerMouseUpHandler), this.browser.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler))
         }
         addTrackDragMouseHandlers(e) {
             if ("ideogram" === this.track.id || "ruler" === this.track.id);
             else {
                 let t;
 
                 function i(i) {
@@ -25441,26 +25571,37 @@
                 n.scale(i, i), this.track.paintAxis(n, e, t)
             }
         }
         maxViewportContentHeight() {
             return Math.max(this.viewports.map((e => e.getContentHeight())))
         }
     }
-    const ju = "rgb(150,150,150)";
-    class $u extends zl {
+    class Ru extends Rl {
+        static defaults = {
+            height: 50,
+            color: "rgb(150, 150, 150)",
+            altColor: "rgb(150, 150, 150)",
+            flipAxis: !1,
+            logScale: !1,
+            windowFunction: "mean",
+            graphType: "bar",
+            autoscale: !0,
+            normalize: void 0,
+            scaleFactor: void 0
+        };
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.type = "wig", this.height = e.height || 50, this.featureType = "numeric", this.paintAxis = Ed;
+            super.init(e), this.type = "wig", this.featureType = "numeric", this.paintAxis = cd;
             const t = e.format ? e.format.toLowerCase() : e.format;
-            this.flipAxis = !!e.flipAxis && e.flipAxis, this.logScale = !!e.logScale && e.logScale, e.featureSource ? (this.featureSource = e.featureSource, delete e.featureSource) : this.featureSource = "bigwig" === t ? new fc(e, this.browser.genome) : "tdf" === t ? new wc(e, this.browser.genome) : Sc(e, this.browser.genome), this.autoscale = e.autoscale || void 0 === e.max, this.autoscale || (this.dataRange = {
+            e.featureSource ? (this.featureSource = e.featureSource, delete e.featureSource) : this.featureSource = "bigwig" === t ? new Kh(e, this.browser.genome) : "tdf" === t ? new nc(e, this.browser.genome) : cc(e, this.browser.genome), void 0 === e.max || !0 === e.autoscale ? this.autoscale = !0 : this.dataRange = {
                 min: e.min || 0,
                 max: e.max
-            }), this.windowFunction = e.windowFunction || "mean", this.graphType = e.graphType || "bar", this.normalize = e.normalize, this.scaleFactor = e.scaleFactor
+            }
         }
         async postInit() {
             const e = await this.getHeader();
             this.disposed || e && this.setTrackProperties(e)
         }
         async getFeatures(e, t, i, n) {
             const r = await this.featureSource.getFeatures({
@@ -25508,70 +25649,69 @@
             const t = e.features,
                 i = e.context,
                 n = e.bpPerPixel,
                 r = e.bpStart,
                 s = e.pixelWidth;
             e.pixelHeight;
             const o = r + s * n + 1,
-                a = this.color || ju;
+                a = this.color || Ru.defaults.color;
             let l;
-            "string" == typeof a && a.startsWith("rgb(") && (l = js.addAlpha(a, .1));
+            "string" == typeof a && a.startsWith("rgb(") && (l = Ds.addAlpha(a, .1));
             const h = this.getScaleFactor(this.dataRange.min, this.dataRange.max, e.pixelHeight, this.logScale),
                 c = e => this.logScale ? this.computeYPixelValueInLogScale(e, h) : this.computeYPixelValue(e, h);
             if (t && t.length > 0 && (void 0 === this.dataRange.min && (this.dataRange.min = 0), this.dataRange.max > this.dataRange.min)) {
-                let s, a = -1,
-                    h = -1;
-                const d = c(0);
+                let s, a = -1;
+                const h = c(0);
                 for (let e of t) {
                     if (e.end < r) continue;
                     if (e.start > o) break;
                     const t = Math.floor((e.start - r) / n);
                     if (isNaN(t)) continue;
                     let l = c(e.value);
-                    const u = Math.ceil((e.end - r) / n),
-                        f = Math.max(1, u - t),
-                        p = this.getColorForFeature(e);
+                    const d = Math.ceil((e.end - r) / n),
+                        u = Math.max(1, d - t),
+                        f = this.getColorForFeature(e);
                     if ("points" === this.graphType) {
                         const e = this.config.pointSize || 3,
-                            n = t + f / 2;
-                        Mo.fillCircle(i, n, l, e / 2, {
-                            fillStyle: p,
-                            strokeStyle: p
+                            n = t + u / 2;
+                        ko.fillCircle(i, n, l, e / 2, {
+                            fillStyle: f,
+                            strokeStyle: f
                         })
-                    } else if ("line" === this.graphType) null != s && Mo.strokeLine(i, a, s, t, l, {
-                        fillStyle: p,
-                        strokeStyle: p
-                    }), Mo.strokeLine(i, t, l, t + f, l, {
-                        fillStyle: p,
-                        strokeStyle: p
+                    } else if ("line" === this.graphType) null != s && ko.strokeLine(i, a, s, t, l, {
+                        fillStyle: f,
+                        strokeStyle: f
+                    }), ko.strokeLine(i, t, l, t + u, l, {
+                        fillStyle: f,
+                        strokeStyle: f
                     });
                     else {
-                        let n = l - d;
-                        (t + f > a || e.value >= 0 && e.value > h || e.value < 0 && e.value < lastNegValue) && Mo.fillRect(i, t, d, f, n, {
-                            fillStyle: p
+                        const e = l - h;
+                        ko.fillRect(i, t, h, u, e, {
+                            fillStyle: f
                         })
                     }
-                    a = t + f, h = e.value, s = l
+                    a = t + u, s = l
                 }
                 if (this.dataRange.min < 0) {
                     const t = this.dataRange.max / (this.dataRange.max - this.dataRange.min) * e.pixelHeight;
-                    Mo.strokeLine(i, 0, t, e.pixelWidth, t, {
+                    ko.strokeLine(i, 0, t, e.pixelWidth, t, {
                         strokeStyle: l
                     })
                 }
             }
             if (this.config.hasOwnProperty("guideLines"))
                 for (let t of this.config.guideLines)
                     if (t.hasOwnProperty("color") && t.hasOwnProperty("y") && t.hasOwnProperty("dotted")) {
                         let i = c(t.y),
                             n = {
                                 strokeStyle: t.color,
                                 strokeWidth: 2
                             };
-                        t.dotted ? Mo.dashedLine(e.context, 0, i, e.pixelWidth, i, 5, n) : Mo.strokeLine(e.context, 0, i, e.pixelWidth, i, n)
+                        t.dotted ? ko.dashedLine(e.context, 0, i, e.pixelWidth, i, 5, n) : ko.strokeLine(e.context, 0, i, e.pixelWidth, i, n)
                     }
         }
         popupData(e, t) {
             if (void 0 === t && (t = this.clickedFeatures(e)), t && t.length > 0) {
                 const i = e.genomicLocation,
                     n = [];
                 t.sort((function(e, t) {
@@ -25596,78 +25736,74 @@
             }
             return []
         }
         get supportsWholeGenome() {
             return !this.config.indexURL && !1 !== this.config.supportsWholeGenome
         }
         getColorForFeature(e) {
-            let t = e.value < 0 && this.altColor ? this.altColor : this.color || ju;
+            let t = e.value < 0 && this.altColor ? this.altColor : this.color || Ru.defaults.color;
             return "function" == typeof t ? t(e.value) : t
         }
         dispose() {
             this.trackView = void 0
         }
-        getState() {
-            const e = super.getState();
-            return void 0 !== this.flipAxis && (e.flipAxis = this.flipAxis), void 0 !== this.logScale && (e.logScale = this.logScale), e
-        }
     }
 
-    function Wu(e) {
+    function Lu(e) {
         this.thresholds = e.thresholds, this.colors = e.colors
     }
 
-    function Gu(e) {
+    function Iu(e) {
         this.scale = e, this.lowColor = "rgb(" + e.lowR + "," + e.lowG + "," + e.lowB + ")", this.highColor = "rgb(" + e.highR + "," + e.highG + "," + e.highB + ")", this.diff = e.high - e.low
     }
-    Wu.prototype.getColor = function(e) {
+    Lu.prototype.getColor = function(e) {
         for (let t of this.thresholds)
             if (e < t) return this.colors[this.thresholds.indexOf(t)];
         return this.colors[this.colors.length - 1]
-    }, Gu.prototype.getColor = function(e) {
+    }, Iu.prototype.getColor = function(e) {
         var t, i = this.scale;
         return e <= i.low ? this.lowColor : e >= i.high ? this.highColor : (t = (e - i.low) / this.diff, "rgb(" + Math.floor(i.lowR + t * (i.highR - i.lowR)) + "," + Math.floor(i.lowG + t * (i.highG - i.lowG)) + "," + Math.floor(i.lowB + t * (i.highB - i.lowB)) + ")")
     };
-    class Zu {
+    class Bu {
         constructor(e) {
             this.color = e
         }
         getColor() {
             return this.color
         }
     }
-    class Qu extends zl {
+    class Fu extends Rl {
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            if (super.init(e), this.type = e.type || "seg", "maf" === this.type && (this.type = "mut"), this.isLog = e.isLog, this.displayMode = e.displayMode || "EXPANDED", this.height = e.height || 300, this.maxHeight = e.maxHeight || 500, this.squishedRowHeight = e.sampleSquishHeight || e.squishedRowHeight || 2, this.expandedRowHeight = e.sampleExpandHeight || e.expandedRowHeight || 13, this.sampleHeight = this.squishedRowHeight, e.color ? this.color = e.color : (this.posColorScale = e.posColorScale || new Gu({
+            if (super.init(e), this.type = e.type || "seg", "maf" === this.type && (this.type = "mut"), this.isLog = e.isLog, this.displayMode = e.displayMode || "EXPANDED", this.height = e.height || 300, this.maxHeight = e.maxHeight || 500, this.squishedRowHeight = e.sampleSquishHeight || e.squishedRowHeight || 2, this.expandedRowHeight = e.sampleExpandHeight || e.expandedRowHeight || 13, this.sampleHeight = this.squishedRowHeight, e.color ? this.color = e.color : (this.posColorScale = e.posColorScale || new Iu({
                     low: .1,
                     lowR: 255,
                     lowG: 255,
                     lowB: 255,
                     high: 1.5,
                     highR: 255,
                     highG: 0,
                     highB: 0
-                }), this.negColorScale = e.negColorScale || new Gu({
+                }), this.negColorScale = e.negColorScale || new Iu({
                     low: -1.5,
                     lowR: 0,
                     lowG: 0,
                     lowB: 255,
                     high: -.1,
                     highR: 255,
                     highG: 255,
                     highB: 255
-                }), "mut" === this.type && (this.colorTable = new Ao(e.colorTable || Xu))), this.sampleKeys = [], this.sampleNames = new Map, e.samples) {
+                }), "mut" === this.type && (this.colorTable = new yo(e.colorTable || Nu))), this.sampleKeys = [], this.sampleNames = new Map, e.samples) {
                 for (let t of e.samples) this.sampleKeys.push(t), this.sampleNames.set(t, t);
                 this.explicitSamples = !0
             }
             const t = Object.assign({}, this.config);
-            t.maxWGCount = t.maxWGCount || Number.MAX_SAFE_INTEGER, this.featureSource = Sc(t, this.browser.genome), this.initialSort = e.sort
+            t.maxWGCount = t.maxWGCount || Number.MAX_SAFE_INTEGER, this.featureSource = cc(t, this.browser.genome), this.initialSort = e.sort
         }
         async postInit() {
             "function" == typeof this.featureSource.getHeader && (this.header = await this.featureSource.getHeader(), this.disposed) || this.header && this.setTrackProperties(this.header)
         }
         menuItemList() {
             const e = [],
                 t = {
@@ -25716,15 +25852,15 @@
             pixelTop: i,
             pixelWidth: n,
             pixelHeight: r,
             features: s,
             bpPerPixel: o,
             bpStart: a
         }) {
-            if (Mo.fillRect(e, 0, i, n, r, {
+            if (ko.fillRect(e, 0, i, n, r, {
                     fillStyle: "rgb(255, 255, 255)"
                 }), s && s.length > 0) {
                 this.checkForLog(s), this.updateSampleKeys(s);
                 const t = {};
                 let l;
                 switch (this.sampleKeys.forEach((function(e, i) {
                         t[e] = i
@@ -25756,15 +25892,15 @@
                     let f = Math.round((o - a) / u);
                     const p = Math.min(n.end, d),
                         g = Math.round((p - a) / u);
                     let m, b, w = Math.max(1, g - f);
                     if (this.color ? m = "function" == typeof this.color ? this.color(n) : this.color : this.colorTable && (m = this.colorTable.getColor(n.value.toLowerCase())), "mut" === this.type) b = h - 2 * l, w < 3 && (w = 3, f -= 1);
                     else {
                         let e = n.value;
-                        this.isLog || (e = Vs.log2(e / 2)), m = e < -.1 ? this.negColorScale.getColor(e) : e > .1 ? this.posColorScale.getColor(e) : "white";
+                        this.isLog || (e = Ns.log2(e / 2)), m = e < -.1 ? this.negColorScale.getColor(e) : e > .1 ? this.posColorScale.getColor(e) : "white";
                         let t = h;
                         if (h < .25) {
                             const i = .1 + 2 * Math.abs(e);
                             t = Math.min(1, i * h)
                         }
                         b = t - 2 * l
                     }
@@ -25882,15 +26018,15 @@
             if (!this.explicitSamples)
                 for (let t of e) {
                     const e = t.sampleKey || t.sample;
                     this.sampleNames.has(e) || (this.sampleNames.set(e, t.sample), this.sampleKeys.push(e))
                 }
         }
     }
-    const Xu = {
+    const Nu = {
         indel: "rgb(0,200,0)",
         "targeted region": "rgb(236,155,43)",
         truncating: "rgb(\t150,0,0)",
         "non-coding transcript": "rgb(0,0,150)",
         synonymous: "rgb(109,165,95)",
         silent: "rgb(109,135,80)",
         missense_mutation: "rgb(72,130,187)",
@@ -25901,17 +26037,17 @@
         nonsense_mutation: "rgb(216, 57,81)",
         frame_shift_del: "rgb(226,135,65)",
         frame_shift_ins: "rgb(226,135,65)",
         in_frame_del: "rgb(247,235,94)",
         in_frame_ins: "rgb(247,235,94)",
         "*other*": "rgb(159,91,50)"
     };
-    class Yu extends zl {
+    class Ou extends Rl {
         constructor(e, t) {
-            super(e, t), this.type = "merged", this.featureType = "numeric", this.paintAxis = Ed, this.graphType = e.graphType
+            super(e, t), this.type = "merged", this.featureType = "numeric", this.paintAxis = cd, this.graphType = e.graphType
         }
         init(e) {
             if (!e.tracks) throw Error("Error: no tracks defined for merged track" + e);
             super.init(e)
         }
         async postInit() {
             this.tracks = [];
@@ -25943,15 +26079,15 @@
                     this.flipAxis = !this.flipAxis, this.trackView.repaintViews()
                 }
             }), e = e.concat($t.numericDataMenuItems(this.trackView)), e
         }
         async getFeatures(e, t, i, n) {
             const r = this.tracks.map((r => r.getFeatures(e, t, i, n))),
                 s = await Promise.all(r);
-            return new Ku(s)
+            return new Pu(s)
         }
         draw(e) {
             const t = e.features;
             for (let i = 0, n = this.tracks.length; i < n; i++) {
                 const n = Object.assign({}, e);
                 n.features = t.featureArrays[i], this.tracks[i].dataRange = this.dataRange, this.tracks[i].flipAxis = this.flipAxis, this.tracks[i].logScale = this.logScale, this.graphType && (this.tracks[i].graphType = this.graphType), this.tracks[i].draw(n)
             }
@@ -25973,61 +26109,71 @@
         clickedFeatures(e) {
             const t = e.viewport.cachedFeatures;
             if (!t) return [];
             const i = e.genomicLocation,
                 n = [];
             for (let r of t.featureArrays) {
                 const t = e.referenceFrame.bpPerPixel > .2 ? 3 * e.referenceFrame.bpPerPixel : .2,
-                    s = xo(r, i - t, i + t);
+                    s = mo(r, i - t, i + t);
                 for (let e of s) n.push(e)
             }
             return n
         }
         get supportsWholeGenome() {
             return this.tracks.every((e => e.supportsWholeGenome))
         }
     }
-    class Ku {
+    class Pu {
         constructor(e) {
             this.featureArrays = e
         }
         getMax(e, t) {
             let i = -Number.MAX_VALUE;
             for (let n of this.featureArrays)
                 for (let r of n)
                     if (void 0 !== r.value && !Number.isNaN(r.value)) {
                         if (r.end < e) continue;
                         if (r.start > t) break;
                         i = Math.max(i, r.value)
                     } return i
         }
     }
-    class Ju extends zl {
+    class Du extends Rl {
+        static defaults = {
+            height: 250,
+            theta: Math.PI / 4,
+            arcOrientation: !0,
+            showBlocks: !0,
+            blockHeight: 3,
+            thickness: 1,
+            alpha: .02,
+            logScale: !0
+        };
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.theta = e.theta || Math.PI / 4, this.sinTheta = Math.sin(this.theta), this.cosTheta = Math.cos(this.theta), this.height = e.height || 250, this.arcType = function(e) {
+            super.init(e), this.sinTheta = Math.sin(this.theta), this.cosTheta = Math.cos(this.theta), this.arcType = function(e) {
                 if (!e.arcType) return "nested";
                 switch (e.arcType) {
                     case "chiapet":
                         return "inView";
                     case "chiapetoutbound":
                         return "partialInView";
                     default:
                         return e.arcType
                 }
-            }(e), this.arcOrientation = void 0 === e.arcOrientation || e.arcOrientation, this.showBlocks = void 0 === e.showBlocks || e.showBlocks, this.blockHeight = e.blockHeight || 3, this.thickness = e.thickness || 1, this.color = e.color, this.alpha = e.alpha || .02, this.painter = {
+            }(e), this.alpha = e.alpha || .02, this.painter = {
                 flipAxis: !this.arcOrientation,
                 dataRange: this.dataRange,
-                paintAxis: Ed
-            }, e.valueColumn ? (this.valueColumn = e.valueColumn, this.hasValue = !0) : e.useScore && (this.hasValue = !0, this.valueColumn = "score"), this.logScale = !1 !== e.logScale, e.max ? (this.dataRange = {
+                paintAxis: cd
+            }, e.valueColumn ? (this.valueColumn = e.valueColumn, this.hasValue = !0) : e.useScore && (this.hasValue = !0, this.valueColumn = "score"), e.max ? (this.dataRange = {
                 min: e.min || 0,
                 max: e.max
-            }, this.autoscale = !1) : this.autoscale = !0, e.featureSource ? (this.featureSource = e.featureSource, delete e._featureSource) : (this.featureSource = Sc(e, this.browser.genome), this.featureSource.getWGFeatures = sf)
+            }, this.autoscale = !1) : this.autoscale = !0, e.featureSource ? (this.featureSource = e.featureSource, delete e._featureSource) : (this.featureSource = cc(e, this.browser.genome), this.featureSource.getWGFeatures = qu)
         }
         async postInit() {
             if ("function" != typeof this.featureSource.getHeader || (this.header = await this.featureSource.getHeader(), !this.disposed)) return this.header && this.setTrackProperties(this.header), void 0 === this.visibilityWindow && "function" == typeof this.featureSource.defaultVisibilityWindow && (this.visibilityWindow = await this.featureSource.defaultVisibilityWindow(), this.featureSource.visibilityWindow = this.visibilityWindow), this
         }
         get supportsWholeGenome() {
             return !0
         }
@@ -26048,15 +26194,15 @@
             const t = e.context,
                 i = e.pixelWidth,
                 n = e.pixelHeight,
                 r = e.viewportWidth,
                 s = e.bpPerPixel,
                 o = e.bpStart,
                 a = s;
-            Mo.fillRect(t, 0, e.pixelTop, i, n, {
+            ko.fillRect(t, 0, e.pixelTop, i, n, {
                 fillStyle: "rgb(255, 255, 255)"
             });
             const l = e.features;
             if (l) {
                 (function() {
                     let e = 0;
                     for (let t of l) {
@@ -26081,19 +26227,19 @@
                     }
                 }).call(this);
                 const s = this.arcOrientation ? e.pixelHeight : 0,
                     c = this.arcOrientation;
                 t.font = "8px sans-serif", t.textAlign = "center";
                 for (let e of l) {
                     let n;
-                    if (e.drawState = void 0, "function" == typeof this.color ? n = this.color(e) : (n = this.color || e.color || "rgb(180,25,137)", n && this.config.useScore && (n = rf(n, (h = e.score, Math.min(1, .11 + h / 779 * .89).toString())))), t.lineWidth = e.thickness || this.thickness || 1, e.chr1 === e.chr2 || "all" === e.chr) {
+                    if (e.drawState = void 0, "function" == typeof this.color ? n = this.color(e) : (n = this.color || e.color || "rgb(180,25,137)", n && this.config.useScore && (n = Uu(n, (h = e.score, Math.min(1, .11 + h / 779 * .89).toString())))), t.lineWidth = e.thickness || this.thickness || 1, e.chr1 === e.chr2 || "all" === e.chr) {
                         const {
                             m1: l,
                             m2: h
-                        } = ef(e, this.browser.genome);
+                        } = zu(e, this.browser.genome);
                         let d = Math.round((l - o) / a),
                             u = Math.round((h - o) / a);
                         if (u < 0 || d > i) continue;
                         let f = u - d;
                         f < 3 && (f = 3, d--);
                         const p = f / 2,
                             g = p / this.sinTheta,
@@ -26104,27 +26250,27 @@
                             const i = (e.start1 - o) / a,
                                 n = (e.end1 - o) / a,
                                 r = (e.start2 - o) / a,
                                 l = (e.end2 - o) / a,
                                 h = this.arcOrientation ? -this.blockHeight : this.blockHeight;
                             t.fillRect(i, s, n - i, h), t.fillRect(r, s, l - r, h)
                         }
-                        n && !this.config.useScore && f > r && (n = rf(n, this.alpha)), t.strokeStyle = n, t.fillStyle = n, t.beginPath(), t.arc(b, w, g, v, y, !1), t.stroke(), e.drawState = {
+                        n && !this.config.useScore && f > r && (n = Uu(n, this.alpha)), t.strokeStyle = n, t.fillStyle = n, t.beginPath(), t.arc(b, w, g, v, y, !1), t.stroke(), e.drawState = {
                             xc: b,
                             yc: w,
                             r: g
                         }
                     } else {
                         let r = Math.round((e.start - o) / a),
                             s = Math.round((e.end - o) / a);
                         if (s < 0 || r > i) continue;
                         let l = s - r;
                         l < 3 && (l = 3, r--);
                         const h = e.chr === e.chr1 ? e.chr2 : e.chr1;
-                        t.strokeStyle = n, t.fillStyle = rf(Tu(h), .5), c ? (t.fillRect(r, this.height / 2, l, this.height / 2), t.fillText(h, r + l / 2, this.height / 2 - 5), e.drawState = {
+                        t.strokeStyle = n, t.fillStyle = Uu(gu(h), .5), c ? (t.fillRect(r, this.height / 2, l, this.height / 2), t.fillText(h, r + l / 2, this.height / 2 - 5), e.drawState = {
                             x: r,
                             y: this.height / 2,
                             w: l,
                             h: this.height / 2
                         }) : (t.fillRect(r, 0, l, this.height / 2), t.fillText(h, r + l / 2, this.height / 2 + 13), e.drawState = {
                             x: r,
                             y: 0,
@@ -26144,15 +26290,15 @@
                 i = e.pixelWidth,
                 n = e.pixelHeight,
                 r = e.bpPerPixel,
                 s = e.bpStart,
                 o = r,
                 a = e.referenceFrame.start,
                 l = e.referenceFrame.end;
-            Mo.fillRect(t, 0, e.pixelTop, i, n, {
+            ko.fillRect(t, 0, e.pixelTop, i, n, {
                 fillStyle: "rgb(255, 255, 255)"
             });
             const h = e.features;
             if (h && h.length > 0) {
                 const n = 0,
                     r = this.getScaleFactor(n, this.dataRange.max, e.pixelHeight - 1, this.logScale),
                     c = this.arcOrientation ? e.pixelHeight : 0;
@@ -26161,15 +26307,15 @@
                     const n = this.valueColumn ? e[this.valueColumn] : e.score;
                     if (void 0 === n || Number.isNaN(n)) continue;
                     const h = Math.round((this.logScale ? Math.log10(n + 1) : n) * r);
                     if (e.chr1 === e.chr2 || "all" === e.chr) {
                         const {
                             m1: i,
                             m2: r
-                        } = ef(e, this.browser.genome);
+                        } = zu(e, this.browser.genome);
                         let d = Math.round((i - s) / o),
                             u = Math.round((r - s) / o) - d;
                         if (u < 3 && (u = 3, d--), n < this.dataRange.min || n > this.dataRange.max) continue;
                         if ("proportional" !== this.arcType) {
                             const e = "partialInView" === this.arcType,
                                 t = i >= a && r <= l;
                             let n = !1,
@@ -26182,15 +26328,15 @@
                             xc: p,
                             yc: c,
                             radiusX: f,
                             radiusY: h
                         };
                         const g = !!this.arcOrientation,
                             m = e.color || this.color;
-                        if (t.strokeStyle = m, t.lineWidth = e.thickness || this.thickness || 1, !0 === t.isSVG ? t.strokeEllipse(p, c, f, h, 0, 0, Math.PI, g) : (t.beginPath(), t.ellipse(p, c, f, h, 0, 0, Math.PI, g), t.stroke()), this.alpha && (t.fillStyle = rf(m, this.alpha), !0 === t.isSVG ? t.fillEllipse(p, c, f, h, 0, 0, Math.PI, g) : t.fill()), this.showBlocks && "all" !== e.chr) {
+                        if (t.strokeStyle = m, t.lineWidth = e.thickness || this.thickness || 1, !0 === t.isSVG ? t.strokeEllipse(p, c, f, h, 0, 0, Math.PI, g) : (t.beginPath(), t.ellipse(p, c, f, h, 0, 0, Math.PI, g), t.stroke()), this.alpha && (t.fillStyle = Uu(m, this.alpha), !0 === t.isSVG ? t.fillEllipse(p, c, f, h, 0, 0, Math.PI, g) : t.fill()), this.showBlocks && "all" !== e.chr) {
                             t.fillStyle = m;
                             const i = (e.start1 - s) / o,
                                 n = (e.end1 - s) / o,
                                 r = (e.start2 - s) / o,
                                 a = (e.end2 - s) / o,
                                 l = this.arcOrientation ? -this.blockHeight : this.blockHeight;
                             t.fillRect(i, c, n - i, l), t.fillRect(r, c, a - r, l)
@@ -26199,15 +26345,15 @@
                         let r = Math.round((e.start - s) / o),
                             a = Math.round((e.end - s) / o);
                         if (a < 0 || r > i || n < this.dataRange.min || n > this.dataRange.max) continue;
                         const l = Math.min(h, this.height - 13);
                         let c = a - r;
                         c < 3 && (c = 3, r--);
                         const d = e.chr === e.chr1 ? e.chr2 : e.chr1;
-                        if (t.font = "8px sans-serif", t.textAlign = "center", t.fillStyle = rf(Tu(d), .5), this.arcOrientation) {
+                        if (t.font = "8px sans-serif", t.textAlign = "center", t.fillStyle = Uu(gu(d), .5), this.arcOrientation) {
                             const i = this.height - l;
                             t.fillRect(r, i, c, l), t.fillText(d, r + c / 2, i - 5), e.drawState = {
                                 x: r,
                                 y: i,
                                 w: c,
                                 h: l
                             }
@@ -26218,15 +26364,15 @@
                             h: l
                         }
                     }
                 }
             }
         }
         clearAxis(e, t, i) {
-            Mo.fillRect(e, 0, 0, t, i, {
+            ko.fillRect(e, 0, 0, t, i, {
                 fillStyle: "rgb(255, 255, 255)"
             })
         }
         paintAxis(e, t, i) {
             const n = {
                 min: 0,
                 max: this.dataRange.max
@@ -26280,23 +26426,23 @@
                     }
                 }), i.push("<hr/>"), i
             }
         }
         addChordsForViewport(e) {
             const t = ("all" === e.chr ? this.featureSource.getAllFeatures() : this.featureSource.featureCache.queryFeatures(e.chr, e.start, e.end)).filter((e => e.drawState));
             if (0 === t.length) return;
-            ru(t.map((e => {
+            Vd(t.map((e => {
                 const t = e._f || e;
                 return {
                     uniqueId: `${t.chr1}:${t.start1}-${t.end1}_${t.chr2}:${t.start2}-${t.end2}`,
-                    refName: iu(t.chr1),
+                    refName: zd(t.chr1),
                     start: t.start1,
                     end: t.end1,
                     mate: {
-                        refName: iu(t.chr2),
+                        refName: zd(t.chr2),
                         start: t.start2,
                         end: t.end2
                     }
                 }
             })), this, e, .5)
         }
         doAutoscale(e) {
@@ -26314,31 +26460,31 @@
         popupData(e, t) {
             void 0 === t && (t = this.clickedFeatures(e));
             const i = [];
             for (let e of t) {
                 const t = e._ || e;
                 if (i.push({
                         name: "Region 1",
-                        value: tf(t.chr1, t.start1, t.end1, t.strand1)
+                        value: Hu(t.chr1, t.start1, t.end1, t.strand1)
                     }), i.push({
                         name: "Region 2",
-                        value: tf(t.chr2, t.start2, t.end2, t.strand2)
+                        value: Hu(t.chr2, t.start2, t.end2, t.strand2)
                     }), t.name && i.push({
                         name: "Name",
                         value: t.name
                     }), void 0 !== t.value && i.push({
                         name: "Value",
                         value: t.value
                     }), void 0 !== t.score && i.push({
                         name: "Score",
                         value: t.score
                     }), t.extras && this.header && this.header.columnNames) {
                     const e = this.header.columnNames,
                         n = this.header.hiccups ? 6 : 10;
-                    for (let r = n; r < e.length; r++) this.header.colorColumn !== r && ("info" === e[r] ? of(i, t.extras[r - n]) : i.push({
+                    for (let r = n; r < e.length; r++) this.header.colorColumn !== r && ("info" === e[r] ? ju(i, t.extras[r - n]) : i.push({
                         name: e[r],
                         value: t.extras[r - n]
                     }))
                 }
                 break
             }
             return i
@@ -26388,45 +26534,41 @@
                         });
                         break
                     }
                 }
             }
             return i.length > 1 && i.sort(((e, t) => e.score - t.score)), i.map((e => e.feature))
         }
-        getState() {
-            const e = super.getState();
-            return void 0 !== this.arcType && (e.arcType = this.arcType), void 0 !== this.arcOrientation && (e.arcOrientation = this.arcOrientation), void 0 !== this.showBlocks && (e.showBlocks = this.showBlocks), void 0 !== this.blockHeight && (e.blockHeight = this.blockHeight), void 0 !== this.thickness && (e.thickness = this.thickness), void 0 !== this.alpha && (e.alpha = this.alpha), e
-        }
     }
 
-    function ef(e, t) {
+    function zu(e, t) {
         let i = (e.start1 + e.end1) / 2,
             n = (e.start2 + e.end2) / 2;
         if ("all" === e.chr && (i = t.getGenomeCoordinate(e.chr1, i), n = t.getGenomeCoordinate(e.chr2, n)), i > n) {
             const e = i;
             i = n, n = e
         }
         return {
             m1: i,
             m2: n
         }
     }
 
-    function tf(e, t, i, n) {
+    function Hu(e, t, i, n) {
         return n && "." !== n ? `${e}:${Xt(t+1)}-${Xt(i)} (${n})` : `${e}:${Xt(t+1)}-${Xt(i)}`
     }
-    const nf = new Map;
+    const Vu = new Map;
 
-    function rf(e, t) {
+    function Uu(e, t) {
         const i = `${e}_${t}`;
-        let n = nf.get(i);
-        return n || (n = js.addAlpha(e, t), nf.set(i, n)), n
+        let n = Vu.get(i);
+        return n || (n = Ds.addAlpha(e, t), Vu.set(i, n)), n
     }
 
-    function sf(e) {
+    function qu(e) {
         const t = e => {
                 const t = Object.assign({}, e);
                 return t.chr = "all", t.start = i.getGenomeCoordinate(e.chr1, e.start1), t.end = i.getGenomeCoordinate(e.chr2, e.end2), t
             },
             i = this.genome;
         let n, r = 0;
         for (let t of i.wgChromosomeNames) {
@@ -26466,43 +26608,67 @@
             n && h.push(t(n)), h.sort((function(e, t) {
                 return e.start - t.start
             })), console.log(h.length)
         }
         return h
     }
 
-    function of(e, t) {
+    function ju(e, t) {
         const i = t.split(";");
         for (let t of i) {
             const i = t.split("=");
             2 === i.length && e.push({
                 name: i[0],
                 value: i[1]
             })
         }
     }
-    const af = Qt,
-        lf = new Map([
+    const $u = Qt,
+        Wu = new Map([
             ["REF", "referenceBases"],
             ["ALT", "alternateBases"],
             ["QUAL", "quality"],
             ["FILTER", "filter"]
         ]);
-    class hf extends zl {
+    class Gu extends Rl {
+        static defaults = {
+            displayMode: "EXPANDED",
+            sortDirection: "ASC",
+            showGenotypes: !0,
+            squishedVariantHeight: 2,
+            squishedCallHeight: 1,
+            expandedCallHeight: 10,
+            expandedVGap: 2,
+            squishedVGap: 1,
+            expandedGroupGap: 10,
+            squishedGroupGap: 5,
+            featureHeight: 14,
+            noGenotypeColor: "rgb(200,180,180)",
+            noCallColor: "rgb(225, 225, 225)",
+            nonRefColor: "rgb(200, 200, 215)",
+            mixedColor: "rgb(200, 220, 200)",
+            homrefColor: "rgb(200, 200, 200)",
+            homvarColor: "rgb(17,248,254)",
+            hetvarColor: "rgb(34,12,253)",
+            colorBy: void 0,
+            visibilityWindow: void 0,
+            labelDisplayMode: void 0,
+            type: "variant"
+        };
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.visibilityWindow = e.visibilityWindow, this.displayMode = e.displayMode || "EXPANDED", this.labelDisplayMode = e.labelDisplayMode, this.expandedVariantHeight = e.expandedVariantHeight || e.variantHeight || 10, this.squishedVariantHeight = e.squishedVariantHeight || 2, this.squishedCallHeight = e.squishedCallHeight || 1, this.expandedCallHeight = e.expandedCallHeight || 10, this.expandedVGap = void 0 !== e.expandedVGap ? e.expandedVGap : 2, this.squishedVGap = void 0 !== e.squishedVGap ? e.squishedVGap : 1, this.expandedGroupGap = e.expandedGroupGap || 10, this.squishedGroupGap = e.squishedGroupGap || 5, this.featureHeight = e.featureHeight || 14, this.visibilityWindow = e.visibilityWindow, this.featureSource = Sc(e, this.browser.genome), this.noGenotypeColor = e.noGenotypeColor || "rgb(200,180,180)", this.noCallColor = e.noCallColor || "rgb(225, 225, 225)", this.nonRefColor = e.nonRefColor || "rgb(200, 200, 215)", this.mixedColor = e.mixedColor || "rgb(200, 220, 200)", this.homrefColor = e.homrefColor || "rgb(200, 200, 200)", this.homvarColor = e.homvarColor || "rgb(17,248,254)", this.hetvarColor = e.hetvarColor || "rgb(34,12,253)", this.sortDirection = "ASC", this.type = e.type || "variant", this.colorBy = e.colorBy, this._initColorBy = e.colorBy, e.colorTable && (this.colorTables = new Map, this.colorTables.set(e.colorBy, new Ao(e.colorTable))), this._strokecolor = e.strokecolor, this._context_hook = e.context_hook, this.showGenotypes = void 0 === e.showGenotypes || e.showGenotypes, this.variantRowCount(1)
+            super.init(e), this.expandedVariantHeight = e.expandedVariantHeight || e.variantHeight || 10, this.featureSource = cc(e, this.browser.genome), this._initColorBy = e.colorBy, e.colorTable && (this.colorTables = new Map, this.colorTables.set(e.colorBy, new yo(e.colorTable))), this._strokecolor = e.strokecolor, this._context_hook = e.context_hook, this.variantRowCount(1)
         }
         async postInit() {
             if (this.header = await this.getHeader(), !this.disposed) {
                 if (void 0 === this.visibilityWindow && !1 !== this.config.indexed) {
                     const e = ti(this.config.url) ? this.config.url.name : this.config.url;
-                    af(e) && e.toLowerCase().includes("gnomad") ? this.visibilityWindow = 1e3 : "function" == typeof this.featureSource.defaultVisibilityWindow ? this.visibilityWindow = await this.featureSource.defaultVisibilityWindow() : this.visibilityWindow = 1e6
+                    $u(e) && e.toLowerCase().includes("gnomad") ? this.visibilityWindow = 1e3 : "function" == typeof this.featureSource.defaultVisibilityWindow ? this.visibilityWindow = await this.featureSource.defaultVisibilityWindow() : this.visibilityWindow = 1e6
                 }
                 return this
             }
         }
         get supportsWholeGenome() {
             return !1 === this.config.indexed || !0 === this.config.supportsWholeGenome
         }
@@ -26560,25 +26726,25 @@
             pixelWidth: t,
             pixelHeight: i,
             bpPerPixel: n,
             bpStart: r,
             pixelTop: s,
             features: o
         }) {
-            Mo.fillRect(e, 0, s, t, i, {
+            ko.fillRect(e, 0, s, t, i, {
                 fillStyle: "rgb(255, 255, 255)"
             });
             const a = "SQUISHED" === this.displayMode ? this.squishedVGap : this.expandedVGap,
                 l = "COLLAPSED" === this.displayMode ? 1 : this.nVariantRows,
                 h = "SQUISHED" === this.displayMode ? this.squishedVariantHeight : this.expandedVariantHeight;
             this.variantBandHeight = 10 + l * (h + a);
             let c = this.callSets;
             !c && this._f && (c = this._f.callSets);
             const d = this.getCallsetsLength();
-            if (c && d > 0 && !1 !== this.showGenotypes && Mo.strokeLine(e, 0, this.variantBandHeight, t, this.variantBandHeight, {
+            if (c && d > 0 && !1 !== this.showGenotypes && ko.strokeLine(e, 0, this.variantBandHeight, t, this.variantBandHeight, {
                     strokeStyle: "rgb(224,224,224) "
                 }), o) {
                 const i = "SQUISHED" === this.displayMode ? this.squishedCallHeight : this.expandedCallHeight,
                     s = "SQUISHED" === this.displayMode ? this.squishedVGap : this.expandedVGap,
                     a = r + t * n + 1;
                 for (let t of o) {
                     if (t.end < r) continue;
@@ -26633,19 +26799,19 @@
         getColorForFeature(e) {
             const t = e._f || e;
             let i;
             if (this.colorBy) {
                 const e = this.colorBy;
                 let n;
                 if (t.info.hasOwnProperty(e)) n = t.info[e];
-                else if (lf.has(e)) {
-                    n = t[lf.get(e)]
+                else if (Wu.has(e)) {
+                    n = t[Wu.get(e)]
                 }
                 i = this.getVariantColorTable(e).getColor(n), i || (i = "gray")
-            } else i = this._color ? "function" == typeof this._color ? this._color(e) : this._color : "NONVARIANT" === t.type ? this.nonRefColor : "MIXED" === t.type ? this.mixedColor : this.defaultColor;
+            } else i = this._color ? "function" == typeof this._color ? this._color(e) : this._color : "NONVARIANT" === t.type ? this.nonRefColor : "MIXED" === t.type ? this.mixedColor : this.color;
             return i
         }
         getVariantStrokecolor(e) {
             const t = e._f || e;
             let i;
             return i = this._strokecolor ? "function" == typeof this._strokecolor ? this._strokecolor(t) : this._strokecolor : void 0, i
         }
@@ -26808,31 +26974,36 @@
                     click: () => {
                         this.sendChordsForViewport(t)
                     }
                 }), i.push("<hr/>"), i
             }
         }
         sendChordsForViewport(e) {
-            const t = e.referenceFrame,
-                i = "all" === t.chr ? this.featureSource.getAllFeatures() : this.featureSource.featureCache.queryFeatures(t.chr, t.start, t.end);
-            ru(i.filter((e => {
+            const t = e.referenceFrame;
+            let i;
+            if ("all" === t.chr) {
+                const e = this.featureSource.getAllFeatures(),
+                    t = Object.keys(e).map((t => e[t]));
+                i = [].concat(...t)
+            } else i = this.featureSource.featureCache.queryFeatures(t.chr, t.start, t.end);
+            Vd(i.filter((e => {
                 const t = e._f || e;
                 return t.info && t.info.CHR2 && t.info.END && (t.info.CHR2 !== t.chr || Math.abs(Number.parseInt(t.info.END) - t.pos) > 1e6)
             })).map((e => {
                 const t = e._f || e,
                     i = Number.parseInt(t.info.END),
                     n = i - 100,
                     r = i + 100;
                 return {
                     uniqueId: `${t.chr}:${t.start}-${t.end}_${t.info.CHR2}:${t.info.END}`,
-                    refName: iu(t.chr),
+                    refName: zd(t.chr),
                     start: t.start,
                     end: t.end,
                     mate: {
-                        refName: iu(t.info.CHR2),
+                        refName: zd(t.info.CHR2),
                         start: n,
                         end: r
                     }
                 }
             })), this, t, .5)
         }
         colorByCB(e, t) {
@@ -26848,62 +27019,62 @@
         getState() {
             const e = super.getState();
             return this._color && "function" != typeof this._color && (e.color = this._color), e
         }
         getVariantColorTable(e) {
             if (this.colorTables || (this.colorTables = new Map), !this.colorTables.has(e)) {
                 let t;
-                if ("SVTYPE" === e) t = cf;
-                else t = new So("Set1");
+                if ("SVTYPE" === e) t = Zu;
+                else t = new vo("Set1");
                 this.colorTables.set(e, t)
             }
             return this.colorTables.get(e)
         }
     }
-    const cf = new Ao({
+    const Zu = new yo({
         DEL: "#ff2101",
         INS: "#001888",
         DUP: "#028401",
         INV: "#008688",
         CNV: "#8931ff",
         BND: "#891100",
         "*": "#002eff"
     });
-    class df extends zl {
+    class Qu extends Rl {
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
             super.init(e), this.name = e.name, this.pValueField = e.pValueField || "pValue", this.geneField = e.geneField || "geneSymbol", this.snpField = e.snpField || "snp";
             const t = e.minLogP || e.min,
                 i = e.maxLogP || e.max;
             this.dataRange = {
                 min: t || 3.5,
                 max: i || 25
-            }, this.autoscale = !i || e.autoscale, this.autoscalePercentile = void 0 === e.autoscalePercentile ? 98 : e.autoscalePercentile, this.background = e.background, this.divider = e.divider || "rgb(225,225,225)", this.dotSize = e.dotSize || 2, this.height = e.height || 100, this.autoHeight = !1, this.disableButtons = e.disableButtons, this.visibilityWindow = void 0 === e.visibilityWindow ? 2e6 : e.visibilityWindow >= 0 ? Math.min(2e6, e.visibilityWindow) : 2e6, this.featureSource = Sc(e, this.browser.genome), au.gtexLoaded = !0
+            }, this.autoscale = !i || e.autoscale, this.autoscalePercentile = void 0 === e.autoscalePercentile ? 98 : e.autoscalePercentile, this.background = e.background, this.divider = e.divider || "rgb(225,225,225)", this.dotSize = e.dotSize || 2, this.height = e.height || 100, this.autoHeight = !1, this.disableButtons = e.disableButtons, this.visibilityWindow = void 0 === e.visibilityWindow ? 2e6 : e.visibilityWindow >= 0 ? Math.min(2e6, e.visibilityWindow) : 2e6, this.featureSource = cc(e, this.browser.genome), jd.gtexLoaded = !0
         }
         paintAxis(e, t, i) {
             const n = (this.dataRange.max - this.dataRange.min) / i,
                 r = {
                     font: "normal 10px Arial",
                     textAlign: "right",
                     strokeStyle: "black"
                 };
-            Mo.fillRect(e, 0, 0, t, i, {
+            ko.fillRect(e, 0, 0, t, i, {
                 fillStyle: "rgb(255, 255, 255)"
             });
             const s = Math.ceil(10 * (this.dataRange.max - this.dataRange.min) / i);
             for (let o = 4; o <= this.dataRange.max; o += s) {
                 const s = .85 * t,
                     a = s - 5,
                     l = s,
                     h = i - (o - this.dataRange.min) / n;
-                Mo.strokeLine(e, a, h, l, h, r), h > 8 && Mo.fillText(e, o, a - 1, h + 2, r)
+                ko.strokeLine(e, a, h, l, h, r), h > 8 && ko.fillText(e, o, a - 1, h + 2, r)
             }
-            r.textAlign = "center", Mo.fillText(e, "-log10(pvalue)", t / 4, i / 2, r, {
+            r.textAlign = "center", ko.fillText(e, "-log10(pvalue)", t / 4, i / 2, r, {
                 rotate: {
                     angle: -90
                 }
             })
         }
         async getFeatures(e, t, i) {
             const n = this.pValueField,
@@ -26918,17 +27089,17 @@
                 e.value = e[n]
             })), s
         }
         draw(e) {
             const t = e.context,
                 i = e.pixelWidth,
                 n = e.pixelHeight;
-            this.background && Mo.fillRect(t, 0, 0, i, n, {
+            this.background && ko.fillRect(t, 0, 0, i, n, {
                 fillStyle: this.background
-            }), Mo.strokeLine(t, 0, n - 1, i, n - 1, {
+            }), ko.strokeLine(t, 0, n - 1, i, n - 1, {
                 strokeStyle: this.divider
             });
             const r = r => {
                 const s = r ? 2 * this.dotSize : this.dotSize,
                     o = e.bpStart,
                     a = (this.dataRange.max - this.dataRange.min) / n,
                     l = e.referenceFrame.selection;
@@ -26943,21 +27114,21 @@
                         l && l.snp === u && l.addGene(f);
                         var h = -Math.log(c[this.pValueField]) / Math.LN10;
                         if (h >= this.dataRange.min) {
                             let e;
                             h > this.dataRange.max ? (h = this.dataRange.max, e = !0) : e = !1;
                             const i = Math.max(0 + s, n - Math.round((h - this.dataRange.min) / a));
                             let o;
-                            c.px = d, c.py = i, c.radius = s, r && l ? (o = l.colorForGene(f), Mo.setProperties(t, {
+                            c.px = d, c.py = i, c.radius = s, r && l ? (o = l.colorForGene(f), ko.setProperties(t, {
                                 fillStyle: o,
                                 strokeStyle: "black"
-                            })) : (o = e ? "rgb(150, 150, 150)" : "rgb(180, 180, 180)", Mo.setProperties(t, {
+                            })) : (o = e ? "rgb(150, 150, 150)" : "rgb(180, 180, 180)", ko.setProperties(t, {
                                 fillStyle: o,
                                 strokeStyle: o
-                            })), Mo.fillCircle(t, d, i, s), Mo.strokeCircle(t, d, i, s)
+                            })), ko.fillCircle(t, d, i, s), ko.strokeCircle(t, d, i, s)
                         }
                     }
                 }
             };
             r(!1), r(!0)
         }
         popupData(e, t) {
@@ -26986,23 +27157,23 @@
             return $t.numericDataMenuItems(this.trackView)
         }
         doAutoscale(e) {
             if (e.length > 0) {
                 var t = e.map((function(e) {
                     return -Math.log(e.value) / Math.LN10
                 }));
-                this.dataRange.max = Vs.percentile(t, this.autoscalePercentile)
+                this.dataRange.max = Ns.percentile(t, this.autoscalePercentile)
             } else {
                 const e = this.config.maxLogP || this.config.max;
                 this.dataRange.max = e || 25
             }
             return this.dataRange
         }
     }
-    const uf = {
+    const Xu = {
         X: "rgb(204, 153, 0)",
         Y: "rgb(153, 204, 0)",
         Un: "darkGray)",
         1: "rgb(80, 80, 255)",
         2: "rgb(206, 61, 50)",
         "2a": "rgb(210, 65, 55)",
         "2b": "rgb(215, 70, 60)",
@@ -27049,37 +27220,37 @@
         43: "rgb(102, 0, 153)",
         44: "rgb(153, 0, 128)",
         45: "rgb(214, 0, 71)",
         46: "rgb(255, 20, 99)",
         47: "rgb(0, 214, 143)",
         48: "rgb(20, 255, 177)"
     };
-    for (let nw of Object.keys(uf)) {
-        uf["chr" + nw] = uf[nw]
+    for (let Xb of Object.keys(Xu)) {
+        Xu["chr" + Xb] = Xu[Xb]
     }
-    for (let rw = 1; rw <= 48; rw++) {
-        if (10 === rw) continue;
-        const sw = ff(rw);
-        uf[sw] = uf[rw.toString()]
+    for (let Yb = 1; Yb <= 48; Yb++) {
+        if (10 === Yb) continue;
+        const Kb = Yu(Yb);
+        Xu[Kb] = Xu[Yb.toString()]
     }
 
-    function ff(e) {
+    function Yu(e) {
         if (!+e) return !1;
         for (var t = String(+e).split(""), i = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"], n = "", r = 3; r--;) n = (i[+t.pop() + 10 * r] || "") + n;
         return Array(+t.join("") + 1).join("M") + n
     }
-    class pf extends zl {
+    class Ku extends Rl {
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.useChrColors = void 0 === e.useChrColors || e.useChrColors, this.trait = e.trait, this.posteriorProbability = e.posteriorProbability, this.valueProperty = "bed" === e.format ? "score" : "value", this.height = e.height || 100, this.autoscale = e.autoscale, this.autoscalePercentile = void 0 === e.autoscalePercentile ? 98 : e.autoscalePercentile, this.background = e.background, this.divider = e.divider || "rgb(225,225,225)", this.dotSize = e.dotSize || 3, this.popoverWindow = void 0 === e.popoverWindow ? 1e8 : e.popoverWindow, this.useChrColors ? this.colorScale = new Ao(e.colorTable || uf) : e.color ? this.colorScale = new Zu(e.color) : this.colorScale = new Wu(e.colorScale || {
+            super.init(e), this.useChrColors = void 0 === e.useChrColors || e.useChrColors, this.trait = e.trait, this.posteriorProbability = e.posteriorProbability, this.valueProperty = "bed" === e.format ? "score" : "value", this.height = e.height || 100, this.autoscale = e.autoscale, this.autoscalePercentile = void 0 === e.autoscalePercentile ? 98 : e.autoscalePercentile, this.background = e.background, this.divider = e.divider || "rgb(225,225,225)", this.dotSize = e.dotSize || 3, this.popoverWindow = void 0 === e.popoverWindow ? 1e8 : e.popoverWindow, this.useChrColors ? this.colorScale = new yo(e.colorTable || Xu) : e.color ? this.colorScale = new Bu(e.color) : this.colorScale = new Lu(e.colorScale || {
                 thresholds: [5e-8, 5e-4, .5],
                 colors: ["rgb(255,50,50)", "rgb(251,100,100)", "rgb(251,170,170)", "rgb(227,238,249)"]
-            }), this.featureSource = Sc(e, this.browser.genome)
+            }), this.featureSource = cc(e, this.browser.genome)
         }
         async postInit() {
             if ("function" != typeof this.featureSource.getHeader || (this.header = await this.featureSource.getHeader(), !this.disposed)) return this.header && this.setTrackProperties(this.header), this.autoscale || (this.posteriorProbability ? this.dataRange = {
                 min: void 0 === this.config.min ? 0 : this.config.min,
                 max: void 0 === this.config.max ? 1 : this.config.max
             } : this.dataRange = {
                 min: void 0 === this.config.min ? 0 : this.config.min,
@@ -27099,17 +27270,17 @@
             })
         }
         draw(e) {
             const t = e.features,
                 i = e.context,
                 n = e.pixelWidth,
                 r = e.pixelHeight;
-            if (this.background && Mo.fillRect(i, 0, 0, n, r, {
+            if (this.background && ko.fillRect(i, 0, 0, n, r, {
                     fillStyle: this.background
-                }), Mo.strokeLine(i, 0, r - 1, n, r - 1, {
+                }), ko.strokeLine(i, 0, r - 1, n, r - 1, {
                     strokeStyle: this.divider
                 }), t) {
                 const s = e.bpPerPixel,
                     o = e.bpStart,
                     a = o + n * s + 1;
                 for (let e of t) {
                     const t = e.start;
@@ -27123,49 +27294,49 @@
                         n = -Math.log10(t)
                     }
                     const l = this.useChrColors ? e._f ? e._f.chr : e.chr : n,
                         h = this.colorScale.getColor(l),
                         c = (this.dataRange.max - this.dataRange.min) / r,
                         d = Math.round((t - o) / s),
                         u = Math.max(this.dotSize, r - Math.round((n - this.dataRange.min) / c));
-                    h && Mo.setProperties(i, {
+                    h && ko.setProperties(i, {
                         fillStyle: h,
                         strokeStyle: "black"
-                    }), Mo.fillCircle(i, d, u, this.dotSize), e.px = d, e.py = u
+                    }), ko.fillCircle(i, d, u, this.dotSize), e.px = d, e.py = u
                 }
             }
         }
         paintAxis(e, t, i) {
-            Mo.fillRect(e, 0, 0, t, i, {
+            ko.fillRect(e, 0, 0, t, i, {
                 fillStyle: "rgb(255, 255, 255)"
             });
             var n = {
                 font: "normal 10px Arial",
                 textAlign: "right",
                 strokeStyle: "black"
             };
             const r = (this.dataRange.max - this.dataRange.min) / i;
             if (this.posteriorProbability) {
                 const t = .1;
                 for (let s = this.dataRange.min; s < this.dataRange.max; s += t) {
                     const t = i - Math.round((s - this.dataRange.min) / r);
-                    Mo.strokeLine(e, 45, t - 2, 50, t - 2, n), Mo.fillText(e, s.toFixed(1), 44, t + 2, n)
+                    ko.strokeLine(e, 45, t - 2, 50, t - 2, n), ko.fillText(e, s.toFixed(1), 44, t + 2, n)
                 }
             } else {
                 const t = Math.ceil(10 * (this.dataRange.max - this.dataRange.min) / i);
                 for (let s = this.dataRange.min; s < this.dataRange.max; s += t) {
                     const t = i - Math.round((s - this.dataRange.min) / r);
-                    Mo.strokeLine(e, 45, t, 50, t, n), Mo.fillText(e, Math.floor(s), 44, t + 4, n)
+                    ko.strokeLine(e, 45, t, 50, t, n), ko.fillText(e, Math.floor(s), 44, t + 4, n)
                 }
             }
-            n.textAlign = "center", this.posteriorProbability ? Mo.fillText(e, "PPA", t / 2, i / 2, n, {
+            n.textAlign = "center", this.posteriorProbability ? ko.fillText(e, "PPA", t / 2, i / 2, n, {
                 rotate: {
                     angle: -90
                 }
-            }) : Mo.fillText(e, "-log10(pvalue)", t / 2, i / 2, n, {
+            }) : ko.fillText(e, "-log10(pvalue)", t / 2, i / 2, n, {
                 rotate: {
                     angle: -90
                 }
             })
         }
         popupData(e, t) {
             void 0 === t && (t = e.viewport.cachedFeatures);
@@ -27218,34 +27389,34 @@
                     i = this.posteriorProbability,
                     n = e.map((function(e) {
                         const n = e[t];
                         return {
                             value: i ? n : -Math.log(n) / Math.LN10
                         }
                     }));
-                this.dataRange = Fo(n)
+                this.dataRange = To(n)
             } else this.posteriorProbability ? this.dataRange = {
                 min: this.config.min || 0,
                 max: this.config.max || 1
             } : this.dataRange = {
                 min: this.config.max || 25,
                 max: this.config.min || 0
             };
             return this.dataRange
         }
     }
-    class gf extends zl {
+    class Ju extends Rl {
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
             super.init(e), this.autoscale = e.autoscale || void 0 === e.max, this.dataRange = {
                 min: e.min || 0,
                 max: e.max
-            }, this.windowFunction = e.windowFunction || "mean", this.paintAxis = Ed, this.graphType = e.graphType || "bar", e._featureSource ? (this.featureSource = e._featureSource, delete e._featureSource) : this.featureSource = Sc(this.config, this.browser.genome), this.visibilityWindow = -1, this.featureSource.visibilityWindow = this.visibilityWindow
+            }, this.windowFunction = e.windowFunction || "mean", this.paintAxis = cd, this.graphType = e.graphType || "bar", e._featureSource ? (this.featureSource = e._featureSource, delete e._featureSource) : this.featureSource = cc(this.config, this.browser.genome), this.visibilityWindow = -1, this.featureSource.visibilityWindow = this.visibilityWindow
         }
         async postInit() {
             if ("function" == typeof this.featureSource.getHeader) {
                 if (this.header = await this.featureSource.getHeader(), this.disposed) return;
                 if (this.sampleNames = this.header.columnNames.slice(3), this.setTrackProperties(this.header), this.header.hasOwnProperty("clickToHighlight")) {
                     let e = this.header.clickToHighlight;
                     this.config.clickToHighlight = e, this.config.samplesClickedToHighlight = {}
@@ -27309,47 +27480,47 @@
                             const l = this.sampleNames[s],
                                 p = d.values[s],
                                 g = a(p);
                             if (t - f >= 1) {
                                 const s = o[l],
                                     c = a(s),
                                     d = e && e[l];
-                                d ? h.push([f, c, t, g, d]) : r && l in this.config.samplesClickedToHighlight ? h.push([f, c, t, g, this.config.samplesClickedToHighlight[l]]) : Mo.strokeLine(i, f, c, t, g, {
+                                d ? h.push([f, c, t, g, d]) : r && l in this.config.samplesClickedToHighlight ? h.push([f, c, t, g, this.config.samplesClickedToHighlight[l]]) : ko.strokeLine(i, f, c, t, g, {
                                     strokeStyle: "#D9D9D9"
                                 }), n && !(l in e) || this.clickDetectorCache[t].push([f, c, t, g, l, d || "gray"])
                             }
                             if (u - t >= 1) {
                                 const s = e && e[l];
-                                s ? c.push([t, g, u, g, s]) : r && l in this.config.samplesClickedToHighlight ? c.push([t, g, u, g, this.config.samplesClickedToHighlight[l]]) : Mo.strokeLine(i, t, g, u, g, {
+                                s ? c.push([t, g, u, g, s]) : r && l in this.config.samplesClickedToHighlight ? c.push([t, g, u, g, this.config.samplesClickedToHighlight[l]]) : ko.strokeLine(i, t, g, u, g, {
                                     strokeStyle: "gray"
                                 }), n && !(l in e) || this.clickDetectorCache[u].push([t, g, u, g, l, s || "gray"])
                             }
                             o[l] = p
                         }
                         s = d.end
                     }
                 }
-                for (let e of h) Mo.strokeLine(i, e[0], e[1], e[2], e[3], {
+                for (let e of h) ko.strokeLine(i, e[0], e[1], e[2], e[3], {
                     strokeStyle: e[4],
                     lineWidth: 1.3
                 });
-                for (let e of c) Mo.strokeLine(i, e[0], e[1], e[2], e[3], {
+                for (let e of c) ko.strokeLine(i, e[0], e[1], e[2], e[3], {
                     strokeStyle: e[4],
                     lineWidth: 2
                 })
             }(e => {
                 if (this.config.hasOwnProperty("guideLines"))
                     for (let t of this.config.guideLines)
                         if (t.hasOwnProperty("color") && t.hasOwnProperty("y") && t.hasOwnProperty("dotted")) {
                             let i = a(t.y),
                                 n = {
                                     strokeStyle: t.color,
                                     strokeWidth: 2
                                 };
-                            t.dotted ? Mo.dashedLine(e.context, 0, i, e.pixelWidth, i, 5, n) : Mo.strokeLine(e.context, 0, i, e.pixelWidth, i, n)
+                            t.dotted ? ko.dashedLine(e.context, 0, i, e.pixelWidth, i, 5, n) : ko.strokeLine(e.context, 0, i, e.pixelWidth, i, n)
                         }
             })(e)
         }
         doAutoscale(e) {
             let t, i;
             return e.length > 0 ? (t = Number.MAX_VALUE, i = -Number.MAX_VALUE, e.forEach((function(e) {
                 t = Math.min(t, ...e.values), i = Math.max(i, ...e.values)
@@ -27371,15 +27542,15 @@
                 for (let n of a) {
                     const r = n[0],
                         s = n[2];
                     if (t < r || t > s) return [];
                     const a = n[1],
                         l = n[3];
                     if (i < Math.min(a, l) - 10 || i > Math.max(a, l) + 10) continue;
-                    const h = mf(t, i, r, a, s, l);
+                    const h = ef(t, i, r, a, s, l);
                     h < e && (o = [{
                         name: n[4],
                         color: n[5]
                     }], e = h)
                 }
                 if (e < 5) {
                     if (this.config.clickToHighlight) {
@@ -27396,35 +27567,35 @@
             }
             return []
         }
         popupData(e, t) {
             void 0 === t && (t = this.clickedFeatures(e));
             const i = [];
             return t.forEach((function(e) {
-                for (let t of Object.keys(e)) Bo(e[t]) && i.push({
+                for (let t of Object.keys(e)) Eo(e[t]) && i.push({
                     name: t,
                     value: e[t]
                 })
             })), i
         }
         get supportsWholeGenome() {
             return !1
         }
     }
 
-    function mf(e, t, i, n, r, s) {
+    function ef(e, t, i, n, r, s) {
         const o = r - i,
             a = s - n,
             l = Math.abs(o * (n - t) - (i - e) * a),
             h = Math.sqrt(o * o + a * a);
         return h > 0 ? l / h : 0
     }
-    class bf extends zl {
+    class tf extends Rl {
         constructor(e, t) {
-            super(e, t), e.height || (this.height = 300), this.arcOrientation = !1, this.theta = Math.PI / 2, "bp" === e.format ? this.featureSource = new vf(e, t.genome) : this.featureSource = new Kh(e, t.genome)
+            super(e, t), e.height || (this.height = 300), this.arcOrientation = !1, this.theta = Math.PI / 2, "bp" === e.format ? this.featureSource = new rf(e, t.genome) : this.featureSource = new Ph(e, t.genome)
         }
         async getFeatures(e, t, i) {
             const n = this.visibilityWindow;
             return this.featureSource.getFeatures({
                 chr: e,
                 start: t,
                 end: i,
@@ -27437,20 +27608,20 @@
                 n = e.pixelWidth,
                 r = e.pixelHeight;
             e.viewportWidth;
             const s = e.bpPerPixel,
                 o = e.bpStart,
                 a = s,
                 l = this.arcOrientation;
-            Mo.fillRect(t, 0, e.pixelTop, n, r, {
+            ko.fillRect(t, 0, e.pixelTop, n, r, {
                 fillStyle: "rgb(255, 255, 255)"
             });
             const h = e.features;
             if (h) {
-                wf(h, 1);
+                nf(h, 1);
                 for (let e of h)
                     if (e.startLeft) {
                         let n = Math.round((e.startLeft - o) / a),
                             r = Math.round((e.startRight - o) / a),
                             s = Math.round((e.endLeft - o) / a),
                             h = Math.round((e.endRight - o) / a);
                         t.fillStyle = e.color, t.strokeStyle = e.color, t.beginPath();
@@ -27491,15 +27662,15 @@
                         }
                     }
             }
         }
         clickedFeatures(e) {
             const t = super.clickedFeatures(e),
                 i = [];
-            wf(t, -1);
+            nf(t, -1);
             for (let n of t) {
                 const t = n.drawState,
                     r = e.canvasX - t.x1,
                     s = e.canvasY - t.y1,
                     o = Math.sqrt(r * r + s * s),
                     a = t.r1 + 3;
                 let l, h;
@@ -27526,39 +27697,39 @@
                 click: function() {
                     e.arcOrientation = !e.arcOrientation, e.trackView.repaintViews()
                 }
             }]
         }
     }
 
-    function wf(e, t) {
+    function nf(e, t) {
         e.sort((function(e, i) {
             const n = void 0 === e.score ? -Number.MAX_VALUE : e.score,
                 r = void 0 === i.score ? -Number.MAX_VALUE : i.score;
             return (void 0 === t ? 1 : t) * (n - r)
         }))
     }
-    class vf {
+    class rf {
         constructor(e, t) {
             this.config = e, this.genome = t
         }
         async getFeatures({
             chr: e,
             start: t,
             end: i,
             bpPerPixel: n,
             visibilityWindow: r
         }) {
             const s = this.genome;
             if (this.featureCache) return this.featureCache.queryFeatures(e, t, i); {
-                const n = No(this.config),
-                    r = await lo.loadString(this.config.url, n);
-                return this.featureCache = new vo(function(e) {
+                const n = Mo(this.config),
+                    r = await io.loadString(this.config.url, n);
+                return this.featureCache = new fo(function(e) {
                     if (!e) return null;
-                    const t = xh(e);
+                    const t = lh(e);
                     let i, n = !0;
                     const r = [],
                         s = [],
                         o = [];
                     for (; void 0 !== (i = t.nextLine());) {
                         const e = i.split("\t");
                         if (n && i.startsWith("color:")) {
@@ -27594,15 +27765,15 @@
                         }
                     }
                     return o
                 }(r), s), this.featureCache.queryFeatures(e, t, i)
             }
         }
     }
-    class yf {
+    class sf {
         constructor(e) {
             this.browser = e, this.type = "ideogram", this.height = 16, this.order = Number.MIN_SAFE_INTEGER, this.disableButtons = !0, this.ignoreTrackMenu = !0
         }
         async getFeatures(e, t, i) {
             return []
         }
         computePixelHeight(e) {
@@ -27626,33 +27797,33 @@
                 height: s,
                 stainColors: o
             }) {
                 const a = 1,
                     l = .5 * a,
                     h = 0;
                 if (void 0 === n) return;
-                Mo.fillRect(e, 0, 0, r, s, {
-                    fillStyle: js.greyScale(255)
+                ko.fillRect(e, 0, 0, r, s, {
+                    fillStyle: Ds.greyScale(255)
                 });
                 const c = n.getCytobands(t);
                 if (c) {
                     const t = h + s / 2,
                         i = [],
                         n = [];
                     if (0 === c.length) return;
                     const d = r / c[c.length - 1].end;
-                    e.beginPath(), Mo.roundRect(e, l, l + h, r - 2 * l, s - 2 * l, (s - 2 * l) / 2, 0, 1), e.clip();
+                    e.beginPath(), ko.roundRect(e, l, l + h, r - 2 * l, s - 2 * l, (s - 2 * l) / 2, 0, 1), e.clip();
                     for (let r = 0; r < c.length; r++) {
                         const l = c[r],
                             u = d * l.start,
                             f = d * l.end;
-                        "c" === l.type ? ("p" === l.name.charAt(0) ? (i[0] = u, n[0] = s + h, i[1] = u, n[1] = h, i[2] = f, n[2] = t) : (i[0] = f, n[0] = s + h, i[1] = f, n[1] = h, i[2] = u, n[2] = t), e.fillStyle = "rgb(150, 0, 0)", e.strokeStyle = "rgb(150, 0, 0)", Mo.polygon(e, i, n, 1, 0)) : (e.fillStyle = _f(o, l), Mo.fillRect(e, u, a + h, f - u, s - 2 * a))
+                        "c" === l.type ? ("p" === l.name.charAt(0) ? (i[0] = u, n[0] = s + h, i[1] = u, n[1] = h, i[2] = f, n[2] = t) : (i[0] = f, n[0] = s + h, i[1] = f, n[1] = h, i[2] = u, n[2] = t), e.fillStyle = "rgb(150, 0, 0)", e.strokeStyle = "rgb(150, 0, 0)", ko.polygon(e, i, n, 1, 0)) : (e.fillStyle = of(o, l), ko.fillRect(e, u, a + h, f - u, s - 2 * a))
                     }
                 }
-                e.strokeStyle = js.greyScale(41), Mo.roundRect(e, l, l + h, r - 2 * l, s - 2 * l, (s - 2 * l) / 2, 0, 1)
+                e.strokeStyle = Ds.greyScale(41), ko.roundRect(e, l, l + h, r - 2 * l, s - 2 * l, (s - 2 * l) / 2, 0, 1)
             }({
                 ctx: e,
                 chr: r,
                 referenceFrame: t,
                 genome: t.genome,
                 width: i,
                 height: n,
@@ -27676,33 +27847,33 @@
             }
         }
         dispose() {
             this.trackView = void 0
         }
     }
 
-    function _f(e, t) {
+    function of(e, t) {
         if ("c" === t.type) return "rgb(150, 10, 10)";
         var i = t.stain,
             n = 230;
         "p" === t.type && (n = Math.floor(230 - i / 100 * 230));
         var r = e[n];
         return r || (r = "rgb(" + n + "," + n + "," + n + ")", e[n] = r), r
     }
-    let xf = new So("Dark2");
+    let af = new vo("Dark2");
     ["GT/AG", "CT/AC", "GC/AG", "CT/GC", "AT/AC", "GT/AT", "non-canonical"].forEach((e => {
-        xf.getColor(e)
+        af.getColor(e)
     }));
-    const kf = {};
-    class Cf extends zl {
+    const lf = {};
+    class hf extends Rl {
         constructor(e, t) {
             super(e, t)
         }
         init(e) {
-            super.init(e), this.type = e.type || "junctions", e._featureSource ? (this.featureSource = e._featureSource, delete e._featureSource) : this.featureSource = e.featureSource ? e.featureSource : Sc(e, this.browser.genome), this.margin = void 0 === e.margin ? 10 : e.margin, this.height || (this.height = 100), void 0 === e.colorByNumReadsThreshold && (e.colorByNumReadsThreshold = 5)
+            super.init(e), this.type = e.type || "junctions", e._featureSource ? (this.featureSource = e._featureSource, delete e._featureSource) : this.featureSource = e.featureSource ? e.featureSource : cc(e, this.browser.genome), this.margin = void 0 === e.margin ? 10 : e.margin, this.height || (this.height = 100), void 0 === e.colorByNumReadsThreshold && (e.colorByNumReadsThreshold = 5)
         }
         async postInit() {
             if ("function" != typeof this.featureSource.getHeader || (this.header = await this.featureSource.getHeader(), !this.disposed)) return this.header && this.setTrackProperties(this.header), void 0 === this.visibilityWindow && "function" == typeof this.featureSource.defaultVisibilityWindow && (this.visibilityWindow = await this.featureSource.defaultVisibilityWindow()), this
         }
         get supportsWholeGenome() {
             return !1
         }
@@ -27723,41 +27894,41 @@
             const t = e.features,
                 i = e.context,
                 n = e.bpPerPixel,
                 r = e.bpStart,
                 s = e.pixelWidth,
                 o = e.pixelHeight,
                 a = r + s * n + 1;
-            if (this.config.isMergedTrack || Mo.fillRect(i, 0, e.pixelTop, s, o, {
+            if (this.config.isMergedTrack || ko.fillRect(i, 0, e.pixelTop, s, o, {
                     fillStyle: "rgb(255, 255, 255)"
                 }), t) {
-                kf.referenceFrame = e.viewport.referenceFrame, kf.referenceFrameStart = kf.referenceFrame.start, kf.referenceFrameEnd = kf.referenceFrameStart + kf.referenceFrame.toBP(e.viewport.getWidth()), kf.featureZoomOutTracker = {};
+                lf.referenceFrame = e.viewport.referenceFrame, lf.referenceFrameStart = lf.referenceFrame.start, lf.referenceFrameEnd = lf.referenceFrameStart + lf.referenceFrame.toBP(e.viewport.getWidth()), lf.featureZoomOutTracker = {};
                 for (let e of t)
                     if (!(e.end < r)) {
                         if (e.start > a) break;
                         this.renderJunction(e, r, n, o, i)
                     }
             } else console.log("No feature list")
         }
         renderJunction(e, t, i, n, r) {
             e.isVisible = !1;
             const s = Math.round((e.start - t) / i),
                 o = Math.round((e.end - t) / i),
                 a = (s + o) / 2;
             if (o - s <= 3) {
-                if (a in kf.featureZoomOutTracker) return;
-                kf.featureZoomOutTracker[a] = !0
+                if (a in lf.featureZoomOutTracker) return;
+                lf.featureZoomOutTracker[a] = !0
             }
             if (this.config.hideAnnotatedJunctions && "true" === e.attributes.annotated_junction) return;
             if (this.config.hideUnannotatedJunctions && "false" === e.attributes.annotated_junction) return;
             if (this.config.hideMotifs && this.config.hideMotifs.includes(e.attributes.motif)) return;
             if (this.config.hideStrand === e.strand) return;
             if (this.config.minJunctionEndsVisible) {
                 let t = 0;
-                if (e.start >= kf.referenceFrameStart && e.start <= kf.referenceFrameEnd && (t += 1), e.end >= kf.referenceFrameStart && e.end <= kf.referenceFrameEnd && (t += 1), t < this.config.minJunctionEndsVisible) return
+                if (e.start >= lf.referenceFrameStart && e.start <= lf.referenceFrameEnd && (t += 1), e.end >= lf.referenceFrameStart && e.end <= lf.referenceFrameEnd && (t += 1), t < this.config.minJunctionEndsVisible) return
             }
             let l, h, c, d;
             if (e.attributes.uniquely_mapped) {
                 if (l = parseInt(e.attributes.uniquely_mapped), l < this.config.minUniquelyMappedReads) return;
                 if (h = parseInt(e.attributes.multi_mapped), c = l + h, c < this.config.minTotalReads) return;
                 if (c > 0 && h / c > this.config.maxFractionMultiMappedReads) return;
                 if (e.attributes.maximum_spliced_alignment_overhang && parseInt(e.attributes.maximum_spliced_alignment_overhang) < this.config.minSplicedAlignmentOverhang) return
@@ -27771,15 +27942,15 @@
                 f = this.height,
                 p = u + .5 * f;
             let g = u;
             const m = u + f - 10,
                 b = (s + a) / 2,
                 w = (a + o) / 2;
             let v, y, _ = 1;
-            e.attributes.line_width ? _ = Number(e.attributes.line_width) : (void 0 === this.config.thicknessBasedOn || "numUniqueReads" === this.config.thicknessBasedOn ? _ = l : "numReads" === this.config.thicknessBasedOn ? _ = c : "numSamplesWithThisJunction" === this.config.thicknessBasedOn && void 0 !== d && (_ = d), _ = 1 + Math.log(_ + 1) / Math.log(12)), void 0 === this.config.bounceHeightBasedOn || "random" === this.config.bounceHeightBasedOn ? v = (e.start + e.end) % 7 : "distance" === this.config.bounceHeightBasedOn ? v = 6 * (e.end - e.start) / (kf.referenceFrameEnd - kf.referenceFrameStart) : "thickness" === this.config.bounceHeightBasedOn && (v = 2 * _), g += f * Math.max(7 - v, 0) / 10, y = e.attributes.color ? e.attributes.color : void 0 === this.config.colorBy || "numUniqueReads" === this.config.colorBy ? l > this.config.colorByNumReadsThreshold ? "blue" : "#AAAAAA" : "numReads" === this.config.colorBy ? c > this.config.colorByNumReadsThreshold ? "blue" : "#AAAAAA" : "isAnnotatedJunction" === this.config.colorBy ? "true" === e.attributes.annotated_junction ? "#b0b0ec" : "orange" : "strand" === this.config.colorBy ? "+" === e.strand ? "#b0b0ec" : "#ecb0b0" : "motif" === this.config.colorBy ? xf.getColor(e.attributes.motif) : "#AAAAAA";
+            e.attributes.line_width ? _ = Number(e.attributes.line_width) : (void 0 === this.config.thicknessBasedOn || "numUniqueReads" === this.config.thicknessBasedOn ? _ = l : "numReads" === this.config.thicknessBasedOn ? _ = c : "numSamplesWithThisJunction" === this.config.thicknessBasedOn && void 0 !== d && (_ = d), _ = 1 + Math.log(_ + 1) / Math.log(12)), void 0 === this.config.bounceHeightBasedOn || "random" === this.config.bounceHeightBasedOn ? v = (e.start + e.end) % 7 : "distance" === this.config.bounceHeightBasedOn ? v = 6 * (e.end - e.start) / (lf.referenceFrameEnd - lf.referenceFrameStart) : "thickness" === this.config.bounceHeightBasedOn && (v = 2 * _), g += f * Math.max(7 - v, 0) / 10, y = e.attributes.color ? e.attributes.color : void 0 === this.config.colorBy || "numUniqueReads" === this.config.colorBy ? l > this.config.colorByNumReadsThreshold ? "blue" : "#AAAAAA" : "numReads" === this.config.colorBy ? c > this.config.colorByNumReadsThreshold ? "blue" : "#AAAAAA" : "isAnnotatedJunction" === this.config.colorBy ? "true" === e.attributes.annotated_junction ? "#b0b0ec" : "orange" : "strand" === this.config.colorBy ? "+" === e.strand ? "#b0b0ec" : "#ecb0b0" : "motif" === this.config.colorBy ? af.getColor(e.attributes.motif) : "#AAAAAA";
             let x = "";
             e.attributes.label ? x = e.attributes.label.replace(/_/g, " ") : void 0 === this.config.labelWith || "uniqueReadCount" === this.config.labelWith ? x = l : "totalReadCount" === this.config.labelWith ? x = c : "numSamplesWithThisJunction" === this.config.labelWith ? void 0 !== d && (x = d) : "percentSamplesWithThisJunction" === this.config.labelWith ? void 0 !== e.attributes.percent_samples_with_this_junction && (x = e.attributes.percent_samples_with_this_junction.toFixed(0) + "%") : "motif" === this.config.labelWith && void 0 !== e.attributes.motif && (x += e.attributes.motif), "uniqueReadCount" === this.config.labelWithInParen ? x += " (" + l + ")" : "totalReadCount" === this.config.labelWithInParen ? x += " (" + c + ")" : "multiMappedReadCount" === this.config.labelWithInParen ? h > 0 && (x += " (+" + h + ")") : "numSamplesWithThisJunction" === this.config.labelWithInParen ? void 0 !== d && (x += " (" + d + ")") : "percentSamplesWithThisJunction" === this.config.labelWithInParen ? void 0 !== e.attributes.percent_samples_with_this_junction && (x += " (" + e.attributes.percent_samples_with_this_junction.toFixed(0) + "%)") : "motif" === this.config.labelWithInParen && void 0 !== e.attributes.motif && (x += ` ${e.attributes.motif}`), e.isVisible = !0, r.beginPath(), r.moveTo(s, m), r.bezierCurveTo(b, g, w, g, o, m), r.lineWidth = _, r.strokeStyle = y, r.stroke();
             const k = (e, t, i, n) => {
                 e.beginPath(), e.moveTo(t, i), e.lineTo(t - n / 2, i - n), e.lineTo(t + n / 2, i - n), e.lineTo(t, i), e.closePath(), e.fill()
             };
             if (e.attributes.left_shape || e.attributes.right_shape) {
                 r.fillStyle = y;
@@ -27803,15 +27974,15 @@
             }
             return n
         }
         dispose() {
             this.trackView = void 0
         }
     }
-    class Sf {
+    class cf {
         constructor(e) {
             var t;
             this.config = e, this.url = (t = e.path || e.url).includes("//www.dropbox.com") ? t.replace("//www.dropbox.com", "//dl.dropboxusercontent.com") : t.startsWith("ftp://ftp.ncbi.nlm.nih.gov") ? t.replace("ftp://", "https://") : t
         }
         async read(e, t) {
             const i = this.config.headers || {};
             if (void 0 !== e && t) {
@@ -27839,15 +28010,15 @@
             if (s >= 400) {
                 const e = Error(r.statusText);
                 throw e.code = s, e
             }
             return r.arrayBuffer()
         }
     }
-    class Af {
+    class df {
         constructor(e) {
             this.file = e.file, this.fetchSize = e.fetchSize || 16e3, this.maxSize = e.maxSize || 1e6, this.buffers = []
         }
         async read(e, t) {
             let i = this.buffers.filter((i => i.overlaps(e, e + t)));
             for (let n of i)
                 if (n.contains(e, e + t)) return n.slice(e, e + t);
@@ -27862,47 +28033,47 @@
                         t(e[i]) ? r = i : n = i
                     }
                     return r
                 }(this.buffers, (t => t.start > e), 0);
                 n < this.buffers.length && (i = Math.min(i, this.buffers[n].start - e));
                 const r = e,
                     s = await this.file.read(r, i),
-                    o = new Ef(r, s);
+                    o = new uf(r, s);
                 return this.addBuffer(o), o.slice(e, e + t)
             } {
                 i.sort(((e, t) => e.start - t.start));
                 const n = [];
                 let r = e;
                 for (let e of i) {
                     if (r < e.start) {
                         const t = r,
                             i = e.start - r,
                             s = await this.file.read(t, i),
-                            o = new Ef(t, s);
+                            o = new uf(t, s);
                         n.push(o)
                     }
                     n.push(e), r = e.end
                 }
                 const s = e + t;
                 if (s > r) {
                     const e = r,
                         t = s - e,
                         i = await this.file.read(e, t),
-                        o = new Ef(e, i);
+                        o = new uf(e, i);
                     n.push(o)
                 }
                 const o = n[0].start,
                     a = function(e) {
                         const t = e.reduce(((e, t) => e + t.byteLength), 0),
                             i = new Uint8Array(t);
                         let n = 0;
                         for (let t of e) i.set(new Uint8Array(t), n), n += t.byteLength;
                         return i.buffer
                     }(n.map((e => e.buffer))),
-                    l = new Ef(o, a),
+                    l = new uf(o, a),
                     h = new Set(i);
                 return this.buffers = this.buffers.filter((e => !h.has(e))), this.addBuffer(l), l.slice(e, e + t)
             }
         }
         addBuffer(e) {
             const t = this.buffers.reduce(((e, t) => e + t.size), 0) + e.size;
             if (t > this.maxSize) {
@@ -27911,15 +28082,15 @@
                 let i, n = 0;
                 for (i = 0; i < this.buffers.length && (n += this.buffers[i].size, !(n > e)); i++);
                 this.buffers = i < this.buffers.length - 1 ? this.buffers.slice(i) : []
             }
             e.size <= this.maxSize && this.buffers.push(e)
         }
     }
-    class Ef {
+    class uf {
         constructor(e, t) {
             this.creationTime = Date.now(), this.start = e, this.buffer = t
         }
         slice(e, t) {
             if (e < this.start || t - e > this.buffer.byteLength) throw Error("buffer bounds error");
             return this.buffer.slice(e - this.start, t - this.start)
         }
@@ -27935,69 +28106,69 @@
         overlaps(e, t) {
             return e > this.start && e < this.end || t > this.start && t < this.end
         }
         toString() {
             return `Buffer ${this.creationTime}   ${this.start} - ${this.end}`
         }
     }
-    class Tf {
+    class ff {
         constructor(e) {
             this.file = e
         }
         async read(e, t) {
             if (0 === t) return new ArrayBuffer;
             return (null != e && t ? this.file.slice(e, e + t) : this.file).arrayBuffer()
         }
     }
-    async function Mf(e, t, i = 0) {
+    async function pf(e, t, i = 0) {
         var n = new Map;
         for (let [r, s] of e.entries()) {
-            let e = await Pf.unpack_from_async("<" + s, t, i);
-            i += Pf.calcsize(s), 1 == e.length && (e = e[0]), n.set(r, e)
+            let e = await _f.unpack_from_async("<" + s, t, i);
+            i += _f.calcsize(s), 1 == e.length && (e = e[0]), n.set(r, e)
         }
         return n
     }
 
-    function Rf(e, t, i = 0) {
+    function gf(e, t, i = 0) {
         var n = new Map;
         for (let [r, s] of e.entries()) {
-            let e = Pf.unpack_from("<" + s, t, i);
-            i += Pf.calcsize(s), 1 == e.length && (e = e[0]), n.set(r, e)
+            let e = _f.unpack_from("<" + s, t, i);
+            i += _f.calcsize(s), 1 == e.length && (e = e[0]), n.set(r, e)
         }
         return n
     }
 
-    function Lf(e) {
+    function mf(e) {
         e || e()
     }
 
-    function If(e) {
+    function bf(e) {
         var t = "<" + Array.from(e.values()).join("");
-        return Pf.calcsize(t)
+        return _f.calcsize(t)
     }
 
-    function Bf(e, t = 8) {
+    function wf(e, t = 8) {
         return Math.ceil(e / t) * t
     }
-    var Nf = {
+    var vf = {
         u: "Uint",
         i: "Int",
         f: "Float"
     };
 
-    function Ff(e) {
-        var t, i, n = Pf._is_big_endian(e);
+    function yf(e) {
+        var t, i, n = _f._is_big_endian(e);
         if (/S/.test(e)) t = "getString", i = 0 | ((e.match(/S(\d*)/) || [])[1] || 1);
         else {
-            let [n, r, s] = e.match(/[<>=!@]?(i|u|f)(\d*)/), o = 8 * (i = parseInt(s || 4, 10));
-            t = "get" + Nf[r] + o.toFixed()
+            let [n, r, s] = e.match(/[<>=!@]?(i|u|f)(\d*)/);
+            i = parseInt(s || 4, 10), t = "get" + vf[r] + (8 * i).toFixed()
         }
         return [t, n, i]
     }
-    var Pf = new class {
+    var _f = new class {
         constructor() {
             this.big_endian = function() {
                 const e = new Uint8Array(4);
                 return !((new Uint32Array(e.buffer)[0] = 1) & e[0])
             }(), this.getters = {
                 s: "getUint8",
                 b: "getInt8",
@@ -28042,15 +28213,15 @@
             return !/^</.test(e) && (!!/^(!|>)/.test(e) || this.big_endian)
         }
         async unpack_from_async(e, t, i) {
             i = Number(i || 0);
             const n = this.calcsize(e),
                 r = await t.slice(i, i + n);
             let s = 0;
-            for (var o, a = new Of(r), l = [], h = this._is_big_endian(e), c = new RegExp(this.fmt_size_regex, "g"); null !== (o = c.exec(e));) {
+            for (var o, a = new xf(r), l = [], h = this._is_big_endian(e), c = new RegExp(this.fmt_size_regex, "g"); null !== (o = c.exec(e));) {
                 let e = parseInt(o[1] || 1, 10),
                     t = o[2],
                     i = this.getters[t],
                     n = this.byte_lengths[t];
                 if ("s" == t) l.push((new TextDecoder).decode(r.slice(s, s + e))), s += e;
                 else
                     for (var d = 0; d < e; d++) l.push(a[i](s, !h)), s += n
@@ -28058,27 +28229,27 @@
             return l
         }
         unpack_from(e, t, i) {
             i = Number(i || 0);
             const n = this.calcsize(e),
                 r = t.slice(i, i + n);
             let s = 0;
-            for (var o, a = new Of(r), l = [], h = this._is_big_endian(e), c = new RegExp(this.fmt_size_regex, "g"); null !== (o = c.exec(e));) {
+            for (var o, a = new xf(r), l = [], h = this._is_big_endian(e), c = new RegExp(this.fmt_size_regex, "g"); null !== (o = c.exec(e));) {
                 let e = parseInt(o[1] || 1, 10),
                     t = o[2],
                     i = this.getters[t],
                     n = this.byte_lengths[t];
                 if ("s" == t) l.push((new TextDecoder).decode(r.slice(s, s + e))), s += e;
                 else
                     for (var d = 0; d < e; d++) l.push(a[i](s, !h)), s += n
             }
             return l
         }
     };
-    var Of = class extends DataView {
+    var xf = class extends DataView {
         getUint64(e, t) {
             const i = BigInt(this.getUint32(e, t)),
                 n = BigInt(this.getUint32(e + 4, t));
             return Number(t ? i + (n << 32n) : (i << 32n) + n)
         }
         getInt64(e, t) {
             var i, n;
@@ -28091,47 +28262,47 @@
             return (new TextDecoder).decode(n)
         }
         getVLENStruct(e, t, i) {
             return [this.getUint32(e, t), this.getUint64(e + 4, t), this.getUint32(e + 12, t)]
         }
     };
 
-    function Df(e) {
+    function kf(e) {
         return e.toString(2).length
     }
 
-    function zf(e, t, i = 0, n = !0) {
+    function Cf(e, t, i = 0, n = !0) {
         const r = t.slice(i, i + e);
         let s = new Uint8Array(r);
         n || s.reverse();
         let o = s.reduce(((e, t, i) => e + (t << 8 * i)), 0);
         return o
     }
-    var Hf = class {
+    var Sf = class {
             constructor(e, t) {
                 this.buf = e, this.offset = t, this.dtype = this.determine_dtype()
             }
             async determine_dtype() {
-                let e = await Mf(Vf, this.buf, this.offset);
-                this.offset += Uf;
+                let e = await pf(Af, this.buf, this.offset);
+                this.offset += Ef;
                 let t = 15 & e.get("class_and_version");
-                if (t == qf) return this._determine_dtype_fixed_point(e);
-                if (t == jf) return this._determine_dtype_floating_point(e);
-                if (t == $f) throw "Time datatype class not supported.";
-                if (t == Wf) return this._determine_dtype_string(e);
-                if (t == Gf) throw "Bitfield datatype class not supported.";
-                if (t == Zf) return {
-                    datatype_class: Zf,
+                if (t == Mf) return this._determine_dtype_fixed_point(e);
+                if (t == Tf) return this._determine_dtype_floating_point(e);
+                if (t == Rf) throw "Time datatype class not supported.";
+                if (t == Lf) return this._determine_dtype_string(e);
+                if (t == If) throw "Bitfield datatype class not supported.";
+                if (t == Bf) return {
+                    datatype_class: Bf,
                     size: e.get("size")
                 };
-                if (t == Qf) return this._determine_dtype_compound(e);
-                if (t == Xf) return ["REFERENCE", e.get("size")];
-                if (t == Yf) return this.determine_dtype();
-                if (t == Jf) throw "Array datatype class not supported.";
-                if (t == Kf) {
+                if (t == Ff) return this._determine_dtype_compound(e);
+                if (t == Nf) return ["REFERENCE", e.get("size")];
+                if (t == Of) return this.determine_dtype();
+                if (t == Df) throw "Array datatype class not supported.";
+                if (t == Pf) {
                     let t = this._determine_dtype_vlen(e);
                     if ("VLEN_SEQUENCE" == t[0]) {
                         t = ["VLEN_SEQUENCE", this.determine_dtype()]
                     }
                     return t
                 }
                 throw "Invalid datatype class " + t
@@ -28155,93 +28326,93 @@
             _determine_dtype_vlen(e) {
                 return 1 != (1 & e.get("class_bit_field_0")) ? ["VLEN_SEQUENCE", 0, 0] : ["VLEN_STRING", e.get("class_bit_field_0") >> 4, 1 & e.get("class_bit_field_1")]
             }
             _determine_dtype_compound(e) {
                 throw "Compound type not yet implemented!"
             }
         },
-        Vf = new Map([
+        Af = new Map([
             ["class_and_version", "B"],
             ["class_bit_field_0", "B"],
             ["class_bit_field_1", "B"],
             ["class_bit_field_2", "B"],
             ["size", "I"]
         ]),
-        Uf = If(Vf);
-    If(new Map([
+        Ef = bf(Af);
+    bf(new Map([
         ["offset", "I"],
         ["dimensionality", "B"],
         ["reserved_0", "B"],
         ["reserved_1", "B"],
         ["reserved_2", "B"],
         ["permutation", "I"],
         ["reserved_3", "I"],
         ["dim_size_1", "I"],
         ["dim_size_2", "I"],
         ["dim_size_3", "I"],
         ["dim_size_4", "I"]
     ]));
-    var qf = 0,
-        jf = 1,
-        $f = 2,
-        Wf = 3,
-        Gf = 4,
-        Zf = 5,
-        Qf = 6,
-        Xf = 7,
-        Yf = 8,
-        Kf = 9,
-        Jf = 10;
+    var Mf = 0,
+        Tf = 1,
+        Rf = 2,
+        Lf = 3,
+        If = 4,
+        Bf = 5,
+        Ff = 6,
+        Nf = 7,
+        Of = 8,
+        Pf = 9,
+        Df = 10;
 
-    function ep(e) {
+    function zf(e) {
         let t = e.length;
         for (; --t >= 0;) e[t] = 0
     }
-    ep(new Array(576)), ep(new Array(60)), ep(new Array(512)), ep(new Array(256)), ep(new Array(29)), ep(new Array(30));
-    var tp = (e, t, i, n) => {
+    zf(new Array(576)), zf(new Array(60)), zf(new Array(512)), zf(new Array(256)), zf(new Array(29)), zf(new Array(30));
+    var Hf = (e, t, i, n) => {
             let r = 65535 & e | 0,
                 s = e >>> 16 & 65535 | 0,
                 o = 0;
             for (; 0 !== i;) {
                 o = i > 2e3 ? 2e3 : i, i -= o;
                 do {
                     r = r + t[n++] | 0, s = s + r | 0
                 } while (--o);
                 r %= 65521, s %= 65521
             }
             return r | s << 16 | 0
         },
-        ip = new Uint32Array((() => {
+        Vf = new Uint32Array((() => {
             let e, t = [];
             for (var i = 0; i < 256; i++) {
                 e = i;
                 for (var n = 0; n < 8; n++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                 t[i] = e
             }
             return t
         })()),
-        np = (e, t, i, n) => {
-            const r = ip,
+        Uf = (e, t, i, n) => {
+            const r = Vf,
                 s = n + i;
             e ^= -1;
             for (let i = n; i < s; i++) e = e >>> 8 ^ r[255 & (e ^ t[i])];
             return -1 ^ e
         },
-        rp = {
+        qf = {
             2: "need dictionary",
             1: "stream end",
             0: "",
             "-1": "file error",
             "-2": "stream error",
             "-3": "data error",
             "-4": "insufficient memory",
             "-5": "buffer error",
             "-6": "incompatible version"
         },
-        sp = {
+        jf = {
             Z_NO_FLUSH: 0,
             Z_PARTIAL_FLUSH: 1,
             Z_SYNC_FLUSH: 2,
             Z_FULL_FLUSH: 3,
             Z_FINISH: 4,
             Z_BLOCK: 5,
             Z_TREES: 6,
@@ -28263,23 +28434,23 @@
             Z_FIXED: 4,
             Z_DEFAULT_STRATEGY: 0,
             Z_BINARY: 0,
             Z_TEXT: 1,
             Z_UNKNOWN: 2,
             Z_DEFLATED: 8
         },
-        op = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
-        ap = {
+        $f = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
+        Wf = {
             assign: function(e) {
                 const t = Array.prototype.slice.call(arguments, 1);
                 for (; t.length;) {
                     const i = t.shift();
                     if (i) {
                         if ("object" != typeof i) throw new TypeError(i + "must be non-object");
-                        for (const t in i) op(i, t) && (e[t] = i[t])
+                        for (const t in i) $f(i, t) && (e[t] = i[t])
                     }
                 }
                 return e
             },
             flattenChunks: e => {
                 let t = 0;
                 for (let i = 0, n = e.length; i < n; i++) t += e[i].length;
@@ -28287,24 +28458,24 @@
                 for (let t = 0, n = 0, r = e.length; t < r; t++) {
                     let r = e[t];
                     i.set(r, n), n += r.length
                 }
                 return i
             }
         },
-        lp = !0;
+        Gf = !0;
     try {
         String.fromCharCode.apply(null, new Uint8Array(1))
-    } catch (ow) {
-        lp = !1
+    } catch (Jb) {
+        Gf = !1
     }
-    var hp = new Uint8Array(256);
-    for (let aw = 0; aw < 256; aw++) hp[aw] = aw >= 252 ? 6 : aw >= 248 ? 5 : aw >= 240 ? 4 : aw >= 224 ? 3 : aw >= 192 ? 2 : 1;
-    hp[254] = hp[254] = 1;
-    var cp = {
+    var Zf = new Uint8Array(256);
+    for (let ew = 0; ew < 256; ew++) Zf[ew] = ew >= 252 ? 6 : ew >= 248 ? 5 : ew >= 240 ? 4 : ew >= 224 ? 3 : ew >= 192 ? 2 : 1;
+    Zf[254] = Zf[254] = 1;
+    var Qf = {
         string2buf: e => {
             if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(e);
             let t, i, n, r, s, o = e.length,
                 a = 0;
             for (r = 0; r < o; r++) i = e.charCodeAt(r), 55296 == (64512 & i) && r + 1 < o && (n = e.charCodeAt(r + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), r++)), a += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
             for (t = new Uint8Array(a), s = 0, r = 0; s < a; r++) i = e.charCodeAt(r), 55296 == (64512 & i) && r + 1 < o && (n = e.charCodeAt(r + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), r++)), i < 128 ? t[s++] = i : i < 2048 ? (t[s++] = 192 | i >>> 6, t[s++] = 128 | 63 & i) : i < 65536 ? (t[s++] = 224 | i >>> 12, t[s++] = 128 | i >>> 6 & 63, t[s++] = 128 | 63 & i) : (t[s++] = 240 | i >>> 18, t[s++] = 128 | i >>> 12 & 63, t[s++] = 128 | i >>> 6 & 63, t[s++] = 128 | 63 & i);
             return t
@@ -28316,39 +28487,39 @@
             const s = new Array(2 * i);
             for (r = 0, n = 0; n < i;) {
                 let t = e[n++];
                 if (t < 128) {
                     s[r++] = t;
                     continue
                 }
-                let o = hp[t];
+                let o = Zf[t];
                 if (o > 4) s[r++] = 65533, n += o - 1;
                 else {
                     for (t &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && n < i;) t = t << 6 | 63 & e[n++], o--;
                     o > 1 ? s[r++] = 65533 : t < 65536 ? s[r++] = t : (t -= 65536, s[r++] = 55296 | t >> 10 & 1023, s[r++] = 56320 | 1023 & t)
                 }
             }
             return ((e, t) => {
-                if (t < 65534 && e.subarray && lp) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
+                if (t < 65534 && e.subarray && Gf) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                 let i = "";
                 for (let n = 0; n < t; n++) i += String.fromCharCode(e[n]);
                 return i
             })(s, r)
         },
         utf8border: (e, t) => {
             (t = t || e.length) > e.length && (t = e.length);
             let i = t - 1;
             for (; i >= 0 && 128 == (192 & e[i]);) i--;
-            return i < 0 || 0 === i ? t : i + hp[e[i]] > t ? i : t
+            return i < 0 || 0 === i ? t : i + Zf[e[i]] > t ? i : t
         }
     };
-    var dp = function() {
+    var Xf = function() {
             this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
         },
-        up = function(e, t) {
+        Yf = function(e, t) {
             let i, n, r, s, o, a, l, h, c, d, u, f, p, g, m, b, w, v, y, _, x, k, C, S;
             const A = e.state;
             i = e.next_in, C = e.input, n = i + (e.avail_in - 5), r = e.next_out, S = e.output, s = r - (t - e.avail_out), o = r + (e.avail_out - 257), a = A.dmax, l = A.wsize, h = A.whave, c = A.wnext, d = A.window, u = A.hold, f = A.bits, p = A.lencode, g = A.distcode, m = (1 << A.lenbits) - 1, b = (1 << A.distbits) - 1;
             e: do {
                 f < 15 && (u += C[i++] << f, f += 8, u += C[i++] << f, f += 8), w = p[u & m];
                 t: for (;;) {
                     if (v = w >>> 24, u >>>= v, f -= v, v = w >>> 16 & 255, 0 === v) S[r++] = 65535 & w;
@@ -28426,52 +28597,52 @@
                         }
                     }
                     break
                 }
             } while (i < n && r < o);
             y = f >> 3, i -= y, f -= y << 3, u &= (1 << f) - 1, e.next_in = i, e.next_out = r, e.avail_in = i < n ? n - i + 5 : 5 - (i - n), e.avail_out = r < o ? o - r + 257 : 257 - (r - o), A.hold = u, A.bits = f
         },
-        fp = 15,
-        pp = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
-        gp = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
-        mp = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
-        bp = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
-        wp = (e, t, i, n, r, s, o, a) => {
+        Kf = 15,
+        Jf = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
+        ep = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
+        tp = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
+        ip = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
+        np = (e, t, i, n, r, s, o, a) => {
             const l = a.bits;
             let h, c, d, u, f, p, g = 0,
                 m = 0,
                 b = 0,
                 w = 0,
                 v = 0,
                 y = 0,
                 _ = 0,
                 x = 0,
                 k = 0,
                 C = 0,
                 S = null,
                 A = 0;
             const E = new Uint16Array(16),
-                T = new Uint16Array(16);
-            let M, R, L, I = null,
+                M = new Uint16Array(16);
+            let T, R, L, I = null,
                 B = 0;
-            for (g = 0; g <= fp; g++) E[g] = 0;
+            for (g = 0; g <= Kf; g++) E[g] = 0;
             for (m = 0; m < n; m++) E[t[i + m]]++;
-            for (v = l, w = fp; w >= 1 && 0 === E[w]; w--);
+            for (v = l, w = Kf; w >= 1 && 0 === E[w]; w--);
             if (v > w && (v = w), 0 === w) return r[s++] = 20971520, r[s++] = 20971520, a.bits = 1, 0;
             for (b = 1; b < w && 0 === E[b]; b++);
-            for (v < b && (v = b), x = 1, g = 1; g <= fp; g++)
+            for (v < b && (v = b), x = 1, g = 1; g <= Kf; g++)
                 if (x <<= 1, x -= E[g], x < 0) return -1;
             if (x > 0 && (0 === e || 1 !== w)) return -1;
-            for (T[1] = 0, g = 1; g < fp; g++) T[g + 1] = T[g] + E[g];
-            for (m = 0; m < n; m++) 0 !== t[i + m] && (o[T[t[i + m]]++] = m);
-            if (0 === e ? (S = I = o, p = 19) : 1 === e ? (S = pp, A -= 257, I = gp, B -= 257, p = 256) : (S = mp, I = bp, p = -1), C = 0, m = 0, g = b, f = s, y = v, _ = 0, d = -1, k = 1 << v, u = k - 1, 1 === e && k > 852 || 2 === e && k > 592) return 1;
+            for (M[1] = 0, g = 1; g < Kf; g++) M[g + 1] = M[g] + E[g];
+            for (m = 0; m < n; m++) 0 !== t[i + m] && (o[M[t[i + m]]++] = m);
+            if (0 === e ? (S = I = o, p = 19) : 1 === e ? (S = Jf, A -= 257, I = ep, B -= 257, p = 256) : (S = tp, I = ip, p = -1), C = 0, m = 0, g = b, f = s, y = v, _ = 0, d = -1, k = 1 << v, u = k - 1, 1 === e && k > 852 || 2 === e && k > 592) return 1;
             for (;;) {
-                M = g - _, o[m] < p ? (R = 0, L = o[m]) : o[m] > p ? (R = I[B + o[m]], L = S[A + o[m]]) : (R = 96, L = 0), h = 1 << g - _, c = 1 << y, b = c;
+                T = g - _, o[m] < p ? (R = 0, L = o[m]) : o[m] > p ? (R = I[B + o[m]], L = S[A + o[m]]) : (R = 96, L = 0), h = 1 << g - _, c = 1 << y, b = c;
                 do {
-                    c -= h, r[f + (C >> _) + c] = M << 24 | R << 16 | L | 0
+                    c -= h, r[f + (C >> _) + c] = T << 24 | R << 16 | L | 0
                 } while (0 !== c);
                 for (h = 1 << g - 1; C & h;) h >>= 1;
                 if (0 !== h ? (C &= h - 1, C += h) : C = 0, m++, 0 == --E[g]) {
                     if (g === w) break;
                     g = t[i + o[m]]
                 }
                 if (g > v && (C & u) !== d) {
@@ -28479,268 +28650,268 @@
                     if (k += 1 << y, 1 === e && k > 852 || 2 === e && k > 592) return 1;
                     d = C & u, r[d] = v << 24 | y << 16 | f - s | 0
                 }
             }
             return 0 !== C && (r[f + C] = g - _ << 24 | 64 << 16 | 0), a.bits = v, 0
         },
         {
-            Z_FINISH: vp,
-            Z_BLOCK: yp,
-            Z_TREES: _p,
-            Z_OK: xp,
-            Z_STREAM_END: kp,
-            Z_NEED_DICT: Cp,
-            Z_STREAM_ERROR: Sp,
-            Z_DATA_ERROR: Ap,
-            Z_MEM_ERROR: Ep,
-            Z_BUF_ERROR: Tp,
-            Z_DEFLATED: Mp
-        } = sp,
-        Rp = 12,
-        Lp = 30,
-        Ip = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
+            Z_FINISH: rp,
+            Z_BLOCK: sp,
+            Z_TREES: op,
+            Z_OK: ap,
+            Z_STREAM_END: lp,
+            Z_NEED_DICT: hp,
+            Z_STREAM_ERROR: cp,
+            Z_DATA_ERROR: dp,
+            Z_MEM_ERROR: up,
+            Z_BUF_ERROR: fp,
+            Z_DEFLATED: pp
+        } = jf,
+        gp = 12,
+        mp = 30,
+        bp = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
 
-    function Bp() {
+    function wp() {
         this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
     }
-    var Np, Fp, Pp = e => {
-            if (!e || !e.state) return Sp;
+    var vp, yp, _p = e => {
+            if (!e || !e.state) return cp;
             const t = e.state;
-            return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, xp
+            return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, ap
         },
-        Op = e => {
-            if (!e || !e.state) return Sp;
+        xp = e => {
+            if (!e || !e.state) return cp;
             const t = e.state;
-            return t.wsize = 0, t.whave = 0, t.wnext = 0, Pp(e)
+            return t.wsize = 0, t.whave = 0, t.wnext = 0, _p(e)
         },
-        Dp = (e, t) => {
+        kp = (e, t) => {
             let i;
-            if (!e || !e.state) return Sp;
+            if (!e || !e.state) return cp;
             const n = e.state;
-            return t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Sp : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, Op(e))
+            return t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? cp : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, xp(e))
         },
-        zp = (e, t) => {
-            if (!e) return Sp;
-            const i = new Bp;
+        Cp = (e, t) => {
+            if (!e) return cp;
+            const i = new wp;
             e.state = i, i.window = null;
-            const n = Dp(e, t);
-            return n !== xp && (e.state = null), n
+            const n = kp(e, t);
+            return n !== ap && (e.state = null), n
         },
-        Hp = !0,
-        Vp = e => {
-            if (Hp) {
-                Np = new Int32Array(512), Fp = new Int32Array(32);
+        Sp = !0,
+        Ap = e => {
+            if (Sp) {
+                vp = new Int32Array(512), yp = new Int32Array(32);
                 let t = 0;
                 for (; t < 144;) e.lens[t++] = 8;
                 for (; t < 256;) e.lens[t++] = 9;
                 for (; t < 280;) e.lens[t++] = 7;
                 for (; t < 288;) e.lens[t++] = 8;
-                for (wp(1, e.lens, 0, 288, Np, 0, e.work, {
+                for (np(1, e.lens, 0, 288, vp, 0, e.work, {
                         bits: 9
                     }), t = 0; t < 32;) e.lens[t++] = 5;
-                wp(2, e.lens, 0, 32, Fp, 0, e.work, {
+                np(2, e.lens, 0, 32, yp, 0, e.work, {
                     bits: 5
-                }), Hp = !1
+                }), Sp = !1
             }
-            e.lencode = Np, e.lenbits = 9, e.distcode = Fp, e.distbits = 5
+            e.lencode = vp, e.lenbits = 9, e.distcode = yp, e.distbits = 5
         },
-        Up = (e, t, i, n) => {
+        Ep = (e, t, i, n) => {
             let r;
             const s = e.state;
             return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), n >= s.wsize ? (s.window.set(t.subarray(i - s.wsize, i), 0), s.wnext = 0, s.whave = s.wsize) : (r = s.wsize - s.wnext, r > n && (r = n), s.window.set(t.subarray(i - n, i - n + r), s.wnext), (n -= r) ? (s.window.set(t.subarray(i - n, i), 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += r, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += r))), 0
         },
-        qp = (e, t) => {
+        Mp = (e, t) => {
             let i, n, r, s, o, a, l, h, c, d, u, f, p, g, m, b, w, v, y, _, x, k, C = 0;
             const S = new Uint8Array(4);
             let A, E;
-            const T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
-            if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return Sp;
-            i = e.state, i.mode === Rp && (i.mode = 13), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, d = a, u = l, k = xp;
+            const M = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
+            if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return cp;
+            i = e.state, i.mode === gp && (i.mode = 13), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, d = a, u = l, k = ap;
             e: for (;;) switch (i.mode) {
                 case 1:
                     if (0 === i.wrap) {
                         i.mode = 13;
                         break
                     }
                     for (; c < 16;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if (2 & i.wrap && 35615 === h) {
-                        i.check = 0, S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = np(i.check, S, 2, 0), h = 0, c = 0, i.mode = 2;
+                        i.check = 0, S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Uf(i.check, S, 2, 0), h = 0, c = 0, i.mode = 2;
                         break
                     }
                     if (i.flags = 0, i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) {
-                        e.msg = "incorrect header check", i.mode = Lp;
+                        e.msg = "incorrect header check", i.mode = mp;
                         break
                     }
-                    if ((15 & h) !== Mp) {
-                        e.msg = "unknown compression method", i.mode = Lp;
+                    if ((15 & h) !== pp) {
+                        e.msg = "unknown compression method", i.mode = mp;
                         break
                     }
                     if (h >>>= 4, c -= 4, x = 8 + (15 & h), 0 === i.wbits) i.wbits = x;
                     else if (x > i.wbits) {
-                        e.msg = "invalid window size", i.mode = Lp;
+                        e.msg = "invalid window size", i.mode = mp;
                         break
                     }
-                    i.dmax = 1 << i.wbits, e.adler = i.check = 1, i.mode = 512 & h ? 10 : Rp, h = 0, c = 0;
+                    i.dmax = 1 << i.wbits, e.adler = i.check = 1, i.mode = 512 & h ? 10 : gp, h = 0, c = 0;
                     break;
                 case 2:
                     for (; c < 16;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    if (i.flags = h, (255 & i.flags) !== Mp) {
-                        e.msg = "unknown compression method", i.mode = Lp;
+                    if (i.flags = h, (255 & i.flags) !== pp) {
+                        e.msg = "unknown compression method", i.mode = mp;
                         break
                     }
                     if (57344 & i.flags) {
-                        e.msg = "unknown header flags set", i.mode = Lp;
+                        e.msg = "unknown header flags set", i.mode = mp;
                         break
                     }
-                    i.head && (i.head.text = h >> 8 & 1), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = np(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 3;
+                    i.head && (i.head.text = h >> 8 & 1), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Uf(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 3;
                 case 3:
                     for (; c < 32;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    i.head && (i.head.time = h), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, S[2] = h >>> 16 & 255, S[3] = h >>> 24 & 255, i.check = np(i.check, S, 4, 0)), h = 0, c = 0, i.mode = 4;
+                    i.head && (i.head.time = h), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, S[2] = h >>> 16 & 255, S[3] = h >>> 24 & 255, i.check = Uf(i.check, S, 4, 0)), h = 0, c = 0, i.mode = 4;
                 case 4:
                     for (; c < 16;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    i.head && (i.head.xflags = 255 & h, i.head.os = h >> 8), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = np(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 5;
+                    i.head && (i.head.xflags = 255 & h, i.head.os = h >> 8), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Uf(i.check, S, 2, 0)), h = 0, c = 0, i.mode = 5;
                 case 5:
                     if (1024 & i.flags) {
                         for (; c < 16;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
-                        i.length = h, i.head && (i.head.extra_len = h), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = np(i.check, S, 2, 0)), h = 0, c = 0
+                        i.length = h, i.head && (i.head.extra_len = h), 512 & i.flags && (S[0] = 255 & h, S[1] = h >>> 8 & 255, i.check = Uf(i.check, S, 2, 0)), h = 0, c = 0
                     } else i.head && (i.head.extra = null);
                     i.mode = 6;
                 case 6:
-                    if (1024 & i.flags && (f = i.length, f > a && (f = a), f && (i.head && (x = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(n.subarray(s, s + f), x)), 512 & i.flags && (i.check = np(i.check, n, f, s)), a -= f, s += f, i.length -= f), i.length)) break e;
+                    if (1024 & i.flags && (f = i.length, f > a && (f = a), f && (i.head && (x = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(n.subarray(s, s + f), x)), 512 & i.flags && (i.check = Uf(i.check, n, f, s)), a -= f, s += f, i.length -= f), i.length)) break e;
                     i.length = 0, i.mode = 7;
                 case 7:
                     if (2048 & i.flags) {
                         if (0 === a) break e;
                         f = 0;
                         do {
                             x = n[s + f++], i.head && x && i.length < 65536 && (i.head.name += String.fromCharCode(x))
                         } while (x && f < a);
-                        if (512 & i.flags && (i.check = np(i.check, n, f, s)), a -= f, s += f, x) break e
+                        if (512 & i.flags && (i.check = Uf(i.check, n, f, s)), a -= f, s += f, x) break e
                     } else i.head && (i.head.name = null);
                     i.length = 0, i.mode = 8;
                 case 8:
                     if (4096 & i.flags) {
                         if (0 === a) break e;
                         f = 0;
                         do {
                             x = n[s + f++], i.head && x && i.length < 65536 && (i.head.comment += String.fromCharCode(x))
                         } while (x && f < a);
-                        if (512 & i.flags && (i.check = np(i.check, n, f, s)), a -= f, s += f, x) break e
+                        if (512 & i.flags && (i.check = Uf(i.check, n, f, s)), a -= f, s += f, x) break e
                     } else i.head && (i.head.comment = null);
                     i.mode = 9;
                 case 9:
                     if (512 & i.flags) {
                         for (; c < 16;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         if (h !== (65535 & i.check)) {
-                            e.msg = "header crc mismatch", i.mode = Lp;
+                            e.msg = "header crc mismatch", i.mode = mp;
                             break
                         }
                         h = 0, c = 0
                     }
-                    i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = Rp;
+                    i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = gp;
                     break;
                 case 10:
                     for (; c < 32;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
-                    e.adler = i.check = Ip(h), h = 0, c = 0, i.mode = 11;
+                    e.adler = i.check = bp(h), h = 0, c = 0, i.mode = 11;
                 case 11:
-                    if (0 === i.havedict) return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, Cp;
-                    e.adler = i.check = 1, i.mode = Rp;
-                case Rp:
-                    if (t === yp || t === _p) break e;
+                    if (0 === i.havedict) return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, hp;
+                    e.adler = i.check = 1, i.mode = gp;
+                case gp:
+                    if (t === sp || t === op) break e;
                 case 13:
                     if (i.last) {
                         h >>>= 7 & c, c -= 7 & c, i.mode = 27;
                         break
                     }
                     for (; c < 3;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     switch (i.last = 1 & h, h >>>= 1, c -= 1, 3 & h) {
                         case 0:
                             i.mode = 14;
                             break;
                         case 1:
-                            if (Vp(i), i.mode = 20, t === _p) {
+                            if (Ap(i), i.mode = 20, t === op) {
                                 h >>>= 2, c -= 2;
                                 break e
                             }
                             break;
                         case 2:
                             i.mode = 17;
                             break;
                         case 3:
-                            e.msg = "invalid block type", i.mode = Lp
+                            e.msg = "invalid block type", i.mode = mp
                     }
                     h >>>= 2, c -= 2;
                     break;
                 case 14:
                     for (h >>>= 7 & c, c -= 7 & c; c < 32;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if ((65535 & h) != (h >>> 16 ^ 65535)) {
-                        e.msg = "invalid stored block lengths", i.mode = Lp;
+                        e.msg = "invalid stored block lengths", i.mode = mp;
                         break
                     }
-                    if (i.length = 65535 & h, h = 0, c = 0, i.mode = 15, t === _p) break e;
+                    if (i.length = 65535 & h, h = 0, c = 0, i.mode = 15, t === op) break e;
                 case 15:
                     i.mode = 16;
                 case 16:
                     if (f = i.length, f) {
                         if (f > a && (f = a), f > l && (f = l), 0 === f) break e;
                         r.set(n.subarray(s, s + f), o), a -= f, s += f, l -= f, o += f, i.length -= f;
                         break
                     }
-                    i.mode = Rp;
+                    i.mode = gp;
                     break;
                 case 17:
                     for (; c < 14;) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if (i.nlen = 257 + (31 & h), h >>>= 5, c -= 5, i.ndist = 1 + (31 & h), h >>>= 5, c -= 5, i.ncode = 4 + (15 & h), h >>>= 4, c -= 4, i.nlen > 286 || i.ndist > 30) {
-                        e.msg = "too many length or distance symbols", i.mode = Lp;
+                        e.msg = "too many length or distance symbols", i.mode = mp;
                         break
                     }
                     i.have = 0, i.mode = 18;
                 case 18:
                     for (; i.have < i.ncode;) {
                         for (; c < 3;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
-                        i.lens[T[i.have++]] = 7 & h, h >>>= 3, c -= 3
+                        i.lens[M[i.have++]] = 7 & h, h >>>= 3, c -= 3
                     }
-                    for (; i.have < 19;) i.lens[T[i.have++]] = 0;
+                    for (; i.have < 19;) i.lens[M[i.have++]] = 0;
                     if (i.lencode = i.lendyn, i.lenbits = 7, A = {
                             bits: i.lenbits
-                        }, k = wp(0, i.lens, 0, 19, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
-                        e.msg = "invalid code lengths set", i.mode = Lp;
+                        }, k = np(0, i.lens, 0, 19, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
+                        e.msg = "invalid code lengths set", i.mode = mp;
                         break
                     }
                     i.have = 0, i.mode = 19;
                 case 19:
                     for (; i.have < i.nlen + i.ndist;) {
                         for (; C = i.lencode[h & (1 << i.lenbits) - 1], m = C >>> 24, b = C >>> 16 & 255, w = 65535 & C, !(m <= c);) {
                             if (0 === a) break e;
@@ -28750,15 +28921,15 @@
                         else {
                             if (16 === w) {
                                 for (E = m + 2; c < E;) {
                                     if (0 === a) break e;
                                     a--, h += n[s++] << c, c += 8
                                 }
                                 if (h >>>= m, c -= m, 0 === i.have) {
-                                    e.msg = "invalid bit length repeat", i.mode = Lp;
+                                    e.msg = "invalid bit length repeat", i.mode = mp;
                                     break
                                 }
                                 x = i.lens[i.have - 1], f = 3 + (3 & h), h >>>= 2, c -= 2
                             } else if (17 === w) {
                                 for (E = m + 3; c < E;) {
                                     if (0 === a) break e;
                                     a--, h += n[s++] << c, c += 8
@@ -28768,43 +28939,43 @@
                                 for (E = m + 7; c < E;) {
                                     if (0 === a) break e;
                                     a--, h += n[s++] << c, c += 8
                                 }
                                 h >>>= m, c -= m, x = 0, f = 11 + (127 & h), h >>>= 7, c -= 7
                             }
                             if (i.have + f > i.nlen + i.ndist) {
-                                e.msg = "invalid bit length repeat", i.mode = Lp;
+                                e.msg = "invalid bit length repeat", i.mode = mp;
                                 break
                             }
                             for (; f--;) i.lens[i.have++] = x
                         }
                     }
-                    if (i.mode === Lp) break;
+                    if (i.mode === mp) break;
                     if (0 === i.lens[256]) {
-                        e.msg = "invalid code -- missing end-of-block", i.mode = Lp;
+                        e.msg = "invalid code -- missing end-of-block", i.mode = mp;
                         break
                     }
                     if (i.lenbits = 9, A = {
                             bits: i.lenbits
-                        }, k = wp(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
-                        e.msg = "invalid literal/lengths set", i.mode = Lp;
+                        }, k = np(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, A), i.lenbits = A.bits, k) {
+                        e.msg = "invalid literal/lengths set", i.mode = mp;
                         break
                     }
                     if (i.distbits = 6, i.distcode = i.distdyn, A = {
                             bits: i.distbits
-                        }, k = wp(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, A), i.distbits = A.bits, k) {
-                        e.msg = "invalid distances set", i.mode = Lp;
+                        }, k = np(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, A), i.distbits = A.bits, k) {
+                        e.msg = "invalid distances set", i.mode = mp;
                         break
                     }
-                    if (i.mode = 20, t === _p) break e;
+                    if (i.mode = 20, t === op) break e;
                 case 20:
                     i.mode = 21;
                 case 21:
                     if (a >= 6 && l >= 258) {
-                        e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, up(e, u), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, i.mode === Rp && (i.back = -1);
+                        e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, Yf(e, u), o = e.next_out, r = e.output, l = e.avail_out, s = e.next_in, n = e.input, a = e.avail_in, h = i.hold, c = i.bits, i.mode === gp && (i.back = -1);
                         break
                     }
                     for (i.back = 0; C = i.lencode[h & (1 << i.lenbits) - 1], m = C >>> 24, b = C >>> 16 & 255, w = 65535 & C, !(m <= c);) {
                         if (0 === a) break e;
                         a--, h += n[s++] << c, c += 8
                     }
                     if (b && 0 == (240 & b)) {
@@ -28815,19 +28986,19 @@
                         h >>>= v, c -= v, i.back += v
                     }
                     if (h >>>= m, c -= m, i.back += m, i.length = w, 0 === b) {
                         i.mode = 26;
                         break
                     }
                     if (32 & b) {
-                        i.back = -1, i.mode = Rp;
+                        i.back = -1, i.mode = gp;
                         break
                     }
                     if (64 & b) {
-                        e.msg = "invalid literal/length code", i.mode = Lp;
+                        e.msg = "invalid literal/length code", i.mode = mp;
                         break
                     }
                     i.extra = 15 & b, i.mode = 22;
                 case 22:
                     if (i.extra) {
                         for (E = i.extra; c < E;) {
                             if (0 === a) break e;
@@ -28845,36 +29016,36 @@
                         for (v = m, y = b, _ = w; C = i.distcode[_ + ((h & (1 << v + y) - 1) >> v)], m = C >>> 24, b = C >>> 16 & 255, w = 65535 & C, !(v + m <= c);) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         h >>>= v, c -= v, i.back += v
                     }
                     if (h >>>= m, c -= m, i.back += m, 64 & b) {
-                        e.msg = "invalid distance code", i.mode = Lp;
+                        e.msg = "invalid distance code", i.mode = mp;
                         break
                     }
                     i.offset = w, i.extra = 15 & b, i.mode = 24;
                 case 24:
                     if (i.extra) {
                         for (E = i.extra; c < E;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         i.offset += h & (1 << i.extra) - 1, h >>>= i.extra, c -= i.extra, i.back += i.extra
                     }
                     if (i.offset > i.dmax) {
-                        e.msg = "invalid distance too far back", i.mode = Lp;
+                        e.msg = "invalid distance too far back", i.mode = mp;
                         break
                     }
                     i.mode = 25;
                 case 25:
                     if (0 === l) break e;
                     if (f = u - l, i.offset > f) {
                         if (f = i.offset - f, f > i.whave && i.sane) {
-                            e.msg = "invalid distance too far back", i.mode = Lp;
+                            e.msg = "invalid distance too far back", i.mode = mp;
                             break
                         }
                         f > i.wnext ? (f -= i.wnext, p = i.wsize - f) : p = i.wnext - f, f > i.length && (f = i.length), g = i.window
                     } else g = r, p = o - i.offset, f = i.length;
                     f > l && (f = l), l -= f, i.length -= f;
                     do {
                         r[o++] = g[p++]
@@ -28887,159 +29058,159 @@
                     break;
                 case 27:
                     if (i.wrap) {
                         for (; c < 32;) {
                             if (0 === a) break e;
                             a--, h |= n[s++] << c, c += 8
                         }
-                        if (u -= l, e.total_out += u, i.total += u, u && (e.adler = i.check = i.flags ? np(i.check, r, u, o - u) : tp(i.check, r, u, o - u)), u = l, (i.flags ? h : Ip(h)) !== i.check) {
-                            e.msg = "incorrect data check", i.mode = Lp;
+                        if (u -= l, e.total_out += u, i.total += u, u && (e.adler = i.check = i.flags ? Uf(i.check, r, u, o - u) : Hf(i.check, r, u, o - u)), u = l, (i.flags ? h : bp(h)) !== i.check) {
+                            e.msg = "incorrect data check", i.mode = mp;
                             break
                         }
                         h = 0, c = 0
                     }
                     i.mode = 28;
                 case 28:
                     if (i.wrap && i.flags) {
                         for (; c < 32;) {
                             if (0 === a) break e;
                             a--, h += n[s++] << c, c += 8
                         }
                         if (h !== (4294967295 & i.total)) {
-                            e.msg = "incorrect length check", i.mode = Lp;
+                            e.msg = "incorrect length check", i.mode = mp;
                             break
                         }
                         h = 0, c = 0
                     }
                     i.mode = 29;
                 case 29:
-                    k = kp;
+                    k = lp;
                     break e;
-                case Lp:
-                    k = Ap;
+                case mp:
+                    k = dp;
                     break e;
                 case 31:
-                    return Ep;
+                    return up;
                 default:
-                    return Sp
+                    return cp
             }
-            return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, (i.wsize || u !== e.avail_out && i.mode < Lp && (i.mode < 27 || t !== vp)) && Up(e, e.output, e.next_out, u - e.avail_out), d -= e.avail_in, u -= e.avail_out, e.total_in += d, e.total_out += u, i.total += u, i.wrap && u && (e.adler = i.check = i.flags ? np(i.check, r, u, e.next_out - u) : tp(i.check, r, u, e.next_out - u)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === Rp ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0), (0 === d && 0 === u || t === vp) && k === xp && (k = Tp), k
+            return e.next_out = o, e.avail_out = l, e.next_in = s, e.avail_in = a, i.hold = h, i.bits = c, (i.wsize || u !== e.avail_out && i.mode < mp && (i.mode < 27 || t !== rp)) && Ep(e, e.output, e.next_out, u - e.avail_out), d -= e.avail_in, u -= e.avail_out, e.total_in += d, e.total_out += u, i.total += u, i.wrap && u && (e.adler = i.check = i.flags ? Uf(i.check, r, u, e.next_out - u) : Hf(i.check, r, u, e.next_out - u)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === gp ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0), (0 === d && 0 === u || t === rp) && k === ap && (k = fp), k
         },
-        jp = {
-            inflateReset: Op,
-            inflateReset2: Dp,
-            inflateResetKeep: Pp,
-            inflateInit: e => zp(e, 15),
-            inflateInit2: zp,
-            inflate: qp,
+        Tp = {
+            inflateReset: xp,
+            inflateReset2: kp,
+            inflateResetKeep: _p,
+            inflateInit: e => Cp(e, 15),
+            inflateInit2: Cp,
+            inflate: Mp,
             inflateEnd: e => {
-                if (!e || !e.state) return Sp;
+                if (!e || !e.state) return cp;
                 let t = e.state;
-                return t.window && (t.window = null), e.state = null, xp
+                return t.window && (t.window = null), e.state = null, ap
             },
             inflateGetHeader: (e, t) => {
-                if (!e || !e.state) return Sp;
+                if (!e || !e.state) return cp;
                 const i = e.state;
-                return 0 == (2 & i.wrap) ? Sp : (i.head = t, t.done = !1, xp)
+                return 0 == (2 & i.wrap) ? cp : (i.head = t, t.done = !1, ap)
             },
             inflateSetDictionary: (e, t) => {
                 const i = t.length;
                 let n, r, s;
-                return e && e.state ? (n = e.state, 0 !== n.wrap && 11 !== n.mode ? Sp : 11 === n.mode && (r = 1, r = tp(r, t, i, 0), r !== n.check) ? Ap : (s = Up(e, t, i, i), s ? (n.mode = 31, Ep) : (n.havedict = 1, xp))) : Sp
+                return e && e.state ? (n = e.state, 0 !== n.wrap && 11 !== n.mode ? cp : 11 === n.mode && (r = 1, r = Hf(r, t, i, 0), r !== n.check) ? dp : (s = Ep(e, t, i, i), s ? (n.mode = 31, up) : (n.havedict = 1, ap))) : cp
             },
             inflateInfo: "pako inflate (from Nodeca project)"
         };
-    var $p = function() {
+    var Rp = function() {
             this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
         },
-        Wp = Object.prototype.toString,
+        Lp = Object.prototype.toString,
         {
-            Z_NO_FLUSH: Gp,
-            Z_FINISH: Zp,
-            Z_OK: Qp,
-            Z_STREAM_END: Xp,
-            Z_NEED_DICT: Yp,
-            Z_STREAM_ERROR: Kp,
-            Z_DATA_ERROR: Jp,
-            Z_MEM_ERROR: eg
-        } = sp;
+            Z_NO_FLUSH: Ip,
+            Z_FINISH: Bp,
+            Z_OK: Fp,
+            Z_STREAM_END: Np,
+            Z_NEED_DICT: Op,
+            Z_STREAM_ERROR: Pp,
+            Z_DATA_ERROR: Dp,
+            Z_MEM_ERROR: zp
+        } = jf;
 
-    function tg(e) {
-        this.options = ap.assign({
+    function Hp(e) {
+        this.options = Wf.assign({
             chunkSize: 65536,
             windowBits: 15,
             to: ""
         }, e || {});
         const t = this.options;
-        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new dp, this.strm.avail_out = 0;
-        let i = jp.inflateInit2(this.strm, t.windowBits);
-        if (i !== Qp) throw new Error(rp[i]);
-        if (this.header = new $p, jp.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = cp.string2buf(t.dictionary) : "[object ArrayBuffer]" === Wp.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = jp.inflateSetDictionary(this.strm, t.dictionary), i !== Qp))) throw new Error(rp[i])
+        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Xf, this.strm.avail_out = 0;
+        let i = Tp.inflateInit2(this.strm, t.windowBits);
+        if (i !== Fp) throw new Error(qf[i]);
+        if (this.header = new Rp, Tp.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = Qf.string2buf(t.dictionary) : "[object ArrayBuffer]" === Lp.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = Tp.inflateSetDictionary(this.strm, t.dictionary), i !== Fp))) throw new Error(qf[i])
     }
 
-    function ig(e, t) {
-        const i = new tg(t);
-        if (i.push(e), i.err) throw i.msg || rp[i.err];
+    function Vp(e, t) {
+        const i = new Hp(t);
+        if (i.push(e), i.err) throw i.msg || qf[i.err];
         return i.result
     }
-    tg.prototype.push = function(e, t) {
+    Hp.prototype.push = function(e, t) {
         const i = this.strm,
             n = this.options.chunkSize,
             r = this.options.dictionary;
         let s, o, a;
         if (this.ended) return !1;
-        for (o = t === ~~t ? t : !0 === t ? Zp : Gp, "[object ArrayBuffer]" === Wp.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;) {
-            for (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), s = jp.inflate(i, o), s === Yp && r && (s = jp.inflateSetDictionary(i, r), s === Qp ? s = jp.inflate(i, o) : s === Jp && (s = Yp)); i.avail_in > 0 && s === Xp && i.state.wrap > 0 && 0 !== e[i.next_in];) jp.inflateReset(i), s = jp.inflate(i, o);
+        for (o = t === ~~t ? t : !0 === t ? Bp : Ip, "[object ArrayBuffer]" === Lp.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;) {
+            for (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), s = Tp.inflate(i, o), s === Op && r && (s = Tp.inflateSetDictionary(i, r), s === Fp ? s = Tp.inflate(i, o) : s === Dp && (s = Op)); i.avail_in > 0 && s === Np && i.state.wrap > 0 && 0 !== e[i.next_in];) Tp.inflateReset(i), s = Tp.inflate(i, o);
             switch (s) {
-                case Kp:
-                case Jp:
-                case Yp:
-                case eg:
+                case Pp:
+                case Dp:
+                case Op:
+                case zp:
                     return this.onEnd(s), this.ended = !0, !1
             }
-            if (a = i.avail_out, i.next_out && (0 === i.avail_out || s === Xp))
+            if (a = i.avail_out, i.next_out && (0 === i.avail_out || s === Np))
                 if ("string" === this.options.to) {
-                    let e = cp.utf8border(i.output, i.next_out),
+                    let e = Qf.utf8border(i.output, i.next_out),
                         t = i.next_out - e,
-                        r = cp.buf2string(i.output, e);
+                        r = Qf.buf2string(i.output, e);
                     i.next_out = t, i.avail_out = n - t, t && i.output.set(i.output.subarray(e, e + t), 0), this.onData(r)
                 } else this.onData(i.output.length === i.next_out ? i.output : i.output.subarray(0, i.next_out));
-            if (s !== Qp || 0 !== a) {
-                if (s === Xp) return s = jp.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
+            if (s !== Fp || 0 !== a) {
+                if (s === Np) return s = Tp.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
                 if (0 === i.avail_in) break
             }
         }
         return !0
-    }, tg.prototype.onData = function(e) {
+    }, Hp.prototype.onData = function(e) {
         this.chunks.push(e)
-    }, tg.prototype.onEnd = function(e) {
-        e === Qp && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = ap.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
+    }, Hp.prototype.onEnd = function(e) {
+        e === Fp && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Wf.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
     };
-    var ng = function(e, t) {
-            return (t = t || {}).raw = !0, ig(e, t)
+    var Up = function(e, t) {
+            return (t = t || {}).raw = !0, Vp(e, t)
         },
-        rg = {
-            Inflate: tg,
-            inflate: ig,
-            inflateRaw: ng,
-            ungzip: ig,
-            constants: sp
+        qp = {
+            Inflate: Hp,
+            inflate: Vp,
+            inflateRaw: Up,
+            ungzip: Vp,
+            constants: jf
         },
         {
-            Inflate: sg,
-            inflate: og,
-            inflateRaw: ag,
-            ungzip: lg
-        } = rg,
-        hg = og,
-        cg = lg;
-    var dg = new Map([
+            Inflate: jp,
+            inflate: $p,
+            inflateRaw: Wp,
+            ungzip: Gp
+        } = qp,
+        Zp = $p,
+        Qp = Gp;
+    var Xp = new Map([
             [1, function(e, t) {
                 let i = new Uint8Array(e);
-                return hg(i).buffer
+                return Zp(i).buffer
             }],
             [2, function(e, t) {
                 let i = e.byteLength,
                     n = new Uint8Array(i),
                     r = Math.floor(i / t),
                     s = new DataView(e);
                 for (var o = 0; o < t; o++)
@@ -29050,20 +29221,20 @@
                 return function(e) {
                     for (var t = e.byteLength % 2 != 0, i = e.byteLength - 4, n = new DataView(e), r = 0, s = 0, o = 0; o < i - 1; o += 2) {
                         s = (s + (r = (r + n.getUint16(o, !0)) % 65535)) % 65535
                     }
                     if (t) {
                         s = (s + (r = (r + n.getUint8(i - 1)) % 65535)) % 65535
                     }
-                    var [a, l] = Pf.unpack_from(">HH", e, i);
+                    var [a, l] = _f.unpack_from(">HH", e, i);
                     if (l %= 65535, r != (a %= 65535) || s != l) throw 'ValueError("fletcher32 checksum invalid")'
                 }(e), e.slice(0, -4)
             }]
         ]),
-        ug = class {
+        Yp = class {
             constructor(e, t) {
                 this.fh = e, this.offset = t, this.depth = null
             }
             async init() {
                 this.all_nodes = new Map, await this._read_root_node(), await this._read_children()
             }
             async _read_children() {
@@ -29086,74 +29257,74 @@
                 let i = await this._read_node_header(e, t);
                 return i.set("keys", []), i.set("addresses", []), i
             }
             async _read_node_header(e) {
                 throw "NotImplementedError: must define _read_node_header in implementation class"
             }
         },
-        fg = class extends ug {
+        Kp = class extends Yp {
             B_LINK_NODE = new Map([
                 ["signature", "4s"],
                 ["node_type", "B"],
                 ["node_level", "B"],
                 ["entries_used", "H"],
                 ["left_sibling", "Q"],
                 ["right_sibling", "Q"]
             ]);
             async _read_node_header(e, t) {
-                let i = await Mf(this.B_LINK_NODE, this.fh, e);
+                let i = await pf(this.B_LINK_NODE, this.fh, e);
                 if (null != t && i.get("node_level") != t) throw "node level does not match";
                 return i
             }
         },
-        pg = class extends fg {
+        Jp = class extends Kp {
             NODE_TYPE = 0;
             constructor(e, t) {
                 super(e, t), this.ready = this.init()
             }
             async _read_node(e, t) {
                 let i = await this._read_node_header(e, t);
-                e += If(this.B_LINK_NODE);
+                e += bf(this.B_LINK_NODE);
                 let n = [],
                     r = [],
                     s = i.get("entries_used");
                 for (var o = 0; o < s; o++) {
-                    let t = (await Pf.unpack_from_async("<Q", this.fh, e))[0];
+                    let t = (await _f.unpack_from_async("<Q", this.fh, e))[0];
                     e += 8;
-                    let i = (await Pf.unpack_from_async("<Q", this.fh, e))[0];
+                    let i = (await _f.unpack_from_async("<Q", this.fh, e))[0];
                     e += 8, n.push(t), r.push(i)
                 }
-                return n.push((await Pf.unpack_from_async("<Q", this.fh, e))[0]), i.set("keys", n), i.set("addresses", r), i
+                return n.push((await _f.unpack_from_async("<Q", this.fh, e))[0]), i.set("keys", n), i.set("addresses", r), i
             }
             symbol_table_addresses() {
                 var e = [],
                     t = this.all_nodes.get(0);
                 for (var i of t) e = e.concat(i.get("addresses"));
                 return e
             }
         },
-        gg = class extends fg {
+        eg = class extends Kp {
             NODE_TYPE = 1;
             constructor(e, t, i) {
                 super(e, t), this.dims = i, this.ready = this.init()
             }
             async _read_node(e, t) {
                 let i = await this._read_node_header(e, t);
-                e += If(this.B_LINK_NODE);
+                e += bf(this.B_LINK_NODE);
                 var n = [],
                     r = [];
                 let s = i.get("entries_used");
                 for (var o = 0; o < s; o++) {
-                    let [t, i] = await Pf.unpack_from_async("<II", this.fh, e);
+                    let [t, i] = await _f.unpack_from_async("<II", this.fh, e);
                     e += 8;
                     let s = "<" + this.dims.toFixed() + "Q",
-                        o = Pf.calcsize(s),
-                        a = await Pf.unpack_from_async(s, this.fh, e);
+                        o = _f.calcsize(s),
+                        a = await _f.unpack_from_async(s, this.fh, e);
                     e += o;
-                    let l = (await Pf.unpack_from_async("<Q", this.fh, e))[0];
+                    let l = (await _f.unpack_from_async("<Q", this.fh, e))[0];
                     e += 8, n.push(new Map([
                         ["chunk_size", t],
                         ["filter_mask", i],
                         ["chunk_offset", a]
                     ])), r.push(l)
                 }
                 return i.set("keys", n), i.set("addresses", r), i
@@ -29166,15 +29337,15 @@
                         if (8 != i[1]) throw "NotImplementedError('Unsupported Reference type')";
                         i = "<u8";
                         r = "getUint64", s = !1, o = 8
                     } else {
                         if ("VLEN_STRING" != e && "VLEN_SEQUENCE" != e) throw "NotImplementedError('datatype not implemented')";
                         r = "getVLENStruct", s = !1, o = 16
                     }
-                } else [r, s, o] = Ff(i);
+                } else [r, s, o] = yf(i);
                 var a = t.reduce((function(e, t) {
                         return e * t
                     }), 1),
                     l = e.reduce((function(e, t) {
                         return e * t
                     }), 1);
                 let h = t.length;
@@ -29202,15 +29373,15 @@
                         else {
                             m = await this.fh.slice(p, p + c.get("chunk_size"));
                             let e = c.get("filter_mask");
                             m = this._filter_chunk(m, e, n, o)
                         }
                         for (var b = c.get("chunk_offset").slice(), w = b.slice(), v = w.map((function() {
                                 return 0
-                            })), y = new Of(m), _ = 0; _ < l; _++) {
+                            })), y = new xf(m), _ = 0; _ < l; _++) {
                             for (var x = h - 1; x >= 0 && v[x] >= e[x]; x--) v[x] = 0, w[x] = b[x], x > 0 && (v[x - 1] += 1, w[x - 1] += 1);
                             if (w.slice(0, -1).every((function(e, i) {
                                     return e < t[i]
                                 }))) {
                                 let e = _ * o,
                                     t = y[r](e, !s, o),
                                     i = w.slice(0, -1).reduce((function(e, t, i) {
@@ -29228,21 +29399,21 @@
                 let r = i.length,
                     s = e.slice();
                 for (var o = r - 1; o >= 0; o--) {
                     if (t & 1 << o) continue;
                     let e = i[o],
                         r = e.get("filter_id"),
                         a = e.get("client_data");
-                    if (!dg.has(r)) throw 'NotImplementedError("Filter with id:' + r.toFixed() + ' not supported")';
-                    s = dg.get(r)(s, n, a)
+                    if (!Xp.has(r)) throw 'NotImplementedError("Filter with id:' + r.toFixed() + ' not supported")';
+                    s = Xp.get(r)(s, n, a)
                 }
                 return s
             }
         },
-        mg = class extends ug {
+        tg = class extends Yp {
             B_TREE_HEADER = new Map([
                 ["signature", "4s"],
                 ["version", "B"],
                 ["node_type", "B"],
                 ["node_size", "I"],
                 ["record_size", "H"],
                 ["depth", "H"],
@@ -29264,15 +29435,15 @@
                 let e = await this._read_tree_header(this.offset);
                 this.address_formats = this._calculate_address_formats(e), this.header = e, this.depth = e.get("depth");
                 let t = [e.get("root_address"), e.get("root_nrecords"), e.get("total_nrecords")],
                     i = await this._read_node(t, this.depth);
                 this._add_node(i)
             }
             async _read_tree_header(e) {
-                return await Mf(this.B_TREE_HEADER, this.fh, this.offset)
+                return await pf(this.B_TREE_HEADER, this.fh, this.offset)
             }
             _calculate_address_formats(e) {
                 let t = e.get("node_size"),
                     i = e.get("record_size"),
                     n = 0,
                     r = 0,
                     s = new Map,
@@ -29288,93 +29459,93 @@
                 }
                 return s
             }
             _nrecords_max(e, t, i) {
                 return Math.floor((e - 10 - i) / (t + i))
             }
             _required_bytes(e) {
-                return Math.ceil(Df(e) / 8)
+                return Math.ceil(kf(e) / 8)
             }
             _int_format(e) {
                 return ["<B", "<H", "<I", "<Q"][e - 1]
             }
             async _read_node(e, t) {
                 let [i, n, r] = e, s = this._read_node_header(i, t);
-                i += If(this.B_LINK_NODE);
+                i += bf(this.B_LINK_NODE);
                 let o = this.header.get("record_size"),
                     a = [];
                 for (let e = 0; e < n; e++) {
                     let e = await this._parse_record(this.fh, i, o);
                     i += o, a.push(e)
                 }
                 let l = [],
                     h = this.address_formats.get(t);
                 if (0 != t) {
                     let [e, t, r, s, o, a] = h;
                     for (let h = 0; h <= n; h++) {
-                        let n = (await Pf.unpack_from_async(s, this.fh, i))[0];
+                        let n = (await _f.unpack_from_async(s, this.fh, i))[0];
                         i += e;
-                        let h = (await Pf.unpack_from_async(o, this.fh, i))[0];
+                        let h = (await _f.unpack_from_async(o, this.fh, i))[0];
                         i += t;
                         let c = h;
-                        r > 0 && (c = (await Pf.unpack_from_async(a, this.fh, i))[0], i += r), l.push([n, h, c])
+                        r > 0 && (c = (await _f.unpack_from_async(a, this.fh, i))[0], i += r), l.push([n, h, c])
                     }
                 }
                 return s.set("keys", a), s.set("addresses", l), s
             }
             async _read_node_header(e, t) {
-                let i = await Mf(this.B_LINK_NODE, this.fh, e);
+                let i = await pf(this.B_LINK_NODE, this.fh, e);
                 return i.set("node_level", t), i
             }* iter_records() {
                 for (let e of this.all_nodes.values())
                     for (let t of e)
                         for (let e of t.get("keys")) yield e
             }
             _parse_record(e) {
                 throw "NotImplementedError"
             }
         },
-        bg = class extends mg {
+        ig = class extends tg {
             NODE_TYPE = 5;
             async _parse_record(e, t, i) {
-                let n = (await Pf.unpack_from_async("<I", e, t))[0];
+                let n = (await _f.unpack_from_async("<I", e, t))[0];
                 t += 4;
                 const r = await e.slice(t, t + 7);
                 return new Map([
                     ["namehash", n],
                     ["heapid", r]
                 ])
             }
         },
-        wg = class extends mg {
+        ng = class extends tg {
             NODE_TYPE = 6;
             async _parse_record(e, t, i) {
-                let n = (await Pf.unpack_from_async("<Q", e, t))[0];
+                let n = (await _f.unpack_from_async("<Q", e, t))[0];
                 t += 8;
                 const r = await e.slice(t, t + 7);
                 return new Map([
                     ["creationorder", n],
                     ["heapid", r]
                 ])
             }
         },
-        vg = class {
+        rg = class {
             constructor(e, t, i = !1) {
                 this.ready = this.init(e, t, i)
             }
             async init(e, t, i) {
                 var n;
                 if (i) n = new Map([
                     ["symbols", 1]
                 ]);
                 else {
-                    if ("SNOD" != (n = await Mf(Mg, e, t)).get("signature")) throw "incorrect node type";
-                    t += Rg
+                    if ("SNOD" != (n = await pf(pg, e, t)).get("signature")) throw "incorrect node type";
+                    t += gg
                 }
-                for (var r = [], s = n.get("symbols"), o = 0; o < s; o++) r.push(await Mf(Eg, e, t)), t += Tg;
+                for (var r = [], s = n.get("symbols"), o = 0; o < s; o++) r.push(await pf(ug, e, t)), t += fg;
                 return i && (this.group_offset = r[0].get("object_header_address")), this.entries = r, this._contents = n, this
             }
             assign_name(e) {
                 this.entries.forEach((function(t) {
                     let i = t.get("link_name_offset"),
                         n = e.get_object_name(i);
                     t.set("link_name", n)
@@ -29387,48 +29558,48 @@
                         r = i.get("link_name");
                     if (0 == n || 1 == n) t[r] = i.get("object_header_address");
                     else if (2 == n) {
                         let n = i.get("scratch"),
                             o = new ArrayBuffer(4),
                             a = new Uint8Array(o);
                         for (var s = 0; s < 4; s++) a[s] = n.charCodeAt(s);
-                        let l = Pf.unpack_from("<I", o, 0)[0];
+                        let l = _f.unpack_from("<I", o, 0)[0];
                         t[r] = e.get_object_name(l)
                     }
                 })), t
             }
         },
-        yg = class {
+        sg = class {
             constructor(e, t) {
                 this.ready = this.init(e, t)
             }
             async init(e, t) {
-                let i = await Mf(Ig, e, t);
-                t += Bg;
-                let n = i.get("collection_size") - Bg,
+                let i = await pf(bg, e, t);
+                t += wg;
+                let n = i.get("collection_size") - wg,
                     r = await e.slice(t, t + n);
                 this.heap_data = r, this._header = i, this._objects = null
             }
             get objects() {
                 if (null == this._objects) {
                     this._objects = new Map;
-                    for (var e = 0; e <= this.heap_data.byteLength - Fg;) {
-                        let t = Rf(Ng, this.heap_data, e);
+                    for (var e = 0; e <= this.heap_data.byteLength - yg;) {
+                        let t = gf(vg, this.heap_data, e);
                         if (0 == t.get("object_index")) break;
-                        e += Fg;
+                        e += yg;
                         let i = this.heap_data.slice(e, e + t.get("object_size"));
-                        this._objects.set(t.get("object_index"), i), e += Bf(t.get("object_size"))
+                        this._objects.set(t.get("object_index"), i), e += wf(t.get("object_size"))
                     }
                 }
                 return this._objects
             }
         },
-        _g = Pf.unpack_from("8s", new Uint8Array([137, 72, 68, 70, 13, 10, 26, 10]).buffer)[0],
-        xg = Pf.unpack_from("<Q", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer)[0],
-        kg = new Map([
+        og = _f.unpack_from("8s", new Uint8Array([137, 72, 68, 70, 13, 10, 26, 10]).buffer)[0],
+        ag = _f.unpack_from("<Q", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer)[0],
+        lg = new Map([
             ["format_signature", "8s"],
             ["superblock_version", "B"],
             ["free_storage_version", "B"],
             ["root_group_version", "B"],
             ["reserved_0", "B"],
             ["shared_header_version", "B"],
             ["offset_size", "B"],
@@ -29438,66 +29609,66 @@
             ["group_internal_node_k", "H"],
             ["file_consistency_flags", "L"],
             ["base_address_lower", "Q"],
             ["free_space_address", "Q"],
             ["end_of_file_address", "Q"],
             ["driver_information_address", "Q"]
         ]),
-        Cg = If(kg),
-        Sg = new Map([
+        hg = bf(lg),
+        cg = new Map([
             ["format_signature", "8s"],
             ["superblock_version", "B"],
             ["offset_size", "B"],
             ["length_size", "B"],
             ["file_consistency_flags", "B"],
             ["base_address", "Q"],
             ["superblock_extension_address", "Q"],
             ["end_of_file_address", "Q"],
             ["root_group_address", "Q"],
             ["superblock_checksum", "I"]
         ]),
-        Ag = If(Sg),
-        Eg = new Map([
+        dg = bf(cg),
+        ug = new Map([
             ["link_name_offset", "Q"],
             ["object_header_address", "Q"],
             ["cache_type", "I"],
             ["reserved", "I"],
             ["scratch", "16s"]
         ]),
-        Tg = If(Eg),
-        Mg = new Map([
+        fg = bf(ug),
+        pg = new Map([
             ["signature", "4s"],
             ["version", "B"],
             ["reserved_0", "B"],
             ["symbols", "H"]
         ]),
-        Rg = If(Mg),
-        Lg = new Map([
+        gg = bf(pg),
+        mg = new Map([
             ["signature", "4s"],
             ["version", "B"],
             ["reserved", "3s"],
             ["data_segment_size", "Q"],
             ["offset_to_free_list", "Q"],
             ["address_of_data_segment", "Q"]
         ]),
-        Ig = new Map([
+        bg = new Map([
             ["signature", "4s"],
             ["version", "B"],
             ["reserved", "3s"],
             ["collection_size", "Q"]
         ]),
-        Bg = If(Ig),
-        Ng = new Map([
+        wg = bf(bg),
+        vg = new Map([
             ["object_index", "H"],
             ["reference_count", "H"],
             ["reserved", "I"],
             ["object_size", "Q"]
         ]),
-        Fg = If(Ng),
-        Pg = new Map([
+        yg = bf(vg),
+        _g = new Map([
             ["signature", "4s"],
             ["version", "B"],
             ["object_index_size", "H"],
             ["filter_info_size", "H"],
             ["flags", "B"],
             ["max_managed_object_size", "I"],
             ["next_huge_object_index", "Q"],
@@ -29516,246 +29687,246 @@
             ["starting_block_size", "Q"],
             ["maximum_direct_block_size", "Q"],
             ["log2_maximum_heap_size", "H"],
             ["indirect_starting_rows_count", "H"],
             ["root_block_address", "Q"],
             ["indirect_current_rows_count", "H"]
         ]),
-        Og = class {
+        xg = class {
             constructor(e, t) {
                 this.ready = this.init(e, t)
             }
             async init(e, t) {
-                let i = (await Pf.unpack_from_async("<B", e, t))[0];
+                let i = (await _f.unpack_from_async("<B", e, t))[0];
                 if (1 == i) var [n, r, s] = await this._parse_v1_objects(e, t);
                 else {
                     if (i != "O".charCodeAt(0)) throw "InvalidHDF5File('unknown Data Object Header')";
                     var [n, r, s] = await this._parse_v2_objects(e, t)
                 }
                 this.fh = e, this.msgs = n, this.msg_data = r, this.offset = t, this._global_heaps = {}, this._header = s, this._filter_pipeline = null, this._chunk_params_set = !1, this._chunks = null, this._chunk_dims = null, this._chunk_address = null
             }
             get dtype() {
-                let e = this.find_msg_type(dm)[0].get("offset_to_message");
-                return new Hf(this.fh, e).dtype
+                let e = this.find_msg_type(Xg)[0].get("offset_to_message");
+                return new Sf(this.fh, e).dtype
             }
             get chunks() {
                 return this._get_chunk_params().then((() => this._chunks))
             }
             get shape() {
-                let e = this.find_msg_type(hm)[0].get("offset_to_message");
+                let e = this.find_msg_type(Zg)[0].get("offset_to_message");
                 return async function(e, t) {
-                    let i = (await Pf.unpack_from_async("<B", e, t))[0];
+                    let i = (await _f.unpack_from_async("<B", e, t))[0];
                     var n;
-                    if (1 == i) Lf(1 == (n = await Mf(Wg, e, t)).get("version")), t += Gg;
+                    if (1 == i) mf(1 == (n = await pf(Lg, e, t)).get("version")), t += Ig;
                     else {
                         if (2 != i) throw "InvalidHDF5File('unknown dataspace message version')";
-                        Lf(2 == (n = await Mf(Zg, e, t)).get("version")), t += Qg
+                        mf(2 == (n = await pf(Bg, e, t)).get("version")), t += Fg
                     }
                     let r = n.get("dimensionality"),
-                        s = await Pf.unpack_from_async("<" + (2 * r).toFixed() + "I", e, t);
+                        s = await _f.unpack_from_async("<" + (2 * r).toFixed() + "I", e, t);
                     return s.filter((function(e, t) {
                         return t % 2 == 0
                     }))
                 }(this.fh, e)
             }
             async get_filter_pipeline() {
                 if (null != this._filter_pipeline) return this._filter_pipeline;
-                let e = this.find_msg_type(gm);
+                let e = this.find_msg_type(em);
                 if (!e.length) return this._filter_pipeline = null, this._filter_pipeline;
                 var t = e[0].get("offset_to_message");
-                let [i, n] = await Pf.unpack_from_async("<BB", this.fh, t);
-                t += Pf.calcsize("<BB");
+                let [i, n] = await _f.unpack_from_async("<BB", this.fh, t);
+                t += _f.calcsize("<BB");
                 var r = [];
                 if (1 == i) {
-                    await Pf.unpack_from_async("<HI", this.fh, t), t += Pf.calcsize("<HI");
+                    await _f.unpack_from_async("<HI", this.fh, t), t += _f.calcsize("<HI");
                     for (var s = 0; s < n; s++) {
-                        let e = await Mf(am, this.fh, t);
-                        t += lm;
-                        let i = Bf(e.get("name_length"), 8),
+                        let e = await pf(Wg, this.fh, t);
+                        t += Gg;
+                        let i = wf(e.get("name_length"), 8),
                             n = "<" + i.toFixed() + "s",
-                            s = (await Pf.unpack_from_async(n, this.fh, t))[0];
+                            s = (await _f.unpack_from_async(n, this.fh, t))[0];
                         e.set("filter_name", s), t += i, n = "<" + e.get("client_data_values").toFixed() + "I";
-                        let o = await Pf.unpack_from_async(n, this.fh, t);
+                        let o = await _f.unpack_from_async(n, this.fh, t);
                         e.set("client_data", o), t += 4 * e.get("client_data_values"), e.get("client_data_values") % 2 && (t += 4), r.push(e)
                     }
                 } else {
                     if (2 != i) throw `version ${i} is not supported`;
                     for (let e = 0; e < n; e++) {
                         let e = new Map,
                             i = this.fh,
-                            n = (await Pf.unpack_from_async("<H", i, t))[0];
+                            n = (await _f.unpack_from_async("<H", i, t))[0];
                         t += 2, e.set("filter_id", n);
                         let s = 0;
-                        n > 255 && (s = (await Pf.unpack_from_async("<H", i, t))[0], t += 2);
-                        let o = (await Pf.unpack_from_async("<H", i, t))[0];
+                        n > 255 && (s = (await _f.unpack_from_async("<H", i, t))[0], t += 2);
+                        let o = (await _f.unpack_from_async("<H", i, t))[0];
                         t += 2;
                         let a = (1 & o) > 0;
                         e.set("optional", a);
-                        let l, h = (await Pf.unpack_from_async("<H", i, t))[0];
-                        t += 2, s > 0 && (l = (await Pf.unpack_from_async(`${s}s`, i, t))[0], t += s), e.set("name", l);
-                        let c = await Pf.unpack_from_async(`<${h}i`, i, t);
+                        let l, h = (await _f.unpack_from_async("<H", i, t))[0];
+                        t += 2, s > 0 && (l = (await _f.unpack_from_async(`${s}s`, i, t))[0], t += s), e.set("name", l);
+                        let c = await _f.unpack_from_async(`<${h}i`, i, t);
                         t += 4 * h, e.set("client_data_values", c), r.push(e)
                     }
                 }
                 return this._filter_pipeline = r, this._filter_pipeline
             }
             find_msg_type(e) {
                 return this.msgs.filter((function(t) {
                     return t.get("type") == e
                 }))
             }
             async get_attributes() {
                 let e = {},
-                    t = this.find_msg_type(mm);
+                    t = this.find_msg_type(tm);
                 for (let i of t) {
                     let t = i.get("offset_to_message"),
                         [n, r] = await this.unpack_attribute(t);
                     e[n] = r
                 }
                 return e
             }
             async get_fillvalue() {
-                var e, t = this.find_msg_type(um)[0].get("offset_to_message");
-                let i = (await Pf.unpack_from_async("<B", this.fh, t))[0];
+                var e, t = this.find_msg_type(Yg)[0].get("offset_to_message");
+                let i = (await _f.unpack_from_async("<B", this.fh, t))[0];
                 var n, r, s;
-                if (1 == i || 2 == i) n = await Mf(nm, this.fh, t), t += rm, e = n.get("fillvalue_defined");
+                if (1 == i || 2 == i) n = await pf(Ug, this.fh, t), t += qg, e = n.get("fillvalue_defined");
                 else {
                     if (3 != i) throw 'InvalidHDF5File("Unknown fillvalue msg version: "' + String(i);
-                    n = await Mf(sm, this.fh, t), t += om, e = 32 & n.get("flags")
+                    n = await pf(jg, this.fh, t), t += $g, e = 32 & n.get("flags")
                 }
-                if (e ? (r = (await Pf.unpack_from_async("<I", this.fh, t))[0], t += 4) : r = 0, r) {
-                    let [e, i, n] = Ff(await this.dtype);
-                    s = new Of(await this.fh.slice(t, t + n))[e](t, !i, n)
+                if (e ? (r = (await _f.unpack_from_async("<I", this.fh, t))[0], t += 4) : r = 0, r) {
+                    let [e, i, n] = yf(await this.dtype);
+                    s = new xf(await this.fh.slice(t, t + n))[e](t, !i, n)
                 } else s = 0;
                 return s
             }
             async unpack_attribute(e) {
-                let t = (await Pf.unpack_from_async("<B", this.fh, e))[0];
+                let t = (await _f.unpack_from_async("<B", this.fh, e))[0];
                 var i, n;
-                if (1 == t) Lf(1 == (i = await Mf(Hg, this.fh, e)).get("version")), e += Vg, n = 8;
+                if (1 == t) mf(1 == (i = await pf(Sg, this.fh, e)).get("version")), e += Ag, n = 8;
                 else {
                     if (3 != t) throw "unsupported attribute message version: " + t;
-                    Lf(3 == (i = await Mf(Ug, this.fh, e)).get("version")), e += qg, n = 1
+                    mf(3 == (i = await pf(Eg, this.fh, e)).get("version")), e += Mg, n = 1
                 }
                 let r = i.get("name_size"),
-                    s = (await Pf.unpack_from_async("<" + r.toFixed() + "s", this.fh, e))[0];
+                    s = (await _f.unpack_from_async("<" + r.toFixed() + "s", this.fh, e))[0];
                 var o;
-                s = s.replace(/\x00$/, ""), e += Bf(r, n);
+                s = s.replace(/\x00$/, ""), e += wf(r, n);
                 try {
-                    o = await new Hf(this.fh, e).dtype
+                    o = await new Sf(this.fh, e).dtype
                 } catch (e) {
                     return console.warn("Attribute " + s + " type not implemented, set to null."), [s, null]
                 }
-                e += Bf(i.get("datatype_size"), n);
+                e += wf(i.get("datatype_size"), n);
                 let a = await this.determine_data_shape(this.fh, e),
                     l = a.reduce((function(e, t) {
                         return e * t
                     }), 1);
-                if (e += Bf(i.get("dataspace_size"), n), 5 === o.datatype_class) h = await this.fh.slice(e, e + o.size);
+                if (e += wf(i.get("dataspace_size"), n), 5 === o.datatype_class) h = await this.fh.slice(e, e + o.size);
                 else {
                     var h = await this._attr_value(o, this.fh, l, e);
                     0 == a.length && (h = h[0])
                 }
                 return [s, h]
             }
             async determine_data_shape(e, t) {
-                let i = (await Pf.unpack_from_async("<B", e, t))[0];
+                let i = (await _f.unpack_from_async("<B", e, t))[0];
                 var n;
-                if (1 == i) Lf(1 == (n = await Mf(Wg, e, t)).get("version")), t += Gg;
+                if (1 == i) mf(1 == (n = await pf(Lg, e, t)).get("version")), t += Ig;
                 else {
                     if (2 != i) throw "unknown dataspace message version";
-                    Lf(2 == (n = await Mf(Zg, e, t)).get("version")), t += Qg
+                    mf(2 == (n = await pf(Bg, e, t)).get("version")), t += Fg
                 }
                 let r = n.get("dimensionality");
-                return await Pf.unpack_from_async("<" + r.toFixed() + "Q", e, t)
+                return await _f.unpack_from_async("<" + r.toFixed() + "Q", e, t)
             }
             async _attr_value(e, t, i, n) {
                 var r = new Array(i);
                 if (e instanceof Array) {
                     let h = e[0];
                     for (var s = 0; s < i; s++)
                         if ("VLEN_STRING" == h) {
                             let i = e[2];
                             var [o, a] = await this._vlen_size_and_data(t, n);
                             const l = new TextDecoder(0 == i ? "ascii" : "utf-8");
                             r[s] = l.decode(a), n += 16
                         } else if ("REFERENCE" == h) {
-                        var l = await Pf.unpack_from_async("<Q", t, n);
+                        var l = await _f.unpack_from_async("<Q", t, n);
                         r[s] = l, n += 8
                     } else {
                         if ("VLEN_SEQUENCE" != h) throw "NotImplementedError"; {
                             let i = e[1];
                             var [o, a] = this._vlen_size_and_data(t, n);
                             r[s] = this._attr_value(i, a, o, 0), n += 16
                         }
                     }
                 } else {
-                    let [o, a, l] = Ff(e);
+                    let [o, a, l] = yf(e);
                     const h = await t.slice(n, n + i * l);
-                    let c = new Of(h, 0),
+                    let c = new xf(h, 0),
                         d = 0;
                     for (s = 0; s < i; s++) r[s] = c[o](d, !a, l), d += l
                 }
                 return r
             }
             async _vlen_size_and_data(e, t) {
-                let i = (await Pf.unpack_from_async("<I", e, t))[0],
-                    n = await Mf(zg, e, t + 4),
+                let i = (await _f.unpack_from_async("<I", e, t))[0],
+                    n = await pf(Cg, e, t + 4),
                     r = n.get("collection_address");
                 var s;
-                return Lf(n.get("collection_address") < Number.MAX_SAFE_INTEGER), r in this._global_heaps || (s = new yg(this.fh, r), await s.ready, this._global_heaps[r] = s), [i, (s = this._global_heaps[r]).objects.get(n.get("object_index"))]
+                return mf(n.get("collection_address") < Number.MAX_SAFE_INTEGER), r in this._global_heaps || (s = new sg(this.fh, r), await s.ready, this._global_heaps[r] = s), [i, (s = this._global_heaps[r]).objects.get(n.get("object_index"))]
             }
             async _parse_v1_objects(e, t) {
-                let i = await Mf(jg, e, t);
-                Lf(1 == i.get("version"));
+                let i = await pf(Tg, e, t);
+                mf(1 == i.get("version"));
                 let n = i.get("total_header_messages");
-                for (var r = i.get("object_header_size"), s = t + If(jg), o = await e.slice(s, s + r), a = [
+                for (var r = i.get("object_header_size"), s = t + bf(Tg), o = await e.slice(s, s + r), a = [
                         [s, r]
                     ], l = 0, h = 0, c = new Array(n), d = 0; d < n; d++) {
                     h >= r && ([s, r] = a[++l], h = 0);
-                    let t = await Mf(Xg, e, s + h),
-                        i = s + h + Yg;
-                    if (t.set("offset_to_message", i), t.get("type") == bm) {
-                        var [u, f] = await Pf.unpack_from_async("<QQ", e, i);
+                    let t = await pf(Ng, e, s + h),
+                        i = s + h + Og;
+                    if (t.set("offset_to_message", i), t.get("type") == im) {
+                        var [u, f] = await _f.unpack_from_async("<QQ", e, i);
                         a.push([u, f])
                     }
-                    h += Yg + t.get("size"), c[d] = t
+                    h += Og + t.get("size"), c[d] = t
                 }
                 return [c, o, i]
             }
             async _parse_v2_objects(e, t) {
                 var [i, n, r] = await this._parse_v2_header(e, t);
                 t = r;
                 for (var s = [], o = i.get("size_of_chunk_0"), a = e.slice(t, t += o), l = [
                         [r, o]
                     ], h = 0, c = 0;;) {
-                    if (c >= o - Jg) {
+                    if (c >= o - Dg) {
                         let e = l[++h];
                         if (null == e) break;
                         [r, o] = e, c = 0
                     }
-                    let t = await Mf(Kg, e, r + c),
-                        i = r + c + Jg + n;
-                    if (t.set("offset_to_message", i), t.get("type") == bm) {
-                        var [d, u] = await Pf.unpack_from_async("<QQ", e, i);
+                    let t = await pf(Pg, e, r + c),
+                        i = r + c + Dg + n;
+                    if (t.set("offset_to_message", i), t.get("type") == im) {
+                        var [d, u] = await _f.unpack_from_async("<QQ", e, i);
                         l.push([d + 4, u - 4])
                     }
-                    c += Jg + t.get("size") + n, s.push(t)
+                    c += Dg + t.get("size") + n, s.push(t)
                 }
                 return [s, a, i]
             }
             async _parse_v2_header(e, t) {
-                let i = await Mf($g, e, t);
+                let i = await pf(Rg, e, t);
                 var n;
-                if (t += If($g), Lf(2 == i.get("version")), n = 4 & i.get("flags") ? 2 : 0, Lf(0 == (16 & i.get("flags"))), 32 & i.get("flags")) {
-                    let n = await Pf.unpack_from_async("<4I", e, t);
+                if (t += bf(Rg), mf(2 == i.get("version")), n = 4 & i.get("flags") ? 2 : 0, mf(0 == (16 & i.get("flags"))), 32 & i.get("flags")) {
+                    let n = await _f.unpack_from_async("<4I", e, t);
                     t += 16, i.set("access_time", n[0]), i.set("modification_time", n[1]), i.set("change_time", n[2]), i.set("birth_time", n[3])
                 }
                 let r = ["<B", "<H", "<I", "<Q"][3 & i.get("flags")];
-                return i.set("size_of_chunk_0", (await Pf.unpack_from_async(r, e, t))[0]), [i, n, t += Pf.calcsize(r)]
+                return i.set("size_of_chunk_0", (await _f.unpack_from_async(r, e, t))[0]), [i, n, t += _f.calcsize(r)]
             }
             async find_link(e) {
                 if (this._links) {
                     for (link of this._links)
                         if (e === link[0]) return link
                 } else {
                     const t = [];
@@ -29768,67 +29939,67 @@
             }
             async get_links() {
                 const e = [];
                 for await (const t of this.iter_links()) e.push(t);
                 return Object.fromEntries(e)
             }
             async * iter_links() {
-                for (let e of this.msgs) e.get("type") == wm ? yield* this._iter_links_from_symbol_tables(e): e.get("type") == fm ? yield this._get_link_from_link_msg(e): e.get("type") == cm && (yield* this._iter_link_from_link_info_msg(e))
+                for (let e of this.msgs) e.get("type") == nm ? yield* this._iter_links_from_symbol_tables(e): e.get("type") == Kg ? yield this._get_link_from_link_msg(e): e.get("type") == Qg && (yield* this._iter_link_from_link_info_msg(e))
             }
             async * _iter_links_from_symbol_tables(e) {
-                Lf(16 == e.get("size"));
-                let t = await Mf(em, this.fh, e.get("offset_to_message"));
+                mf(16 == e.get("size"));
+                let t = await pf(zg, this.fh, e.get("offset_to_message"));
                 yield* this._iter_links_btree_v1(t.get("btree_address"), t.get("heap_address"))
             }
             async * _iter_links_btree_v1(e, t) {
-                let i = new pg(this.fh, e);
+                let i = new Jp(this.fh, e);
                 await i.ready;
                 let n = new class {
                     constructor(e, t) {
                         this.ready = this.init(e, t)
                     }
                     async init(e, t) {
-                        let i = await Mf(Lg, e, t);
-                        Lf("HEAP" == i.get("signature")), Lf(0 == i.get("version"));
+                        let i = await pf(mg, e, t);
+                        mf("HEAP" == i.get("signature")), mf(0 == i.get("version"));
                         let n = i.get("address_of_data_segment"),
                             r = await e.slice(n, n + i.get("data_segment_size"));
                         i.set("heap_data", r), this._contents = i, this.data = r
                     }
                     get_object_name(e) {
                         let t = new Uint8Array(this.data).indexOf(0, e) - e;
-                        return Pf.unpack_from("<" + t.toFixed() + "s", this.data, e)[0]
+                        return _f.unpack_from("<" + t.toFixed() + "s", this.data, e)[0]
                     }
                 }(this.fh, t);
                 await n.ready;
                 for (let e of i.symbol_table_addresses()) {
-                    let t = new vg(this.fh, e);
+                    let t = new rg(this.fh, e);
                     await t.ready, t.assign_name(n), yield* Object.entries(t.get_links(n))
                 }
             }
             async _get_link_from_link_msg(e) {
                 let t = e.get("offset_to_message");
                 return await this._decode_link_msg(this.fh, t)[1]
             }
             async _decode_link_msg(e, t) {
-                let [i, n] = await Pf.unpack_from_async("<BB", e, t);
-                t += 2, Lf(1 == i);
+                let [i, n] = await _f.unpack_from_async("<BB", e, t);
+                t += 2, mf(1 == i);
                 let r, s, o = 2 ** (3 & n),
                     a = (16 & n) > 0,
                     l = (4 & n) > 0;
-                (8 & n) > 0 ? (r = (await Pf.unpack_from_async("<B", e, t))[0], t += 1) : r = 0, Lf([0, 1].includes(r)), l && (s = (await Pf.unpack_from_async("<Q", e, t))[0], t += 8);
+                (8 & n) > 0 ? (r = (await _f.unpack_from_async("<B", e, t))[0], t += 1) : r = 0, mf([0, 1].includes(r)), l && (s = (await _f.unpack_from_async("<Q", e, t))[0], t += 8);
                 let h = 0;
-                a && (h = (await Pf.unpack_from_async("<B", e, t))[0], t += 1);
+                a && (h = (await _f.unpack_from_async("<B", e, t))[0], t += 1);
                 let c = 0 == h ? "ascii" : "utf-8",
                     d = ["<B", "<H", "<I", "<Q"][3 & n],
-                    u = (await Pf.unpack_from_async(d, e, t))[0];
+                    u = (await _f.unpack_from_async(d, e, t))[0];
                 t += o;
                 let f, p = new TextDecoder(c).decode(await e.slice(t, t + u));
-                if (t += u, 0 == r) f = (await Pf.unpack_from_async("<Q", e, t))[0];
+                if (t += u, 0 == r) f = (await _f.unpack_from_async("<Q", e, t))[0];
                 else if (1 == r) {
-                    let i = (await Pf.unpack_from_async("<H", e, t))[0];
+                    let i = (await _f.unpack_from_async("<H", e, t))[0];
                     t += 2, f = new TextDecoder(c).decode(await e.slice(t, t + i))
                 }
                 return [s, [p, f]]
             }
             async * _iter_link_from_link_info_msg(e) {
                 let t = e.get("offset_to_message"),
                     i = await this._decode_link_info_msg(this.fh, t),
@@ -29839,40 +30010,40 @@
             }
             async * _iter_links_btree_v2(e, t, i) {
                 let n, r = new class {
                     constructor(e, t) {
                         this.fh = e, this.ready = this.init(t)
                     }
                     async init(e) {
-                        let t = await Mf(Pg, this.fh, e);
-                        if (e += If(Pg), Lf("FRHP" == t.get("signature")), Lf(0 == t.get("version")), t.get("filter_info_size") > 0) throw "Filter info size not supported on FractalHeap";
-                        if (t.get("btree_address_huge_objects") != xg) throw "Huge objects not implemented in FractalHeap";
-                        t.set("btree_address_huge_objects", null), t.get("root_block_address") == xg && t.set("root_block_address", null);
+                        let t = await pf(_g, this.fh, e);
+                        if (e += bf(_g), mf("FRHP" == t.get("signature")), mf(0 == t.get("version")), t.get("filter_info_size") > 0) throw "Filter info size not supported on FractalHeap";
+                        if (t.get("btree_address_huge_objects") != ag) throw "Huge objects not implemented in FractalHeap";
+                        t.set("btree_address_huge_objects", null), t.get("root_block_address") == ag && t.set("root_block_address", null);
                         let i = t.get("log2_maximum_heap_size"),
                             n = this._min_size_nbits(i),
                             r = new Map([
                                 ["signature", "4s"],
                                 ["version", "B"],
                                 ["heap_header_adddress", "Q"],
                                 ["block_offset", `${n}B`]
                             ]);
-                        this.indirect_block_header = new Map(r), this.indirect_block_header_size = If(r), 2 == (2 & t.get("flags")) && r.set("checksum", "I"), this.direct_block_header = r, this.direct_block_header_size = If(r);
+                        this.indirect_block_header = new Map(r), this.indirect_block_header_size = bf(r), 2 == (2 & t.get("flags")) && r.set("checksum", "I"), this.direct_block_header = r, this.direct_block_header_size = bf(r);
                         let s = t.get("maximum_direct_block_size");
                         this._managed_object_offset_size = this._min_size_nbits(i);
                         let o = Math.min(s, t.get("max_managed_object_size"));
                         this._managed_object_length_size = this._min_size_integer(o);
                         let a = t.get("starting_block_size"),
                             l = t.get("table_width");
                         if (!(a > 0)) throw "Starting block size == 0 not implemented";
                         let h = Number(Math.floor(Math.log2(s)));
-                        Lf(1n << BigInt(h) == s);
+                        mf(1n << BigInt(h) == s);
                         let c = Number(Math.floor(Math.log2(a)));
-                        Lf(1n << BigInt(c) == a), this._max_direct_nrows = h - c + 2;
+                        mf(1n << BigInt(c) == a), this._max_direct_nrows = h - c + 2;
                         let d = Math.floor(Math.log2(l));
-                        Lf(1 << d == l), this._indirect_nrows_sub = d + c - 1, this.header = t, this.nobjects = t.get("managed_object_count") + t.get("huge_object_count") + t.get("tiny_object_count");
+                        mf(1 << d == l), this._indirect_nrows_sub = d + c - 1, this.header = t, this.nobjects = t.get("managed_object_count") + t.get("huge_object_count") + t.get("tiny_object_count");
                         let u = [],
                             f = t.get("root_block_address"),
                             p = 0;
                         if (null != f && (p = t.get("indirect_current_rows_count")), p > 0)
                             for await (let e of this._iter_indirect_block(this.fh, f, p)) u.push(e);
                         else {
                             let e = await this._read_direct_block(this.fh, f, a);
@@ -29883,52 +30054,52 @@
                             b = 0;
                         u.forEach((e => {
                             m.set(new Uint8Array(e), b), b += e.byteLength
                         })), this.managed = m.buffer
                     }
                     async _read_direct_block(e, t, i) {
                         let n = await e.slice(t, t + i);
-                        return Lf("FHDB" == Rf(this.direct_block_header, n).get("signature")), n
+                        return mf("FHDB" == gf(this.direct_block_header, n).get("signature")), n
                     }
                     get_data(e) {
-                        let t = Pf.unpack_from("<B", e, 0)[0],
+                        let t = _f.unpack_from("<B", e, 0)[0],
                             i = t >> 4 & 3,
                             n = 1;
                         if (0 == i) {
-                            Lf(0 == t >> 6);
+                            mf(0 == t >> 6);
                             let i = this._managed_object_offset_size,
-                                r = zf(i, e, n);
+                                r = Cf(i, e, n);
                             n += i, i = this._managed_object_length_size;
-                            let s = zf(i, e, n);
+                            let s = Cf(i, e, n);
                             return this.managed.slice(r, r + s)
                         }
                         throw 1 == i ? "tiny objectID not supported in FractalHeap" : 2 == i ? "huge objectID not supported in FractalHeap" : "unknown objectID type in FractalHeap"
                     }
                     _min_size_integer(e) {
-                        return this._min_size_nbits(Df(e))
+                        return this._min_size_nbits(kf(e))
                     }
                     _min_size_nbits(e) {
                         return Math.ceil(e / 8)
                     }
                     async * _iter_indirect_block(e, t, i) {
-                        let n = await Mf(this.indirect_block_header, e, t);
-                        t += this.indirect_block_header_size, Lf("FHIB" == n.get("signature"));
+                        let n = await pf(this.indirect_block_header, e, t);
+                        t += this.indirect_block_header_size, mf("FHIB" == n.get("signature"));
                         let r = n.get("block_offset").reduce(((e, t, i) => e + (t << 8 * i)), 0);
                         n.set("block_offset", r);
                         let [s, o] = this._indirect_info(i), a = [];
                         for (let i = 0; i < s; i++) {
-                            let n = (await Pf.unpack_from_async("<Q", e, t))[0];
-                            if (t += 8, n == xg) break;
+                            let n = (await _f.unpack_from_async("<Q", e, t))[0];
+                            if (t += 8, n == ag) break;
                             let r = this._calc_block_size(i);
                             a.push([n, r])
                         }
                         let l = [];
                         for (let i = s; i < s + o; i++) {
-                            let n = (await Pf.unpack_from_async("<Q", e, t))[0];
-                            if (t += 8, n == xg) break;
+                            let n = (await _f.unpack_from_async("<Q", e, t))[0];
+                            if (t += 8, n == ag) break;
                             let r = this._calc_block_size(i),
                                 s = this._iblock_nrows_from_block_size(r);
                             l.push([n, s])
                         }
                         for (let [t, i] of a) {
                             let n = await this._read_direct_block(e, t, i);
                             yield n
@@ -29938,66 +30109,66 @@
                     }
                     _calc_block_size(e) {
                         let t = Math.floor(e / this.header.get("table_width"));
                         return 2 ** Math.max(t - 1, 0) * this.header.get("starting_block_size")
                     }
                     _iblock_nrows_from_block_size(e) {
                         let t = Math.floor(Math.log2(e));
-                        return Lf(2 ** t == e), t - this._indirect_nrows_sub
+                        return mf(2 ** t == e), t - this._indirect_nrows_sub
                     }
                     _indirect_info(e) {
                         let t, i, n = this.header.get("table_width"),
                             r = e * n,
                             s = this._max_direct_nrows * n;
                         return e <= s ? (t = r, i = 0) : (t = s, i = r - s), [t, i]
                     }
                     _int_format(e) {
                         return ["B", "H", "I", "Q"][e - 1]
                     }
                 }(this.fh, i);
                 await r.ready;
                 const s = null != t;
-                s ? (n = new wg(this.fh, t), await n.ready) : (n = new bg(this.fh, e), await n.ready);
+                s ? (n = new ng(this.fh, t), await n.ready) : (n = new ig(this.fh, e), await n.ready);
                 let o = new Map;
                 for (let e of n.iter_records()) {
                     let t = r.get_data(e.get("heapid")),
                         [i, n] = await this._decode_link_msg(t, 0);
                     const a = s ? i : n[0];
                     o.set(a, n)
                 }
                 let a = Array.from(o.keys()).sort();
                 for (let e of a) yield o.get(e)
             }
             async _decode_link_info_msg(e, t) {
-                let [i, n] = await Pf.unpack_from_async("<BB", e, t);
-                Lf(0 == i), t += 2, (1 & n) > 0 && (t += 8);
-                let r = (2 & n) > 0 ? im : tm,
-                    s = await Mf(r, e, t),
+                let [i, n] = await _f.unpack_from_async("<BB", e, t);
+                mf(0 == i), t += 2, (1 & n) > 0 && (t += 8);
+                let r = (2 & n) > 0 ? Vg : Hg,
+                    s = await pf(r, e, t),
                     o = new Map;
-                for (let [e, t] of s.entries()) o.set(e, t == Dg ? null : t);
+                for (let [e, t] of s.entries()) o.set(e, t == kg ? null : t);
                 return o
             }
             get is_dataset() {
-                return this.find_msg_type(hm).length > 0
+                return this.find_msg_type(Zg).length > 0
             }
             async get_data() {
-                let e = this.find_msg_type(pm)[0].get("offset_to_message");
+                let e = this.find_msg_type(Jg)[0].get("offset_to_message");
                 var [t, i, n, r] = await this._get_data_message_properties(e);
                 if (0 == n) throw "Compact storage of DataObject not implemented";
                 return 1 == n ? this._get_contiguous_data(r) : 2 == n ? this._get_chunked_data(e) : void 0
             }
             async _get_data_message_properties(e) {
-                let t, i, n, [r, s, o] = await Pf.unpack_from_async("<BBB", this.fh, e);
-                return 1 == r || 2 == r ? (t = s, i = o, n = e, n += Pf.calcsize("<BBB"), n += Pf.calcsize("<BI"), Lf(1 == i || 2 == i)) : 3 != r && 4 != r || (i = s, n = e, n += Pf.calcsize("<BB")), Lf(r >= 1 && r <= 4), [r, t, i, n]
+                let t, i, n, [r, s, o] = await _f.unpack_from_async("<BBB", this.fh, e);
+                return 1 == r || 2 == r ? (t = s, i = o, n = e, n += _f.calcsize("<BBB"), n += _f.calcsize("<BI"), mf(1 == i || 2 == i)) : 3 != r && 4 != r || (i = s, n = e, n += _f.calcsize("<BB")), mf(r >= 1 && r <= 4), [r, t, i, n]
             }
             async _get_contiguous_data(e) {
-                let [t] = await Pf.unpack_from_async("<Q", this.fh, e);
+                let [t] = await _f.unpack_from_async("<Q", this.fh, e);
                 const i = await this.shape,
                     n = await this.dtype;
-                if (t == Dg) {
+                if (t == kg) {
                     let e = i.reduce((function(e, t) {
                         return e * t
                     }), 1);
                     return new Array(e)
                 }
                 var r = i.reduce((function(e, t) {
                     return e * t
@@ -30017,177 +30188,177 @@
                             s[o] = i.decode(n), t += 16
                         }
                         return s
                     }
                     throw "NotImplementedError('datatype not implemented')"
                 }
                 if (/[<>=!@\|]?(i|u|f|S)(\d*)/.test(n)) {
-                    let [e, i, s] = Ff(n), a = new Array(r);
+                    let [e, i, s] = yf(n), a = new Array(r);
                     const l = await this.fh.slice(t, t + s * r);
-                    let h = new Of(l);
+                    let h = new xf(l);
                     for (var o = 0; o < r; o++) a[o] = h[e](o * s, !i, s);
                     return a
                 }
                 if (5 === n.datatype_class) return this.fh.slice(t, t + n.size);
                 throw "not Implemented - no proper dtype defined"
             }
             async _get_chunked_data(e) {
-                if (await this._get_chunk_params(), this._chunk_address == Dg) return [];
-                var t = new gg(this.fh, this._chunk_address, this._chunk_dims);
+                if (await this._get_chunk_params(), this._chunk_address == kg) return [];
+                var t = new eg(this.fh, this._chunk_address, this._chunk_dims);
                 await t.ready;
                 const i = await this.dtype,
                     n = await this.shape,
                     r = await this.chunks,
                     s = await this.get_filter_pipeline();
                 let o = await t.construct_data_from_chunks(r, n, i, s);
                 if (i instanceof Array && /^VLEN/.test(i[0])) {
                     let e = i[0];
                     for (var a = 0; a < o.length; a++) {
                         let [t, n, r] = o[a];
                         var l;
-                        n in this._global_heaps ? l = this._global_heaps[n] : (l = new yg(this.fh, n), await l.ready, this._global_heaps[n] = l);
+                        n in this._global_heaps ? l = this._global_heaps[n] : (l = new sg(this.fh, n), await l.ready, this._global_heaps[n] = l);
                         let s = l.objects.get(r);
                         if ("VLEN_STRING" == e) {
                             let e = i[2];
                             const t = new TextDecoder(0 == e ? "ascii" : "utf-8");
                             o[a] = t.decode(s)
                         }
                     }
                 }
                 return o
             }
             async _get_chunk_params() {
                 if (!this._chunk_params_set) {
                     this._chunk_params_set = !0;
-                    var e = this.find_msg_type(pm)[0].get("offset_to_message"),
+                    var e = this.find_msg_type(Jg)[0].get("offset_to_message"),
                         [t, i, n, r] = await this._get_data_message_properties(e);
                     if (2 == n) {
                         var s;
                         if (1 == t || 2 == t) {
-                            var o = (await Pf.unpack_from_async("<Q", this.fh, r))[0];
-                            s = r + Pf.calcsize("<Q")
+                            var o = (await _f.unpack_from_async("<Q", this.fh, r))[0];
+                            s = r + _f.calcsize("<Q")
                         } else if (3 == t) {
-                            var [i, o] = await Pf.unpack_from_async("<BQ", this.fh, r);
-                            s = r + Pf.calcsize("<BQ")
+                            var [i, o] = await _f.unpack_from_async("<BQ", this.fh, r);
+                            s = r + _f.calcsize("<BQ")
                         }
-                        Lf(t >= 1 && t <= 3);
+                        mf(t >= 1 && t <= 3);
                         var a = "<" + (i - 1).toFixed() + "I",
-                            l = await Pf.unpack_from_async(a, this.fh, s);
+                            l = await _f.unpack_from_async(a, this.fh, s);
                         this._chunks = l, this._chunk_dims = i, this._chunk_address = o
                     }
                 }
             }
         };
-    var Dg = Pf.unpack_from("<Q", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer),
-        zg = new Map([
+    var kg = _f.unpack_from("<Q", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer),
+        Cg = new Map([
             ["collection_address", "Q"],
             ["object_index", "I"]
         ]);
-    If(zg);
-    var Hg = new Map([
+    bf(Cg);
+    var Sg = new Map([
             ["version", "B"],
             ["reserved", "B"],
             ["name_size", "H"],
             ["datatype_size", "H"],
             ["dataspace_size", "H"]
         ]),
-        Vg = If(Hg),
-        Ug = new Map([
+        Ag = bf(Sg),
+        Eg = new Map([
             ["version", "B"],
             ["flags", "B"],
             ["name_size", "H"],
             ["datatype_size", "H"],
             ["dataspace_size", "H"],
             ["character_set_encoding", "B"]
         ]),
-        qg = If(Ug),
-        jg = new Map([
+        Mg = bf(Eg),
+        Tg = new Map([
             ["version", "B"],
             ["reserved", "B"],
             ["total_header_messages", "H"],
             ["object_reference_count", "I"],
             ["object_header_size", "I"],
             ["padding", "I"]
         ]),
-        $g = new Map([
+        Rg = new Map([
             ["signature", "4s"],
             ["version", "B"],
             ["flags", "B"]
         ]),
-        Wg = new Map([
+        Lg = new Map([
             ["version", "B"],
             ["dimensionality", "B"],
             ["flags", "B"],
             ["reserved_0", "B"],
             ["reserved_1", "I"]
         ]),
-        Gg = If(Wg),
-        Zg = new Map([
+        Ig = bf(Lg),
+        Bg = new Map([
             ["version", "B"],
             ["dimensionality", "B"],
             ["flags", "B"],
             ["type", "B"]
         ]),
-        Qg = If(Zg),
-        Xg = new Map([
+        Fg = bf(Bg),
+        Ng = new Map([
             ["type", "H"],
             ["size", "H"],
             ["flags", "B"],
             ["reserved", "3s"]
         ]),
-        Yg = If(Xg),
-        Kg = new Map([
+        Og = bf(Ng),
+        Pg = new Map([
             ["type", "B"],
             ["size", "H"],
             ["flags", "B"]
         ]),
-        Jg = If(Kg),
-        em = new Map([
+        Dg = bf(Pg),
+        zg = new Map([
             ["btree_address", "Q"],
             ["heap_address", "Q"]
         ]),
-        tm = new Map([
+        Hg = new Map([
             ["heap_address", "Q"],
             ["name_btree_address", "Q"]
         ]),
-        im = new Map([
+        Vg = new Map([
             ["heap_address", "Q"],
             ["name_btree_address", "Q"],
             ["order_btree_address", "Q"]
         ]),
-        nm = new Map([
+        Ug = new Map([
             ["version", "B"],
             ["space_allocation_time", "B"],
             ["fillvalue_write_time", "B"],
             ["fillvalue_defined", "B"]
         ]),
-        rm = If(nm),
-        sm = new Map([
+        qg = bf(Ug),
+        jg = new Map([
             ["version", "B"],
             ["flags", "B"]
         ]),
-        om = If(sm),
-        am = new Map([
+        $g = bf(jg),
+        Wg = new Map([
             ["filter_id", "H"],
             ["name_length", "H"],
             ["flags", "H"],
             ["client_data_values", "H"]
         ]),
-        lm = If(am),
-        hm = 1,
-        cm = 2,
-        dm = 3,
-        um = 5,
-        fm = 6,
-        pm = 8,
-        gm = 11,
-        mm = 12,
-        bm = 16,
-        wm = 17,
-        vm = class {
+        Gg = bf(Wg),
+        Zg = 1,
+        Qg = 2,
+        Xg = 3,
+        Yg = 5,
+        Kg = 6,
+        Jg = 8,
+        em = 11,
+        tm = 12,
+        im = 16,
+        nm = 17,
+        rm = class {
             constructor(e, t) {
                 null == t ? (this.parent = this, this.file = this) : (this.parent = t, this.file = t.file), this.name = e
             }
             async init(e) {
                 const t = this.file.index;
                 t && this.name in t ? this._links = t[this.name] : this._links = await e.get_links(), this._dataobjects = e, this._attrs = null, this._keys = null
             }
@@ -30204,15 +30375,15 @@
                 if (!e) throw "cannot deference null reference";
                 let t = this.file._get_object_by_address(e);
                 if (null == t) throw "reference not found in file";
                 return t
             }
             async get(e) {
                 if ("number" == typeof e) return this._dereference(e);
-                var t = xm(e);
+                var t = am(e);
                 if ("/" == t) return this.file;
                 if ("." == t) return this;
                 if (/^\//.test(t)) return this.file.get(t.slice(1));
                 if ("" != function(e) {
                         let t = "/",
                             i = e.lastIndexOf(t) + 1,
                             n = e.slice(0, i),
@@ -30220,114 +30391,114 @@
                             s = new RegExp(t + "$");
                         n && !r.test(n) && (n = n.replace(s, ""));
                         return n
                     }(t)) var [i, n] = t.split(/\/(.*)/);
                 else var i = t,
                     n = ".";
                 if (!(i in this._links)) throw i + " not found in group";
-                var r = xm(this.name + "/" + i);
+                var r = am(this.name + "/" + i);
                 let s = this._links[i];
                 if ("string" == typeof s) try {
                     return this.get(s)
                 } catch (e) {
                     return null
                 }
-                var o = new Og(this.file._fh, s);
+                var o = new xg(this.file._fh, s);
                 if (await o.ready, o.is_dataset) {
                     if ("." != n) throw r + " is a dataset, not a group";
-                    return new _m(r, o, this)
+                    return new om(r, o, this)
                 }
-                var a = new vm(r, this);
+                var a = new rm(r, this);
                 return await a.init(o), a.get(n)
             }
             visit(e) {
                 return this.visititems(((t, i) => e(t)))
             }
             visititems(e) {
                 var t = this.name.length;
                 /\/$/.test(this.name) || (t += 1);
                 for (var i = this.values.slice(); i;) {
                     let n = i.shift();
                     1 == i.length && console.log(n);
                     let r = e(n.name.slice(t), n);
                     if (null != r) return r;
-                    n instanceof vm && (i = i.concat(n.values))
+                    n instanceof rm && (i = i.concat(n.values))
                 }
                 return null
             }
             get attrs() {
                 return null == this._attrs && (this._attrs = this._dataobjects.get_attributes()), this._attrs
             }
         },
-        ym = class extends vm {
+        sm = class extends rm {
             constructor(e, t, i) {
                 super("/", null), this.ready = this.init(e, t, i)
             }
             async init(e, t, i) {
                 var n = new class {
                     constructor(e, t) {
                         this.ready = this.init(e, t)
                     }
                     async init(e, t) {
-                        let i = await Pf.unpack_from_async("<B", e, t + 8);
+                        let i = await _f.unpack_from_async("<B", e, t + 8);
                         var n;
-                        if (0 == i) n = await Mf(kg, e, t), this._end_of_sblock = t + Cg;
+                        if (0 == i) n = await pf(lg, e, t), this._end_of_sblock = t + hg;
                         else {
                             if (2 != i && 3 != i) throw "unsupported superblock version: " + i.toFixed();
-                            n = await Mf(Sg, e, t), this._end_of_sblock = t + Ag
+                            n = await pf(cg, e, t), this._end_of_sblock = t + dg
                         }
-                        if (n.get("format_signature") != _g) throw "Incorrect file signature: " + n.get("format_signature");
+                        if (n.get("format_signature") != og) throw "Incorrect file signature: " + n.get("format_signature");
                         if (8 != n.get("offset_size") || 8 != n.get("length_size")) throw "File uses non-64-bit addressing";
                         this.version = n.get("superblock_version"), this._contents = n, this._root_symbol_table = null, this._fh = e
                     }
                     async get_offset_to_dataobjects() {
                         if (0 == this.version) {
-                            var e = new vg(this._fh, this._end_of_sblock, !0);
+                            var e = new rg(this._fh, this._end_of_sblock, !0);
                             return await e.ready, this._root_symbol_table = e, e.group_offset
                         }
                         if (2 == this.version || 3 == this.version) return this._contents.get("root_group_address");
                         throw "Not implemented version = " + this.version.toFixed()
                     }
                 }(e, 0);
                 await n.ready;
                 var r = await n.get_offset_to_dataobjects(),
-                    s = new Og(e, r);
+                    s = new xg(e, r);
                 if (await s.ready, this.parent = this, this.file = this, this.name = "/", this._dataobjects = s, this._attrs = null, this._keys = null, this._fh = e, this.filename = t || "", this.mode = "r", this.userblock_size = 0, i && i.index) this.index = i.index;
                 else {
                     let t;
                     if (i && i.indexOffset) t = i.indexOffset;
                     else {
                         const e = await this.attrs;
                         if (e.hasOwnProperty("_index_offset")) t = e._index_offset;
                         else {
                             const e = this.indexName || "_index",
                                 i = await s.find_link(e);
                             i && (t = i[1])
                         }
                     }
                     if (t) try {
-                        const i = new Og(e, t);
+                        const i = new xg(e, t);
                         await i.ready;
                         const n = await i.get_data(),
-                            r = cg(n),
+                            r = Qp(n),
                             s = (new TextDecoder).decode(r);
                         this.index = JSON.parse(s)
                     } catch (e) {
                         console.error(`Error loading index by offset ${e}`)
                     }
                 }
                 this.index && this.name in this.index ? this._links = this.index[this.name] : this._links = await s.get_links()
             }
             _get_object_by_address(e) {
                 return this._dataobjects.offset == e ? this : this.visititems((e => {
                     e._dataobjects.offset
                 }))
             }
         },
-        _m = class extends Array {
+        om = class extends Array {
             constructor(e, t, i) {
                 super(), this.parent = i, this.file = i.file, this.name = e, this._dataobjects = t, this._attrs = null, this._astype = null
             }
             get value() {
                 var e = this._dataobjects.get_data();
                 return null == this._astype ? this.getValue(e) : e.astype(this._astype)
             }
@@ -30365,132 +30536,135 @@
                 (await this.value, await this.shape)
             }
             async getValue(e) {
                 return (await this.dtype).startsWith("S") ? (await e).map((e => e.substr(0, e.indexOf("\0")))) : e
             }
         };
 
-    function xm(e) {
+    function am(e) {
         return e.replace(/\/(\/)+/g, "/")
     }
-    async function km(e) {
-        e.url && "function" == typeof e.url.slice && (e.file = e.url, e.url = void 0);
-        const t = void 0 !== e.url;
-        let i = e.reader ? e.reader : function(e) {
-            if (e.url) return new Sf(e);
+    async function lm(e) {
+        var t;
+        e.url && ("function" == typeof(t = e.url).slice && "function" == typeof t.arrayBuffer) && (e.file = e.url, e.url = void 0);
+        const i = void 0 !== e.url;
+        let n = e.reader ? e.reader : function(e) {
+            if (e.url) return new cf(e);
             if (e.path) return new NodeLocalFile(e);
-            if (e.file) return new Tf(e.file);
+            if (e.file) return new ff(e.file);
             throw Error("One of 'url', 'path (node only)', or 'file (browser only)' must be specified")
         }(e);
-        const n = e.fetchSize || 2e3,
-            r = e.maxSize || 2e5;
-        t && (i = new Af({
-            file: i,
-            fetchSize: n,
-            maxSize: r
+        const r = e.fetchSize || 2e3,
+            s = e.maxSize || 2e5;
+        i && (n = new df({
+            file: n,
+            fetchSize: r,
+            maxSize: s
         }));
-        const s = new Cm(i),
-            o = await async function(e) {
+        const o = new hm(n),
+            a = await async function(e) {
                 let t;
                 if (e.indexReader) t = e.indexReader;
                 else {
                     if (e.index) return e.index;
-                    e.indexURL ? t = new Sf({
+                    e.indexURL ? t = new cf({
                         url: e.indexURL
                     }) : e.indexPath ? t = new NodeLocalFile({
                         path: e.indexPath
-                    }) : e.indexFile && (t = new Tf({
+                    }) : e.indexFile && (t = new ff({
                         file: e.indexFile
                     }))
                 }
                 if (t) {
                     const e = await t.read(),
                         i = (new TextDecoder).decode(e);
                     return JSON.parse(i)
                 }
                 return
-            }(e), a = e.indexOffset, l = function(e) {
-                if (e.url) return Sm(e.url);
-                if (e.path) return Sm(e.path);
+            }(e), l = e.indexOffset, h = function(e) {
+                if (e.url) return cm(e.url);
+                if (e.path) return cm(e.path);
                 if (e.file) return e.file.name
-            }(e), h = new ym(s, l, {
-                index: o,
-                indexOffset: a
+            }(e), c = new sm(o, h, {
+                index: a,
+                indexOffset: l
             });
-        return await h.ready, h
+        return await c.ready, c
     }
-    class Cm {
+    class hm {
         constructor(e) {
             this.fileReader = e
         }
         async slice(e, t) {
             return this.fileReader.read(e, t - e)
         }
     }
 
-    function Sm(e) {
+    function cm(e) {
         const t = e.lastIndexOf("/");
         return t > 0 ? e.substring(t + 1) : e
     }
-    class Am {
+    class dm {
         constructor(e, t = 1e5) {
             this.h5_file = e, this.bin_size = t, this.h5_obj = void 0
         }
         async fetch() {
-            return this.h5_obj || (this.h5_obj = await km({
+            return this.h5_obj || (this.h5_obj = await lm({
                 url: this.h5_file,
                 fetchSize: 1e6,
                 maxSize: 2e8
             })), this.h5_obj
         }
         async get_keys() {
             return (await this.fetch()).keys
         }
         async get_rd_signal(e = this.bin_size) {
             let t = await this.fetch(),
                 i = t.keys,
-                n = new Em(i);
-            this.rd_bins = n.get_rd_bins(), this.rd_bins.includes(e) || (e = this.rd_bins[rd_bins.length - 1]);
-            const r = await t.get("rd_chromosomes");
-            await r.dtype;
-            let s = await r.value,
-                o = await this.rd_stat(t, i, e);
-            var a = [],
-                l = [],
-                h = [],
+                n = new um(i),
+                r = n.get_rd_bins(),
+                s = n.get_snp_bins();
+            this.available_bins = [...new Set(r, s)], this.available_bins.includes(e) || (e = this.available_bins.at(-1));
+            const o = await t.get("rd_chromosomes");
+            await o.dtype;
+            let a = await o.value,
+                l = await this.rd_stat(t, i, e);
+            var h = [],
                 c = [],
                 d = [],
-                u = [];
-            for (let n of s) {
-                var f = `his_rd_p_${n}_${e}`;
-                let r = await this.get_chr_signal(t, i, n, e, f, o);
-                a = a.concat(r);
-                var p = `his_rd_p_${n}_${e}_GC`;
-                let s = await this.get_chr_signal(t, i, n, e, p, o);
-                l = l.concat(s);
-                let g = `his_rd_p_${n}_${e}_partition_GC_merge`,
-                    m = await this.get_chr_signal(t, i, n, e, g, o);
-                h = h.concat(m);
-                let b = await this.rd_call_combined(t, i, n, e, o);
-                c = c.concat(b);
+                u = [],
+                f = [],
+                p = [];
+            for (let n of a) {
+                var g = `his_rd_p_${n}_${e}`;
+                let r = await this.get_chr_signal(t, i, n, e, g, l);
+                h = h.concat(r);
+                var m = `his_rd_p_${n}_${e}_GC`;
+                let s = await this.get_chr_signal(t, i, n, e, m, l);
+                c = c.concat(s);
+                let o = `his_rd_p_${n}_${e}_partition_GC_merge`,
+                    a = await this.get_chr_signal(t, i, n, e, o, l);
+                d = d.concat(a);
+                let b = await this.rd_call_combined(t, i, n, e, l);
+                u = u.concat(b);
                 let w = `snp_likelihood_${n}_${e}_mask`,
                     v = await this.get_baf_signals(t, i, n, e, w);
-                d = d.concat(v[0]), u = u.concat(v[1])
+                f = f.concat(v[0]), p = p.concat(v[1])
             }
-            this.callers = [], 0 != c.length && this.callers.push("MeanShift"), 0 != c.length && this.callers.push("Combined");
-            var g = {},
-                m = {
-                    RD_Raw: a,
-                    RD_Raw_gc_coor: l,
-                    MeanShift: h,
-                    Combined: c,
-                    BAF1: d,
-                    BAF2: u
+            this.callers = [], 0 != u.length && this.callers.push("ReadDepth"), 0 != u.length && this.callers.push("2D");
+            var b = {},
+                w = {
+                    RD_Raw: h,
+                    RD_Raw_gc_coor: c,
+                    ReadDepth: d,
+                    "2D": u,
+                    BAF1: f,
+                    BAF2: p
                 };
-            return g[e] = m, g
+            return b[e] = w, b
         }
         decode_segments(e) {
             let t = [],
                 i = [];
             for (let n of e) 4294967295 == n ? (t.push(i), i = []) : i.push(n);
             return t
         }
@@ -30562,16 +30736,37 @@
                         end: (t + 1) * n,
                         value: -2 * (1 - l)
                     })
                 }))
             }
             return [s, o]
         }
+        async get_baf_signals_v2(e, t, i, n, r) {
+            let s = [],
+                o = [];
+            if (t.includes(r)) {
+                let t = await e.get(r);
+                (await t.to_array()).forEach(((e, t) => {
+                    isNaN(e) || (s.push({
+                        chr: i,
+                        start: t * n,
+                        end: (t + 1) * n,
+                        value: -2 * (.5 - e)
+                    }), .5 != e && o.push({
+                        chr: i,
+                        start: t * n,
+                        end: (t + 1) * n,
+                        value: -2 * (.5 + e)
+                    }))
+                }))
+            }
+            return console.log(i, s, o), [s, o]
+        }
     }
-    class Em {
+    class um {
         constructor(e) {
             this.signals = e
         }
         get_rd_bins() {
             let e = [];
             this.signals.forEach((t => {
                 let i = t.match(/^his_rd_p_(.*)_(\d+)$/);
@@ -30591,35 +30786,82 @@
                     bin_size: i[2]
                 })
             }));
             return [...new Set(e.map((e => Number(e.bin_size))))]
         }
     }
 
-    function Tm(e) {
+    function fm(e) {
         let t = function(e) {
             if (e.length < 4) return e;
             let t, i, n, r, s, o;
             return t = e.slice().sort(((e, t) => e - t)), t.length / 4 % 1 == 0 ? (i = .5 * (t[t.length / 4] + t[t.length / 4 + 1]), n = .5 * (t[t.length * (3 / 4)] + t[t.length * (3 / 4) + 1])) : (i = t[Math.floor(t.length / 4 + 1)], n = t[Math.ceil(t.length * (3 / 4) + 1)]), r = n - i, s = n + 1.5 * r, o = i - 1.5 * r, t.filter((e => e >= o && e <= s))
         }(e);
         const i = t.length,
             n = t.reduce(((e, t) => e + t)) / i,
             r = Math.sqrt(t.map((e => Math.pow(e - n, 2))).reduce(((e, t) => e + t)) / i);
         return [n, r]
     }
+    var pm = {
+        range_function: function(e, t, i) {
+            return Array(Math.ceil((t - e) / i)).fill(e).map(((e, t) => e + t * i))
+        },
+        getDistParams: fm,
+        linspace: function(e, t, i) {
+            if (void 0 === i && (i = Math.max(Math.round(t - e) + 1, 1)), i < 2) return 1 === i ? [e] : [];
+            var n = Array(i);
+            for (let r = --i; r >= 0; r--) n[r] = (r * t + (i - r) * e) / i;
+            return n
+        },
+        GetFit: class {
+            constructor(e) {
+                this.allBins = e
+            }
+            getValues() {
+                return Object.values(this.allBins).reduce(((e, t) => e.concat(t.filter((e => e.binScore > 0)).map((e => e.binScore)))), [])
+            }
+            getMean(e) {
+                return e.reduce((function(e, t) {
+                    return e + t
+                })) / e.length
+            }
+            fit_data() {
+                return fm(this.getValues())
+            }
+            histogram(e, t) {
+                const i = t[1] - t[0],
+                    n = [];
+                e.forEach(((e, r) => {
+                    t.forEach(((t, r) => {
+                        if (n[t] || (n[t] = {
+                                count: 0
+                            }), t <= e && e < t + i) return n[t].count++, !1
+                    }))
+                }));
+                const r = [];
+                return n.forEach(((e, t) => {
+                    r.push(e.count)
+                })), r
+            }
+        }
+    };
+
+    function gm(e, t) {
+        return isNaN(e) || isNaN(t) || t <= 0 ? NaN : 0 === e ? .5 : .5 + .5 * (mm(.5 * t, .5, 1) - mm(.5 * t, .5, t / (t + e * e))) * Math.sign(e)
+    }
 
-    function Mm(e, t, i) {
+    function mm(e, t, i) {
         if (0 == i) return 0;
         if (1 == i) return 1; {
-            let n = Bm(e + t) - Bm(e) - Bm(t) + e * Math.log(i) + t * Math.log(1 - i);
-            return i < (e + 1) / (e + t + 2) ? Math.exp(n) * Rm(e, t, i) / e : 1 - Math.exp(n) * Rm(t, e, 1 - i) / t
+            let n = ym(e + t) - ym(e) - ym(t) + e * Math.log(i) + t * Math.log(1 - i);
+            return i < (e + 1) / (e + t + 2) ? Math.exp(n) * bm(e, t, i) / e : 1 - Math.exp(n) * bm(t, e, 1 - i) / t
         }
     }
 
-    function Rm(e, t, i, n = 1e3) {
+    function bm(e, t, i, n = 1e3) {
         let r = 1,
             s = 1,
             o = 1,
             a = e + t,
             l = e + 1,
             h = e - 1,
             c = 1 - a * i / l;
@@ -30632,124 +30874,321 @@
             f = -(e + n) * (a + n) * i / ((l + u) * (e + u));
             let m = g + f * c,
                 b = r;
             if (s = p / m, o = g / m, r = (p + f * r) / m, c = 1, Math.abs(r - b) < 3e-7 * Math.abs(r)) return r
         }
     }
 
-    function Lm(e) {
+    function wm(e) {
         if (0 == e || 1 == e) return 1;
-        return e * Lm(e - 1)
+        return e * wm(e - 1)
     }
 
-    function Im(e) {
+    function vm(e) {
         let t;
         var i = [75122.633153, 80916.6278952, 36308.2951477, 8687.24529705, 1168.92649479, 83.8676043424, 2.50662827511],
             n = 0,
             r = 1;
         if (0 == e) t = 1e99;
-        else if (e % 1 == 0) t = Lm(e - 1);
+        else if (e % 1 == 0) t = wm(e - 1);
         else {
             for (let t = 0; t < i.length; t++) n += i[t] * Math.pow(e, t), r *= e + t;
             t = n * Math.pow(e + 5.5, e + .5) * Math.exp(-(e + 5.5)) / r
         }
         return t
     }
 
-    function Bm(e) {
-        return Math.log(Im(e))
+    function ym(e) {
+        return Math.log(vm(e))
     }
-    var Nm = {
-        TdistributionCDF: function(e, t) {
-            return isNaN(e) || isNaN(t) || t <= 0 ? NaN : 0 === e ? .5 : .5 + .5 * (Mm(.5 * t, .5, 1) - Mm(.5 * t, .5, t / (t + e * e))) * Math.sign(e)
-        },
-        gamma: Im
+    var _m = {
+        TdistributionCDF: gm,
+        gamma: vm,
+        t_test_1_sample: function(e, t, i, n) {
+            0 == i && (i = 1);
+            var r = (e - t) / i * Math.sqrt(n);
+            return 1 - gm(Math.abs(r), n - 1)
+        },
+        t_test_2_samples: function(e, t, i, n, r, s) {
+            0 == t && (t = 1), 0 == r && (r = 1);
+            var o = (e - n) / Math.sqrt(t ** 2 / i + r ** 2 / s),
+                a = (t ** 2 / i + r ** 2 / s) ** 2 * (i - 1) * (s - 1) / (t ** 4 * (s - 1) / i ** 2 + r ** 4 * (i - 1) / s ** 2);
+            return 1 - gm(Math.abs(o), parseInt(a + .5))
+        }
     };
-    class Fm {
-        constructor(e) {
-            this.allBins = e
+
+    function xm(e) {
+        return e.reduce((function(e, t) {
+            return e > t ? e : t
+        }))
+    }
+
+    function km(e, t, i, n) {
+        return t * Math.exp(-1 * (e - i) ** 2 / (2 * n ** 2)) / Math.sqrt(2 * Math.PI) / n
+    }
+
+    function Cm(e, t, i, n) {
+        return Math.exp(-1 * (e - i) ** 2 / (t ** 2 + n ** 2))
+    }
+
+    function Sm(e, t) {
+        let i;
+        try {
+            i = e.reduce(((e, i, n) => e + Math.min(i, t[n])))
+        } catch {
+            return console.log("Failed to find likelihood overlap: ", e, t), 0
         }
-        getValues() {
-            return Object.values(this.allBins).reduce(((e, t) => e.concat(t.filter((e => e.binScore > 0)).map((e => e.binScore)))), [])
+        return i
+    }
+
+    function Am(e, t, i, n) {
+        return 0 == t && 0 == n ? {
+            nl: .5 * (e + i),
+            ne: 0
+        } : {
+            nl: (e * n * n + i * t * t) / (t * t + n * n),
+            ne: Math.sqrt(t * t * n * n / (t * t + n * n))
         }
-        getMean(e) {
-            return e.reduce((function(e, t) {
-                return e + t
-            })) / e.length
+    }
+
+    function Em(e, t) {
+        let i = parseInt(t * (e.length - 1)),
+            n = t * (e.length - 1) - i;
+        return i < e.length - 1 ? e[i] * (1 - n) + e[i + 1] * n : e[i]
+    }
+
+    function Mm(e) {
+        const t = e.length,
+            i = Math.max(...e);
+        let n = e.indexOf(i);
+        n > Math.floor(t / 2) && (n = t - 1 - n);
+        const r = (t / 2 - n) / (t + 1),
+            s = Math.floor((t / 2 + n) / 2),
+            o = t - 1 - s;
+        let a = e.slice(s, o + 1).reduce(((e, t) => e + t), 0) / e.reduce(((e, t) => e + t), 0);
+        return n === Math.floor(t / 2) && (a = 1), {
+            mean: r,
+            p: a
         }
-        fit_data() {
-            return Tm(this.getValues())
+    }
+    var Tm = class {
+        constructor(e, t) {
+            this.wigFeatures = e, this.binSize = t
         }
-        histogram(e, t) {
-            const i = t[1] - t[0],
-                n = [];
-            e.forEach(((e, r) => {
-                t.forEach(((t, r) => {
-                    if (n[t] || (n[t] = {
-                            count: 0
-                        }), t <= e && e < t + i) return n[t].count++, !1
+        get_fit() {
+            var e = new pm.GetFit(this.wigFeatures),
+                [t, i] = e.fit_data();
+            return {
+                globalMean: t,
+                globalStd: i
+            }
+        }
+        async call_2d(e = null, t = null, i = "both", n = .1, r = 0, s = 10, o = 0) {
+            let a = this.get_fit();
+            this.globalMean = a.globalMean, this.globalStd = a.globalStd;
+            let l = null == e ? .05 * this.binSize / 3e9 : e,
+                h = null == t ? parseInt(this.binSize / 1e4) : t,
+                c = [],
+                d = [],
+                u = [],
+                f = [],
+                p = [],
+                g = [];
+            for (const [e, t] of Object.entries(this.wigFeatures)) {
+                let e = [],
+                    i = [],
+                    s = [];
+                t.forEach(((t, n) => {
+                    t.hets_count > 4 && t.dp_count > h && (e.push([n]), i.push(t.binScore), s.push(t.likelihood_score), delete t.likelihood_score)
+                }));
+                let o = [];
+                for (let e = 1; e < i.length; e++) o.push(Math.abs(i[e] - i[e - 1]));
+                let a = [0];
+                for (let e = 1; e < o.length; e++) a.push(Math.min(o[e - 1], o[e]));
+                a.push(0);
+                let g = i.map(((e, t) => Math.sqrt(Math.sqrt(e) ** 2 + this.globalStd ** 2 + Math.pow(a[t] / 2, 2)))),
+                    m = [];
+                for (let t = 0; t < e.length - 1; t++) {
+                    let n = 0;
+                    try {
+                        n = Sm(s[t], s[t + 1])
+                    } catch {
+                        console.log("Overlap failed: ", t, s[t], e[t + 1], s[t + 1])
+                    }
+                    let r = Cm(i[t], g[t], i[t + 1], g[t + 1]);
+                    m.push(r * n)
+                }
+                for (; m.length > 0;) {
+                    m = m.filter((e => "number" == typeof e));
+                    let t = xm(m);
+                    if (isNaN(t) && console.log("NaN value", m), t < l) break;
+                    let n, r, o = m.indexOf(t),
+                        a = Am(i[o], g[o], i[o + 1], g[o + 1]);
+                    try {
+                        n = s[o].map(((e, t) => e * s[o + 1][t])), r = n.reduce(((e, t) => e + t))
+                    } catch {
+                        console.log(s), console.log("max_overlap:", t, o, m.length), console.log("likelihood: ", o, s[o], s[o + 1]), console.log("nlh: ", r)
+                    }
+                    if (i[o] = a.nl, g[o] = a.ne, s[o] = n.map((function(e) {
+                            return e / r
+                        })), e[o].push(...e[o + 1]), i.splice(o + 1, 1), g.splice(o + 1, 1), e.splice(o + 1, 1), s.splice(o + 1, 1), m.splice(o, 1), o < m.length) {
+                        let e = Cm(i[o], g[o], i[o + 1], g[o + 1]) * Sm(s[o], s[o + 1]);
+                        m[o] = e
+                    }
+                    if (o > 0) {
+                        let e = Cm(i[o - 1], g[o - 1], i[o], g[o]) * Sm(s[o - 1], s[o]);
+                        m[o - 1] = e
+                    }
+                }
+                let b = -1;
+                for (;;) {
+                    m = [];
+                    for (let t = 0; t < i.length; t++)
+                        for (let r = t; r < i.length; r++) e[r][0] - e[t].at(-1) < n * (e[t].length + e[r].length) && m.push(Cm(i[t], g[t], i[r], g[r]) * Sm(s[t], s[r]));
+                    if (0 == m.length) break;
+                    let t = xm(m);
+                    if (t < l) break;
+                    let r = 0,
+                        o = 1;
+                    for (; r < e.length - 1;) {
+                        let a = Cm(i[r], g[r], i[o], g[o]) * Sm(s[r], s[o]);
+                        if (e[o][0] - e[r].at(-1) < n * (e[r].length + e[o].length) && a == t) {
+                            let t = Am(i[r], g[r], i[r + 1], g[r + 1]);
+                            i[r] = t.nl, g[r] = t.ne;
+                            let n = s[r].map(((e, t) => e * s[r + 1][t])),
+                                a = n.reduce(((e, t) => e + t));
+                            s[r] = n.map((function(e) {
+                                return e / a
+                            })), e[r].push(...e[r + 1]), e[r] = e[r].sort(((e, t) => e - t)), i.splice(o, 1), g.splice(o, 1), e.splice(o, 1), s.splice(o, 1), o >= e.length && (r += 1, o = r + 1)
+                        } else o += 1, o >= e.length && (r += 1, o = r + 1)
+                    }
+                    if (b == e.length) break;
+                    b = e.length
+                }
+                e.forEach(((e, n) => {
+                    let o = Mm(s[n]);
+                    e.length > 1 && (e.forEach(((e, s) => {
+                        d.push(t[e]), o.mean <= r && c.push(t[e]), t[e].segment_score = i[n]
+                    })), u.push(i[n]), f.push(g[n]), p.push(s[n]))
                 }))
+            }
+            let m = parseInt(1e3 * (1 - o));
+            0 == m && (m = 1);
+            let b = pm.linspace(o, 1, m),
+                w = {},
+                v = {};
+            for (let e = 10; e > -1; e--)
+                for (let t = 0; t < e / 2 + 1; t++) {
+                    let n, r, s = e - t,
+                        o = b.map(((t, i) => 1 - t + t * e / 2)),
+                        a = e / 2;
+                    e > 0 ? (n = .5 - t / (t + s), r = b.map(((e, i) => .5 - (1 - e + e * t) / (2 - 2 * e + (t + s) * e)))) : (n = 0, r = b.map(((e, t) => 0 * e)));
+                    for (let i = 0; i < u.length; i++) {
+                        let l = km(a * this.globalMean, 1, u[i], f[i]) * Em(p[i], .5 + n);
+                        i in v ? v[i].push([e, t, s, l, 1]) : v[i] = [e, t, s, l, 1];
+                        let h = 0,
+                            c = 0,
+                            d = 0;
+                        o.forEach(((e, t) => {
+                            if (!isNaN(r[t])) {
+                                let n = km(e * this.globalMean, 1, u[i], f[i]) * Em(p[i], .5 + r[t]);
+                                h += n, n > c && (c = n, d = b[t])
+                            }
+                        })), i in w ? w[i].push([e, t, s, h / b.length, d]) : w[i] = [e, t, s, h / b.length, d]
+                    }
+                    for (let e = 0; e < u.length; e++)
+                        if ("germline" == i) w[e].sort(((e, t) => e[3] - t[3]));
+                        else if (w[e].sort(((e, t) => e[3] - t[3])), "both" == i && (v[e].sort(((e, t) => e[3] - t[3])), v[e][0][3] > w[e][0][3])) {
+                        let t = w[e].filter((t => t[0] != v[e][0][0] && t[1] <= v[e][0][1]));
+                        w[e] = [v[e][0]].push(...t)
+                    }
+                    for (let e = 0; e < u.length; e++) w[e][0][0], w[e][0][0], u[e], this.globalMean, _m.t_test_1_sample(this.globalMean, u[e], f[e], g[e])
+                }
+            return {
+                binScore: this.formatDataStructure(this.wigFeatures, "binScore", this.globalMean),
+                segment_score: this.formatDataStructure(this.wigFeatures, "segment_score", this.globalMean)
+            }
+        }
+        formatDataStructure(e, t, i = 1) {
+            const n = [];
+            for (const [r, s] of Object.entries(e)) s.forEach((e => {
+                var r = {
+                    ...e
+                };
+                1 != i && (r.value = e[t] / i * 2), n.push(r)
             }));
-            const r = [];
-            return n.forEach(((e, t) => {
-                r.push(e.count)
-            })), r
+            return n
         }
-    }
+        formatDataStructure_BAF(e, t = 2) {
+            const i = [],
+                n = [];
+            for (const [t, r] of Object.entries(this.wigFeatures)) r.forEach((t => {
+                var r = {
+                        ...t
+                    },
+                    s = {
+                        ...t
+                    };
+                let o = t[e];
+                .5 != o && (s.value = -2 * (1 - o), n.push(s)), r.value = -2 * o, i.push(r)
+            }));
+            return [i, n]
+        }
+    };
 
-    function Pm(e) {
+    function Rm(e) {
         for (var t = 1, i = 1, n = 1 * e, r = 1; r < 50; r++) t *= r, n += (i *= -1) * Math.pow(e, 2 * r + 1) / (t * (2 * r + 1));
         return 2 * n / Math.sqrt(3.14159265358979)
     }
 
-    function Om(e, t, i, n, r) {
-        var s = new Hm(i.slice(n, r));
-        return 0 == s.std && (s.std = t > 0 ? t * s.mean / e : 1), Vm(e, s.mean, s.std, r - n) / (r - n)
+    function Lm(e, t, i, n, r) {
+        var s = new Fm(i.slice(n, r));
+        return 0 == s.std && (s.std = t > 0 ? t * s.mean / e : 1), Nm(e, s.mean, s.std, r - n) / (r - n)
     }
 
-    function Dm(e, t, i, n, r) {
-        var s = new Hm(i.slice(n, r));
+    function Im(e, t, i, n, r) {
+        var s = new Fm(i.slice(n, r));
         if (s.mean < e) {
             var o = (s.max - s.mean) / (t * Math.sqrt(2));
-            return Math.pow(.5 * (1 + Pm(o)), r - n)
+            return Math.pow(.5 * (1 + Rm(o)), r - n)
         }
         o = (s.min - s.mean) / (t * Math.sqrt(2));
-        return Math.pow(.5 * (1 - Pm(o)), r - n)
+        return Math.pow(.5 * (1 - Rm(o)), r - n)
     }
 
-    function zm(e, t, i, n, r, s, o = 1e3) {
-        for (var a = Om(e, t, i, n, r), l = 0, h = !1; a > s & !h & l < o;) {
+    function Bm(e, t, i, n, r, s, o = 1e3) {
+        for (var a = Lm(e, t, i, n, r), l = 0, h = !1; a > s & !h & l < o;) {
             h = !0, l += 1;
             var [c, d, u, f] = [1e10, 1e10, 1e10, 1e10];
-            if (n > 0 && (c = Om(e, t, i, n - 1, r)), r - n > 2) var d = Om(e, t, i, n + 1, r),
-                u = Om(e, t, i, n, r - 1);
-            if (r < i.length) var f = Om(e, t, i, n, r + 1);
+            if (n > 0 && (c = Lm(e, t, i, n - 1, r)), r - n > 2) var d = Lm(e, t, i, n + 1, r),
+                u = Lm(e, t, i, n, r - 1);
+            if (r < i.length) var f = Lm(e, t, i, n, r + 1);
             Math.min[f] < a && (h = !1, c == Math.min[f] && (n -= 1, a = c), elif(d == Math.min[f]), n += 1, a = d, elif(u == Math.min[f]), r -= 1, a = u, elif(f == Math.min[f]), r += 1, a = f)
         }
         return a <= s ? r : 0
     }
-    class Hm {
+    class Fm {
         constructor(e) {
             this.data = e, this.mean = e.reduce(((e, t) => e + t)) / e.length, this.std = Math.sqrt(e.reduce(((e, t) => (t - this.mean) ** 2)) / e.length)
         }
     }
 
-    function Vm(e, t, i, n) {
+    function Nm(e, t, i, n) {
         0 == i && (i = 1);
         var r = (e - t) / i * Math.sqrt(n);
-        return 1 - Nm.TdistributionCDF(Math.abs(r), n - 1)
+        return 1 - _m.TdistributionCDF(Math.abs(r), n - 1)
     }
 
-    function Um(e, t, i, n, r, s) {
+    function Om(e, t, i, n, r, s) {
         0 == t && (t = 1), 0 == r && (r = 1);
         var o = (e - n) / Math.sqrt(t ** 2 / i + r ** 2 / s),
             a = (t ** 2 / i + r ** 2 / s) ** 2 * (i - 1) * (s - 1) / (t ** 4 * (s - 1) / i ** 2 + r ** 4 * (i - 1) / s ** 2);
-        return 1 - Nm.TdistributionCDF(Math.abs(o), parseInt(a + .5))
+        return 1 - _m.TdistributionCDF(Math.abs(o), parseInt(a + .5))
     }
-    class qm {
+    var Pm = class {
         constructor(e, t, i) {
             this.rd = e, this.mean = t, this.std = i, this.bin_bands = [2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128]
         }
         get_rd_signal_bandwidth(e) {
             var t = [];
             return e.forEach(((e, i) => {
                 var n = 0;
@@ -30803,30 +31242,30 @@
                         var _ = [f[p], f[p]];
                         if (!(p < f.length - 1)) continue;
                         _[1] = f[p + 1];
                         var x = v[1] - v[0],
                             k = y[1] - y[0],
                             C = _[1] - _[0];
                         if (x <= 1) continue;
-                        var S = new Hm(s.slice(v[0], v[1]));
+                        var S = new Fm(s.slice(v[0], v[1]));
                         if (C <= 15 || k <= 15 || x <= 15) {
                             var A = 1.8 * Math.sqrt(s[y[0]] / this.mean) * this.std;
                             if (Math.abs(s[y[0]] - s[v[0]]) < A) continue;
                             if (A = 1.8 * Math.sqrt(s[_[0]] / this.mean) * this.std, Math.abs(s[_[0]] - s[v[0]]) < A) continue
                         } else {
                             var E = s.slice(y[0], y[1]),
-                                T = new Hm(E),
-                                M = s.slice(_[0], _[1]),
-                                R = new Hm(M);
-                            if (Um(S.mean, S.std, S.data.length, T.mean, T.std, T.data.length) > .01 / genome_size * bin_size * (x + k)) continue;
-                            if (Um(S.mean, S.std, S.data.length, R.mean, R.std, R.data.length) > .01 / genome_size * bin_size * (x + C)) continue
+                                M = new Fm(E),
+                                T = s.slice(_[0], _[1]),
+                                R = new Fm(T);
+                            if (Om(S.mean, S.std, S.data.length, M.mean, M.std, M.data.length) > .01 / genome_size * bin_size * (x + k)) continue;
+                            if (Om(S.mean, S.std, S.data.length, R.mean, R.std, R.data.length) > .01 / genome_size * bin_size * (x + C)) continue
                         }
-                        if (Vm(this.mean, S.mean, S.std, S.data.length) > .05) continue;
+                        if (Nm(this.mean, S.mean, S.std, S.data.length) > .05) continue;
                         let e = a.slice(v[0], v[1]);
-                        var L = new Hm(e);
+                        var L = new Fm(e);
                         r.fill(!0, v[0], v[1]), s.fill(L.mean, v[0], v[1])
                     }
                 })), t[i] = s
             })), t
         }
         call_mean_shift(e = 3) {
             for (var t = new Array(this.rd.length).fill(!1), i = new Array(this.rd.length), n = 0; n < this.rd.length; n++) t[n] || (i[n] = this.rd[n]);
@@ -30869,29 +31308,29 @@
                         var _ = [g[h], g[h]];
                         if (h < g.length - 1) {
                             _[1] = g[h + 1];
                             var x = v[1] - v[0],
                                 k = y[1] - y[0],
                                 C = _[1] - _[0];
                             if (!(x <= 1)) {
-                                var S = new Hm(i.slice(v[0], v[1]));
+                                var S = new Fm(i.slice(v[0], v[1]));
                                 if (C <= 15 || k <= 15 || x <= 15) {
                                     var A = 1.8 * Math.sqrt(i[y[0]] / this.mean) * this.std;
                                     if (Math.abs(i[y[0]] - i[v[0]]) < A) continue;
                                     if (A = 1.8 * Math.sqrt(i[_[0]] / this.mean) * this.std, Math.abs(i[_[0]] - i[v[0]]) < A) continue
                                 } else {
                                     var E = i.slice(y[0], y[1]),
-                                        T = new Hm(E),
-                                        M = i.slice(_[0], _[1]),
-                                        R = new Hm(M);
-                                    if (Um(S.mean, S.std, S.data.length, T.mean, T.std, T.data.length) > 3.483106931382794e-9 * (x + k)) continue;
-                                    if (Um(S.mean, S.std, S.data.length, R.mean, R.std, R.data.length) > 3.483106931382794e-9 * (x + C)) continue
+                                        M = new Fm(E),
+                                        T = i.slice(_[0], _[1]),
+                                        R = new Fm(T);
+                                    if (Om(S.mean, S.std, S.data.length, M.mean, M.std, M.data.length) > 3.483106931382794e-9 * (x + k)) continue;
+                                    if (Om(S.mean, S.std, S.data.length, R.mean, R.std, R.data.length) > 3.483106931382794e-9 * (x + C)) continue
                                 }
-                                if (!(Vm(this.mean, S.mean, S.std, S.data.length) > .05)) {
-                                    var L = new Hm(this.rd.slice(v[0], v[1]));
+                                if (!(Nm(this.mean, S.mean, S.std, S.data.length) > .05)) {
+                                    var L = new Fm(this.rd.slice(v[0], v[1]));
                                     t.fill(!0, v[0], v[1]), i.fill(L.mean, v[0], v[1])
                                 }
                             }
                         }
                     }
                 }
             })), i
@@ -30915,71 +31354,71 @@
                     for (let e = 0; e < d.length - 2; e++) {
                         var u = Math.abs(h[d[e]] - h[d[e + 1]]);
                         if (u < t) {
                             var f = u + 1,
                                 p = u + 1;
                             if (e > 0 && (f = Math.abs(h[d[e]] - h[d[e - 1]])), e < d.length - 3 && (p = Math.abs(s[d[e + 1]] - h[d[e + 2]])), u < f && u < p) {
                                 c = !1;
-                                var g = new Hm(h.slice(d[e], d[e + 2]));
+                                var g = new Fm(h.slice(d[e], d[e + 2]));
                                 h.fill(g.mean, d[e], d[e + 2]), d.splice(e + 1, e + 1)
                             }
                         }
                     }
                 }
                 var m = [];
                 Object.entries(this.rd[l]).forEach((([e, t]) => {
                     m.push(t.binScore)
                 }));
                 for (var b, w = new Array(h.length).fill(""), v = 0, y = .05 * e / r; v < h.length;) {
                     for (var _ = v, x = v; v < h.length & h[v] < i;) v += 1;
                     if ((C = v) > x + 1) {
-                        var k = zm(this.mean, this.std, m, x, C, y);
+                        var k = Bm(this.mean, this.std, m, x, C, y);
                         if (k) {
                             var C = k;
                             w.fill("D", x, C)
                         }
                     }
                     for (x = v; v < h.length & h[v] > n;) v += 1;
-                    (C = v) > x + 1 && (k = zm(this.mean, this.std, m, x, C, y)) && (C = k, w.fill("A", x, C)), v == _ && (v += 1)
+                    (C = v) > x + 1 && (k = Bm(this.mean, this.std, m, x, C, y)) && (C = k, w.fill("A", x, C)), v == _ && (v += 1)
                 }
                 for (v = 0; v < h.length;) {
                     for (; v < h.length & "" != w[v];) v += 1;
                     for (x = v; v < h.length & h[v] < i;) v += 1;
-                    (C = v) > x + 1 && (Dm(this.mean, this.std, m, x, C) < 1682935038707506e-26 && w.fill(["d"] * (C - x), x, C), v -= 1), v += 1
+                    (C = v) > x + 1 && (Im(this.mean, this.std, m, x, C) < 1682935038707506e-26 && w.fill(["d"] * (C - x), x, C), v -= 1), v += 1
                 }(v = 0) < h.length && (b = w[v]), x = 0;
                 for (var S = [...m]; v < h.length;) {
                     for (; w[v] == b && !((v += 1) >= w.length););
                     if (v > x) {
-                        var A = new Hm(S.slice(x, v));
+                        var A = new Fm(S.slice(x, v));
                         S.fill(A.mean, x, v)
                     }
                     v < h.length && (b = w[v]), x = v
                 }
                 for (o[l] = S, v = 0; v < h.length;) {
                     if ("" == (b = w[v])) {
                         v += 1;
                         continue
                     }
                     for (x = v; v < h.length & b == w[v];) v += 1;
-                    let t, i = new Hm(S.slice(x, v)).mean / this.mean;
+                    let t, i = new Fm(S.slice(x, v)).mean / this.mean;
                     t = "D" == b ? "deletion" : "duplication";
                     let n = {
                         chr: l,
                         start: e * x + 1,
                         end: e * v,
                         size: e * (v - x + 1),
                         value: 2 * i,
                         event_type: t
                     };
                     a.push(n)
                 }
             })), [o, a]
         }
-    }
-    class jm {
+    };
+    class Dm {
         constructor(e, t) {
             this.allVariants = e, this.rowBinSize = 1e4, this.binSize = t, this.binFactor = t / this.rowBinSize
         }
         async computeDepthFeatures() {
             const e = Object.keys(this.allVariants),
                 t = [];
             for (let i of e) {
@@ -31052,17 +31491,17 @@
                             n[i][e].binScore += s
                         }
                 }
             }
             return this.readDepthMeanshift(n)
         }
         readDepthMeanshift(e) {
-            var t = new Fm(e),
+            var t = new pm.GetFit(e),
                 [i, n] = t.fit_data(),
-                r = new qm(e, i, n),
+                r = new Pm(e, i, n),
                 s = r.meanShiftCaller(),
                 o = r.cnv_calling();
             return Object.entries(e).forEach((([e, t]) => {
                 t.forEach(((t, i) => {
                     t.partition_level = parseInt(s[e][i]), t.partition_call = parseInt(o[0][e][i])
                 }))
             })), [this.formatDataStructure(e, "binScore", i), this.formatDataStructure(e, "partition_level", i), this.formatDataStructure(e, "partition_call", i), o[1]]
@@ -31073,63 +31512,14 @@
                 var r = {
                     ...e
                 };
                 1 != i && (r.value = e[t] / i * 2), n.push(r)
             }));
             return n
         }
-        async computeBAF() {
-            const e = Object.keys(this.allVariants),
-                t = {},
-                i = [];
-            for (let s of e) {
-                const e = this.allVariants[s];
-                if (0 === e.length) continue;
-                var n;
-                for (let o of e) {
-                    if (n = Math.max(Math.floor(o.start / this.binSize), 0), t[s] || (t[s] = []), !t[s][n]) {
-                        if (n > 0) {
-                            let e = n - 1;
-                            if (t[s][e]) {
-                                const n = this.get_max_min_score(t[s][e]);
-                                t[s][e] = n, i.push(t[s][e])
-                            }
-                        }
-                        t[s][n] = {
-                            chr: s,
-                            start: n * this.binSize,
-                            end: (n + 1) * this.binSize,
-                            value: 0,
-                            count: 0,
-                            likelihood_score: [],
-                            min_score: 0
-                        }
-                    }
-                    const e = o.calls[9];
-                    let a = e.genotype,
-                        l = e.info.AD.split(","),
-                        h = l[0],
-                        c = l[1];
-                    if (0 == a[0] && 1 == a[1] || 1 == a[0] && 0 == a[1]) {
-                        if (0 == t[s][n].likelihood_score.length) t[s][n].likelihood_score = Wm(0, 1, 200).map(((e, t) => $m(h, c, e)));
-                        else {
-                            var r = 0;
-                            t[s][n].likelihood_score = Wm(0, 1, 200).map(((e, i) => {
-                                var o = t[s][n].likelihood_score[i] * $m(h, c, e);
-                                return r += o, o
-                            })), t[s][n].likelihood_score = Wm(0, 1, 200).map(((e, i) => t[s][n].likelihood_score[i] / r))
-                        }
-                        t[s][n].count++
-                    }
-                }
-                const o = this.get_max_min_score(t[s][n]);
-                t[s][n] = o, i.push(t[s][n])
-            }
-            return [i, this.format_BAF_likelihood(t)]
-        }
         async computeBAF_v2() {
             const e = Object.keys(this.allVariants),
                 t = {},
                 i = [],
                 n = [];
             for (let o of e) {
                 const e = this.allVariants[o];
@@ -31160,21 +31550,21 @@
                     }
                     const e = a.calls[9];
                     let l = e.genotype,
                         h = e.info.AD.split(","),
                         c = h[0],
                         d = h[1];
                     if (0 == l[0] && 1 == l[1] || 1 == l[0] && 0 == l[1]) {
-                        if (0 == t[o][r].likelihood_score.length) t[o][r].likelihood_score = Wm(0, 1, 100).map(((e, t) => $m(c, d, e)));
+                        if (0 == t[o][r].likelihood_score.length) t[o][r].likelihood_score = pm.linspace(0, 1, 100).map(((e, t) => zm(c, d, e)));
                         else {
                             var s = 0;
-                            t[o][r].likelihood_score = Wm(0, 1, 100).map(((e, i) => {
-                                var n = t[o][r].likelihood_score[i] * $m(c, d, e);
+                            t[o][r].likelihood_score = pm.linspace(0, 1, 100).map(((e, i) => {
+                                var n = t[o][r].likelihood_score[i] * zm(c, d, e);
                                 return s += n, n
-                            })), t[o][r].likelihood_score = Wm(0, 1, 100).map(((e, i) => t[o][r].likelihood_score[i] / s))
+                            })), t[o][r].likelihood_score = pm.linspace(0, 1, 100).map(((e, i) => t[o][r].likelihood_score[i] / s))
                         }
                         t[o][r].count++
                     }
                 }
                 const a = this.get_max_min_score(t[o][r]);
                 if (.5 != a.value) {
                     let e = Object.assign({}, a);
@@ -31194,87 +31584,182 @@
             }));
             return t
         }
         get_max_min_score(e) {
             if (e.likelihood_score.length > 0) {
                 const t = Math.max(...e.likelihood_score),
                     i = e.likelihood_score.indexOf(t);
-                e.likelihood_score = [], e.value = Math.max(i / 100, 1 - i / 100), e.min_score = Math.min(i / 100, 1 - i / 100)
+                e.value = Math.max(i / 100, 1 - i / 100), e.min_score = Math.min(i / 100, 1 - i / 100)
             } else e.score = 0;
             return e
         }
         async getAllbins() {
             const e = await this.computeDepthFeatures();
-            return new Fm(e).fit_data(), e
+            return new pm.GetFit(e).fit_data(), e
+        }
+        async read_rd_baf(e = "ReadDepth") {
+            const t = Object.keys(this.allVariants);
+            var i = {};
+            for (let e of t) {
+                const t = this.allVariants[e];
+                var n;
+                if (0 !== t.length)
+                    for (let r of t) {
+                        n = Math.max(Math.floor(r.start / this.rowBinSize), 0), i[e] || (i[e] = []), i[e][n] || (i[e][n] = {
+                            chr: e,
+                            start: n * this.rowBinSize,
+                            end: (n + 1) * this.rowBinSize,
+                            dp_sum_score: 0,
+                            dp_count: 0,
+                            hets_count: 0,
+                            hets: []
+                        });
+                        const t = r.calls[9],
+                            s = t.info.DP;
+                        s && (i[e][n].dp_sum_score += Number.parseInt(s), i[e][n].dp_count++);
+                        let o = t.info.AD.split(","),
+                            a = t.genotype;
+                        if (0 == a[0] && 1 == a[1] || 1 == a[0] && 0 == a[1]) {
+                            i[e][n].hets_count++;
+                            let t = parseInt(o[0]),
+                                r = parseInt(o[1]);
+                            i[e][n].hets.push({
+                                ref: t,
+                                alt: r
+                            })
+                        }
+                    }
+            }
+            var r, s = this.adjust_bin_size(i);
+            if ("ReadDepth" == e) {
+                r = this.readDepthMeanshift(s);
+                var o = this.formatDataStructure_BAF(s, "max_likelihood")
+            } else if ("2D" == e) {
+                let e = new Tm(s, this.binSize),
+                    t = await e.call_2d();
+                r = [t.binScore, [], t.segment_score];
+                o = e.formatDataStructure_BAF("max_likelihood")
+            }
+            return [r, o]
+        }
+        formatDataStructure_BAF(e, t, i = 2) {
+            const n = [],
+                r = [];
+            for (const [i, s] of Object.entries(e)) s.forEach((e => {
+                delete e.likelihood_score;
+                var i = {
+                        ...e
+                    },
+                    s = {
+                        ...e
+                    };
+                let o = e[t];
+                .5 != o && (s.value = -2 * (1 - o), r.push(s)), i.value = -2 * o, n.push(i)
+            }));
+            return [n, r]
+        }
+        adjust_bin_size(e) {
+            const t = Object.keys(this.allVariants);
+            var i = {};
+            for (let s of t) {
+                i[s] || (i[s] = []);
+                for (let t = 0; t < e[s].length / this.binFactor; t++) {
+                    const o = t;
+                    i[s][t] || (i[s][t] = {
+                        chr: s,
+                        start: o * this.binSize,
+                        end: (o + 1) * this.binSize,
+                        dp_count: 0,
+                        hets_count: 0,
+                        binScore: 0,
+                        likelihood_score: []
+                    });
+                    for (var n = 10 * t; n < 10 * t + 10; n++)
+                        if (e[s][n]) {
+                            var r = 100 * parseInt(e[s][n].dp_sum_score / e[s][n].dp_count);
+                            i[s][t].binScore += r, i[s][t].dp_count += e[s][n].dp_count, i[s][t].hets_count += e[s][n].hets_count, 0 != e[s][n].hets.length && e[s][n].hets.forEach(((e, n) => {
+                                if (0 == i[s][t].likelihood_score.length) i[s][t].likelihood_score = pm.linspace(0, 1, 100).map(((t, i) => zm(e.ref, e.alt, t)));
+                                else {
+                                    var r = 0;
+                                    i[s][t].likelihood_score = pm.linspace(0, 1, 100).map(((n, o) => {
+                                        var a = i[s][t].likelihood_score[o] * zm(e.ref, e.alt, n);
+                                        return r += a, a
+                                    })), i[s][t].likelihood_score = pm.linspace(0, 1, 100).map(((e, n) => i[s][t].likelihood_score[n] / r))
+                                }
+                            }))
+                        } const a = this.get_max_min_score(i[s][t]);
+                    i[s][t].max_likelihood = a.value
+                }
+            }
+            return i
         }
     }
 
-    function $m(e, t, i, n = !0) {
+    function zm(e, t, i, n = !0) {
         return i ** e * (1 - i) ** t + i ** t * (1 - i) ** e
     }
-
-    function Wm(e, t, i) {
-        if (void 0 === i && (i = Math.max(Math.round(t - e) + 1, 1)), i < 2) return 1 === i ? [e] : [];
-        var n = Array(i);
-        for (let r = --i; r >= 0; r--) n[r] = (r * t + (i - r) * e) / i;
-        return n
-    }
-    class Gm extends zl {
+    class Hm extends Rl {
         constructor(e, t) {
-            super(e, t), this.featureType = "numeric", this.paintAxis = Ed, this.defaultScale = !0, e.max || (this.autoscale = !1), this.height = void 0 !== e.height ? e.height : 250
+            super(e, t), this.featureType = "numeric", this.paintAxis = cd, e.max || (this.defaultScale = !0, this.autoscale = !1), this.height = void 0 !== e.height ? e.height : 250
         }
         async init(e) {
-            this.type = "cnvpytor", this.graphType = e.graphType || "points", this.bin_size = e.bin_size || 1e5, this.signal_name = e.signal_name || "rd_snp", this.cnv_caller = e.cnv_caller || "2D", this.colors = e.colors || ["gray", "black", "green", "blue"], this.colors.push(this.colors[3]), super.init(e)
+            this.type = "cnvpytor", this.graphType = e.graphType || "points", this.bin_size = e.bin_size || 1e5, this.signal_name = e.signal_name || "rd_snp", this.cnv_caller = e.cnv_caller || "2D", this.colors = e.colors || ["gray", "black", "green", "blue"], super.init(e)
         }
         get supportsWholeGenome() {
             return !0
         }
         get_signals() {
             let e = [];
             return "rd_snp" == this.signal_name ? e = ["RD_Raw", "RD_Raw_gc_coor", this.cnv_caller, "BAF1", "BAF2"] : "rd" == this.signal_name ? e = ["RD_Raw", "RD_Raw_gc_coor", this.cnv_caller] : "snp" == this.signal_name ? e = ["BAF1", "BAF2"] : "cnh" == this.signal_name && (e = [this.cnv_caller]), e
         }
         get_signal_colors() {
-            let e;
-            return "rd_snp" == this.signal_name || "rd" == this.signal_name ? e = this.colors : "snp" == this.signal_name ? e = this.colors.slice(-2) : "cnh" == this.signal_name && (e = this.colors.slice(2, 3)), e
+            return [{
+                singal_name: "RD_Raw",
+                color: this.colors[0]
+            }, {
+                singal_name: "RD_Raw_gc_coor",
+                color: this.colors[1]
+            }, {
+                singal_name: "ReadDepth",
+                color: this.colors[2]
+            }, {
+                singal_name: "2D",
+                color: this.colors[2]
+            }, {
+                singal_name: "BAF1",
+                color: this.colors[3]
+            }, {
+                singal_name: "BAF2",
+                color: this.colors[3]
+            }]
         }
         async postInit() {
             if ("vcf" == this.config.format) {
-                this.featureSource = Sc(this.config, this.browser.genome), this.header = await this.getHeader();
+                this.featureSource = cc(this.config, this.browser.genome), this.header = await this.getHeader();
                 var e = this.featureSource.reader.features.reduce((function(e, t) {
                     return e[t.chr] = e[t.chr] || [], e[t.chr].push(t), e
                 }), Object.create(null));
-                const t = new jm(e, this.bin_size),
-                    i = await t.computeReadDepth(),
-                    n = await t.computeBAF_v2();
-                this.wigFeatures_obj = {}, this.wigFeatures_obj[this.bin_size] = {
-                    RD_Raw: i[0],
-                    RD_Raw_gc_coor: i[1],
-                    ReadDepth: i[2],
-                    "2D": [],
-                    BAF1: n[0],
-                    BAF2: n[1]
-                }, this.rd_bins = [this.bin_size], this.available_callers = ["ReadDepth"], this.set_available_callers()
-            } else this.cnvpytor_obj = new Am(this.config.url, this.bin_size), this.wigFeatures_obj = await this.cnvpytor_obj.get_rd_signal(this.bin_size), this.rd_bins = this.cnvpytor_obj.rd_bins, this.available_callers = this.cnvpytor_obj.callers, this.set_available_callers();
+                const t = new Dm(e, this.bin_size);
+                let i, n, r;
+                this.wigFeatures_obj = {}, this.wigFeatures_obj[this.bin_size] = {}, "2D" == this.config.cnv_caller ? (r = await t.read_rd_baf("2D"), i = r[0], n = r[1], this.wigFeatures_obj[this.bin_size]["2D"] = i[2], this.available_callers = ["2D"]) : (r = await t.read_rd_baf(), i = r[0], n = r[1], this.wigFeatures_obj[this.bin_size].ReadDepth = i[2], this.available_callers = ["ReadDepth"]), this.wigFeatures_obj[this.bin_size].RD_Raw = i[0], this.wigFeatures_obj[this.bin_size].RD_Raw_gc_coor = i[1], this.wigFeatures_obj[this.bin_size].BAF1 = n[0], this.wigFeatures_obj[this.bin_size].BAF2 = n[1], this.available_bins = [this.bin_size], this.set_available_callers()
+            } else this.cnvpytor_obj = new dm(this.config.url, this.bin_size), this.wigFeatures_obj = await this.cnvpytor_obj.get_rd_signal(this.bin_size), this.available_bins = this.cnvpytor_obj.available_bins, this.available_callers = this.cnvpytor_obj.callers, this.set_available_callers();
             this.tracks = [];
             const t = [];
             this.signals = this.get_signals(), this.signal_colors = this.get_signal_colors();
-            for (let e in this.wigFeatures_obj) {
-                let i = 0;
-                for (const [n, r] of Object.entries(this.wigFeatures_obj[e]))
-                    if (this.signals.includes(n)) {
+            for (let e in this.wigFeatures_obj)
+                for (const [i, n] of Object.entries(this.wigFeatures_obj[e]))
+                    if (this.signals.includes(i)) {
                         let e = {
                             type: "wig",
                             isMergedTrack: !0
                         };
-                        e.features = r, e.name = n, e.color = this.signal_colors[i];
-                        const s = await this.browser.createTrack(e);
-                        s ? (s.autoscale = !1, this.tracks.push(s)) : console.warn("Could not create track " + e), "function" == typeof s.postInit && t.push(s.postInit()), i++
-                    }
-            }
-            this.flipAxis = !!this.config.flipAxis && this.config.flipAxis, this.logScale = !!this.config.logScale && this.config.logScale, this.autoscale = this.config.autoscale, this.autoscale || (this.dataRange = {
+                        e.features = n, e.name = i, e.color = this.signal_colors.filter((e => e.singal_name === i)).map((e => e.color));
+                        const r = await this.browser.createTrack(e);
+                        r ? (r.autoscale = !1, this.tracks.push(r)) : console.warn("Could not create track " + e), "function" == typeof r.postInit && t.push(r.postInit())
+                    } this.flipAxis = !!this.config.flipAxis && this.config.flipAxis, this.logScale = !!this.config.logScale && this.config.logScale, this.autoscale = this.config.autoscale, this.autoscale || (this.dataRange = {
                 min: this.config.min || 0,
                 max: this.config.max
             });
             for (let e of this.tracks) e.autoscale = !1, e.dataRange = this.dataRange;
             return Promise.all(t)
         }
         set_available_callers() {
@@ -31301,15 +31786,15 @@
             let e = [];
             void 0 !== this.flipAxis && e.push({
                 label: "Flip y-axis",
                 click: () => {
                     this.flipAxis = !this.flipAxis, this.trackView.repaintViews()
                 }
             }), e = e.concat($t.numericDataMenuItems(this.trackView)), e.push("<hr/>"), e.push("Bin Sizes");
-            for (let t of this.rd_bins) {
+            for (let t of this.available_bins) {
                 const i = jt(t, t === this.bin_size);
                 e.push({
                     object: ft(i),
                     click: async () => {
                         this.bin_size = t, await this.recreate_tracks(t), this.clearCachedFeatures(), this.trackView.updateViews(), this.trackView.repaintViews()
                     }
                 })
@@ -31340,106 +31825,129 @@
                 })
             }
             return e
         }
         async recreate_tracks(e) {
             this.tracks = [];
             const t = [];
-            e in this.wigFeatures_obj || (console.log(e, ": not found"), this.wigFeatures_obj = {
+            e in this.wigFeatures_obj || (this.wigFeatures_obj = {
                 ...this.wigFeatures_obj,
                 ...await this.cnvpytor_obj.get_rd_signal(e)
-            }, console.log(this.wigFeatures_obj)), this.signals = this.get_signals(), this.signal_colors = this.get_signal_colors();
-            let i = 0;
-            for (const [n, r] of Object.entries(this.wigFeatures_obj[e]))
-                if (this.signals.includes(n)) {
+            }), this.signals = this.get_signals(), this.signal_colors = this.get_signal_colors();
+            for (const [i, n] of Object.entries(this.wigFeatures_obj[e]))
+                if (this.signals.includes(i)) {
                     let e = {
                         type: "wig",
                         isMergedTrack: !0
                     };
-                    e.features = r, e.name = n, e.color = this.signal_colors[i];
-                    const s = await this.browser.createTrack(e);
-                    s ? (s.autoscale = !1, this.tracks.push(s)) : console.warn("Could not create track " + e), "function" == typeof s.postInit && t.push(s.postInit()), i++
+                    e.features = n, e.name = i, e.color = this.signal_colors.filter((e => e.singal_name === i)).map((e => e.color));
+                    const r = await this.browser.createTrack(e);
+                    r ? (r.autoscale = !1, this.tracks.push(r)) : console.warn("Could not create track " + e), "function" == typeof r.postInit && t.push(r.postInit())
                 } this.flipAxis = !!this.config.flipAxis && this.config.flipAxis, this.logScale = !!this.config.logScale && this.config.logScale, this.autoscale = this.config.autoscale, this.autoscale || (this.dataRange = {
                 min: this.config.min || 0,
                 max: this.config.max
             });
             for (let e of this.tracks) e.autoscale = !1, e.dataRange = this.dataRange;
             return Promise.all(t)
         }
         async getFeatures(e, t, i, n) {
             if (this.tracks) {
                 const r = this.tracks.map((r => r.getFeatures(e, t, i, n)));
                 return Promise.all(r)
             }
         }
+        getScaleFactor(e, t, i, n) {
+            return n ? i / (Math.log10(t + 1) - (e <= 0 ? 0 : Math.log10(e + 1))) : i / (t - e)
+        }
+        computeYPixelValue(e, t) {
+            return (this.flipAxis ? e - this.dataRange.min : this.dataRange.max - e) * t
+        }
+        computeYPixelValueInLogScale(e, t) {
+            let i = this.dataRange.max,
+                n = this.dataRange.min;
+            return i <= 0 ? 0 : (n <= -1 && (n = 0), n = n <= 0 ? 0 : Math.log10(n + 1), i = Math.log10(i + 1), e = Math.log10(e + 1), (this.flipAxis ? e - n : i - e) * t)
+        }
         draw(e) {
             const t = e.features;
-            if (t && (this.defaultScale && ("rd_snp" == this.signal_name ? this.dataRange = {
-                    min: this.config.min || -2,
-                    max: this.config.max || 6
+            if (!t) return;
+            if (this.defaultScale && ("rd_snp" == this.signal_name ? this.dataRange = {
+                    min: this.config.min || this.dataRange.min || -2,
+                    max: this.config.max || this.dataRange.max || 6
                 } : "rd" == this.signal_name ? this.dataRange = {
-                    min: this.config.min || 0,
-                    max: this.config.max || 6
+                    min: this.config.min || this.dataRange.min || 0,
+                    max: this.config.max || this.dataRange.max || 6
                 } : "snp" == this.signal_name && (this.dataRange = {
-                    min: this.config.min || -2,
-                    max: this.config.max || 0
+                    min: this.config.min || this.dataRange.min || -2,
+                    max: this.config.max || this.dataRange.max || 0
                 })), this.autoscale && (this.dataRange = function(e, t) {
                     let i = 0,
                         n = -Number.MAX_VALUE;
                     for (let e of t)
                         for (let t of e) void 0 === t.value || Number.isNaN(t.value) || (i = Math.min(i, t.value), n = Math.max(n, t.value));
                     return {
                         min: i,
                         max: n
                     }
-                }(e.referenceFrame.chr, t)), this.tracks))
+                }(e.referenceFrame.chr, t)), this.tracks)
                 for (let i = 0, n = this.tracks.length; i < n; i++) {
                     const n = Object.assign({}, e);
                     n.features = t[i], this.tracks[i].dataRange = this.dataRange, this.tracks[i].flipAxis = this.flipAxis, this.tracks[i].logScale = this.logScale, this.graphType && (this.tracks[i].graphType = this.graphType), this.tracks[i].draw(n)
                 }
+            const i = this.getScaleFactor(this.dataRange.min, this.dataRange.max, e.pixelHeight, this.logScale),
+                n = e => this.logScale ? this.computeYPixelValueInLogScale(e, i) : this.computeYPixelValue(e, i);
+            if (this.config.hasOwnProperty("guideLines"))
+                for (let t of this.config.guideLines)
+                    if (t.hasOwnProperty("color") && t.hasOwnProperty("y") && t.hasOwnProperty("dotted")) {
+                        let i = n(t.y),
+                            r = {
+                                strokeStyle: t.color,
+                                strokeWidth: 1
+                            };
+                        t.dotted ? ko.dashedLine(e.context, 0, i, e.pixelWidth, i, 5, r) : ko.strokeLine(e.context, 0, i, e.pixelWidth, i, r)
+                    }
         }
         popupData(e, t) {
             const i = t || e.viewport.cachedFeatures;
             if (i && i.length === this.tracks.length) {
                 const t = [];
                 for (let n = 0; n < this.tracks.length; n++) {
                     n > 0 && t.push("<hr/>"), t.push(`<div style=background-color:rgb(245,245,245);border-bottom-style:dashed;border-bottom-width:1px;padding-bottom:5px;padding-top:10px;font-weight:bold;font-size:larger >${this.tracks[n].name}</div>`);
                     const r = this.tracks[n].popupData(e, i[n]);
                     t.push(...r)
                 }
                 return t
             }
         }
     }
-    const Zm = new Map([
-            ["ideogram", (e, t) => new yf(e, t)],
-            ["sequence", (e, t) => new ka(e, t)],
-            ["feature", (e, t) => new bu(e, t)],
-            ["seg", (e, t) => new Qu(e, t)],
-            ["mut", (e, t) => new Qu(e, t)],
-            ["maf", (e, t) => new Qu(e, t)],
-            ["wig", (e, t) => new $u(e, t)],
-            ["merged", (e, t) => new Yu(e, t)],
-            ["alignment", (e, t) => new ku(e, t)],
-            ["interaction", (e, t) => new Ju(e, t)],
-            ["interact", (e, t) => new Ju(e, t)],
-            ["variant", (e, t) => new hf(e, t)],
-            ["eqtl", (e, t) => new df(e, t)],
-            ["gwas", (e, t) => new pf(e, t)],
-            ["arc", (e, t) => new bf(e, t)],
-            ["gcnv", (e, t) => new gf(e, t)],
-            ["junction", (e, t) => new Cf(e, t)],
-            ["blat", (e, t) => new yu(e, t)],
-            ["cnvpytor", (e, t) => new Gm(e, t)]
+    const Vm = new Map([
+            ["ideogram", (e, t) => new sf(e, t)],
+            ["sequence", (e, t) => new ma(e, t)],
+            ["feature", (e, t) => new eu(e, t)],
+            ["seg", (e, t) => new Fu(e, t)],
+            ["mut", (e, t) => new Fu(e, t)],
+            ["maf", (e, t) => new Fu(e, t)],
+            ["wig", (e, t) => new Ru(e, t)],
+            ["merged", (e, t) => new Ou(e, t)],
+            ["alignment", (e, t) => new cu(e, t)],
+            ["interaction", (e, t) => new Du(e, t)],
+            ["interact", (e, t) => new Du(e, t)],
+            ["variant", (e, t) => new Gu(e, t)],
+            ["eqtl", (e, t) => new Qu(e, t)],
+            ["gwas", (e, t) => new Ku(e, t)],
+            ["arc", (e, t) => new tf(e, t)],
+            ["gcnv", (e, t) => new Ju(e, t)],
+            ["junction", (e, t) => new hf(e, t)],
+            ["blat", (e, t) => new ou(e, t)],
+            ["cnvpytor", (e, t) => new Hm(e, t)]
         ]),
-        Qm = function(e, t) {
-            Zm.set(e, t)
+        Um = function(e, t) {
+            Vm.set(e, t)
         };
-    var Xm = Qm,
-        Ym = function(e, t, i) {
+    var qm = Um,
+        jm = function(e, t, i) {
             let n;
             switch (e) {
                 case "annotation":
                 case "genes":
                 case "fusionjuncspan":
                 case "snp":
                     n = "feature";
@@ -31452,17 +31960,17 @@
                 case "junctions":
                 case "splicejunctions":
                     n = "junction";
                     break;
                 default:
                     n = e
             }
-            return Zm.has(n) ? Zm.get(n)(t, i) : void 0
+            return Vm.has(n) ? Vm.get(n)(t, i) : void 0
         };
-    class Km {
+    class $m {
         constructor(e, t) {
             const i = (new DOMParser).parseFromString(e, "text/xml");
             this.processRootNode(i, t);
             const n = i.getElementsByTagName("Resource"),
                 r = i.getElementsByTagName("Track"),
                 s = r && r.length > 0,
                 o = [];
@@ -31478,24 +31986,24 @@
             })), s && Array.from(r).forEach((function(e) {
                 const t = e.getElementsByTagName("Track");
                 if (t && t.length > 0) {
                     const i = {
                         type: "merged",
                         tracks: []
                     };
-                    Jm(e, i), o.push(i), Array.from(t).forEach((function(e) {
+                    Wm(e, i), o.push(i), Array.from(t).forEach((function(e) {
                         e.processed = !0;
                         const t = e.getAttribute("id"),
                             n = a.get(t);
-                        n && (i.tracks.push(n), Jm(e, n), n.autoscale = !1, i.height = n.height)
+                        n && (i.tracks.push(n), Wm(e, n), n.autoscale = !1, i.height = n.height)
                     }))
                 } else if (!e.processed) {
                     const t = e.getAttribute("id"),
                         i = a.get(t);
-                    i && (o.push(i), Jm(e, i))
+                    i && (o.push(i), Wm(e, i))
                 }
             }))
         }
         processRootNode(e, t) {
             const i = e.getElementsByTagName("Session");
             !i || i.length;
             const n = i.item(0),
@@ -31504,15 +32012,15 @@
                 o = n.getAttribute("ucscID");
             t && t.hasOwnProperty(r) ? this.genome = r : (this.reference = {
                 fastaURL: r
             }, o && (this.reference.id = o)), s && (this.locus = s)
         }
     }
 
-    function Jm(e, t) {
+    function Wm(e, t) {
         t.name = e.getAttribute("name");
         const i = e.getAttribute("color");
         i && (t.color = "rgb(" + i + ")");
         const n = e.getAttribute("altColor");
         i && (t.altColor = "rgb(" + n + ")");
         const r = e.getAttribute("height");
         r && (t.height = parseInt(r));
@@ -31530,24 +32038,24 @@
         c && (t.normalize = "true" === c);
         const d = e.getElementsByTagName("DataRange");
         if (d.length > 0) {
             const e = d.item(0);
             t.min = Number(e.getAttribute("minimum")), t.max = Number(e.getAttribute("maximum")), t.logScale = "LOG" === e.getAttribute("type")
         }
     }
-    const eb = Yt;
-    class tb {
+    const Gm = Yt;
+    class Zm {
         constructor() {
             this.attributes = {}, this.plinkLoaded = !1
         }
         async loadPlinkFile(e, t) {
             t || (t = {});
-            var i = No(t);
-            const n = await lo.loadString(e, i);
-            var r = eb(n);
+            var i = Mo(t);
+            const n = await io.loadString(e, i);
+            var r = Gm(n);
             for (let e of r) {
                 var s = e.split(" ");
                 this.attributes[s[1]] = {
                     familyId: s[0],
                     fatherId: s[2],
                     motherId: s[3],
                     sex: s[4],
@@ -31562,28 +32070,28 @@
         getAttributeNames() {
             return this.hasAttributes() ? Object.keys(this.attributes[Object.keys(this.attributes)[0]]) : []
         }
         hasAttributes() {
             return Object.keys(this.attributes).length > 0
         }
     }
-    class ib {
+    class Qm {
         constructor(e, t) {
-            this.geneColors = {}, this.gene = null, this.snp = null, this.genesCount = 0, e && (this.gene = e.toUpperCase(), this.geneColors[this.gene] = nb[this.genesCount++]), t && (this.snp = t.toUpperCase())
+            this.geneColors = {}, this.gene = null, this.snp = null, this.genesCount = 0, e && (this.gene = e.toUpperCase(), this.geneColors[this.gene] = Xm[this.genesCount++]), t && (this.snp = t.toUpperCase())
         }
         addGene(e) {
-            this.geneColors[e.toUpperCase()] || (this.geneColors[e.toUpperCase()] = nb[this.genesCount++])
+            this.geneColors[e.toUpperCase()] || (this.geneColors[e.toUpperCase()] = Xm[this.genesCount++])
         }
         colorForGene(e) {
             return this.geneColors[e.toUpperCase()]
         }
     }
-    var nb = [];
-    nb.push("rgb(228,26,28)"), nb.push("rgb(55,126,184)"), nb.push("rgb(77,175,74)"), nb.push("rgb(166,86,40)"), nb.push("rgb(152,78,163)"), nb.push("rgb(255,127,0)"), nb.push("rgb(247,129,191)"), nb.push("rgb(153,153,153)"), nb.push("rgb(255,255,51)"), nb.push("rgb(102, 194, 165"), nb.push("rgb(252, 141, 98"), nb.push("rgb(141, 160, 203"), nb.push("rgb(231, 138, 195"), nb.push("rgb(166, 216, 84"), nb.push("rgb(255, 217, 47"), nb.push("rgb(229, 196, 148"), nb.push("rgb(179, 179, 179"), nb.push("rgb( 141, 211, 199"), nb.push("rgb(255, 255, 179"), nb.push("rgb(190, 186, 218"), nb.push("rgb(251, 128, 114"), nb.push("rgb(128, 177, 211"), nb.push("rgb(253, 180, 98"), nb.push("rgb(179, 222, 105"), nb.push("rgb(252, 205, 229"), nb.push("rgb(217, 217, 217"), nb.push("rgb(188, 128, 189"), nb.push("rgb(204, 235, 197"), nb.push("rgb(255, 237, 111");
-    class rb {
+    var Xm = [];
+    Xm.push("rgb(228,26,28)"), Xm.push("rgb(55,126,184)"), Xm.push("rgb(77,175,74)"), Xm.push("rgb(166,86,40)"), Xm.push("rgb(152,78,163)"), Xm.push("rgb(255,127,0)"), Xm.push("rgb(247,129,191)"), Xm.push("rgb(153,153,153)"), Xm.push("rgb(255,255,51)"), Xm.push("rgb(102, 194, 165"), Xm.push("rgb(252, 141, 98"), Xm.push("rgb(141, 160, 203"), Xm.push("rgb(231, 138, 195"), Xm.push("rgb(166, 216, 84"), Xm.push("rgb(255, 217, 47"), Xm.push("rgb(229, 196, 148"), Xm.push("rgb(179, 179, 179"), Xm.push("rgb( 141, 211, 199"), Xm.push("rgb(255, 255, 179"), Xm.push("rgb(190, 186, 218"), Xm.push("rgb(251, 128, 114"), Xm.push("rgb(128, 177, 211"), Xm.push("rgb(253, 180, 98"), Xm.push("rgb(179, 222, 105"), Xm.push("rgb(252, 205, 229"), Xm.push("rgb(217, 217, 217"), Xm.push("rgb(188, 128, 189"), Xm.push("rgb(204, 235, 197"), Xm.push("rgb(255, 237, 111");
+    class Ym {
         constructor(e, t, i, n, r) {
             this.genome = e, this.chr = t, this.start = i, this.end = n, this.bpPerPixel = r, this.id = _t.guid()
         }
         extend(e) {
             const t = Math.min(e.start, this.start),
                 i = Math.max(e.end, this.end),
                 n = (i - t) / (this.end - this.start);
@@ -31636,15 +32144,15 @@
         getChromosome() {
             return this.genome.getChromosome(this.chr)
         }
         getMultiLocusLabelBPLengthOnly(e) {
             const t = "&nbsp",
                 i = Math.floor(this.start) + 1,
                 n = Math.round(this.start + this.bpPerPixel * e);
-            return `${t}${this.chr}${t}${zo(n-i)}${t}`
+            return `${t}${this.chr}${t}${Io(n-i)}${t}`
         }
         getMultiLocusLabelLocusOnly(e) {
             const t = "&nbsp",
                 {
                     chr: i,
                     start: n,
                     end: r
@@ -31655,15 +32163,15 @@
             const t = "&nbsp",
                 {
                     chr: i,
                     start: n,
                     end: r
                 } = this.getPresentationLocusComponents(e),
                 s = Math.floor(this.start) + 1;
-            return `${t}${i}:${n}-${r}${t}${t}(${zo(Math.round(this.start+this.bpPerPixel*e)-s)})${t}`
+            return `${t}${i}:${n}-${r}${t}${t}(${Io(Math.round(this.start+this.bpPerPixel*e)-s)})${t}`
         }
         getPresentationLocusComponents(e) {
             if ("all" === this.chr) return {
                 chr: this.chr
             }; {
                 const t = Xt(Math.floor(this.start) + 1),
                     i = Xt(Math.round(this.start + this.bpPerPixel * e));
@@ -31681,30 +32189,30 @@
                 return `${this.chr}:${e}-${t}`
             }
         }
         description(e) {
             console.log(` ${e||""} referenceFrame - ${this.chr} bpp ${this.bpPerPixel.toFixed(3)} start ${Xt(Math.round(this.start))} end ${Xt(Math.round(this.end))} `)
         }
     }
-    const sb = {
+    const Km = {
         timeout: 5e3,
         type: "plain",
         url: "https://igv.org/genomes/locus.php?genome=$GENOME$&name=$FEATURE$",
         coords: 0,
         chromosomeField: "chromosome",
         startField: "start",
         endField: "end",
         geneField: "gene",
         snpField: "snp"
     };
-    async function ob(e, t) {
+    async function Jm(e, t) {
         if (void 0 === t || "" === t.trim()) return;
         (t && "all" === t.trim().toLowerCase() || "*" === t) && (t = "all");
         const i = t.split(" ");
-        let n = e.searchConfig || sb,
+        let n = e.searchConfig || Km,
             r = [];
         const s = async i => {
             let r = function(e, t) {
                 const i = t.split("\t");
                 if (i.length >= 3) try {
                     const t = e.genome.getChromosomeName(i[0]),
                         n = parseInt(i[1].replace(/,/g, ""), 10) - 1,
@@ -31747,15 +32255,15 @@
                             }
                         }
                     }
                     return t
                 }
             }(e, i);
             if (!r) {
-                const n = e.genome.featureDB[i.toUpperCase()];
+                const n = e.genome.featureDB.get(i.toUpperCase());
                 n && (r = {
                     chr: n.chr,
                     start: n.start,
                     end: n.end,
                     gene: n.name,
                     locusSearchString: t
                 })
@@ -31763,15 +32271,15 @@
             if (!r && e.config && !1 !== e.config.search) try {
                 r = await async function(e, t, i) {
                     let n = i.url.replace("$FEATURE$", t.toUpperCase());
                     n.indexOf("$GENOME$") > -1 && (n = n.replace("$GENOME$", e.genome.id ? e.genome.id : "hg19"));
                     const r = i.timeout ? {
                             timeout: i.timeout
                         } : void 0,
-                        s = await lo.loadString(n, r),
+                        s = await io.loadString(n, r),
                         o = function(e, t, i) {
                             let n;
                             n = "plain" === i.type ? function(e, t) {
                                 const i = [],
                                     n = [];
                                 return Yt(t).forEach((function(e) {
                                     "" === e || i.push(e)
@@ -31825,50 +32333,50 @@
         }
         if (0 === r.length) {
             const e = await s(t);
             e && (e.locusSearchString = t, r.push(e))
         }
         return 0 === r.length ? void 0 : r
     }
-    class ab {
+    class eb {
         constructor(e) {
             this.browser = e
         }
         navbarDidResize(e) {
             this.updateNavbar(this.createResponsiveClassSchedule(e))
         }
         updateNavbar(e) {
             this.browser.$toggle_button_container.removeClass(), this.browser.$toggle_button_container.addClass(e.$toggle_button_container), ft(this.browser.zoomWidget.zoomContainer).removeClass(), ft(this.browser.zoomWidget.zoomContainer).addClass(e.zoomContainer)
         }
         createResponsiveClassSchedule(e) {
             let t = {};
-            const i = this.browser.isMultiLocusWholeGenomeView() || this.browser.referenceFrameList && za.isWholeGenomeView(this.browser.referenceFrameList[0].chr);
+            const i = this.browser.isMultiLocusWholeGenomeView() || this.browser.referenceFrameList && La.isWholeGenomeView(this.browser.referenceFrameList[0].chr);
             return i ? this.browser.windowSizePanel.hide() : this.browser.windowSizePanel.show(), e > 990 ? (t.$toggle_button_container = "igv-navbar-toggle-button-container", t.zoomContainer = "igv-zoom-widget") : e > 860 ? (t.$toggle_button_container = "igv-navbar-toggle-button-container", t.zoomContainer = "igv-zoom-widget-900") : e > 540 ? (t.$toggle_button_container = "igv-navbar-toggle-button-container-750", t.zoomContainer = "igv-zoom-widget-900") : (t.$toggle_button_container = "igv-navbar-toggle-button-container-750", t.zoomContainer = "igv-zoom-widget-900", this.browser.windowSizePanel.hide()), i && (t.zoomContainer = "igv-zoom-widget-hidden"), t
         }
     }
-    const lb = function(e, t) {
+    const tb = function(e, t) {
         this.container = _t.div({
             class: "igv-chromosome-select-widget-container"
         }), t.appendChild(this.container), this.select = document.createElement("select"), this.select.setAttribute("name", "chromosome-select-widget"), this.container.appendChild(this.select), this.select.addEventListener("change", (() => {
             this.select.blur(), "" !== this.select.value && e.search(this.select.value)
         })), this.showAllChromosomes = !1 !== e.config.showAllChromosomes
     };
-    lb.prototype.show = function() {
+    tb.prototype.show = function() {
         this.container.style.display = "flex"
-    }, lb.prototype.hide = function() {
+    }, tb.prototype.hide = function() {
         this.container.style.display = "none"
-    }, lb.prototype.update = function(e) {
+    }, tb.prototype.update = function(e) {
         const t = this.showAllChromosomes ? e.chromosomeNames.slice() : e.wgChromosomeNames.slice();
         e.showWholeGenomeView() && (t.unshift("all"), t.unshift("")), this.select.innerHTML = "";
         for (let e of t) {
             const t = document.createElement("option");
             t.setAttribute("value", e), t.innerText = e, this.select.appendChild(t)
         }
     };
-    class hb {
+    class ib {
         constructor(e, t) {
             this.container = _t.div({
                 class: "igv-windowsize-panel-container"
             }), e.appendChild(this.container), t.on("locuschange", (e => {
                 this.updatePanel(e)
             })), this.browser = t
         }
@@ -31876,18 +32384,18 @@
             this.container.style.display = "block"
         }
         hide() {
             this.container.style.display = "none"
         }
         updatePanel(e) {
             const t = this.browser.calculateViewportWidth(this.browser.referenceFrameList.length);
-            this.container.innerText = 1 === e.length ? zo(Math.round(t * e[0].bpPerPixel)) : ""
+            this.container.innerText = 1 === e.length ? Io(Math.round(t * e[0].bpPerPixel)) : ""
         }
     }
-    class cb {
+    class nb {
         constructor(e, t) {
             this.browser = t, this.columnContainer = e, this.horizontalGuide = _t.div({
                 class: "igv-cursor-guide-horizontal"
             }), e.appendChild(this.horizontalGuide), this.verticalGuide = _t.div({
                 class: "igv-cursor-guide-vertical"
             }), e.appendChild(this.verticalGuide), this.addMouseHandler(t), this.setVisibility(t.config.showCursorGuide)
         }
@@ -31938,15 +32446,15 @@
             this.verticalGuide.style.display = "block", this.horizontalGuide.style.display = "block"
         }
         hide() {
             if (this.verticalGuide.style.display = "none", this.horizontalGuide.style.display = "none", this.browser.getRulerTrackView())
                 for (let e of this.browser.getRulerTrackView().viewports) e.$tooltip.hide()
         }
     }
-    class db {
+    class rb {
         constructor(e, t) {
             this.browser = e, this.button = _t.div({
                 class: "igv-navbar-button"
             }), t.appendChild(this.button), this.button.textContent = "cursor guide", this.button.addEventListener("click", (() => {
                 e.cursorGuideVisible = !e.cursorGuideVisible, e.setCursorGuideVisibility(e.cursorGuideVisible), this.setButtonState(e.cursorGuideVisible)
             })), this.setButtonState(e.cursorGuideVisible), e.config.showCursorTrackingGuideButton ? this.show() : this.hide()
         }
@@ -31956,15 +32464,15 @@
         show() {
             this.button.style.display = "block", this.setButtonState(this.browser.cursorGuideVisible)
         }
         hide() {
             this.button.style.display = "none"
         }
     }
-    class ub {
+    class sb {
         constructor(e, t) {
             this.browser = e, this.button = _t.div({
                 class: "igv-navbar-button"
             }), t.appendChild(this.button), this.button.textContent = "center line", this.button.addEventListener("click", (() => {
                 e.isCenterLineVisible = !e.isCenterLineVisible, e.setCenterLineVisibility(e.isCenterLineVisible), this.setButtonState(e.isCenterLineVisible)
             })), this.setButtonState(e.isCenterLineVisible), e.config.showCenterGuideButton ? this.show() : this.hide()
         }
@@ -31974,15 +32482,15 @@
         show() {
             this.isVisible = !0, this.button.style.display = "block", this.setButtonState(this.browser.isCenterLineVisible)
         }
         hide() {
             this.isVisible = !1, this.button.style.display = "none"
         }
     }
-    class fb {
+    class ob {
         constructor(e, t) {
             this.button = _t.div({
                 class: "igv-navbar-button"
             }), e.appendChild(this.button), this.button.textContent = "track labels", this.button.addEventListener("click", (() => {
                 t.trackLabelsVisible = !t.trackLabelsVisible, this.setState(t.trackLabelsVisible), t.setTrackLabelVisibility(t.trackLabelsVisible)
             })), this.browser = t, this.setVisibility(t.config.showTrackLabelButton), this.setState(t.trackLabelsVisible)
         }
@@ -31995,15 +32503,15 @@
         show() {
             this.button.style.display = "block", this.setState(this.browser.trackLabelsVisible)
         }
         hide() {
             this.button.style.display = "none"
         }
     }
-    class pb {
+    class ab {
         constructor(e, t) {
             this.button = _t.div({
                 class: "igv-navbar-button"
             }), e.appendChild(this.button), this.button.innerText = "Sample Names", this.setState(t.showSampleNames), this.setVisibility(t.showSampleNameButton), this.button.addEventListener("click", (() => {
                 t.showSampleNames = !t.showSampleNames, this.setState(t.showSampleNames);
                 for (let {
                         sampleNameViewport: e
@@ -32021,24 +32529,24 @@
         hide() {
             this.button.style.display = "none"
         }
         show() {
             this.button.style.display = "block"
         }
     }
-    let gb = 23,
-        mb = 0;
-    const bb = function(e, t) {
+    let lb = 23,
+        hb = 0;
+    const cb = function(e, t) {
         this.browser = e, this.zoomContainer = _t.div({
             class: "igv-zoom-widget"
         }), t.appendChild(this.zoomContainer), this.zoomOutButton = _t.div(), this.zoomContainer.appendChild(this.zoomOutButton), this.zoomOutButton.appendChild(At.createIcon("minus-circle")), this.zoomOutButton.addEventListener("click", (() => {
             e.zoomOut()
         }));
         const i = _t.div();
-        this.zoomContainer.appendChild(i), this.slider = document.createElement("input"), this.slider.type = "range", this.slider.min = "0", this.slider.max = `${gb}`, i.appendChild(this.slider), this.slider.addEventListener("change", (t => {
+        this.zoomContainer.appendChild(i), this.slider = document.createElement("input"), this.slider.type = "range", this.slider.min = "0", this.slider.max = `${lb}`, i.appendChild(this.slider), this.slider.addEventListener("change", (t => {
             t.preventDefault(), t.stopPropagation();
             const i = e.referenceFrameList[0],
                 {
                     bpLength: n
                 } = i.genome.getChromosome(i.chr),
                 {
                     end: r,
@@ -32049,72 +32557,72 @@
             e.zoomWithScaleFactor(a / o)
         })), this.zoomInButton = _t.div(), this.zoomContainer.appendChild(this.zoomInButton), this.zoomInButton.appendChild(At.createIcon("plus-circle")), this.zoomInButton.addEventListener("click", (() => {
             e.zoomIn()
         })), e.on("locuschange", (e => {
             this.browser.isMultiLocusMode() ? this.disable() : (this.enable(), this.update(e))
         }))
     };
-    bb.prototype.update = function(e) {
+    cb.prototype.update = function(e) {
         const t = e[0],
             {
                 bpLength: i
             } = t.genome.getChromosome(t.chr),
             {
                 start: n,
                 end: r
             } = t;
-        gb = Math.ceil(Math.log2(i / this.browser.minimumBases())), this.slider.max = `${gb}`;
+        lb = Math.ceil(Math.log2(i / this.browser.minimumBases())), this.slider.max = `${lb}`;
         const s = i / (r - n);
-        mb = Math.log2(s), this.slider.value = `${Math.round(mb)}`
-    }, bb.prototype.enable = function() {
+        hb = Math.log2(s), this.slider.value = `${Math.round(hb)}`
+    }, cb.prototype.enable = function() {
         this.slider.disabled = !1
-    }, bb.prototype.disable = function() {
+    }, cb.prototype.disable = function() {
         this.slider.disabled = !0
-    }, bb.prototype.hide = function() {
+    }, cb.prototype.hide = function() {
         this.zoomContainer.style.display = "none"
-    }, bb.prototype.show = function() {
+    }, cb.prototype.show = function() {
         this.zoomContainer.style.display = "block"
-    }, bb.prototype.hideSlider = function() {
+    }, cb.prototype.hideSlider = function() {
         this.slider.style.display = "none"
-    }, bb.prototype.showSlider = function() {
+    }, cb.prototype.showSlider = function() {
         this.slider.style.display = "block"
     };
-    const wb = function(e, t) {
+    const db = function(e, t) {
             const i = _t.div({
                 class: "igv-navbar-button"
             });
             e.append(i), i.textContent = "Save SVG", i.addEventListener("click", (() => t.saveSVGtoFile({})))
         },
-        vb = (e, t) => {
+        ub = (e, t) => {
             const i = 0 === e ? t.nextElementSibling : t.previousElementSibling;
             t.remove(), i.remove()
         },
-        yb = e => {
+        fb = e => {
             const t = _t.div({
                 class: "igv-column-shim"
             });
-            qo(t, e);
+            Oo(t, e);
             const i = _t.div({
                 class: "igv-column"
             });
-            return qo(i, t), i
+            return Oo(i, t), i
         },
-        _b = (e, t) => {
+        pb = (e, t) => {
             for (let i = 0; i < t; i++) {
                 const n = _t.div({
                     class: "igv-column"
                 });
-                if (Uo(n, e), t > 1 && i > 0) {
-                    Uo(_t.div({
+                if (No(n, e), t > 1 && i > 0) {
+                    No(_t.div({
                         class: "igv-column-shim"
                     }), n)
                 }
             }
         };
-    class xb {
+    class gb {
         constructor(e, t, i) {
             this.browser = e, this.referenceFrame = t, this.column = i, this.container = _t.div({
                 class: "igv-center-line"
             }), i.appendChild(this.container), e.isCenterLineVisible ? this.show() : this.hide()
         }
         repaint() {
             if (this.referenceFrame) {
@@ -32130,16 +32638,16 @@
         hide() {
             this.isVisible = !1, this.container.style.display = "none"
         }
         resize() {
             this.repaint()
         }
     }
-    const kb = Xt;
-    class Cb {
+    const mb = Xt;
+    class bb {
         constructor(e) {
             this.browser = e, this.height = 40, this.name = "", this.id = "ruler", this.disableButtons = !0, this.ignoreTrackMenu = !0, this.order = .01 * Number.MIN_SAFE_INTEGER, this.removable = !1, this.type = "ruler"
         }
         async getFeatures(e, t, i) {
             return []
         }
         computePixelHeight(e) {
@@ -32149,15 +32657,15 @@
             context: e,
             referenceFrame: t,
             pixelWidth: i,
             pixelHeight: n,
             bpPerPixel: r,
             bpStart: s
         }) {
-            za.isWholeGenomeView(t.chr) ? this.drawWholeGenome({
+            La.isWholeGenomeView(t.chr) ? this.drawWholeGenome({
                 context: e,
                 pixelWidth: i,
                 pixelHeight: n,
                 bpPerPixel: r
             }) : this.doDraw({
                 context: e,
                 referenceFrame: t,
@@ -32168,15 +32676,15 @@
         }
         drawWholeGenome({
             context: e,
             pixelWidth: t,
             pixelHeight: i,
             bpPerPixel: n
         }) {
-            e.save(), Mo.fillRect(e, 0, 0, t, i, {
+            e.save(), ko.fillRect(e, 0, 0, t, i, {
                 fillStyle: "white"
             });
             for (let t of this.browser.genome.wgChromosomeNames) {
                 let r = this.browser.genome.getCumulativeOffset(t),
                     s = this.browser.genome.getChromosome(t).bpLength,
                     o = Math.round(r / n),
                     a = Math.round(s / n);
@@ -32189,25 +32697,25 @@
             referenceFrame: t,
             pixelWidth: i,
             pixelHeight: n,
             bpStart: r
         }) {
             e.clearRect(0, 0, i, n);
             const s = function(e, t) {
-                if (e < 10) return new Sb(1, "bp", 1);
+                if (e < 10) return new wb(1, "bp", 1);
                 const i = Math.floor(Math.log10(e));
                 let n = "bp",
                     r = 1;
                 i > 9 ? (n = "gb", r = 1e9) : i > 6 ? (n = "mb", r = 1e6) : i > 3 && (n = "kb", r = 1e3);
                 const s = Math.pow(10, i - 1),
                     o = e / s,
                     a = 75,
                     l = Math.pow(10, i - 1),
                     h = Math.pow(10, i) / 2;
-                return new Sb(o < a && !0 !== t ? l : h, n, r)
+                return new wb(o < a && !0 !== t ? l : h, n, r)
             }(Math.floor(t.toBP(i)), e.isSVG);
             let o = Math.floor(r / s.majorTick) - 1;
             const {
                 tickDelta: a,
                 labelLength: l
             } = function(e, t, i, n, r) {
                 const s = h(t, l(1 + n, r), i) - h(t, l(n, r), i),
@@ -32231,82 +32739,82 @@
             let d = a;
             const u = .25 * l;
             do {
                 c = Math.floor(o * s.majorTick);
                 const i = `${Xt(Math.floor(c/s.unitMultiplier))} ${s.majorUnit}`;
                 h = Math.round(t.toPixels(c - 1 - r + .5));
                 const n = Math.round(h - e.measureText(i).width / 2);
-                n > 0 && u + l <= d && (Mo.fillText(e, i, n, this.height - 8), d = 0), h > 0 && Mo.strokeLine(e, h, this.height - 6, h, this.height - 2), c = Math.floor((1 + o) * s.majorTick);
+                n > 0 && u + l <= d && (ko.fillText(e, i, n, this.height - 8), d = 0), h > 0 && ko.strokeLine(e, h, this.height - 6, h, this.height - 2), c = Math.floor((1 + o) * s.majorTick);
                 let f = h + (Math.round(t.toPixels(c - 1 - r + .5)) - h) / 2;
-                f > 0 && Mo.strokeLine(e, f, this.height - 6, f, this.height - 2), ++o, d += a
+                f > 0 && ko.strokeLine(e, f, this.height - 6, f, this.height - 2), ++o, d += a
             } while (h < i);
-            Mo.strokeLine(e, 0, this.height - 2, i, this.height - 2)
+            ko.strokeLine(e, 0, this.height - 2, i, this.height - 2)
         }
         renderChromosomeRect(e, t, i, n, r, s) {
-            e.textAlign = "center", e.textBaseline = "middle", e.font = "12px sans-serif", Mo.strokeLine(e, t + n, i, t + n, i + r, {
-                strokeStyle: js.greyScale(191)
+            e.textAlign = "center", e.textBaseline = "middle", e.font = "12px sans-serif", ko.strokeLine(e, t + n, i, t + n, i + r, {
+                strokeStyle: Ds.greyScale(191)
             });
             const o = s.startsWith("chr") ? s.substring(3) : s;
-            n > e.measureText(o).width && Mo.fillText(e, o, t + n / 2, i + r / 2, {
-                fillStyle: js.greyScale(68)
+            n > e.measureText(o).width && ko.fillText(e, o, t + n / 2, i + r / 2, {
+                fillStyle: Ds.greyScale(68)
             })
         }
         get supportsWholeGenome() {
             return !0
         }
         dispose() {}
     }
-    class Sb {
+    class wb {
         constructor(e, t, i) {
             this.majorTick = e, this.minorTick = e / 10, this.majorUnit = t, this.unitMultiplier = i
         }
         description(e) {
-            console.log((e || "") + " tick " + kb(this.majorTick) + " label width " + kb(this.labelWidthBP) + " multiplier " + this.unitMultiplier)
+            console.log((e || "") + " tick " + mb(this.majorTick) + " label width " + mb(this.labelWidthBP) + " multiplier " + this.unitMultiplier)
         }
     }
-    const Ab = function(e, t) {
+    const vb = function(e, t) {
         this.button = _t.div({
             class: "igv-navbar-button"
         }), e.appendChild(this.button), this.button.textContent = "circular view", this.button.addEventListener("click", (() => {
             t.circularViewVisible = !t.circularViewVisible
         })), this.browser = t, this.setVisibility(t.config.showCircularViewButton), this.setState(t.circularViewVisible)
     };
-    Ab.prototype.setVisibility = function(e) {
+    vb.prototype.setVisibility = function(e) {
         !0 === e ? this.show() : this.hide()
-    }, Ab.prototype.setState = function(e) {
+    }, vb.prototype.setState = function(e) {
         !0 === e ? this.button.classList.add("igv-navbar-button-clicked") : this.button.classList.remove("igv-navbar-button-clicked")
-    }, Ab.prototype.show = function() {
+    }, vb.prototype.show = function() {
         this.button.style.display = "block", this.setState(this.browser.circularViewVisible)
-    }, Ab.prototype.hide = function() {
+    }, vb.prototype.hide = function() {
         this.button.style.display = "none"
     };
-    const Eb = function(e, t, i) {
+    const yb = function(e, t, i) {
         const n = _t.div({
             class: "igv-navbar-button"
         });
         e.append(n), n.textContent = i.label, n.addEventListener("click", (() => i.callback(t)))
     };
-    class Tb {
+    class _b {
         constructor(e, t, i, n, r) {
-            this.browser = e, this.roiMenu = t, this.roiTable = i, this.top = n, this.roiSets = r || [], this.boundLocusChangeHandler = Mb.bind(this), e.on("locuschange", this.boundLocusChangeHandler)
+            this.browser = e, this.roiMenu = t, this.roiTable = i, this.top = n, this.roiSets = r || [], this.boundLocusChangeHandler = xb.bind(this), e.on("locuschange", this.boundLocusChangeHandler)
         }
         async initialize() {
             this.roiSets.length > 0 && (this.browser.showROITableButton = !0, this.browser.roiTableControl.setVisibility(this.browser.showROITableButton));
             const e = this.roiSets.map((e => this.renderROISet({
                 browser: this.browser,
                 pixelTop: this.top,
                 roiSet: e
             })));
             e.length > 0 && await Promise.all(e);
             const t = await this.getTableRecords();
             this.roiTable.renderTable(t)
         }
         async loadROI(e, t) {
             const i = Array.isArray(e) ? e : [e];
-            for (let e of i) this.roiSets.push(new Tc(e, t));
+            for (let e of i) this.roiSets.push(new fc(e, t));
             await this.initialize()
         }
         clearROIs() {
             this.roiTable.clearTable();
             const e = this.browser.columnContainer.querySelectorAll(".igv-roi-region");
             for (let t of e) t.remove();
             for (let e of this.roiSets) e.dispose();
@@ -32371,26 +32879,26 @@
                 const h = n[r].querySelectorAll(".igv-roi-region");
                 for (let e of h) {
                     const t = e.dataset.region,
                         {
                             chr: i,
                             start: n,
                             end: r
-                        } = Ib(t);
+                        } = Sb(t);
                     (i !== s || r < o || n > a) && e.remove()
                 }
                 const c = await i.getFeatures(s, o, a);
                 if (c)
                     for (let h of c) {
-                        const c = Rb(s, h.start, h.end),
+                        const c = kb(s, h.start, h.end),
                             {
                                 x: d,
                                 width: u
-                            } = Rc(Math.max(o, h.start), Math.min(a, h.end), o, l),
-                            f = n[r].querySelector(Lb(c));
+                            } = pc(Math.max(o, h.start), Math.min(a, h.end), o, l),
+                            f = n[r].querySelector(Cb(c));
                         if (f) f.style.left = `${d}px`, f.style.width = `${u}px`;
                         else {
                             const s = this.createRegionElement(e.columnContainer, t, d, u, i, c, h.name);
                             n[r].appendChild(s)
                         }
                     }
             }
@@ -32412,33 +32920,33 @@
                 t.preventDefault(), t.stopPropagation(), this.popover && this.popover.dispose(), this.popover = new Vt(e, r.name), this.popover.presentContentWithEvent(t, o)
             })) : l.style.pointerEvents = "none", a
         }
         async getUserDefinedROISet() {
             return this.roiSets.find((e => !0 === e.isUserDefined))
         }
         initializeUserDefinedROISet() {
-            const e = new Tc({
+            const e = new fc({
                 isUserDefined: !0,
                 features: []
             }, this.browser.genome);
             return this.roiSets.push(e), e
         }
         async deleteUserDefinedRegionWithKey(e, t) {
-            t.querySelectorAll(Lb(e)).forEach((e => e.remove()));
+            t.querySelectorAll(Cb(e)).forEach((e => e.remove()));
             const i = await this.findUserDefinedRegionWithKey(e),
                 n = await this.getUserDefinedROISet();
             n && n.removeFeature(i);
             0 === (await this.getTableRecords()).length && (this.browser.roiTableControl.buttonHandler(!1), this.setROITableButtonVisibility(!1))
         }
         async findUserDefinedRegionWithKey(e) {
             const {
                 chr: t,
                 start: i,
                 end: n
-            } = Ib(e), r = await this.getUserDefinedROISet();
+            } = Sb(e), r = await this.getUserDefinedROISet();
             if (r) {
                 const e = await r.getFeatures(t, i, n);
                 for (let r of e)
                     if (r.chr === t && r.start >= i && r.end <= n) return r
             }
         }
         toJSON() {
@@ -32450,60 +32958,65 @@
             for (let t of e) t.remove();
             this.roiMenu && this.roiMenu.dispose(), this.roiTable && this.roiTable.dispose();
             for (let e of this.roiSets) e.dispose();
             for (let e of Object.keys(this)) this[e] = void 0
         }
     }
 
-    function Mb() {
+    function xb() {
         this.renderAllROISets()
     }
 
-    function Rb(e, t, i) {
+    function kb(e, t, i) {
         return `${e}-${t}-${i}`
     }
 
-    function Lb(e) {
+    function Cb(e) {
         return `[data-region="${e}"]`
     }
 
-    function Ib(e) {
+    function Sb(e) {
         let [t, i, n] = e.split("-");
         return i = parseInt(i), n = parseInt(n), {
             chr: t,
             start: i,
             end: n,
             locus: `${t}:${i}-${n}`,
             bedRecord: `${t}\t${i}\t${n}`
         }
     }
-    class Bb extends wu {
+    class Ab extends tu {
+        constructor(e) {
+            super(Object.assign({
+                width: "512px"
+            }, e))
+        }
         tableRowDOM(e) {
             const t = _t.div({
                     class: "igv-roi-table-row"
                 }),
                 {
                     setName: i,
                     feature: n
                 } = e;
-            t.dataset.region = Rb(n.chr, n.start, n.end);
+            t.dataset.region = kb(n.chr, n.start, n.end);
             let r = [n.chr, Xt(n.start), Xt(n.end), n.name || "", i];
             4 === this.columnFormat.length && (r = r.slice(0, 4));
             for (let e = 0; e < r.length; e++) {
                 const i = _t.div();
                 t.appendChild(i), i.style.width = this.columnFormat[e].width, i.innerText = r[e]
             }
             return this.tableRowDOMHelper(t), t
         }
         renderTable(e) {
-            if (Array.from(this.rowContainerDOM.querySelectorAll(".igv-roi-table-row")).forEach((e => e.remove())), e.length > 0) {
+            if (Array.from(this.tableRowContainer.querySelectorAll(".igv-roi-table-row")).forEach((e => e.remove())), e.length > 0) {
                 const t = e.sort(((e, t) => e.feature.chr.localeCompare(t.feature.chr) || e.feature.start - t.feature.start || e.feature.end - t.feature.end));
                 for (let e of t) {
                     const t = this.tableRowDOM(e);
-                    this.rowContainerDOM.appendChild(t)
+                    this.tableRowContainer.appendChild(t)
                 }
             }
         }
         dispose() {
             document.removeEventListener("click", this.boundGotoButtonHandler), this.browser.roiTableControl.buttonHandler(!1), super.dispose()
         }
         static getColumnFormatConfiguration(e) {
@@ -32534,36 +33047,36 @@
             }, {
                 label: "Description",
                 width: "35%"
             }]
         }
         static gotoButtonHandler(e) {
             e.stopPropagation();
-            const t = this.container.querySelectorAll(".igv-roi-table-row-selected"),
+            const t = this.tableDOM.querySelectorAll(".igv-roi-table-row-selected"),
                 i = [];
             for (let e of t) {
                 const {
                     locus: t
-                } = Ib(e.dataset.region);
+                } = Sb(e.dataset.region);
                 i.push(t)
             }
-            for (let e of this.container.querySelectorAll(".igv-roi-table-row")) e.classList.remove("igv-roi-table-row-selected");
+            for (let e of this.tableDOM.querySelectorAll(".igv-roi-table-row")) e.classList.remove("igv-roi-table-row-selected");
             this.setTableRowSelectionState(!1), i.length > 0 && this.browser.search(i.join(" "))
         }
     }
-    class Nb {
+    class Eb {
         constructor(e, t) {
             this.browser = e, this.container = _t.div({
                 class: "igv-roi-menu-next-gen"
             }), t.appendChild(this.container);
             const i = _t.div();
-            this.container.appendChild(i), Tt.attachDialogCloseHandlerWithParent(i, (() => this.container.style.display = "none")), this.body = _t.div(), this.container.appendChild(this.body), this.container.style.display = "none"
+            this.container.appendChild(i), Mt.attachDialogCloseHandlerWithParent(i, (() => this.container.style.display = "none")), this.body = _t.div(), this.container.appendChild(this.body), this.container.style.display = "none"
         }
         async present(e, t, i, n, r) {
-            Fb(this.body);
+            Mb(this.body);
             const s = await this.browser.roiManager.findUserDefinedRegionWithKey(r.dataset.region),
                 o = _t.div();
             this.body.appendChild(o);
             const a = "Description",
                 l = s.name || a;
             o.innerText = l, o.setAttribute("title", l), a === l ? o.classList.add("igv-roi-placeholder") : o.classList.remove("igv-roi-placeholder");
             const h = _t.div();
@@ -32581,15 +33094,15 @@
             }));
             const c = _t.div();
             this.body.appendChild(c), c.innerText = "Delete Region", c.addEventListener("click", (e => {
                 e.stopPropagation(), this.container.style.display = "none", this.browser.roiManager.deleteUserDefinedRegionWithKey(r.dataset.region, this.browser.columnContainer)
             })), this.container.style.left = `${e}px`, this.container.style.top = `${t}px`, this.container.style.display = "flex"
         }
         async __present(e, t, i, n, r) {
-            Fb(this.container);
+            Mb(this.container);
             const s = await this.browser.roiManager.findUserDefinedRegionWithKey(r.dataset.region);
             let o;
             o = _t.div({
                 class: "igv-roi-menu-row-edit-description"
             }), this.container.appendChild(o), o.addEventListener("click", (e => {
                 e.stopPropagation()
             }));
@@ -32609,20 +33122,20 @@
             }))
         }
         dispose() {
             this.container.innerHTML = ""
         }
     }
 
-    function Fb(e) {
+    function Mb(e) {
         for (; e.firstChild;) e.removeChild(e.firstChild)
     }
-    class Pb {
+    class Tb {
         constructor(e, t) {
-            this.name = e.name, this.featureSource = e.featureSource || Sc(e, t), this.color = e.color || Ac
+            this.name = e.name, this.featureSource = e.featureSource || cc(e, t), this.color = e.color || dc
         }
         async getFeatures(e, t, i) {
             return this.featureSource.getFeatures({
                 chr: e,
                 start: t,
                 end: i
             })
@@ -32645,22 +33158,22 @@
                 }
                 of a) {
                 if (o < n) continue;
                 if (e > l) break;
                 const {
                     x: a,
                     width: h
-                } = Rc(e, o, n, i);
-                Mo.fillRect(t, a, r, h, s, {
+                } = pc(e, o, n, i);
+                ko.fillRect(t, a, r, h, s, {
                     fillStyle: this.color
                 })
             }
         }
     }
-    class Ob {
+    class Rb {
         constructor(e, t) {
             this.browser = t, this.button = _t.div({
                 class: "igv-navbar-button"
             }), e.appendChild(this.button), this.button.textContent = "ROI Table", this.button.addEventListener("click", (() => {
                 this.buttonHandler(!t.roiTableVisible)
             })), this.browser = t, this.setVisibility(t.showROITableButton), this.setState(t.roiTableVisible)
         }
@@ -32676,29 +33189,29 @@
         show() {
             this.button.style.display = "block", this.setState(this.browser.roiTableVisible)
         }
         hide() {
             this.button.style.display = "none"
         }
     }
-    class Db {
+    class Lb {
         constructor(e, t) {
             this.config = e, this.guid = _t.guid(), this.namespace = ".browser_" + this.guid, this.parent = t, this.root = _t.div({
                 class: "igv-container"
-            }), t.appendChild(this.root), this.alert = new Lo(this.root), this.columnContainer = _t.div({
+            }), t.appendChild(this.root), this.alert = new So(this.root), this.columnContainer = _t.div({
                 class: "igv-column-container"
-            }), this.root.appendChild(this.columnContainer), this.menuPopup = new zu(this.columnContainer), this.initialize(e), this.trackViews = [], this.constants = {
+            }), this.root.appendChild(this.columnContainer), this.menuPopup = new Su(this.columnContainer), this.initialize(e), this.trackViews = [], this.constants = {
                 dragThreshold: 3,
                 scrollThreshold: 5,
                 defaultColor: "rgb(0,0,150)",
                 doubleClickDelay: e.doubleClickDelay || 500
             }, this.eventHandlers = {}, this.addMouseHandlers(), this.setControls(e)
         }
         initialize(e) {
-            e.gtex && (au.gtexLoaded = !0), this.flanking = e.flanking, this.crossDomainProxy = e.crossDomainProxy, this.formats = e.formats, this.trackDefaults = e.trackDefaults, this.nucleotideColors = e.nucleotideColors || ma;
+            e.gtex && (jd.gtexLoaded = !0), this.flanking = e.flanking, this.crossDomainProxy = e.crossDomainProxy, this.formats = e.formats, this.trackDefaults = e.trackDefaults, this.nucleotideColors = e.nucleotideColors || ha;
             for (let e of Object.keys(this.nucleotideColors)) this.nucleotideColors[e.toLowerCase()] = this.nucleotideColors[e];
             this.trackLabelsVisible = e.showTrackLabels, this.roiTableVisible = e.showROITable, this.showROITableButton = e.showROITableButton, this.isCenterLineVisible = e.showCenterGuide, this.cursorGuideVisible = e.showCursorGuide, this.showSampleNames = e.showSampleNames, this.showSampleNameButton = e.showSampleNameButton, this.sampleNameViewportWidth = e.sampleNameViewportWidth || 200, e.search && (this.searchConfig = {
                 type: "json",
                 url: e.search.url,
                 coords: void 0 === e.search.coords ? 1 : e.search.coords,
                 chromosomeField: e.search.chromosomeField || "chromosome",
                 startField: e.search.startField || "start",
@@ -32709,15 +33222,15 @@
             })
         }
         setControls(e) {
             const t = this.createStandardControls(e);
             t.insertBefore(ft(this.columnContainer)), this.$navigation = t, !1 === e.showControls && t.hide()
         }
         createStandardControls(e) {
-            this.navbarManager = new ab(this);
+            this.navbarManager = new eb(this);
             const t = ft("<div>", {
                 class: "igv-navbar"
             });
             this.$navigation = t;
             const i = ft("<div>", {
                 class: "igv-navbar-left-container"
             });
@@ -32729,15 +33242,15 @@
             const r = ft('<svg width="690px" height="324px" viewBox="0 0 690 324" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>IGV</title><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="IGV" fill="#666666"><polygon id="Path" points="379.54574 8.00169252 455.581247 8.00169252 515.564813 188.87244 532.884012 253.529506 537.108207 253.529506 554.849825 188.87244 614.833392 8.00169252 689.60164 8.00169252 582.729511 320.722144 486.840288 320.722144"></polygon><path d="M261.482414,323.793286 C207.975678,323.793286 168.339046,310.552102 142.571329,284.069337 C116.803612,257.586572 103.919946,217.158702 103.919946,162.784513 C103.919946,108.410325 117.437235,67.8415913 144.472217,41.0770945 C171.507199,14.3125977 212.903894,0.930550071 268.663545,0.930550071 C283.025879,0.930550071 298.232828,1.84616386 314.284849,3.6774189 C330.33687,5.50867394 344.839793,7.97378798 357.794056,11.072835 L357.794056,68.968378 C339.48912,65.869331 323.578145,63.5450806 310.060654,61.9955571 C296.543163,60.4460336 284.574731,59.6712835 274.154998,59.6712835 C255.850062,59.6712835 240.502308,61.4320792 228.111274,64.9537236 C215.720241,68.4753679 205.793482,74.2507779 198.330701,82.2801269 C190.867919,90.309476 185.587729,100.87425 182.48997,113.974767 C179.392212,127.075284 177.843356,143.345037 177.843356,162.784513 C177.843356,181.942258 179.251407,198.000716 182.067551,210.960367 C184.883695,223.920018 189.671068,234.41436 196.429813,242.443709 C203.188559,250.473058 212.059279,256.178037 223.042241,259.558815 C234.025202,262.939594 247.683295,264.629958 264.01693,264.629958 C268.241146,264.629958 273.098922,264.489094 278.590403,264.207362 C284.081883,263.925631 289.643684,263.50304 295.275972,262.939577 L295.275972,159.826347 L361.595831,159.826347 L361.595831,308.579859 C344.698967,313.087564 327.239137,316.750019 309.215815,319.567334 C291.192494,322.38465 275.281519,323.793286 261.482414,323.793286 L261.482414,323.793286 L261.482414,323.793286 Z" id="Path"></path>;<polygon id="Path" points="0.81355666 5.00169252 73.0472883 5.00169252 73.0472883 317.722144 0.81355666 317.722144"></polygon></g> </g> </svg>');
             r.css("width", "34px"), r.css("height", "32px"), n.append(r), this.$current_genome = ft("<div>", {
                 class: "igv-current-genome"
             }), i.append(this.$current_genome), this.$current_genome.text("");
             const s = ft("<div>", {
                 class: "igv-navbar-genomic-location"
             });
-            i.append(s), this.chromosomeSelectWidget = new lb(this, s.get(0)), void 0 === e.showChromosomeWidget && (e.showChromosomeWidget = !0), !0 === e.showChromosomeWidget ? this.chromosomeSelectWidget.show() : this.chromosomeSelectWidget.hide();
+            i.append(s), this.chromosomeSelectWidget = new tb(this, s.get(0)), void 0 === e.showChromosomeWidget && (e.showChromosomeWidget = !0), !0 === e.showChromosomeWidget ? this.chromosomeSelectWidget.show() : this.chromosomeSelectWidget.hide();
             const o = ft("<div>", {
                 class: "igv-locus-size-group"
             });
             s.append(o);
             const a = ft("<div>", {
                 class: "igv-search-container"
             });
@@ -32745,35 +33258,35 @@
                 class: "igv-search-input",
                 type: "text",
                 placeholder: "Locus Search"
             }), a.append(this.$searchInput), this.$searchInput.change((() => this.doSearch(this.$searchInput.val())));
             const l = _t.div({
                 class: "igv-search-icon-container"
             });
-            a.append(ft(l)), l.appendChild(At.createIcon("search")), l.addEventListener("click", (() => this.doSearch(this.$searchInput.val()))), this.windowSizePanel = new hb(o.get(0), this);
+            a.append(ft(l)), l.appendChild(At.createIcon("search")), l.addEventListener("click", (() => this.doSearch(this.$searchInput.val()))), this.windowSizePanel = new ib(o.get(0), this);
             const h = ft("<div>", {
                 class: "igv-navbar-right-container"
             });
             t.append(h);
             const c = ft('<div class="igv-navbar-toggle-button-container">');
-            if (h.append(c), this.$toggle_button_container = c, this.cursorGuide = new cb(this.columnContainer, this), this.cursorGuideButton = new db(this, c.get(0)), this.centerLineButton = new ub(this, c.get(0)), this.setTrackLabelVisibility(e.showTrackLabels), this.trackLabelControl = new fb(c.get(0), this), this.roiTableControl = new Ob(c.get(0), this), this.sampleNameControl = new pb(c.get(0), this), !0 === e.showSVGButton && (this.svgSaveControl = new wb(c.get(0), this)), e.customButtons)
-                for (let t of e.customButtons) new Eb(c.get(0), this, t);
-            return this.zoomWidget = new bb(this, h.get(0)), !1 === e.showNavigation && this.$navigation.hide(), this.inputDialog = new Ft(this.root), this.inputDialog.container.id = `igv-input-dialog-${_t.guid()}`, this.dataRangeDialog = new Zt(this, ft(this.root)), this.dataRangeDialog.$container.get(0).id = `igv-data-range-dialog-${_t.guid()}`, this.genericColorPicker = new qt({
+            if (h.append(c), this.$toggle_button_container = c, this.cursorGuide = new nb(this.columnContainer, this), this.cursorGuideButton = new rb(this, c.get(0)), this.centerLineButton = new sb(this, c.get(0)), this.setTrackLabelVisibility(e.showTrackLabels), this.trackLabelControl = new ob(c.get(0), this), this.roiTableControl = new Rb(c.get(0), this), this.sampleNameControl = new ab(c.get(0), this), !0 === e.showSVGButton && (this.svgSaveControl = new db(c.get(0), this)), e.customButtons)
+                for (let t of e.customButtons) new yb(c.get(0), this, t);
+            return this.zoomWidget = new cb(this, h.get(0)), !1 === e.showNavigation && this.$navigation.hide(), this.inputDialog = new Nt(this.root), this.inputDialog.container.id = `igv-input-dialog-${_t.guid()}`, this.dataRangeDialog = new Zt(this, ft(this.root)), this.dataRangeDialog.$container.get(0).id = `igv-data-range-dialog-${_t.guid()}`, this.genericColorPicker = new qt({
                 parent: this.columnContainer,
                 width: 432
             }), this.genericColorPicker.container.id = `igv-track-color-picker-${_t.guid()}`, t
         }
         getSampleNameViewportWidth() {
             return !1 === this.showSampleNames ? 0 : this.sampleNameViewportWidth
         }
         isMultiLocusMode() {
             return this.referenceFrameList && this.referenceFrameList.length > 1
         }
         addTrackToFactory(e, t) {
-            Xm(e, t)
+            qm(e, t)
         }
         isMultiLocusWholeGenomeView() {
             if (void 0 === this.referenceFrameList || 1 === this.referenceFrameList.length) return !1;
             for (let e of this.referenceFrameList)
                 if ("all" === e.chr.toLowerCase()) return !0;
             return !1
         }
@@ -32782,15 +33295,15 @@
             return void 0 === this.referenceFrameList || 0 === this.referenceFrameList.length ? "" : 1 === this.referenceFrameList.length ? e(this.referenceFrameList[0]) : this.referenceFrameList.map((t => e(t)))
         }
         toSVG() {
             const {
                 y: e,
                 width: t,
                 height: i
-            } = this.columnContainer.getBoundingClientRect(), n = new Na({
+            } = this.columnContainer.getBoundingClientRect(), n = new Ea({
                 width: t,
                 height: 8e3,
                 backdropColor: "white",
                 multiLocusGap: 0,
                 viewbox: {
                     x: 0,
                     y: 0,
@@ -32807,150 +33320,150 @@
         renderSVG(e) {
             const t = this.toSVG();
             return e.empty(), e.append(t), t
         }
         saveSVGtoFile(e) {
             let t = this.toSVG();
             e.$container && (e.$container.empty(), e.$container.append(t));
-            ni(e.filename || "igvjs.svg", URL.createObjectURL(new Blob([t], {
+            ii(e.filename || "igvjs.svg", URL.createObjectURL(new Blob([t], {
                 type: "application/octet-stream"
             })))
         }
         async loadSession(e) {
             let t;
             return this.roiSets = [], t = e.url || e.file ? await async function(e) {
                 const t = e.url || e.file;
                 if (e.url && (e.url.startsWith("blob:") || e.url.startsWith("data:"))) {
-                    const t = Db.uncompressSession(e.url);
+                    const t = Lb.uncompressSession(e.url);
                     return JSON.parse(t)
                 } {
                     let i = e.filename;
-                    if (i || (i = e.url ? await Do(e.url) : e.file.name), i.endsWith(".xml")) {
-                        const e = za.KNOWN_GENOMES,
-                            i = await lo.loadString(t);
-                        return new Km(i, e)
+                    if (i || (i = e.url ? await Lo(e.url) : e.file.name), i.endsWith(".xml")) {
+                        const e = La.KNOWN_GENOMES,
+                            i = await io.loadString(t);
+                        return new $m(i, e)
                     }
-                    return i.endsWith(".json") ? lo.loadJson(t) : void 0
+                    return i.endsWith(".json") ? io.loadJson(t) : void 0
                 }
             }(e): e, this.loadSessionObject(t)
         }
         async loadSessionObject(e) {
-            this.cleanHouseForSession(), this.showSampleNames = e.showSampleNames || !1, this.sampleNameControl.setState(!0 === this.showSampleNames), e.sampleNameViewportWidth && (this.sampleNameViewportWidth = e.sampleNameViewportWidth), Vo(this.columnContainer, "igv-axis-column"), Vo(this.columnContainer, "igv-sample-name-column"), Vo(this.columnContainer, "igv-scrollbar-column"), Vo(this.columnContainer, "igv-track-drag-column"), Vo(this.columnContainer, "igv-gear-menu-column");
+            this.cleanHouseForSession(), this.showSampleNames = e.showSampleNames || !1, this.sampleNameControl.setState(!0 === this.showSampleNames), e.sampleNameViewportWidth && (this.sampleNameViewportWidth = e.sampleNameViewportWidth), Fo(this.columnContainer, "igv-axis-column"), Fo(this.columnContainer, "igv-sample-name-column"), Fo(this.columnContainer, "igv-scrollbar-column"), Fo(this.columnContainer, "igv-track-drag-column"), Fo(this.columnContainer, "igv-gear-menu-column");
             const t = e.reference || e.genome;
             if (!t) return void console.warn("No genome or reference object specified");
-            const i = await za.expandReference(this.alert, t);
+            const i = await La.expandReference(this.alert, t);
             await this.loadReference(i, e.locus), this.centerLineList = this.createCenterLineList(this.columnContainer);
             let n = 0;
             if (!1 !== e.showIdeogram) {
-                const e = new yf(this);
+                const e = new sf(this);
                 e.id = "ideogram";
-                const t = new qu(this, this.columnContainer, e),
+                const t = new Tu(this, this.columnContainer, e),
                     {
                         $viewport: i
                     } = t.viewports[0];
                 n = function(e) {
                     e = "string" == typeof e ? document.querySelector(e) : e;
                     const t = window.getComputedStyle(e),
                         i = parseFloat(t.marginTop) + parseFloat(t.marginBottom),
                         n = e.offsetHeight;
                     return Math.ceil(i + n)
                 }(i.get(0)), this.trackViews.push(t)
             }
-            if (!1 !== e.showRuler && this.trackViews.push(new qu(this, this.columnContainer, new Cb(this))), e.gtexSelections)
+            if (!1 !== e.showRuler && this.trackViews.push(new Tu(this, this.columnContainer, new bb(this))), e.gtexSelections)
                 for (let t of this.referenceFrameList)
                     for (let i of Object.keys(e.gtexSelections)) {
                         const n = e.gtexSelections[i].gene,
                             r = e.gtexSelections[i].snp;
-                        t.selection = new ib(n, r)
+                        t.selection = new Qm(n, r)
                     }
             this.roiManager && this.roiManager.dispose();
-            const r = new Nb(this, this.columnContainer),
+            const r = new Eb(this, this.columnContainer),
                 s = {
                     browser: this,
                     parent: this.columnContainer,
                     headerTitle: "Regions of Interest",
                     dismissHandler: () => this.roiTableControl.buttonHandler(!1),
-                    gotoButtonHandler: Bb.gotoButtonHandler
+                    gotoButtonHandler: Ab.gotoButtonHandler
                 };
             if (e.roi) {
-                const t = e.roi.map((e => new Tc(e, this.genome))),
+                const t = e.roi.map((e => new fc(e, this.genome))),
                     i = t.filter((({
                         name: e
                     }) => void 0 !== e && e.length > 0));
-                s.columnFormat = Bb.getColumnFormatConfiguration(i.length > 0);
-                const o = new Bb(s);
-                this.roiManager = new Tb(this, r, o, n, t)
+                s.columnFormat = Ab.getColumnFormatConfiguration(i.length > 0);
+                const o = new Ab(s);
+                this.roiManager = new _b(this, r, o, n, t)
             } else {
-                s.columnFormat = Bb.getColumnFormatConfiguration(!1);
-                const e = new Bb(s);
-                this.roiManager = new Tb(this, r, e, n, void 0)
+                s.columnFormat = Ab.getColumnFormatConfiguration(!1);
+                const e = new Ab(s);
+                this.roiManager = new _b(this, r, e, n, void 0)
             }
             await this.roiManager.initialize();
             const o = i.tracks || [],
                 a = e.tracks ? o.concat(e.tracks) : o;
             0 === a.filter((e => "sequence" === e.type && !e.url && !e.fastaURL)).length && a.push({
                 type: "sequence",
-                order: ba
+                order: ca
             });
             let l = 1;
             for (let e of a) void 0 === e.order && (e.order = l++);
             await this.loadTrackList(a);
             for (let e of this.trackViews.filter((e => "ruler" === e.track.type || "ideogram" === e.track.type))) e.updateViews();
             this.updateUIWithReferenceFrameList()
         }
         createCenterLineList(e) {
             const t = e.querySelectorAll(".igv-center-line");
             for (let e = 0; e < t.length; e++) t[e].remove();
             const i = [],
                 n = e.querySelectorAll(".igv-column");
-            for (let e = 0; e < n.length; e++) i.push(new xb(this, this.referenceFrameList[e], n[e]));
+            for (let e = 0; e < n.length; e++) i.push(new gb(this, this.referenceFrameList[e], n[e]));
             return i
         }
         async loadReference(e, t) {
-            const i = await za.loadGenome(e),
+            const i = await La.loadGenome(e),
                 n = void 0 === this.genome || this.genome.id !== i.id;
             this.genome = i, this.updateNavbarDOMWithGenome(i), n && this.removeAllTracks();
             let r = function(e, t) {
                 return e ? Array.isArray(e) ? e.join(" ") : e : t.getHomeChromosomeName()
             }(t, i);
             if (!await this.search(r, !0)) {
                 console.log("Initial locus not found: " + r), r = i.getHomeChromosomeName();
                 if (!await this.search(r, !0)) throw new Error("Cannot set initial locus")
             }
             n && this.circularView && this.circularView.setAssembly({
                 name: this.genome.id,
                 id: this.genome.id,
-                chromosomes: nu(this.genome)
+                chromosomes: Hd(this.genome)
             })
         }
         cleanHouseForSession() {
             for (let e of this.trackViews) e.removeDOMFromColumnContainer();
             this.columnContainer.querySelectorAll(".igv-axis-column, .igv-column-shim, .igv-column, .igv-sample-name-column, .igv-scrollbar-column, .igv-track-drag-column, .igv-gear-menu-column").forEach((e => e.remove())), this.trackViews = [], this.circularView && this.circularView.clearChords()
         }
         updateNavbarDOMWithGenome(e) {
             let t = e.id && e.id.length < 10 ? e.id : "";
             this.$current_genome.text(t), this.$current_genome.attr("title", e.id || ""), this.chromosomeSelectWidget.update(e)
         }
         async loadGenome(e) {
-            const t = await za.expandReference(this.alert, e);
+            const t = await La.expandReference(this.alert, e);
             await this.loadReference(t, void 0);
             const i = t.tracks || [];
             return 0 === i.filter((e => "sequence" === e.type)).length && i.push({
                 type: "sequence",
-                order: ba
+                order: ca
             }), await this.loadTrackList(i), await this.updateViews(), this.genome
         }
         updateUIWithReferenceFrameList() {
             const e = this.referenceFrameList;
             this.updateLocusSearchWidget();
-            const t = this.isMultiLocusWholeGenomeView() || za.isWholeGenomeView(e[0].chr);
-            this.navbarManager.navbarDidResize(this.$navigation.width(), t), Ub(this.trackViews, this.trackLabelsVisible), this.setCenterLineAndCenterLineButtonVisibility(!za.isWholeGenomeView(e[0].chr))
+            const t = this.isMultiLocusWholeGenomeView() || La.isWholeGenomeView(e[0].chr);
+            this.navbarManager.navbarDidResize(this.$navigation.width(), t), Nb(this.trackViews, this.trackLabelsVisible), this.setCenterLineAndCenterLineButtonVisibility(!La.isWholeGenomeView(e[0].chr))
         }
         setTrackLabelVisibility(e) {
-            Ub(this.trackViews, e)
+            Nb(this.trackViews, e)
         }
         setROITableVisibility(e) {
             !0 === e ? this.roiManager.presentTable() : this.roiManager.dismissTable()
         }
         setCursorGuideVisibility(e) {
             e ? this.cursorGuide.show() : this.cursorGuide.hide()
         }
@@ -32980,16 +33493,16 @@
         }
         async _loadTrack(e) {
             Qt(e) && (e = JSON.parse(e));
             try {
                 const t = await this.createTrack(e);
                 if (void 0 === t) return;
                 void 0 === t.order && (t.order = this.trackViews.length);
-                const i = new qu(this, this.columnContainer, t);
-                if (this.trackViews.push(i), Ub(this.trackViews, this.trackLabelsVisible), this.reorderTracks(), this.fireEvent("trackorderchanged", [this.getTrackOrder()]), "function" == typeof t.postInit) try {
+                const i = new Tu(this, this.columnContainer, t);
+                if (this.trackViews.push(i), Nb(this.trackViews, this.trackLabelsVisible), this.reorderTracks(), this.fireEvent("trackorderchanged", [this.getTrackOrder()]), "function" == typeof t.postInit) try {
                     i.startSpinner(), await t.postInit()
                 } finally {
                     i.stopSpinner()
                 }
                 return t.autoscaleGroup || (e.sync ? await i.updateViews() : i.updateViews()), "function" == typeof t.hasSamples && t.hasSamples() && !1 !== this.config.showSampleNameButton && this.sampleNameControl.show(), t
             } catch (t) {
                 const i = {
@@ -33032,35 +33545,35 @@
             /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
             (e.url || e.fastaURL);
             if (Qt(t) && (t = t.trim()), t)
                 if (e.format) e.format = e.format.toLowerCase();
                 else if (e.fastaURL) e.format = "fasta";
             else {
                 let i = e.filename;
-                i || (i = await Do(t));
-                const n = Xo(i);
-                "tsv" === n ? e.format = await Jo(e) : n ? e.format = n : "htsget" === e.sourceType && await jh.inferFormat(e)
+                i || (i = await Lo(t));
+                const n = qo(i);
+                "tsv" === n ? e.format = await Wo(e) : n ? e.format = n : "htsget" === e.sourceType && await Rh.inferFormat(e)
             }
             let i = e.type ? e.type.toLowerCase() : void 0;
             if (!i) {
-                if (i = Ko(e), "bedtype" === i) {
-                    const t = Sc(e, this.genome);
+                if (i = $o(e), "bedtype" === i) {
+                    const t = cc(e, this.genome);
                     e._featureSource = t;
                     const n = await t.trackType();
                     i = n || "annotation"
                 }
                 e.type = i
             }
             if (this.trackDefaults && i) {
                 const t = this.trackDefaults[i];
                 if (t)
                     for (let i in t) t.hasOwnProperty(i) && void 0 === e[i] && (e[i] = t[i])
             }
-            const n = Ym(i, e, this);
-            if (void 0 !== n) return e.roi && e.roi.length > 0 && (n.roiSets = e.roi.map((e => new Pb(e, this.genome)))), n;
+            const n = jm(i, e, this);
+            if (void 0 !== n) return e.roi && e.roi.length > 0 && (n.roiSets = e.roi.map((e => new Tb(e, this.genome)))), n;
             this.alert.present(new Error(`Error creating track.  Could not determine track type for file: ${e.url||e}`), void 0)
         }
         reorderTracks() {
             this.trackViews.sort((function(e, t) {
                 const i = e => "ideogram" === e.track.id ? 1 : "ruler" === e.track.id ? 2 : 3,
                     n = i(e),
                     r = i(t);
@@ -33141,18 +33654,18 @@
         }
         async layoutChange() {
             if (this.referenceFrameList.find((e => e.bpPerPixel < 0))) {
                 const e = this.calculateViewportWidth(this.referenceFrameList.length);
                 for (let t of this.referenceFrameList) t.bpPerPixel = (t.end - t.start) / e
             }
             if (this.referenceFrameList) {
-                const e = this.isMultiLocusWholeGenomeView() || za.isWholeGenomeView(this.referenceFrameList[0].chr);
+                const e = this.isMultiLocusWholeGenomeView() || La.isWholeGenomeView(this.referenceFrameList[0].chr);
                 this.navbarManager.navbarDidResize(this.$navigation.width(), e)
             }
-            zb.call(this), await this.updateViews()
+            Ib.call(this), await this.updateViews()
         }
         async updateViews() {
             const e = this.trackViews;
             this.updateLocusSearchWidget();
             for (let e of this.centerLineList) e.repaint();
             if (this.dragObject)
                 for (let t of e) await t.updateViews();
@@ -33171,27 +33684,28 @@
                     for (let t of e) {
                         const e = r[t],
                             s = [];
                         for (let t of e) s.push(t.getInViewFeatures());
                         const o = await Promise.all(s);
                         var i, n = [];
                         for (let e of o) n = n.concat(e);
-                        i = Fo(n);
+                        i = To(n);
                         const a = [];
                         for (let t of e) t.track.dataRange = i, t.track.autoscale = !1, a.push(t.updateViews());
                         await Promise.all(a)
                     }
                 }
                 await Promise.all(s.map((e => e.updateViews())))
             }
         }
         repaintViews() {
             for (let e of this.trackViews) e.repaintViews()
         }
         updateLocusSearchWidget() {
+            if (!this.referenceFrameList) return;
             const e = this.referenceFrameList,
                 t = this.calculateViewportWidth(this.referenceFrameList.length);
             for (let i of e) i.end = i.start + i.bpPerPixel * t;
             this.chromosomeSelectWidget.select.value = 1 === e.length ? this.referenceFrameList[0].chr : "";
             const i = this.referenceFrameList.map((e => e.getLocusString())).join(" ");
             this.$searchInput.val(i), this.fireEvent("locuschange", [this.referenceFrameList])
         }
@@ -33213,51 +33727,53 @@
         zoomIn() {
             this.zoomWithScaleFactor(.5)
         }
         zoomOut() {
             this.zoomWithScaleFactor(2)
         }
         async zoomWithScaleFactor(e, t, i) {
+            if (!this.referenceFrameList) return;
             const n = this.calculateViewportWidth(this.referenceFrameList.length);
             let r = i ? [i] : this.referenceFrameList;
             for (let i of r) i.zoomWithScaleFactor(this, e, n, t)
         }
         async addMultiLocusPanel(e, t, i, n) {
+            if (!this.referenceFrameList) return;
             const r = this.calculateViewportWidth(1 + this.referenceFrameList.length),
                 s = this.calculateViewportWidth(this.referenceFrameList.length) / this.calculateViewportWidth(1 + this.referenceFrameList.length);
             for (let e of this.referenceFrameList) e.bpPerPixel *= s;
             const o = (i - t) / r,
-                a = new rb(this.genome, e, t, i, o),
+                a = new Ym(this.genome, e, t, i, o),
                 l = n ? this.referenceFrameList.indexOf(n) : this.referenceFrameList.length - 1,
                 h = 1 + l,
                 {
                     $viewport: c
                 } = this.trackViews[0].viewports[l],
-                d = yb(c.get(0).parentElement);
+                d = fb(c.get(0).parentElement);
             if (h === this.referenceFrameList.length) {
                 this.referenceFrameList.push(a);
                 for (let e of this.trackViews) {
-                    const t = Nu(e, d, a);
+                    const t = _u(e, d, a);
                     e.viewports.push(t)
                 }
             } else {
                 this.referenceFrameList.splice(h, 0, a);
                 for (let e of this.trackViews) {
-                    const t = Nu(e, d, a);
+                    const t = _u(e, d, a);
                     e.viewports.splice(h, 0, t)
                 }
             }
-            this.centerLineList = this.createCenterLineList(this.columnContainer), zb.call(this), await this.updateViews(!0)
+            this.centerLineList = this.createCenterLineList(this.columnContainer), Ib.call(this), await this.updateViews(!0)
         }
         async removeMultiLocusPanel(e) {
             const t = this.referenceFrameList.indexOf(e),
                 {
                     $viewport: i
                 } = this.trackViews[0].viewports[t];
-            vb(t, i.parent().get(0));
+            ub(t, i.parent().get(0));
             for (let {
                     viewports: e
                 }
                 of this.trackViews) e[t].dispose(), e.splice(t, 1);
             if (this.referenceFrameList.splice(t, 1), 1 === this.referenceFrameList.length && this.getRulerTrackView())
                 for (let e of this.getRulerTrackView().viewports) e.dismissLocusLabel();
             const n = this.calculateViewportWidth(1 + this.referenceFrameList.length) / this.calculateViewportWidth(this.referenceFrameList.length);
@@ -33291,38 +33807,38 @@
             await this.search(e + ":" + t + "-" + i)
         }
         async doSearch(e, t) {
             const i = await this.search(e, t);
             return i || this.alert.present(new Error(`Unrecognized locus: <b> ${e} </b>`)), i
         }
         async search(e, t) {
-            const i = await ob(this, e);
+            const i = await Jm(this, e);
             if (i && i.length > 0) {
                 this.referenceFrameList = function(e, t, i, n, r, s) {
                     return e.map((e => {
                         if (i && e.gene && (e.start = Math.max(0, e.start - i), e.end += i), !s) {
                             const i = t.getChromosome(e.chr);
-                            Po(i.bpLength, e, n)
+                            Ro(i.bpLength, e, n)
                         }
-                        const o = new rb(t, e.chr, e.start, e.end, (e.end - e.start) / r);
-                        return o.locusSearchString = e.locusSearchString, (e.gene || e.snp) && (o.selection = new ib(e.gene, e.snp)), o
+                        const o = new Ym(t, e.chr, e.start, e.end, (e.end - e.start) / r);
+                        return o.locusSearchString = e.locusSearchString, (e.gene || e.snp) && (o.selection = new Qm(e.gene, e.snp)), o
                     }))
                 }(i, this.genome, this.flanking, this.minimumBases(), this.calculateViewportWidth(i.length), this.isSoftclipped());
                 for (let e of this.trackViews) e.removeDOMFromColumnContainer();
-                this.columnContainer.querySelectorAll(".igv-column-shim, .igv-column").forEach((e => e.remove())), _b(this.columnContainer.querySelector(".igv-sample-name-column"), this.referenceFrameList.length), this.centerLineList = this.createCenterLineList(this.columnContainer);
+                this.columnContainer.querySelectorAll(".igv-column-shim, .igv-column").forEach((e => e.remove())), pb(this.columnContainer.querySelector(".igv-sample-name-column"), this.referenceFrameList.length), this.centerLineList = this.createCenterLineList(this.columnContainer);
                 for (let e of this.trackViews) e.addDOMToColumnContainer(this, this.columnContainer, this.referenceFrameList);
                 return this.updateUIWithReferenceFrameList(), t || await this.updateViews(), !0
             }
             return !1
         }
         async loadSampleInformation(e) {
             var t = e;
             ti(e) && (t = e.name), "fam" === t.substr(t.lastIndexOf(".") + 1) && (this.sampleInformation = await
                 function(e, t) {
-                    return (new tb).loadPlinkFile(e, t)
+                    return (new Zm).loadPlinkFile(e, t)
                 }(e))
         }
         on(e, t) {
             this.eventHandlers[e] || (this.eventHandlers[e] = []), this.eventHandlers[e].push(t)
         }
         un(e, t) {
             this.off(e, t)
@@ -33347,18 +33863,18 @@
         }
         dispose() {
             this.removeMouseHandlers();
             for (let e of this.trackViews) e.dispose()
         }
         toJSON() {
             const e = {
-                version: Oa()
+                version: "2.15.7"
             };
-            if (void 0 !== this.showSampleNames && (e.showSampleNames = this.showSampleNames), 200 !== this.sampleNameViewportWidth && (e.sampleNameViewportWidth = this.sampleNameViewportWidth), e.reference = this.genome.toJSON(), ii(e.reference.fastaURL)) throw new Error(`Error. Sessions cannot include local file references ${e.reference.fastaURL.name}.`);
-            if (ii(e.reference.indexURL)) throw new Error(`Error. Sessions cannot include local file references ${e.reference.indexURL.name}.`);
+            if (void 0 !== this.showSampleNames && (e.showSampleNames = this.showSampleNames), 200 !== this.sampleNameViewportWidth && (e.sampleNameViewportWidth = this.sampleNameViewportWidth), e.reference = this.genome.toJSON(), e.reference.fastaURL instanceof File) throw new Error(`Error. Sessions cannot include local file references ${e.reference.fastaURL.name}.`);
+            if (e.reference.indexURL instanceof File) throw new Error(`Error. Sessions cannot include local file references ${e.reference.indexURL.name}.`);
             const t = [],
                 i = {};
             let n = !1,
                 r = this.trackViews[0];
             for (let {
                     referenceFrame: e
                 }
@@ -33392,15 +33908,15 @@
             }
             return e.tracks = s, e
         }
         compressedSession() {
             return function(e) {
                 const t = new Uint8Array(e.length);
                 for (var i = 0; i < e.length; i++) t[i] = e.charCodeAt(i);
-                const n = new Rs(t),
+                const n = new Cs(t),
                     r = String.fromCharCode.apply(null, n);
                 return btoa(r).replace(/\+/g, ".").replace(/\//g, "_").replace(/=/g, "-")
             }(JSON.stringify(this.toJSON()))
         }
         sessionURL() {
             const e = window.location.href.slice(),
                 t = e.indexOf("?");
@@ -33461,68 +33977,68 @@
         addMouseHandlers() {
             this.addWindowResizeHandler(), this.addRootMouseUpHandler(), this.addRootMouseLeaveHandler(), this.addColumnContainerEventHandlers()
         }
         removeMouseHandlers() {
             this.removeWindowResizeHandler(), this.removeRootMouseUpHandler(), this.removeRootMouseLeaveHandler(), this.removeColumnContainerEventHandlers()
         }
         addWindowResizeHandler() {
-            this.boundWindowResizeHandler = zb.bind(this), window.addEventListener("resize", this.boundWindowResizeHandler)
+            this.boundWindowResizeHandler = Ib.bind(this), window.addEventListener("resize", this.boundWindowResizeHandler)
         }
         removeWindowResizeHandler() {
             window.removeEventListener("resize", this.boundWindowResizeHandler)
         }
         addRootMouseUpHandler() {
-            this.boundRootMouseUpHandler = Vb.bind(this), this.root.addEventListener("mouseup", this.boundRootMouseUpHandler)
+            this.boundRootMouseUpHandler = Fb.bind(this), this.root.addEventListener("mouseup", this.boundRootMouseUpHandler)
         }
         removeRootMouseUpHandler() {
             this.root.removeEventListener("mouseup", this.boundRootMouseUpHandler)
         }
         addRootMouseLeaveHandler() {
-            this.boundRootMouseLeaveHandler = Vb.bind(this), this.root.addEventListener("mouseleave", this.boundRootMouseLeaveHandler)
+            this.boundRootMouseLeaveHandler = Fb.bind(this), this.root.addEventListener("mouseleave", this.boundRootMouseLeaveHandler)
         }
         removeRootMouseLeaveHandler() {
             this.root.removeEventListener("mouseleave", this.boundRootMouseLeaveHandler)
         }
         addColumnContainerEventHandlers() {
-            this.boundColumnContainerMouseMoveHandler = Hb.bind(this), this.boundColumnContainerTouchMoveHandler = Hb.bind(this), this.boundColumnContainerMouseLeaveHandler = Vb.bind(this), this.boundColumnContainerMouseUpHandler = Vb.bind(this), this.boundColumnContainerTouchEndHandler = Vb.bind(this), this.columnContainer.addEventListener("mousemove", this.boundColumnContainerMouseMoveHandler), this.columnContainer.addEventListener("touchmove", this.boundColumnContainerTouchMoveHandler), this.columnContainer.addEventListener("mouseleave", this.boundColumnContainerMouseLeaveHandler), this.columnContainer.addEventListener("mouseup", this.boundColumnContainerMouseUpHandler), this.columnContainer.addEventListener("touchend", this.boundColumnContainerTouchEndHandler)
+            this.boundColumnContainerMouseMoveHandler = Bb.bind(this), this.boundColumnContainerTouchMoveHandler = Bb.bind(this), this.boundColumnContainerMouseLeaveHandler = Fb.bind(this), this.boundColumnContainerMouseUpHandler = Fb.bind(this), this.boundColumnContainerTouchEndHandler = Fb.bind(this), this.columnContainer.addEventListener("mousemove", this.boundColumnContainerMouseMoveHandler), this.columnContainer.addEventListener("touchmove", this.boundColumnContainerTouchMoveHandler), this.columnContainer.addEventListener("mouseleave", this.boundColumnContainerMouseLeaveHandler), this.columnContainer.addEventListener("mouseup", this.boundColumnContainerMouseUpHandler), this.columnContainer.addEventListener("touchend", this.boundColumnContainerTouchEndHandler)
         }
         removeColumnContainerEventHandlers() {
             this.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler), this.columnContainer.removeEventListener("touchmove", this.boundColumnContainerTouchMoveHandler), this.columnContainer.removeEventListener("mouseleave", this.boundColumnContainerMouseLeaveHandler), this.columnContainer.removeEventListener("mouseup", this.boundColumnContainerMouseUpHandler), this.columnContainer.removeEventListener("touchend", this.boundColumnContainerTouchEndHandler)
         }
         static uncompressSession(e) {
             let t;
             if (e.indexOf("/gzip;base64") > 0) {
-                t = Hs(e);
+                t = Fs(e);
                 let i = "";
                 for (let e of t) i += String.fromCharCode(e);
                 return i
             }
             return function(e) {
                 e = e.replace(/\./g, "+").replace(/_/g, "/").replace(/-/g, "=");
                 const t = atob(e),
                     i = [];
                 for (let e = 0; e < t.length; e++) i.push(t.charCodeAt(e));
-                const n = Is(i);
+                const n = As(i);
                 let r = "";
                 for (let e of n) r += String.fromCharCode(e);
                 return r
             }(e.substring(5))
         }
         createCircularView(e, t) {
             var i;
-            return t = !0 === t, this.circularView = (i = this, new Xd(e, {
+            return t = !0 === t, this.circularView = (i = this, new Bd(e, {
                 onChordClick: (e, t, n) => {
                     const r = e.data,
                         s = r.mate;
 
                     function o(e) {
                         e.chr = i.genome.getChromosomeName(e.refName);
                         let t = !1;
                         for (let n of i.referenceFrameList) {
-                            const i = Td.fromLocusString(n.getLocusString());
+                            const i = dd.fromLocusString(n.getLocusString());
                             if (i.contains(e)) {
                                 t = !0;
                                 break
                             }
                             if (i.overlaps(e)) {
                                 n.extend(e), t = !0;
                                 break
@@ -33532,49 +34048,50 @@
                             const t = 2e3,
                                 n = (e.start + e.end) / 2;
                             i.addMultiLocusPanel(e.chr, n - t, n + t)
                         }
                     }
                     o(r), o(s)
                 }
-            })), this.circularViewControl = new Ab(this.$toggle_button_container.get(0), this), this.circularView.setAssembly({
+            })), this.circularViewControl = new vb(this.$toggle_button_container.get(0), this), this.circularView.setAssembly({
                 name: this.genome.id,
                 id: this.genome.id,
-                chromosomes: nu(this.genome)
+                chromosomes: Hd(this.genome)
             }), this.circularViewVisible = t, this.circularView
         }
         get circularViewVisible() {
             return void 0 !== this.circularView && this.circularView.visible
         }
         set circularViewVisible(e) {
             this.circularView && (this.circularView.visible = e, this.circularViewControl.setState(e))
         }
     }
-    async function zb() {
+    async function Ib() {
+        if (!this.referenceFrameList) return;
         const e = this.calculateViewportWidth(this.referenceFrameList.length);
         for (let t of this.referenceFrameList) {
             const i = this.referenceFrameList.indexOf(t),
                 {
                     chr: n,
                     genome: r
                 } = t,
                 {
                     bpLength: s
                 } = r.getChromosome(t.chr),
                 o = t.toBP(e);
-            za.isWholeGenomeView(n) || o > s ? t.bpPerPixel = s / e : t.end = t.start + t.toBP(e);
+            La.isWholeGenomeView(n) || o > s ? t.bpPerPixel = s / e : t.end = t.start + t.toBP(e);
             for (let {
                     viewports: t
                 }
                 of this.trackViews) t[i].setWidth(e)
         }
         this.updateUIWithReferenceFrameList(), await this.updateViews(!0)
     }
 
-    function Hb(e) {
+    function Bb(e) {
         e.preventDefault();
         const {
             x: t,
             y: i
         } = _t.pageCoordinates(e);
         if (this.vpMouseDown) {
             const {
@@ -33601,42 +34118,42 @@
                 const t = this.vpMouseDown.r * (this.vpMouseDown.lastMouseY - i);
                 e.trackView.moveScroller(t)
             }
             this.vpMouseDown.lastMouseX = t, this.vpMouseDown.lastMouseY = i
         }
     }
 
-    function Vb(e) {
+    function Fb(e) {
         this.cancelTrackPan(), this.endTrackDrag()
     }
 
-    function Ub(e, t) {
+    function Nb(e, t) {
         for (let {
                 viewports: i
             }
             of e)
             for (let e of i) e.$trackLabel && (0 === i.indexOf(e) && !0 === t ? e.$trackLabel.show() : e.$trackLabel.hide())
     }
-    let qb = [];
-    const jb = lo.setApiKey;
+    let Ob = [];
+    const Pb = io.setApiKey;
     ! function() {
         var e = document.createElement("style");
-        e.setAttribute("type", "text/css"), e.innerHTML = '.igv-navbar {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  box-sizing: border-box;\n  width: 100%;\n  color: #444;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  line-height: 32px;\n  padding-left: 8px;\n  padding-right: 8px;\n  margin-top: 2px;\n  margin-bottom: 6px;\n  height: 32px;\n  border-style: solid;\n  border-radius: 3px;\n  border-width: thin;\n  border-color: #bfbfbf;\n  background-color: #f3f3f3;\n}\n.igv-navbar .igv-navbar-left-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 32px;\n  line-height: 32px;\n}\n.igv-navbar .igv-navbar-left-container .igv-logo {\n  width: 34px;\n  height: 32px;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-left-container .igv-current-genome {\n  height: 32px;\n  margin-left: 4px;\n  margin-right: 4px;\n  user-select: none;\n  line-height: 32px;\n  vertical-align: middle;\n  text-align: center;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 100%;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-chromosome-select-widget-container {\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n  height: 100%;\n  width: 125px;\n  margin-right: 4px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-chromosome-select-widget-container select {\n  display: block;\n  cursor: pointer;\n  width: 100px;\n  height: 75%;\n  outline: none;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  margin-left: 8px;\n  height: 22px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 210px;\n  height: 22px;\n  line-height: 22px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container input.igv-search-input {\n  cursor: text;\n  width: 85%;\n  height: 22px;\n  line-height: 22px;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  text-align: left;\n  padding-left: 8px;\n  margin-right: 8px;\n  outline: none;\n  border-style: solid;\n  border-radius: 3px;\n  border-width: thin;\n  border-color: #bfbfbf;\n  background-color: white;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container .igv-search-icon-container {\n  cursor: pointer;\n  height: 16px;\n  width: 16px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-windowsize-panel-container {\n  margin-left: 4px;\n  user-select: none;\n}\n.igv-navbar .igv-navbar-right-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 32px;\n  line-height: 32px;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 100%;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container div {\n  margin-left: 0;\n  margin-right: 4px;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container div:last-child {\n  margin-left: 0;\n  margin-right: 0;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container-750 {\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget {\n  color: #737373;\n  font-size: 18px;\n  height: 32px;\n  line-height: 32px;\n  margin-left: 8px;\n  user-select: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div {\n  cursor: pointer;\n  margin-left: unset;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:first-child {\n  height: 24px;\n  width: 24px;\n  margin-left: unset;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:last-child {\n  height: 24px;\n  width: 24px;\n  margin-left: 8px;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:nth-child(even) {\n  display: block;\n  height: fit-content;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget input {\n  display: block;\n  width: 125px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget svg {\n  display: block;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 {\n  color: #737373;\n  font-size: 18px;\n  height: 32px;\n  line-height: 32px;\n  margin-left: 8px;\n  user-select: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div {\n  cursor: pointer;\n  margin-left: unset;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:first-child {\n  height: 24px;\n  width: 24px;\n  margin-left: unset;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:last-child {\n  height: 24px;\n  width: 24px;\n  margin-left: 8px;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:nth-child(even) {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 input {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 svg {\n  display: block;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-hidden {\n  display: none;\n}\n\n.igv-navbar-button {\n  display: block;\n  box-sizing: unset;\n  padding-left: 6px;\n  padding-right: 6px;\n  height: 18px;\n  text-transform: capitalize;\n  user-select: none;\n  line-height: 18px;\n  text-align: center;\n  vertical-align: middle;\n  font-family: "Open Sans", sans-serif;\n  font-size: 11px;\n  font-weight: 200;\n  color: #737373;\n  background-color: #f3f3f3;\n  border-color: #737373;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 6px;\n}\n\n.igv-navbar-button-clicked {\n  color: white;\n  background-color: #737373;\n}\n\n.igv-navbar-button:hover {\n  cursor: pointer;\n}\n\n.igv-zoom-in-notice-container {\n  z-index: 1024;\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  transform: translate(-50%, 0%);\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n  background-color: white;\n}\n.igv-zoom-in-notice-container > div {\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-top: 2px;\n  padding-bottom: 2px;\n  width: 100%;\n  height: 100%;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  color: #3f3f3f;\n}\n\n.igv-zoom-in-notice {\n  position: absolute;\n  top: 10px;\n  left: 50%;\n}\n.igv-zoom-in-notice div {\n  position: relative;\n  left: -50%;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #3f3f3f;\n  background-color: rgba(255, 255, 255, 0.51);\n  z-index: 64;\n}\n\n.igv-container-spinner {\n  position: absolute;\n  top: 90%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 1024;\n  width: 24px;\n  height: 24px;\n  pointer-events: none;\n  color: #737373;\n}\n\n.igv-multi-locus-close-button {\n  position: absolute;\n  top: 2px;\n  right: 0;\n  padding-left: 2px;\n  padding-right: 2px;\n  width: 12px;\n  height: 12px;\n  color: #666666;\n  background-color: white;\n  z-index: 1000;\n}\n.igv-multi-locus-close-button > svg {\n  vertical-align: top;\n}\n\n.igv-multi-locus-close-button:hover {\n  cursor: pointer;\n  color: #434343;\n}\n\n.igv-multi-locus-ruler-label {\n  z-index: 64;\n  position: absolute;\n  top: 2px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-multi-locus-ruler-label > div {\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  color: rgb(16, 16, 16);\n  background-color: white;\n}\n.igv-multi-locus-ruler-label > div {\n  cursor: pointer;\n}\n\n.igv-multi-locus-ruler-label-square-dot {\n  z-index: 64;\n  position: absolute;\n  left: 50%;\n  top: 5%;\n  transform: translate(-50%, 0%);\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-multi-locus-ruler-label-square-dot > div:first-child {\n  width: 14px;\n  height: 14px;\n}\n.igv-multi-locus-ruler-label-square-dot > div:last-child {\n  margin-left: 16px;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  color: rgb(16, 16, 16);\n}\n\n.igv-ruler-sweeper {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  top: 26px;\n  bottom: 0;\n  left: 0;\n  width: 0;\n  z-index: 99999;\n  background-color: rgba(68, 134, 247, 0.25);\n}\n\n.igv-ruler-tooltip {\n  pointer-events: none;\n  z-index: 128;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 1px;\n  height: 32px;\n  background-color: transparent;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-ruler-tooltip > div {\n  pointer-events: none;\n  width: 128px;\n  height: auto;\n  padding: 1px;\n  color: #373737;\n  font-size: 10px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  background-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-color: #373737;\n}\n\n.igv-track-label {\n  position: absolute;\n  left: 8px;\n  top: 8px;\n  width: auto;\n  height: auto;\n  max-width: 50%;\n  padding-left: 4px;\n  padding-right: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  text-align: center;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  border-color: #444;\n  border-radius: 2px;\n  border-style: solid;\n  border-width: thin;\n  background-color: white;\n  z-index: 128;\n  cursor: pointer;\n}\n\n.igv-track-label:hover,\n.igv-track-label:focus,\n.igv-track-label:active {\n  background-color: #e8e8e8;\n}\n\n.igv-track-label-popup-shim {\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-top: 4px;\n}\n\n.igv-center-line {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: 8;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  border-left-style: dashed;\n  border-left-width: thin;\n  border-right-style: dashed;\n  border-right-width: thin;\n}\n\n.igv-center-line-wide {\n  background-color: rgba(0, 0, 0, 0);\n  border-left-color: rgba(127, 127, 127, 0.51);\n  border-right-color: rgba(127, 127, 127, 0.51);\n}\n\n.igv-center-line-thin {\n  background-color: rgba(0, 0, 0, 0);\n  border-left-color: rgba(127, 127, 127, 0.51);\n  border-right-color: rgba(0, 0, 0, 0);\n}\n\n.igv-cursor-guide-horizontal {\n  display: none;\n  pointer-events: none;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 50%;\n  height: 1px;\n  z-index: 1;\n  margin-left: 50px;\n  margin-right: 54px;\n  border-top-style: dotted;\n  border-top-width: thin;\n  border-top-color: rgba(127, 127, 127, 0.76);\n}\n\n.igv-cursor-guide-vertical {\n  pointer-events: none;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  width: 1px;\n  z-index: 1;\n  border-left-style: dotted;\n  border-left-width: thin;\n  border-left-color: rgba(127, 127, 127, 0.76);\n  display: none;\n}\n\n.igv-user-feedback {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 512px;\n  height: 360px;\n  z-index: 2048;\n  background-color: white;\n  border-color: #a2a2a2;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #444;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-user-feedback div:first-child {\n  position: relative;\n  height: 24px;\n  width: 100%;\n  background-color: white;\n  border-bottom-color: #a2a2a2;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-user-feedback div:first-child div {\n  position: absolute;\n  top: 2px;\n  width: 16px;\n  height: 16px;\n  background-color: transparent;\n}\n.igv-user-feedback div:first-child div:first-child {\n  left: 8px;\n}\n.igv-user-feedback div:first-child div:last-child {\n  cursor: pointer;\n  right: 8px;\n}\n.igv-user-feedback div:last-child {\n  width: 100%;\n  height: calc(100% - 24px);\n  border-width: 0;\n}\n.igv-user-feedback div:last-child div {\n  width: auto;\n  height: auto;\n  margin: 8px;\n}\n\n.igv-generic-dialog-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  z-index: 2048;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header div {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-generic-dialog-container .igv-generic-dialog-one-liner {\n  color: #373737;\n  width: 95%;\n  height: 24px;\n  line-height: 24px;\n  text-align: left;\n  margin-top: 8px;\n  padding-left: 8px;\n  overflow-wrap: break-word;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input {\n  margin-top: 8px;\n  width: 95%;\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  padding-left: 8px;\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input div {\n  width: 30%;\n  height: 100%;\n  font-size: 16px;\n  text-align: right;\n  padding-right: 8px;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input input {\n  width: 50%;\n  font-size: 16px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input {\n  margin-top: 8px;\n  width: calc(100% - 16px);\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input input {\n  font-size: 16px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel {\n  width: 100%;\n  height: 28px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div {\n  margin-top: 32px;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  width: 75px;\n  height: 28px;\n  line-height: 28px;\n  text-align: center;\n  border-color: transparent;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 2px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:first-child {\n  margin-left: 32px;\n  margin-right: 0;\n  background-color: #5ea4e0;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:last-child {\n  margin-left: 0;\n  margin-right: 32px;\n  background-color: #c4c4c4;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:first-child:hover {\n  cursor: pointer;\n  background-color: #3b5c7f;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:last-child:hover {\n  cursor: pointer;\n  background-color: #7f7f7f;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok {\n  width: 100%;\n  height: 36px;\n  margin-top: 32px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok div {\n  width: 98px;\n  height: 36px;\n  line-height: 36px;\n  text-align: center;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  border-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 4px;\n  background-color: #2B81AF;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok div:hover {\n  cursor: pointer;\n  background-color: #25597f;\n}\n\n.igv-generic-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 2048;\n  background-color: white;\n  cursor: pointer;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-container div:first-child {\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  height: 24px;\n  width: 100%;\n  background-color: #dddddd;\n}\n.igv-generic-container div:first-child i {\n  display: block;\n  color: #5f5f5f;\n  cursor: pointer;\n  width: 14px;\n  height: 14px;\n  margin-right: 8px;\n  margin-bottom: 4px;\n}\n\n.igv-menu-popup {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: max-content;\n  z-index: 4096;\n  cursor: pointer;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  color: #4b4b4b;\n  background: white;\n  border-radius: 4px;\n  border-color: #7F7F7F;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-end;\n  text-align: left;\n}\n.igv-menu-popup > div:not(:first-child) {\n  width: 100%;\n}\n.igv-menu-popup > div:not(:first-child) > div {\n  background: white;\n}\n.igv-menu-popup > div:not(:first-child) > div.context-menu {\n  padding-left: 4px;\n  padding-right: 4px;\n}\n.igv-menu-popup > div:not(:first-child) > div:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-menu-popup > div:not(:first-child) > div:hover {\n  background: #efefef;\n}\n\n.igv-menu-popup-shim {\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-bottom: 1px;\n  padding-top: 1px;\n}\n\n.igv-menu-popup-header {\n  position: relative;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-menu-popup-header div {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-menu-popup-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n\n.igv-menu-popup-check-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  height: 20px;\n  margin-right: 4px;\n  background-color: transparent;\n}\n.igv-menu-popup-check-container div {\n  padding-top: 2px;\n  padding-left: 8px;\n}\n.igv-menu-popup-check-container div:first-child {\n  position: relative;\n  width: 12px;\n  height: 12px;\n}\n.igv-menu-popup-check-container div:first-child svg {\n  position: absolute;\n  width: 12px;\n  height: 12px;\n}\n\n.igv-user-feedback {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 512px;\n  height: 360px;\n  z-index: 2048;\n  background-color: white;\n  border-color: #a2a2a2;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #444;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-user-feedback div:first-child {\n  position: relative;\n  height: 24px;\n  width: 100%;\n  background-color: white;\n  border-bottom-color: #a2a2a2;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-user-feedback div:first-child div {\n  position: absolute;\n  top: 2px;\n  width: 16px;\n  height: 16px;\n  background-color: transparent;\n}\n.igv-user-feedback div:first-child div:first-child {\n  left: 8px;\n}\n.igv-user-feedback div:first-child div:last-child {\n  cursor: pointer;\n  right: 8px;\n}\n.igv-user-feedback div:last-child {\n  width: 100%;\n  height: calc(100% - 24px);\n  border-width: 0;\n}\n.igv-user-feedback div:last-child div {\n  width: auto;\n  height: auto;\n  margin: 8px;\n}\n\n.igv-loading-spinner-container {\n  z-index: 1024;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 32px;\n  height: 32px;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-loading-spinner-container > div {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  border: 4px solid rgba(128, 128, 128, 0.5);\n  border-top-color: rgb(255, 255, 255);\n  animation: spin 1s ease-in-out infinite;\n  -webkit-animation: spin 1s ease-in-out infinite;\n}\n\n@keyframes spin {\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-webkit-keyframes spin {\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n.igv-roi-menu-next-gen {\n  position: absolute;\n  z-index: 512;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  color: #4b4b4b;\n  background-color: white;\n  width: 192px;\n  border-radius: 4px;\n  border-color: #7F7F7F;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-menu-next-gen > div:first-child {\n  height: 24px;\n  border-top-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-roi-menu-next-gen > div:first-child > div {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-roi-menu-next-gen > div:first-child > div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-roi-menu-next-gen > div:last-child {\n  background-color: white;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: 0;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  text-align: start;\n  vertical-align: middle;\n  cursor: pointer;\n}\n.igv-roi-menu-next-gen > div:last-child > div {\n  height: 24px;\n  padding-left: 4px;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  border-bottom-color: #7f7f7f;\n}\n.igv-roi-menu-next-gen > div:last-child > div:not(:first-child):hover {\n  background-color: rgba(127, 127, 127, 0.1);\n}\n.igv-roi-menu-next-gen > div:last-child div:first-child {\n  cursor: default;\n  font-style: italic;\n  text-align: center;\n  padding-right: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.igv-roi-menu-next-gen > div:last-child > div:last-child {\n  border-bottom-width: 0;\n  border-bottom-color: transparent;\n}\n\n.igv-roi-placeholder {\n  font-style: normal;\n  color: rgba(75, 75, 75, 0.6);\n}\n\n.igv-roi-table {\n  position: absolute;\n  z-index: 1024;\n  width: fit-content;\n  border-color: #7f7f7f;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  font-weight: 400;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-table > div {\n  height: 24px;\n  font-size: 14px;\n  text-align: start;\n  vertical-align: middle;\n  line-height: 24px;\n}\n.igv-roi-table > div:first-child {\n  border-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-top-width: 0;\n  border-bottom-color: #7f7f7f;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n}\n.igv-roi-table > div:first-child > div:first-child {\n  text-align: center;\n  width: calc(100% - 4px - 12px);\n}\n.igv-roi-table > div:first-child > div:last-child {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7f7f7f;\n}\n.igv-roi-table > div:first-child > div:last-child > svg {\n  display: block;\n}\n.igv-roi-table > div:first-child > div:last-child:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-roi-table > .igv-roi-table-description {\n  height: fit-content;\n  padding: 4px;\n  margin-left: 4px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-roi-table > .igv-roi-table-column-titles {\n  height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n  padding-right: 16px;\n  background-color: white;\n  border-top-color: #7f7f7f;\n  border-top-style: solid;\n  border-top-width: thin;\n  border-bottom-color: #7f7f7f;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-roi-table > .igv-roi-table-column-titles > div {\n  font-size: 14px;\n  vertical-align: middle;\n  line-height: 24px;\n  text-align: left;\n  margin-left: 8px;\n  height: 24px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border-right-color: #7f7f7f;\n  border-right-style: solid;\n  border-right-width: thin;\n}\n.igv-roi-table > .igv-roi-table-column-titles > div:last-child {\n  border-right: unset;\n}\n.igv-roi-table > .igv-roi-table-row-container {\n  resize: both;\n  overflow: scroll;\n  min-width: 512px;\n  min-height: 72px;\n  height: 144px;\n  max-height: 480px;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row {\n  height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row > div {\n  font-size: 14px;\n  vertical-align: middle;\n  line-height: 24px;\n  text-align: left;\n  margin-left: 8px;\n  height: 24px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border-right-color: transparent;\n  border-right-style: solid;\n  border-right-width: thin;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row > div:last-child {\n  border-right: unset;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row-hover {\n  background-color: rgba(0, 0, 0, 0.04);\n}\n.igv-roi-table > div:last-child {\n  height: 32px;\n  line-height: 32px;\n  border-top-color: #7f7f7f;\n  border-top-style: solid;\n  border-top-width: thin;\n  border-bottom-color: transparent;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-width: 0;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n\n.igv-roi-table-row-selected {\n  background-color: rgba(0, 0, 0, 0.125);\n}\n\n.igv-roi-table-button {\n  height: 20px;\n  user-select: none;\n  line-height: 20px;\n  text-align: center;\n  vertical-align: middle;\n  font-family: "Open Sans", sans-serif;\n  font-size: 13px;\n  font-weight: 400;\n  color: black;\n  padding-left: 6px;\n  padding-right: 6px;\n  background-color: rgb(239, 239, 239);\n  border-color: black;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 3px;\n}\n\n.igv-roi-table-button:hover {\n  cursor: pointer;\n  font-weight: 400;\n  background-color: rgba(0, 0, 0, 0.13);\n}\n\n.igv-roi-region {\n  z-index: 64;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n  overflow: visible;\n  margin-top: 44px;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-region > div {\n  position: relative;\n  width: 100%;\n  height: 8px;\n  cursor: pointer;\n  pointer-events: auto;\n}\n\n.igv-roi-menu {\n  position: absolute;\n  z-index: 1024;\n  width: 144px;\n  border-color: #7f7f7f;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-menu > div:not(:last-child) {\n  border-bottom-color: rgba(128, 128, 128, 0.5);\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-roi-menu > div:first-child {\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-top-color: transparent;\n  border-top-style: solid;\n  border-top-width: 0;\n}\n.igv-roi-menu > div:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: 0;\n}\n\n.igv-roi-menu-row {\n  height: 24px;\n  padding-left: 8px;\n  font-size: small;\n  text-align: start;\n  vertical-align: middle;\n  line-height: 24px;\n  background-color: white;\n}\n\n.igv-roi-menu-row-edit-description {\n  width: -webkit-fill-available;\n  font-size: small;\n  text-align: start;\n  vertical-align: middle;\n  background-color: white;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-bottom: 4px;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n}\n.igv-roi-menu-row-edit-description > label {\n  margin-left: 2px;\n  margin-bottom: 0;\n  display: block;\n  width: -webkit-fill-available;\n}\n.igv-roi-menu-row-edit-description > input {\n  display: block;\n  margin-left: 2px;\n  margin-right: 2px;\n  margin-bottom: 1px;\n  width: -webkit-fill-available;\n}\n\n.igv-container {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  padding-top: 4px;\n  user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n}\n\n.igv-viewport {\n  position: relative;\n  margin-top: 5px;\n  line-height: 1;\n  overflow-x: hidden;\n  overflow-y: hidden;\n}\n\n.igv-viewport-content {\n  position: relative;\n  width: 100%;\n}\n.igv-viewport-content > canvas {\n  position: relative;\n  display: block;\n}\n\n.igv-column-container {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  width: 100%;\n}\n\n.igv-column-shim {\n  width: 1px;\n  margin-left: 2px;\n  margin-right: 2px;\n  background-color: #545453;\n}\n\n.igv-column {\n  position: relative;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n}\n\n.igv-axis-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 50px;\n}\n.igv-axis-column > div {\n  margin-top: 5px;\n  width: 100%;\n}\n\n.igv-sample-name-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n}\n\n.igv-scrollbar-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 14px;\n}\n.igv-scrollbar-column > div {\n  position: relative;\n  margin-top: 5px;\n  width: 14px;\n}\n.igv-scrollbar-column > div > div {\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  left: 2px;\n  width: 8px;\n  border-width: 1px;\n  border-style: solid;\n  border-color: #c4c4c4;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.igv-scrollbar-column > div > div:hover {\n  background-color: #c4c4c4;\n}\n\n.igv-track-drag-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 12px;\n  background-color: white;\n}\n.igv-track-drag-column > .igv-track-drag-handle {\n  z-index: 512;\n  position: relative;\n  cursor: pointer;\n  margin-top: 5px;\n  width: 100%;\n  border-style: solid;\n  border-width: 0;\n  border-top-right-radius: 6px;\n  border-bottom-right-radius: 6px;\n  background-color: #c4c4c4;\n}\n.igv-track-drag-column .igv-track-drag-handle-hover {\n  background-color: #787878;\n}\n.igv-track-drag-column > .igv-track-drag-shim {\n  position: relative;\n  margin-top: 5px;\n  width: 100%;\n  border-style: solid;\n  border-width: 0;\n}\n\n.igv-gear-menu-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 28px;\n}\n.igv-gear-menu-column > div {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  margin-top: 5px;\n  width: 100%;\n  background: white;\n}\n.igv-gear-menu-column > div > div {\n  position: relative;\n  margin-top: 4px;\n  width: 16px;\n  height: 16px;\n  color: #7F7F7F;\n}\n.igv-gear-menu-column > div > div:hover {\n  cursor: pointer;\n  color: #444;\n}\n\n/*# sourceMappingURL=dom.css.map */\n', document.head.append(e)
+        e.setAttribute("type", "text/css"), e.innerHTML = '.igv-navbar {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  box-sizing: border-box;\n  width: 100%;\n  color: #444;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  line-height: 32px;\n  padding-left: 8px;\n  padding-right: 8px;\n  margin-top: 2px;\n  margin-bottom: 6px;\n  height: 32px;\n  border-style: solid;\n  border-radius: 3px;\n  border-width: thin;\n  border-color: #bfbfbf;\n  background-color: #f3f3f3;\n}\n.igv-navbar .igv-navbar-left-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 32px;\n  line-height: 32px;\n}\n.igv-navbar .igv-navbar-left-container .igv-logo {\n  width: 34px;\n  height: 32px;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-left-container .igv-current-genome {\n  height: 32px;\n  margin-left: 4px;\n  margin-right: 4px;\n  user-select: none;\n  line-height: 32px;\n  vertical-align: middle;\n  text-align: center;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 100%;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-chromosome-select-widget-container {\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n  height: 100%;\n  width: 125px;\n  margin-right: 4px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-chromosome-select-widget-container select {\n  display: block;\n  cursor: pointer;\n  width: 100px;\n  height: 75%;\n  outline: none;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  margin-left: 8px;\n  height: 22px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 210px;\n  height: 22px;\n  line-height: 22px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container input.igv-search-input {\n  cursor: text;\n  width: 85%;\n  height: 22px;\n  line-height: 22px;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  text-align: left;\n  padding-left: 8px;\n  margin-right: 8px;\n  outline: none;\n  border-style: solid;\n  border-radius: 3px;\n  border-width: thin;\n  border-color: #bfbfbf;\n  background-color: white;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container .igv-search-icon-container {\n  cursor: pointer;\n  height: 16px;\n  width: 16px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-windowsize-panel-container {\n  margin-left: 4px;\n  user-select: none;\n}\n.igv-navbar .igv-navbar-right-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 32px;\n  line-height: 32px;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 100%;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container div {\n  margin-left: 0;\n  margin-right: 4px;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container div:last-child {\n  margin-left: 0;\n  margin-right: 0;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container-750 {\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget {\n  color: #737373;\n  font-size: 18px;\n  height: 32px;\n  line-height: 32px;\n  margin-left: 8px;\n  user-select: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div {\n  cursor: pointer;\n  margin-left: unset;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:first-child {\n  height: 24px;\n  width: 24px;\n  margin-left: unset;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:last-child {\n  height: 24px;\n  width: 24px;\n  margin-left: 8px;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:nth-child(even) {\n  display: block;\n  height: fit-content;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget input {\n  display: block;\n  width: 125px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget svg {\n  display: block;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 {\n  color: #737373;\n  font-size: 18px;\n  height: 32px;\n  line-height: 32px;\n  margin-left: 8px;\n  user-select: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div {\n  cursor: pointer;\n  margin-left: unset;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:first-child {\n  height: 24px;\n  width: 24px;\n  margin-left: unset;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:last-child {\n  height: 24px;\n  width: 24px;\n  margin-left: 8px;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:nth-child(even) {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 input {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 svg {\n  display: block;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-hidden {\n  display: none;\n}\n\n.igv-navbar-button {\n  display: block;\n  box-sizing: unset;\n  padding-left: 6px;\n  padding-right: 6px;\n  height: 18px;\n  text-transform: capitalize;\n  user-select: none;\n  line-height: 18px;\n  text-align: center;\n  vertical-align: middle;\n  font-family: "Open Sans", sans-serif;\n  font-size: 11px;\n  font-weight: 200;\n  color: #737373;\n  background-color: #f3f3f3;\n  border-color: #737373;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 6px;\n}\n\n.igv-navbar-button-clicked {\n  color: white;\n  background-color: #737373;\n}\n\n.igv-navbar-button:hover {\n  cursor: pointer;\n}\n\n.igv-zoom-in-notice-container {\n  z-index: 1024;\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  transform: translate(-50%, 0%);\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n  background-color: white;\n}\n.igv-zoom-in-notice-container > div {\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-top: 2px;\n  padding-bottom: 2px;\n  width: 100%;\n  height: 100%;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  color: #3f3f3f;\n}\n\n.igv-zoom-in-notice {\n  position: absolute;\n  top: 10px;\n  left: 50%;\n}\n.igv-zoom-in-notice div {\n  position: relative;\n  left: -50%;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #3f3f3f;\n  background-color: rgba(255, 255, 255, 0.51);\n  z-index: 64;\n}\n\n.igv-container-spinner {\n  position: absolute;\n  top: 90%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 1024;\n  width: 24px;\n  height: 24px;\n  pointer-events: none;\n  color: #737373;\n}\n\n.igv-multi-locus-close-button {\n  position: absolute;\n  top: 2px;\n  right: 0;\n  padding-left: 2px;\n  padding-right: 2px;\n  width: 12px;\n  height: 12px;\n  color: #666666;\n  background-color: white;\n  z-index: 1000;\n}\n.igv-multi-locus-close-button > svg {\n  vertical-align: top;\n}\n\n.igv-multi-locus-close-button:hover {\n  cursor: pointer;\n  color: #434343;\n}\n\n.igv-multi-locus-ruler-label {\n  z-index: 64;\n  position: absolute;\n  top: 2px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-multi-locus-ruler-label > div {\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  color: rgb(16, 16, 16);\n  background-color: white;\n}\n.igv-multi-locus-ruler-label > div {\n  cursor: pointer;\n}\n\n.igv-multi-locus-ruler-label-square-dot {\n  z-index: 64;\n  position: absolute;\n  left: 50%;\n  top: 5%;\n  transform: translate(-50%, 0%);\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-multi-locus-ruler-label-square-dot > div:first-child {\n  width: 14px;\n  height: 14px;\n}\n.igv-multi-locus-ruler-label-square-dot > div:last-child {\n  margin-left: 16px;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  color: rgb(16, 16, 16);\n}\n\n.igv-ruler-sweeper {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  top: 26px;\n  bottom: 0;\n  left: 0;\n  width: 0;\n  z-index: 99999;\n  background-color: rgba(68, 134, 247, 0.25);\n}\n\n.igv-ruler-tooltip {\n  pointer-events: none;\n  z-index: 128;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 1px;\n  height: 32px;\n  background-color: transparent;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-ruler-tooltip > div {\n  pointer-events: none;\n  width: 128px;\n  height: auto;\n  padding: 1px;\n  color: #373737;\n  font-size: 10px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  background-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-color: #373737;\n}\n\n.igv-track-label {\n  position: absolute;\n  left: 8px;\n  top: 8px;\n  width: auto;\n  height: auto;\n  max-width: 50%;\n  padding-left: 4px;\n  padding-right: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  text-align: center;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  border-color: #444;\n  border-radius: 2px;\n  border-style: solid;\n  border-width: thin;\n  background-color: white;\n  z-index: 128;\n  cursor: pointer;\n}\n\n.igv-track-label:hover,\n.igv-track-label:focus,\n.igv-track-label:active {\n  background-color: #e8e8e8;\n}\n\n.igv-track-label-popup-shim {\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-top: 4px;\n}\n\n.igv-center-line {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: 8;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  border-left-style: dashed;\n  border-left-width: thin;\n  border-right-style: dashed;\n  border-right-width: thin;\n}\n\n.igv-center-line-wide {\n  background-color: rgba(0, 0, 0, 0);\n  border-left-color: rgba(127, 127, 127, 0.51);\n  border-right-color: rgba(127, 127, 127, 0.51);\n}\n\n.igv-center-line-thin {\n  background-color: rgba(0, 0, 0, 0);\n  border-left-color: rgba(127, 127, 127, 0.51);\n  border-right-color: rgba(0, 0, 0, 0);\n}\n\n.igv-cursor-guide-horizontal {\n  display: none;\n  pointer-events: none;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 50%;\n  height: 1px;\n  z-index: 1;\n  margin-left: 50px;\n  margin-right: 54px;\n  border-top-style: dotted;\n  border-top-width: thin;\n  border-top-color: rgba(127, 127, 127, 0.76);\n}\n\n.igv-cursor-guide-vertical {\n  pointer-events: none;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  width: 1px;\n  z-index: 1;\n  border-left-style: dotted;\n  border-left-width: thin;\n  border-left-color: rgba(127, 127, 127, 0.76);\n  display: none;\n}\n\n.igv-user-feedback {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 512px;\n  height: 360px;\n  z-index: 2048;\n  background-color: white;\n  border-color: #a2a2a2;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #444;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-user-feedback div:first-child {\n  position: relative;\n  height: 24px;\n  width: 100%;\n  background-color: white;\n  border-bottom-color: #a2a2a2;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-user-feedback div:first-child div {\n  position: absolute;\n  top: 2px;\n  width: 16px;\n  height: 16px;\n  background-color: transparent;\n}\n.igv-user-feedback div:first-child div:first-child {\n  left: 8px;\n}\n.igv-user-feedback div:first-child div:last-child {\n  cursor: pointer;\n  right: 8px;\n}\n.igv-user-feedback div:last-child {\n  width: 100%;\n  height: calc(100% - 24px);\n  border-width: 0;\n}\n.igv-user-feedback div:last-child div {\n  width: auto;\n  height: auto;\n  margin: 8px;\n}\n\n.igv-generic-dialog-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  z-index: 2048;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header div {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-generic-dialog-container .igv-generic-dialog-one-liner {\n  color: #373737;\n  width: 95%;\n  height: 24px;\n  line-height: 24px;\n  text-align: left;\n  margin-top: 8px;\n  padding-left: 8px;\n  overflow-wrap: break-word;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input {\n  margin-top: 8px;\n  width: 95%;\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  padding-left: 8px;\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input div {\n  width: 30%;\n  height: 100%;\n  font-size: 16px;\n  text-align: right;\n  padding-right: 8px;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input input {\n  width: 50%;\n  font-size: 16px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input {\n  margin-top: 8px;\n  width: calc(100% - 16px);\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input input {\n  font-size: 16px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel {\n  width: 100%;\n  height: 28px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div {\n  margin-top: 32px;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  width: 75px;\n  height: 28px;\n  line-height: 28px;\n  text-align: center;\n  border-color: transparent;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 2px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:first-child {\n  margin-left: 32px;\n  margin-right: 0;\n  background-color: #5ea4e0;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:last-child {\n  margin-left: 0;\n  margin-right: 32px;\n  background-color: #c4c4c4;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:first-child:hover {\n  cursor: pointer;\n  background-color: #3b5c7f;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:last-child:hover {\n  cursor: pointer;\n  background-color: #7f7f7f;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok {\n  width: 100%;\n  height: 36px;\n  margin-top: 32px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok div {\n  width: 98px;\n  height: 36px;\n  line-height: 36px;\n  text-align: center;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  border-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 4px;\n  background-color: #2B81AF;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok div:hover {\n  cursor: pointer;\n  background-color: #25597f;\n}\n\n.igv-generic-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 2048;\n  background-color: white;\n  cursor: pointer;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-container div:first-child {\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  height: 24px;\n  width: 100%;\n  background-color: #dddddd;\n}\n.igv-generic-container div:first-child i {\n  display: block;\n  color: #5f5f5f;\n  cursor: pointer;\n  width: 14px;\n  height: 14px;\n  margin-right: 8px;\n  margin-bottom: 4px;\n}\n\n.igv-menu-popup {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: max-content;\n  z-index: 4096;\n  cursor: pointer;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  color: #4b4b4b;\n  background: white;\n  border-radius: 4px;\n  border-color: #7F7F7F;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-end;\n  text-align: left;\n}\n.igv-menu-popup > div:not(:first-child) {\n  width: 100%;\n}\n.igv-menu-popup > div:not(:first-child) > div {\n  background: white;\n}\n.igv-menu-popup > div:not(:first-child) > div.context-menu {\n  padding-left: 4px;\n  padding-right: 4px;\n}\n.igv-menu-popup > div:not(:first-child) > div:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-menu-popup > div:not(:first-child) > div:hover {\n  background: #efefef;\n}\n\n.igv-menu-popup-shim {\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-bottom: 1px;\n  padding-top: 1px;\n}\n\n.igv-menu-popup-header {\n  position: relative;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-menu-popup-header div {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-menu-popup-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n\n.igv-menu-popup-check-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  height: 20px;\n  margin-right: 4px;\n  background-color: transparent;\n}\n.igv-menu-popup-check-container div {\n  padding-top: 2px;\n  padding-left: 8px;\n}\n.igv-menu-popup-check-container div:first-child {\n  position: relative;\n  width: 12px;\n  height: 12px;\n}\n.igv-menu-popup-check-container div:first-child svg {\n  position: absolute;\n  width: 12px;\n  height: 12px;\n}\n\n.igv-user-feedback {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 512px;\n  height: 360px;\n  z-index: 2048;\n  background-color: white;\n  border-color: #a2a2a2;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #444;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-user-feedback div:first-child {\n  position: relative;\n  height: 24px;\n  width: 100%;\n  background-color: white;\n  border-bottom-color: #a2a2a2;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-user-feedback div:first-child div {\n  position: absolute;\n  top: 2px;\n  width: 16px;\n  height: 16px;\n  background-color: transparent;\n}\n.igv-user-feedback div:first-child div:first-child {\n  left: 8px;\n}\n.igv-user-feedback div:first-child div:last-child {\n  cursor: pointer;\n  right: 8px;\n}\n.igv-user-feedback div:last-child {\n  width: 100%;\n  height: calc(100% - 24px);\n  border-width: 0;\n}\n.igv-user-feedback div:last-child div {\n  width: auto;\n  height: auto;\n  margin: 8px;\n}\n\n.igv-loading-spinner-container {\n  z-index: 1024;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 32px;\n  height: 32px;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-loading-spinner-container > div {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  border: 4px solid rgba(128, 128, 128, 0.5);\n  border-top-color: rgb(255, 255, 255);\n  animation: spin 1s ease-in-out infinite;\n  -webkit-animation: spin 1s ease-in-out infinite;\n}\n\n@keyframes spin {\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-webkit-keyframes spin {\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n.igv-roi-menu-next-gen {\n  position: absolute;\n  z-index: 512;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  color: #4b4b4b;\n  background-color: white;\n  width: 192px;\n  border-radius: 4px;\n  border-color: #7F7F7F;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-menu-next-gen > div:first-child {\n  height: 24px;\n  border-top-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-roi-menu-next-gen > div:first-child > div {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-roi-menu-next-gen > div:first-child > div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-roi-menu-next-gen > div:last-child {\n  background-color: white;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: 0;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  text-align: start;\n  vertical-align: middle;\n}\n.igv-roi-menu-next-gen > div:last-child > div {\n  height: 24px;\n  padding-left: 4px;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  border-bottom-color: #7f7f7f;\n}\n.igv-roi-menu-next-gen > div:last-child > div:not(:first-child):hover {\n  background-color: rgba(127, 127, 127, 0.1);\n}\n.igv-roi-menu-next-gen > div:last-child div:first-child {\n  font-style: italic;\n  text-align: center;\n  padding-right: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.igv-roi-menu-next-gen > div:last-child > div:last-child {\n  border-bottom-width: 0;\n  border-bottom-color: transparent;\n}\n\n.igv-roi-placeholder {\n  font-style: normal;\n  color: rgba(75, 75, 75, 0.6);\n}\n\n.igv-roi-table {\n  position: absolute;\n  z-index: 1024;\n  width: min-content;\n  max-width: 1600px;\n  border-color: #7f7f7f;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  font-weight: 400;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  cursor: default;\n}\n.igv-roi-table > div {\n  height: 24px;\n  font-size: 14px;\n  text-align: start;\n  vertical-align: middle;\n  line-height: 24px;\n}\n.igv-roi-table > div:first-child {\n  border-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-top-width: 0;\n  border-bottom-color: #7f7f7f;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n}\n.igv-roi-table > div:first-child > div:first-child {\n  text-align: center;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  margin-left: 4px;\n  margin-right: 4px;\n  width: calc(100% - 4px - 12px);\n}\n.igv-roi-table > div:first-child > div:last-child {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7f7f7f;\n}\n.igv-roi-table > div:first-child > div:last-child > svg {\n  display: block;\n}\n.igv-roi-table > div:first-child > div:last-child:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-roi-table > .igv-roi-table-description {\n  padding: 4px;\n  margin-left: 4px;\n  word-break: break-all;\n  overflow-y: auto;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  background-color: transparent;\n}\n.igv-roi-table > .igv-roi-table-goto-explainer {\n  margin-top: 5px;\n  margin-left: 4px;\n  color: #7F7F7F;\n  font-style: italic;\n  height: 24px;\n  border-top: solid lightgray;\n  background-color: transparent;\n}\n.igv-roi-table > .igv-roi-table-column-titles {\n  height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n  padding-right: 16px;\n  background-color: white;\n  border-top-color: #7f7f7f;\n  border-top-style: solid;\n  border-top-width: thin;\n  border-bottom-color: #7f7f7f;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-roi-table > .igv-roi-table-column-titles > div {\n  font-size: 14px;\n  vertical-align: middle;\n  line-height: 24px;\n  text-align: left;\n  margin-left: 4px;\n  height: 24px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border-right-color: #7f7f7f;\n  border-right-style: solid;\n  border-right-width: thin;\n}\n.igv-roi-table > .igv-roi-table-column-titles > div:last-child {\n  border-right: unset;\n}\n.igv-roi-table > .igv-roi-table-row-container {\n  overflow: auto;\n  resize: both;\n  max-width: 1600px;\n  height: 360px;\n  background-color: transparent;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row {\n  height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row > div {\n  font-size: 14px;\n  vertical-align: middle;\n  line-height: 24px;\n  text-align: left;\n  margin-left: 4px;\n  height: 24px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border-right-color: transparent;\n  border-right-style: solid;\n  border-right-width: thin;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row > div:last-child {\n  border-right: unset;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row-hover {\n  background-color: rgba(0, 0, 0, 0.04);\n}\n.igv-roi-table > div:last-child {\n  height: 32px;\n  line-height: 32px;\n  border-top-color: #7f7f7f;\n  border-top-style: solid;\n  border-top-width: thin;\n  border-bottom-color: transparent;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-width: 0;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n\n.igv-roi-table-row-selected {\n  background-color: rgba(0, 0, 0, 0.125);\n}\n\n.igv-roi-table-button {\n  cursor: pointer;\n  height: 20px;\n  user-select: none;\n  line-height: 20px;\n  text-align: center;\n  vertical-align: middle;\n  font-family: "Open Sans", sans-serif;\n  font-size: 13px;\n  font-weight: 400;\n  color: black;\n  padding-left: 6px;\n  padding-right: 6px;\n  background-color: rgb(239, 239, 239);\n  border-color: black;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 3px;\n}\n\n.igv-roi-table-button:hover {\n  font-weight: 400;\n  background-color: rgba(0, 0, 0, 0.13);\n}\n\n.igv-roi-region {\n  z-index: 64;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n  overflow: visible;\n  margin-top: 44px;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-region > div {\n  position: relative;\n  width: 100%;\n  height: 8px;\n  pointer-events: auto;\n}\n\n.igv-roi-menu {\n  position: absolute;\n  z-index: 1024;\n  width: 144px;\n  border-color: #7f7f7f;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-menu > div:not(:last-child) {\n  border-bottom-color: rgba(128, 128, 128, 0.5);\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-roi-menu > div:first-child {\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-top-color: transparent;\n  border-top-style: solid;\n  border-top-width: 0;\n}\n.igv-roi-menu > div:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: 0;\n}\n\n.igv-roi-menu-row {\n  height: 24px;\n  padding-left: 8px;\n  font-size: small;\n  text-align: start;\n  vertical-align: middle;\n  line-height: 24px;\n  background-color: white;\n}\n\n.igv-roi-menu-row-edit-description {\n  width: -webkit-fill-available;\n  font-size: small;\n  text-align: start;\n  vertical-align: middle;\n  background-color: white;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-bottom: 4px;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n}\n.igv-roi-menu-row-edit-description > label {\n  margin-left: 2px;\n  margin-bottom: 0;\n  display: block;\n  width: -webkit-fill-available;\n}\n.igv-roi-menu-row-edit-description > input {\n  display: block;\n  margin-left: 2px;\n  margin-right: 2px;\n  margin-bottom: 1px;\n  width: -webkit-fill-available;\n}\n\n.igv-container {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  padding-top: 4px;\n  user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n}\n\n.igv-viewport {\n  position: relative;\n  margin-top: 5px;\n  line-height: 1;\n  overflow-x: hidden;\n  overflow-y: hidden;\n}\n\n.igv-viewport-content {\n  position: relative;\n  width: 100%;\n}\n.igv-viewport-content > canvas {\n  position: relative;\n  display: block;\n}\n\n.igv-column-container {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  width: 100%;\n}\n\n.igv-column-shim {\n  width: 1px;\n  margin-left: 2px;\n  margin-right: 2px;\n  background-color: #545453;\n}\n\n.igv-column {\n  position: relative;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n}\n\n.igv-axis-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 50px;\n}\n.igv-axis-column > div {\n  margin-top: 5px;\n  width: 100%;\n}\n\n.igv-sample-name-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n}\n\n.igv-scrollbar-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 14px;\n}\n.igv-scrollbar-column > div {\n  position: relative;\n  margin-top: 5px;\n  width: 14px;\n}\n.igv-scrollbar-column > div > div {\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  left: 2px;\n  width: 8px;\n  border-width: 1px;\n  border-style: solid;\n  border-color: #c4c4c4;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.igv-scrollbar-column > div > div:hover {\n  background-color: #c4c4c4;\n}\n\n.igv-track-drag-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 12px;\n  background-color: white;\n}\n.igv-track-drag-column > .igv-track-drag-handle {\n  z-index: 512;\n  position: relative;\n  cursor: pointer;\n  margin-top: 5px;\n  width: 100%;\n  border-style: solid;\n  border-width: 0;\n  border-top-right-radius: 6px;\n  border-bottom-right-radius: 6px;\n  background-color: #c4c4c4;\n}\n.igv-track-drag-column .igv-track-drag-handle-hover {\n  background-color: #787878;\n}\n.igv-track-drag-column > .igv-track-drag-shim {\n  position: relative;\n  margin-top: 5px;\n  width: 100%;\n  border-style: solid;\n  border-width: 0;\n}\n\n.igv-gear-menu-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 28px;\n}\n.igv-gear-menu-column > div {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  margin-top: 5px;\n  width: 100%;\n  background: white;\n}\n.igv-gear-menu-column > div > div {\n  position: relative;\n  margin-top: 4px;\n  width: 16px;\n  height: 16px;\n  color: #7F7F7F;\n}\n.igv-gear-menu-column > div > div:hover {\n  cursor: pointer;\n  color: #444;\n}\n\n/*# sourceMappingURL=dom.css.map */\n', document.head.append(e)
     }();
-    const $b = lo.oauth;
-    var Wb = {
-        TrackUtils: ea,
-        IGVGraphics: Mo,
+    const Db = io.oauth;
+    var zb = {
+        TrackUtils: Go,
+        IGVGraphics: ko,
         MenuUtils: $t,
         DataRangeDialog: Zt,
         createTrack: async function(e, t) {
-            return await Db.prototype.createTrack.call(t, e)
+            return await Lb.prototype.createTrack.call(t, e)
         },
         createBrowser: async function(e, t) {
-            void 0 === t && (t = {}), za.KNOWN_GENOMES || await za.initializeGenomes(t),
+            void 0 === t && (t = {}), La.KNOWN_GENOMES || await La.initializeGenomes(t),
                 function(e) {
                     void 0 === e.minimumBases && (e.minimumBases = 40);
                     void 0 === e.showIdeogram && (e.showIdeogram = !0);
                     void 0 === e.showCircularView && (e.showCircularView = !1);
                     void 0 === e.showCircularViewButton && (e.showCircularViewButton = !1);
                     void 0 === e.showTrackLabelButton && (e.showTrackLabelButton = !0);
                     void 0 === e.showTrackLabels && (e.showTrackLabels = !0);
@@ -33671,17 +34188,17 @@
                             }
                             const i = {
                                 url: c[t]
                             };
                             d && d.length > t && (i.indexURL = d[t]), u && u.length > t && (i.name = u[t]), e.tracks.push(i)
                         }
                     }
-                }(t), t.apiKey && lo.setApiKey(t.apiKey), t.oauthToken && lo.setOauthToken(t.oauthToken), t.clientId && !eo() && await async function(e) {
+                }(t), t.apiKey && io.setApiKey(t.apiKey), t.oauthToken && io.setOauthToken(t.oauthToken), t.clientId && !Zs() && await async function(e) {
                     if (!google.accounts.oauth2.initTokenClient) throw new Error("Google accounts token client not loaded (https://accounts.google.com/gsi/client)");
-                    if (eo()) throw new Error("Google client is already initialized");
+                    if (Zs()) throw new Error("Google client is already initialized");
                     const t = {
                             client_id: e.client_id,
                             scope: e.scope || "https://www.googleapis.com/auth/userinfo.profile",
                             state: e.state || "igv",
                             error: e => {
                                 throw new Error(e.type)
                             },
@@ -33694,35 +34211,35 @@
                         apiKey: e.apiKey
                     }
                 }({
                     clientId: t.clientId,
                     apiKey: t.apiKey,
                     scope: "https://www.googleapis.com/auth/userinfo.profile"
                 });
-            const i = new Db(t, e);
-            return qb.push(i), t.sessionURL ? await i.loadSession({
+            const i = new Lb(t, e);
+            return Ob.push(i), t.sessionURL ? await i.loadSession({
                 url: t.sessionURL
             }) : await i.loadSessionObject(t), i.navbarManager.navbarDidResize(i.$navigation.width()), i
         },
         removeBrowser: function(e) {
-            e.dispose(), e.root.remove(), qb = qb.filter((t => t !== e))
+            e.dispose(), e.root.remove(), Ob = Ob.filter((t => t !== e))
         },
         removeAllBrowsers: function() {
-            for (let e of qb) e.dispose(), e.root.remove();
-            qb = []
+            for (let e of Ob) e.dispose(), e.root.remove();
+            Ob = []
         },
         visibilityChange: async function() {
-            for (let e of qb) await e.visibilityChange()
+            for (let e of Ob) await e.visibilityChange()
         },
         setGoogleOauthToken: function(e) {
-            return lo.setOauthToken(e)
+            return io.setOauthToken(e)
         },
         setOauthToken: function(e, t) {
-            return lo.setOauthToken(e, t)
+            return io.setOauthToken(e, t)
         },
-        oauth: $b,
-        version: Oa,
-        setApiKey: jb
+        oauth: Db,
+        version: Ta,
+        setApiKey: Pb
     };
-    return Wb
+    return zb
 }();
 //# sourceMappingURL=igv.iife.js.map
```

### Comparing `igv-notebook-0.5.0/igv_notebook/js/localNotebookFile.js` & `igv-notebook-0.5.1/igv_notebook/js/localNotebookFile.js`

 * *Files identical despite different names*

### Comparing `igv-notebook-0.5.0/igv_notebook/js/messageHandler.js` & `igv-notebook-0.5.1/igv_notebook/js/messageHandler.js`

 * *Files identical despite different names*

### Comparing `igv-notebook-0.5.0/igv_notebook/svg.py` & `igv-notebook-0.5.1/igv_notebook/svg.py`

 * *Files identical despite different names*

### Comparing `igv-notebook-0.5.0/setup.py` & `igv-notebook-0.5.1/setup.py`

 * *Files identical despite different names*

