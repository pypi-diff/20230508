# Comparing `tmp/energiapy-1.0.6-py3-none-any.whl.zip` & `tmp/energiapy-1.0.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,69 +1,81 @@
-Zip file size: 84248 bytes, number of entries: 67
+Zip file size: 100702 bytes, number of entries: 79
 -rw-rw-rw-  2.0 fat      346 b- defN 23-Mar-16 20:41 energiapy/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-16 20:41 energiapy/aggregation/__init__.py
--rw-rw-rw-  2.0 fat    11235 b- defN 23-Apr-05 12:45 energiapy/aggregation/ahc.py
--rw-rw-rw-  2.0 fat     6110 b- defN 23-Apr-05 12:43 energiapy/aggregation/dtw.py
--rw-rw-rw-  2.0 fat     3507 b- defN 23-Apr-05 12:43 energiapy/aggregation/kmeans.py
--rw-rw-rw-  2.0 fat     5064 b- defN 23-Apr-05 12:43 energiapy/aggregation/reduce_scenario.py
+-rw-rw-rw-  2.0 fat    11211 b- defN 23-Apr-15 15:03 energiapy/aggregation/ahc.py
+-rw-rw-rw-  2.0 fat     6110 b- defN 23-Apr-07 16:10 energiapy/aggregation/dtw.py
+-rw-rw-rw-  2.0 fat     3503 b- defN 23-Apr-15 15:03 energiapy/aggregation/kmeans.py
+-rw-rw-rw-  2.0 fat     5064 b- defN 23-Apr-07 16:10 energiapy/aggregation/reduce_scenario.py
 -rw-rw-rw-  2.0 fat      357 b- defN 23-Mar-16 20:41 energiapy/components/__init__.py
--rw-rw-rw-  2.0 fat    11242 b- defN 23-Apr-05 12:43 energiapy/components/location.py
+-rw-rw-rw-  2.0 fat    13865 b- defN 23-May-02 15:12 energiapy/components/location.py
 -rw-rw-rw-  2.0 fat     1869 b- defN 23-Mar-29 12:31 energiapy/components/material.py
--rw-rw-rw-  2.0 fat     4650 b- defN 23-Mar-29 12:31 energiapy/components/network.py
--rw-rw-rw-  2.0 fat     8028 b- defN 23-Mar-29 12:31 energiapy/components/process.py
--rw-rw-rw-  2.0 fat     3952 b- defN 23-Apr-05 12:43 energiapy/components/resource.py
+-rw-rw-rw-  2.0 fat     5240 b- defN 23-May-02 15:12 energiapy/components/network.py
+-rw-rw-rw-  2.0 fat     9088 b- defN 23-May-02 15:12 energiapy/components/process.py
+-rw-rw-rw-  2.0 fat     5862 b- defN 23-May-02 15:12 energiapy/components/resource.py
 -rw-rw-rw-  2.0 fat     5521 b- defN 23-Mar-29 12:31 energiapy/components/result.py
--rw-rw-rw-  2.0 fat    21830 b- defN 23-Apr-05 12:43 energiapy/components/scenario.py
+-rw-rw-rw-  2.0 fat    29561 b- defN 23-May-03 16:57 energiapy/components/scenario.py
 -rw-rw-rw-  2.0 fat     2342 b- defN 23-Mar-29 12:31 energiapy/components/temporal_scale.py
--rw-rw-rw-  2.0 fat     2487 b- defN 23-Mar-29 12:31 energiapy/components/transport.py
+-rw-rw-rw-  2.0 fat     2487 b- defN 23-Apr-19 18:21 energiapy/components/transport.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-02 15:12 energiapy/conversion/__init__.py
+-rw-rw-rw-  2.0 fat     2857 b- defN 23-May-04 20:24 energiapy/conversion/photovoltaic.py
+-rw-rw-rw-  2.0 fat     3783 b- defN 23-May-04 20:26 energiapy/conversion/windmill.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-04 13:53 energiapy/fitting/__init__.py
--rw-rw-rw-  2.0 fat      942 b- defN 23-Apr-04 13:53 energiapy/fitting/dist.py
+-rw-rw-rw-  2.0 fat      942 b- defN 23-Apr-07 16:10 energiapy/fitting/dist.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-16 20:41 energiapy/graph/__init__.py
 -rw-rw-rw-  2.0 fat     3651 b- defN 23-Mar-29 12:31 energiapy/graph/graph.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-16 20:41 energiapy/model/__init__.py
--rw-rw-rw-  2.0 fat    19677 b- defN 23-Apr-05 12:43 energiapy/model/formulate.py
--rw-rw-rw-  2.0 fat     4867 b- defN 23-Mar-29 12:31 energiapy/model/objectives.py
--rw-rw-rw-  2.0 fat     5784 b- defN 23-Apr-05 12:43 energiapy/model/sets.py
--rw-rw-rw-  2.0 fat     3763 b- defN 23-Mar-29 12:31 energiapy/model/solve.py
+-rw-rw-rw-  2.0 fat     1177 b- defN 23-May-03 17:29 energiapy/model/bounds.py
+-rw-rw-rw-  2.0 fat    26799 b- defN 23-May-03 16:57 energiapy/model/formulate.py
+-rw-rw-rw-  2.0 fat    10207 b- defN 23-May-02 15:12 energiapy/model/objectives.py
+-rw-rw-rw-  2.0 fat     6464 b- defN 23-May-02 15:12 energiapy/model/sets.py
+-rw-rw-rw-  2.0 fat     4848 b- defN 23-Apr-20 21:23 energiapy/model/solve.py
 -rw-rw-rw-  2.0 fat      364 b- defN 23-Mar-16 20:41 energiapy/model/constraints/__init__.py
--rw-rw-rw-  2.0 fat      354 b- defN 23-Apr-04 13:53 energiapy/model/constraints/chance.py
--rw-rw-rw-  2.0 fat    23040 b- defN 23-Apr-05 12:43 energiapy/model/constraints/cost.py
--rw-rw-rw-  2.0 fat    10496 b- defN 23-Apr-04 13:53 energiapy/model/constraints/emission.py
--rw-rw-rw-  2.0 fat     2467 b- defN 23-Mar-29 12:31 energiapy/model/constraints/failure.py
--rw-rw-rw-  2.0 fat     1717 b- defN 23-Mar-29 12:31 energiapy/model/constraints/integer_cuts.py
--rw-rw-rw-  2.0 fat     9045 b- defN 23-Mar-29 12:31 energiapy/model/constraints/inventory.py
--rw-rw-rw-  2.0 fat     4293 b- defN 23-Mar-29 12:31 energiapy/model/constraints/land.py
--rw-rw-rw-  2.0 fat      784 b- defN 23-Mar-26 11:39 energiapy/model/constraints/lifecyle.py
--rw-rw-rw-  2.0 fat     5045 b- defN 23-Mar-29 12:31 energiapy/model/constraints/mode.py
--rw-rw-rw-  2.0 fat     9433 b- defN 23-Mar-29 12:31 energiapy/model/constraints/production.py
--rw-rw-rw-  2.0 fat    21310 b- defN 23-Apr-05 12:43 energiapy/model/constraints/resource_balance.py
--rw-rw-rw-  2.0 fat     8757 b- defN 23-Mar-29 12:31 energiapy/model/constraints/transport.py
--rw-rw-rw-  2.0 fat     3133 b- defN 23-Mar-29 12:31 energiapy/model/constraints/uncertain.py
+-rw-rw-rw-  2.0 fat     1849 b- defN 23-May-02 15:12 energiapy/model/constraints/chance.py
+-rw-rw-rw-  2.0 fat      768 b- defN 23-May-02 15:12 energiapy/model/constraints/constraints.py
+-rw-rw-rw-  2.0 fat    25403 b- defN 23-May-03 16:58 energiapy/model/constraints/cost.py
+-rw-rw-rw-  2.0 fat     3588 b- defN 23-Apr-17 18:22 energiapy/model/constraints/credit.py
+-rw-rw-rw-  2.0 fat    11547 b- defN 23-May-03 19:58 energiapy/model/constraints/emission.py
+-rw-rw-rw-  2.0 fat     2565 b- defN 23-Apr-17 18:22 energiapy/model/constraints/failure.py
+-rw-rw-rw-  2.0 fat     4044 b- defN 23-Apr-17 18:22 energiapy/model/constraints/integer_cuts.py
+-rw-rw-rw-  2.0 fat     8663 b- defN 23-Apr-17 18:22 energiapy/model/constraints/inventory.py
+-rw-rw-rw-  2.0 fat     4287 b- defN 23-Apr-17 18:22 energiapy/model/constraints/land.py
+-rw-rw-rw-  2.0 fat      778 b- defN 23-Apr-17 18:22 energiapy/model/constraints/lifecyle.py
+-rw-rw-rw-  2.0 fat     3760 b- defN 23-Apr-17 18:22 energiapy/model/constraints/material.py
+-rw-rw-rw-  2.0 fat     7247 b- defN 23-Apr-17 18:22 energiapy/model/constraints/mode.py
+-rw-rw-rw-  2.0 fat     8815 b- defN 23-Apr-17 18:22 energiapy/model/constraints/network.py
+-rw-rw-rw-  2.0 fat     9642 b- defN 23-May-02 15:12 energiapy/model/constraints/production.py
+-rw-rw-rw-  2.0 fat    28903 b- defN 23-May-02 15:12 energiapy/model/constraints/resource_balance.py
+-rw-rw-rw-  2.0 fat     8751 b- defN 23-Apr-17 18:22 energiapy/model/constraints/transport.py
+-rw-rw-rw-  2.0 fat     3127 b- defN 23-Apr-17 18:22 energiapy/model/constraints/uncertain.py
 -rw-rw-rw-  2.0 fat      362 b- defN 23-Mar-16 20:41 energiapy/model/variables/__init__.py
--rw-rw-rw-  2.0 fat     1258 b- defN 23-Mar-29 12:31 energiapy/model/variables/binary.py
--rw-rw-rw-  2.0 fat      594 b- defN 23-Mar-29 12:31 energiapy/model/variables/cost.py
--rw-rw-rw-  2.0 fat     1511 b- defN 23-Mar-29 12:31 energiapy/model/variables/mode.py
--rw-rw-rw-  2.0 fat     7311 b- defN 23-Mar-29 12:31 energiapy/model/variables/network.py
--rw-rw-rw-  2.0 fat     2258 b- defN 23-Mar-29 12:31 energiapy/model/variables/schedule.py
--rw-rw-rw-  2.0 fat     2002 b- defN 23-Mar-29 12:31 energiapy/model/variables/transport.py
--rw-rw-rw-  2.0 fat     2499 b- defN 23-Mar-29 12:31 energiapy/model/variables/uncertain.py
+-rw-rw-rw-  2.0 fat     1252 b- defN 23-Apr-17 18:22 energiapy/model/variables/binary.py
+-rw-rw-rw-  2.0 fat      676 b- defN 23-Apr-15 15:03 energiapy/model/variables/cost.py
+-rw-rw-rw-  2.0 fat     1415 b- defN 23-Apr-17 18:22 energiapy/model/variables/credit.py
+-rw-rw-rw-  2.0 fat     2372 b- defN 23-Apr-17 18:22 energiapy/model/variables/emission.py
+-rw-rw-rw-  2.0 fat     1829 b- defN 23-Apr-17 18:22 energiapy/model/variables/land.py
+-rw-rw-rw-  2.0 fat     1536 b- defN 23-Apr-17 18:22 energiapy/model/variables/material.py
+-rw-rw-rw-  2.0 fat     1670 b- defN 23-Apr-17 18:22 energiapy/model/variables/mode.py
+-rw-rw-rw-  2.0 fat     5342 b- defN 23-May-02 15:12 energiapy/model/variables/network.py
+-rw-rw-rw-  2.0 fat     2713 b- defN 23-May-02 15:12 energiapy/model/variables/schedule.py
+-rw-rw-rw-  2.0 fat     1996 b- defN 23-Apr-17 18:22 energiapy/model/variables/transport.py
+-rw-rw-rw-  2.0 fat     1620 b- defN 23-Apr-20 17:17 energiapy/model/variables/uncertain.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-16 20:41 energiapy/plot/__init__.py
--rw-rw-rw-  2.0 fat     4172 b- defN 23-Apr-04 13:53 energiapy/plot/plot_fit.py
--rw-rw-rw-  2.0 fat    12614 b- defN 23-Apr-05 12:43 energiapy/plot/plot_results.py
--rw-rw-rw-  2.0 fat     8743 b- defN 23-Apr-04 13:53 energiapy/plot/plot_scenario.py
+-rw-rw-rw-  2.0 fat     4162 b- defN 23-Apr-15 15:03 energiapy/plot/plot_fit.py
+-rw-rw-rw-  2.0 fat    12614 b- defN 23-Apr-07 16:10 energiapy/plot/plot_results.py
+-rw-rw-rw-  2.0 fat    11560 b- defN 23-May-02 15:12 energiapy/plot/plot_scenario.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-16 20:41 energiapy/utils/__init__.py
 -rw-rw-rw-  2.0 fat      416 b- defN 23-Mar-26 11:39 energiapy/utils/cluster_utils.py
--rw-rw-rw-  2.0 fat    14438 b- defN 23-Apr-04 13:53 energiapy/utils/data_utils.py
--rw-rw-rw-  2.0 fat     3360 b- defN 23-Mar-29 12:31 energiapy/utils/latex_utils.py
+-rw-rw-rw-  2.0 fat    14792 b- defN 23-Apr-07 16:10 energiapy/utils/data_utils.py
+-rw-rw-rw-  2.0 fat     3360 b- defN 23-Apr-10 13:20 energiapy/utils/latex_utils.py
 -rw-rw-rw-  2.0 fat     2900 b- defN 23-Mar-29 12:31 energiapy/utils/math_utils.py
--rw-rw-rw-  2.0 fat     4849 b- defN 23-Mar-29 12:31 energiapy/utils/nsrdb_utils.py
+-rw-rw-rw-  2.0 fat     5052 b- defN 23-May-04 15:15 energiapy/utils/nsrdb_utils.py
 -rw-rw-rw-  2.0 fat     1542 b- defN 23-Mar-24 20:04 energiapy/utils/plot_utils.py
--rw-rw-rw-  2.0 fat     1041 b- defN 23-Mar-29 12:31 energiapy/utils/process_utils.py
+-rw-rw-rw-  2.0 fat     1053 b- defN 23-Apr-15 15:03 energiapy/utils/process_utils.py
 -rw-rw-rw-  2.0 fat     1461 b- defN 23-Mar-24 17:50 energiapy/utils/pwl_utils.py
--rw-rw-rw-  2.0 fat     1289 b- defN 23-Apr-05 12:43 energiapy/utils/resource_utils.py
--rw-rw-rw-  2.0 fat     2912 b- defN 23-Apr-05 12:43 energiapy/utils/scale_utils.py
--rw-rw-rw-  2.0 fat     1092 b- defN 23-Apr-05 14:42 energiapy-1.0.6.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     5933 b- defN 23-Apr-05 14:42 energiapy-1.0.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-05 14:42 energiapy-1.0.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       10 b- defN 23-Apr-05 14:42 energiapy-1.0.6.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     5929 b- defN 23-Apr-05 14:42 energiapy-1.0.6.dist-info/RECORD
-67 files, 318050 bytes uncompressed, 74762 bytes compressed:  76.5%
+-rw-rw-rw-  2.0 fat     1391 b- defN 23-May-02 15:12 energiapy/utils/resource_utils.py
+-rw-rw-rw-  2.0 fat     2937 b- defN 23-Apr-15 15:03 energiapy/utils/scale_utils.py
+-rw-rw-rw-  2.0 fat     1092 b- defN 23-May-08 19:09 energiapy-1.0.7.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     6001 b- defN 23-May-08 19:09 energiapy-1.0.7.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-08 19:09 energiapy-1.0.7.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       10 b- defN 23-May-08 19:09 energiapy-1.0.7.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     7035 b- defN 23-May-08 19:09 energiapy-1.0.7.dist-info/RECORD
+79 files, 397508 bytes uncompressed, 89458 bytes compressed:  77.5%
```

## zipnote {}

```diff
@@ -42,14 +42,23 @@
 
 Filename: energiapy/components/temporal_scale.py
 Comment: 
 
 Filename: energiapy/components/transport.py
 Comment: 
 
+Filename: energiapy/conversion/__init__.py
+Comment: 
+
+Filename: energiapy/conversion/photovoltaic.py
+Comment: 
+
+Filename: energiapy/conversion/windmill.py
+Comment: 
+
 Filename: energiapy/fitting/__init__.py
 Comment: 
 
 Filename: energiapy/fitting/dist.py
 Comment: 
 
 Filename: energiapy/graph/__init__.py
@@ -57,14 +66,17 @@
 
 Filename: energiapy/graph/graph.py
 Comment: 
 
 Filename: energiapy/model/__init__.py
 Comment: 
 
+Filename: energiapy/model/bounds.py
+Comment: 
+
 Filename: energiapy/model/formulate.py
 Comment: 
 
 Filename: energiapy/model/objectives.py
 Comment: 
 
 Filename: energiapy/model/sets.py
@@ -75,17 +87,23 @@
 
 Filename: energiapy/model/constraints/__init__.py
 Comment: 
 
 Filename: energiapy/model/constraints/chance.py
 Comment: 
 
+Filename: energiapy/model/constraints/constraints.py
+Comment: 
+
 Filename: energiapy/model/constraints/cost.py
 Comment: 
 
+Filename: energiapy/model/constraints/credit.py
+Comment: 
+
 Filename: energiapy/model/constraints/emission.py
 Comment: 
 
 Filename: energiapy/model/constraints/failure.py
 Comment: 
 
 Filename: energiapy/model/constraints/integer_cuts.py
@@ -96,17 +114,23 @@
 
 Filename: energiapy/model/constraints/land.py
 Comment: 
 
 Filename: energiapy/model/constraints/lifecyle.py
 Comment: 
 
+Filename: energiapy/model/constraints/material.py
+Comment: 
+
 Filename: energiapy/model/constraints/mode.py
 Comment: 
 
+Filename: energiapy/model/constraints/network.py
+Comment: 
+
 Filename: energiapy/model/constraints/production.py
 Comment: 
 
 Filename: energiapy/model/constraints/resource_balance.py
 Comment: 
 
 Filename: energiapy/model/constraints/transport.py
@@ -120,14 +144,26 @@
 
 Filename: energiapy/model/variables/binary.py
 Comment: 
 
 Filename: energiapy/model/variables/cost.py
 Comment: 
 
+Filename: energiapy/model/variables/credit.py
+Comment: 
+
+Filename: energiapy/model/variables/emission.py
+Comment: 
+
+Filename: energiapy/model/variables/land.py
+Comment: 
+
+Filename: energiapy/model/variables/material.py
+Comment: 
+
 Filename: energiapy/model/variables/mode.py
 Comment: 
 
 Filename: energiapy/model/variables/network.py
 Comment: 
 
 Filename: energiapy/model/variables/schedule.py
@@ -180,23 +216,23 @@
 
 Filename: energiapy/utils/resource_utils.py
 Comment: 
 
 Filename: energiapy/utils/scale_utils.py
 Comment: 
 
-Filename: energiapy-1.0.6.dist-info/LICENSE
+Filename: energiapy-1.0.7.dist-info/LICENSE
 Comment: 
 
-Filename: energiapy-1.0.6.dist-info/METADATA
+Filename: energiapy-1.0.7.dist-info/METADATA
 Comment: 
 
-Filename: energiapy-1.0.6.dist-info/WHEEL
+Filename: energiapy-1.0.7.dist-info/WHEEL
 Comment: 
 
-Filename: energiapy-1.0.6.dist-info/top_level.txt
+Filename: energiapy-1.0.7.dist-info/top_level.txt
 Comment: 
 
-Filename: energiapy-1.0.6.dist-info/RECORD
+Filename: energiapy-1.0.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## energiapy/aggregation/ahc.py

```diff
@@ -8,15 +8,14 @@
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 
 from enum import Enum, auto
-from typing import Tuple
 
 import matplotlib.pyplot as plt
 import numpy
 import pandas
 from sklearn.cluster import AgglomerativeClustering
 from sklearn.neighbors import NearestCentroid
 
@@ -252,15 +251,15 @@
             x, 2) + theta[0] * pow(x, 3) for x in range_list]
         # y_slope = [theta[2] + 2*theta[1] *
                 #    pow(x, 1) + 3*theta[0] * pow(x, 2) for x in range_list]
 
     fig, ax = plt.subplots(figsize=(8, 6))
     x = range_list
 
-    ax.plot(x, y_line, label='MARS fit', color='steelblue', alpha=0.6)
+    # ax.plot(x, y_line, label='MARS fit', color='steelblue', alpha=0.6)
 
     ax.scatter(x, wcss_list, color='indianred')
 
     included = ''.join([str(i).split('IncludeAHC.')[1] + str(' ')
                        for i in include])
 
     plt.title(f'Clustering using AHC for Houston for {included}')
```

## energiapy/aggregation/kmeans.py

```diff
@@ -84,15 +84,15 @@
         kmeans = KMeans(n_clusters = periods*scales.discretization_list[scale_level+1], random_state = 0, n_init = 'auto').fit(data)
 
     # prediction = kmeans.predict(data)
 
     cluster_centers = kmeans.cluster_centers_
 
     kmeans_df = pandas.DataFrame(cluster_centers, columns= combined_df.columns)
-    
+
     # scale = scales.scale[scale_level]
 
     # creates a new TemporalScale object on the reduced scale
     reduced_dicretization_list = list(scales.discretization_list)
     reduced_dicretization_list[scale_level] = periods
     reduced_temporal_scale = TemporalScale(reduced_dicretization_list)
```

## energiapy/components/location.py

```diff
@@ -1,15 +1,15 @@
 """Location data class
 """
 
 __author__ = "Rahul Kakodkar"
-__copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
+__copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
-__version__ = "1.0.5"
+__version__ = "1.1.0"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from dataclasses import dataclass
 from itertools import product
 from random import sample
@@ -32,25 +32,29 @@
     The scale levels of capacity, cost, and demand need to be provided as well
 
     Args:
         name (str): name of the location, short ones are better to deal with.
         processes (Set[Process]): set of processes (Process objects) to include at location
         scales (TemporalScale): temporal scales of the problem
         demand (Dict[Resource, float]): demand for resources at location. Defaults to None.
-        demand_factor (Union[float, Dict[Resource, DataFrame]), optional): Factor for varying demand, scale changer normalizes.Defaults to 1.0
-        price_factor (Union[float, Dict[Resource, DataFrame]), optional): Factor for varying cost, scale changer normalizes. Defaults to 1.0
-        capacity_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying capacity, scale changer normalizes.Defaults to 1.0
-        capex_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying capital expenditure, scale changer normalizes. Defaults to 1.0
-        vopex_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying variable operational expenditure, scale changer normalizes. Defaults to 1.0
-        fopex_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying fixed operational expenditure, scale changer normalizes. Defaults to 1.0
-        demand_scale_level (int, optional): scale level for demand (resource). Defaults to 1.0
-        price_scale_level (int, optional): scale level for purchase cost (resource). Defaults to 1.0
-        capacity_scale_level(int, optional): scale level for capacity (process). Defaults to 1.0
-        expenditure_scale_level(int, optional): scale level for technology (process). Defaults to 1.0
-        land_cost(float, optional): cost of land. Defaults to 0
+        demand_factor (Union[float, Dict[Resource, DataFrame]), optional): Factor for varying demand, scale changer normalizes.Defaults to None
+        price_factor (Union[float, Dict[Resource, DataFrame]), optional): Factor for varying cost, scale changer normalizes. Defaults to None
+        capacity_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying capacity, scale changer normalizes.Defaults to None
+        capex_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying capital expenditure, scale changer normalizes. Defaults to None
+        vopex_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying variable operational expenditure, scale changer normalizes. Defaults to None
+        fopex_factor (Union[float, Dict[Process, DataFrame]), optional):  Factor for varying fixed operational expenditure, scale changer normalizes. Defaults to None
+        availability_factor (Union[float, Dict[Resource, DataFrame]), optional): Factor for varying resource availability, scale changer normalizes. Defaults to None
+        revenue_factor (Union[float, Dict[Resource, DataFrame]), optional): Factor for varying resource revenue, scale changer normalizes. Defaults to None
+        demand_scale_level (int, optional): scale level for demand (resource). Defaults to 0
+        price_scale_level (int, optional): scale level for purchase cost (resource). Defaults to 0
+        capacity_scale_level (int, optional): scale level for capacity (process). Defaults to 0
+        expenditure_scale_level (int, optional): scale level for technology (process). Defaults to 0
+        availability_scale_level (int, optional): scale level for availability (resource). Defaults to 0
+        land_cost (float, optional): cost of land. Defaults to 0
+        credit (Dict[Process, float], optional): credit earned by process per unit basis. Defaults to None.
         label(str, optional):Longer descriptive label if required. Defaults to ''
 
     Examples:
         Locations need a set of processes and the scale levels for demand, capacity, and cost, and if applicable demand factors, price_factors, capacity factors
 
         >>> Goa= Location(name='Goa', processes= {Process1, Process2}, demand_scale_level=2, capacity_scale_level= 2, price_scale_level= 1, demand_factor= {Resource1: DataFrame,}, price_factor = {Resource2: DataFrame}, capacity_factor = {Process1: DataFrame}, scales= TemporalScale object, label='Home')
     """
@@ -61,19 +65,23 @@
     demand: Dict[Resource, float] = None
     demand_factor: Union[float, Dict[Resource, float]] = None
     price_factor: Union[float, Dict[Resource, float]] = None
     capacity_factor: Union[float, Dict[Process, float]] = None
     capex_factor: Union[float, Dict[Process, float]] = None
     vopex_factor: Union[float, Dict[Process, float]] = None
     fopex_factor: Union[float, Dict[Process, float]] = None
+    availability_factor: Union[float, Dict[Resource, float]] = None
+    revenue_factor: Union[float, Dict[Resource, float]] = None
     demand_scale_level: int = 0
     price_scale_level: int = 0
     capacity_scale_level: int = 0
-    expenditure_scale_level:int = 0
+    expenditure_scale_level: int = 0
+    availability_scale_level: int = 0
     land_cost: float = 0
+    credit: Dict[Process, float] = None
     label: str = ''
 
     def __post_init__(self):
         """Sets and stuff generated insitu
 
         Args:
             resources (Set[Resource]): set of resources. Get resources fetches these using the processes
@@ -90,14 +98,19 @@
         self.resources_full = self.resources.union(
             {i.resource_storage for i in self.processes if i.resource_storage is not None})
         self.materials = self.get_materials()
         self.scale_levels = self.scales.scale_levels
         self.processes_full = self.processes.union({create_storage_process(
             i) for i in self.processes if i.processmode == ProcessMode.STORAGE})
         self.prod_max = self.get_prod_max()
+        self.prod_min = self.get_prod_min()
+        self.resource_price = self.get_resource_price()
+        self.resource_revenue = self.get_resource_revenue()
+        self.failure_processes = self.get_failure_processes()
+        self.fail_factor = self.make_fail_factor()
 
         if self.capacity_factor is not None:
             self.varying_capacity = set(self.capacity_factor.keys())
             if isinstance(list(self.capacity_factor.values())[0], DataFrame):
                 self.capacity_factor = scale_changer(
                     self.capacity_factor, scales=self.scales, scale_level=self.capacity_scale_level)
             else:
@@ -118,17 +131,31 @@
             if isinstance(list(self.demand_factor.values())[0], DataFrame):
                 self.demand_factor = scale_changer(
                     self.demand_factor, scales=self.scales, scale_level=self.demand_scale_level)
             else:
                 warn(
                     'Input should be a dict of a DataFrame, Dict[Resource, float]')
 
-        self.resource_price = self.get_resource_price()
-        self.failure_processes = self.get_failure_processes()
-        self.fail_factor = self.make_fail_factor()
+        if self.availability_factor is not None:
+            self.varying_availability = set(self.availability_factor.keys())
+            if isinstance(list(self.availability_factor.values())[0], DataFrame):
+                self.availability_factor = scale_changer(
+                    self.availability_factor, scales=self.scales, scale_level=self.availability_scale_level)
+            else:
+                warn(
+                    'Input should be a dict of a DataFrame, Dict[Resource, float]')
+
+        if self.revenue_factor is not None:
+            self.varying_revenue = set(self.revenue_factor.keys())
+            if isinstance(list(self.revenue_factor.values())[0], DataFrame):
+                self.revenue_factor = scale_changer(
+                    self.revenue_factor, scales=self.scales, scale_level=self.demand_scale_level)
+            else:
+                warn(
+                    'Input should be a dict of a DataFrame, Dict[Resource, float]')
 
         if self.capex_factor is not None:
             self.varying_capex = set(self.capex_factor.keys())
             if isinstance(list(self.capex_factor.values())[0], DataFrame):
                 self.capex_factor = scale_changer(
                     self.capex_factor, scales=self.scales, scale_level=self.expenditure_scale_level)
             else:
@@ -158,39 +185,49 @@
 
         Returns:
             Set[Resource]: set of resources
         """
         if len(self.processes) == 0:
             return None
 
-        resources_single = set().union(*[set(i.conversion.keys()) for i in self.processes if i.processmode == ProcessMode.SINGLE])
+        resources_single = set().union(
+            *[set(i.conversion.keys()) for i in self.processes if i.processmode == ProcessMode.SINGLE])
         resources_multi = set()
         for i in [i for i in self.processes if i.processmode == ProcessMode.MULTI]:
-            resources_multi = resources_multi.union(*[set(j.keys()) for j in list(i.conversion.values())])
+            resources_multi = resources_multi.union(
+                *[set(j.keys()) for j in list(i.conversion.values())])
         return resources_single.union(resources_multi)
 
     def get_materials(self) -> Set[Material]:
         """fetches required materials for processes introduced at locations
 
         Returns:
             Set[Material]: set of materials
         """
         if len(self.processes) == 0:
             return None
         else:
             return set().union(*[set(i.material_cons.keys()) for i in self.processes if i.material_cons is not None])
 
-    def get_resource_price(self):
+    def get_resource_price(self) -> dict:
         """gets resource prices for resources with non-varying costs
 
         Returns:
-            Set[Resource]: set of resources with non-varying cost factors
+            dict: with resource prices
         """
         return {i.name: i.price for i in self.resources}
 
+    def get_resource_revenue(self) -> dict:
+        """gets resource revenues for resources with non-varying costs
+
+        Returns:
+            dict: with resource revenues
+        """
+        return {i.name: i.revenue for i in self.resources}
+
     def get_failure_processes(self):
         """get processes with failure rates
 
         Returns:
             Set[Process]: set of resources with failure rates
         """
         return {i for i in self.processes if i.p_fail is not None}
@@ -213,18 +250,32 @@
         make a dictionary with maximum production
         """
         prod_max_dict = {}
         for i in self.processes_full:
             if i.processmode == ProcessMode.MULTI:
                 prod_max_dict[i.name] = i.prod_max
             else:
-                prod_max_dict[i.name] = {0: None}
-                prod_max_dict[i.name][0] = i.prod_max
+                prod_max_dict[i.name] = {j: None for j in self.scales.scale[0]}
+                for j in self.scales.scale[0]:
+                    prod_max_dict[i.name][j] = i.prod_max
         return prod_max_dict
 
+    def get_prod_min(self) -> dict:
+        """
+        make a dictionary with minimum production
+        """
+        prod_min_dict = {}
+        for i in self.processes_full:
+            if i.processmode == ProcessMode.MULTI:
+                prod_min_dict[i.name] = i.prod_min
+            else:
+                prod_min_dict[i.name] = {0: None}
+                prod_min_dict[i.name][0] = i.prod_min
+        return prod_min_dict
+
     def __repr__(self):
         return self.name
 
     def __hash__(self):
         return hash(self.name)
 
     def __eq__(self, other):
```

## energiapy/components/network.py

```diff
@@ -1,15 +1,15 @@
-"""Linkage data class
+"""Network data class
 """
 
 __author__ = "Rahul Kakodkar"
-__copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
+__copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
-__license__ = "Open"
-__version__ = "0.0.1"
+__license__ = "MIT"
+__version__ = "1.1.0"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from dataclasses import dataclass, field
 from itertools import product
 from typing import List
@@ -28,21 +28,34 @@
         source_locations (List[location], optional): list of location dataclass objects of source locations
         sink_locations (List[location], optional): list of location dataclass objects of sink locations
         distance_matrix (List[List[float]], optional): matrix with distances between sources and sinks, needs to be ordered
         transport_matrix (List[List[float]], optional): matrix with distances between sources and sinks, needs to be ordered
         label(str, optional):Longer descriptive label if required. Defaults to ''
 
     Examples:
+
         Networks object with to and from movement of resources using Transport. In the following example, Train and Pipeline can be set up from 'Goa' to 'Texas'
 
         >>> Move = Network(name= 'Network', source_locations= [Goa, Texas], sink_locations= [Texas, Goa], distance_matrix= [[0, 500],[500, 0]], transport_matrix= [[], [Train, Pipe]], [[Train, Pipe], []]], label = 'network for moving stuff')
 
         Networks can also have one way movement of resources. In the following example, a Pipeline is set up from Goa to Texas.
 
         >>> BrainDrain = Network(name= 'BrainDrain', source_locations= [Goa], sink_locations= [Texas], distance_matrix= [[0, 500],[500, 0]], transport_matrix= [[], [Pipe]], [[], []]], label = 'The Pipeline') )
+
+        Declaring distance matrix: 
+        Consider a source (Goa), and two sinks (Texas, Macedonia) at a distance of 1000 and 500 units. The source will form the rows and sinks the columns. 
+        The distance matrix will look something like this:
+
+        >>> distance_matrix = [[1000, 500]]
+
+        Declaring transport matrix:
+        Similarly say, there is a ship (Ship) avaiable between only Goa and Macedonia, and a flight (Plane) available from Goa to both regions. 
+        The transport matrix can be stated as:
+
+        >>> transport_matrix = [[[Ship], [Ship, Plane]]]
     """
     name: str
     source_locations: List[Location] = field(default_factory=list)
     sink_locations: List[Location] = field(default_factory=list)
     distance_matrix: List[List[float]] = field(default_factory=list)
     transport_matrix: List[List[Transport]] = field(default_factory=list)
     label: str = ''
@@ -65,26 +78,26 @@
     def make_distance_dict(self) -> dict:
         """returns a dictionary of distances from sources to sinks
 
         Returns:
             dict: a dictionary of distances from sources to sinks
         """
         distance_dict = {(self.source_locations[i].name, self.sink_locations[j].name):
-                             self.distance_matrix[i][j] for i, j in
+                         self.distance_matrix[i][j] for i, j in
                          product(range(len(self.source_locations)), range(len(self.sink_locations)))}
         return distance_dict
 
     def make_transport_dict(self) -> dict:
         """returns a dictionary of trasportation modes available between sources to sinks
 
         Returns:
             dict: a dictionary of trasportation modes available between sources to sinks
         """
         transport_dict = {(self.source_locations[i].name, self.sink_locations[j].name):
-                              set(self.transport_matrix[i][j]) for i, j in
+                          set(self.transport_matrix[i][j]) for i, j in
                           product(range(len(self.source_locations)), range(len(self.sink_locations)))}
         return transport_dict
 
     def make_transport_avail_dict(self) -> dict:
         """returns a dictionary with transportation modes available between sources and sinks
 
         Returns:
```

## energiapy/components/process.py

```diff
@@ -8,15 +8,15 @@
 __version__ = "0.0.1"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from dataclasses import dataclass
 from enum import Enum, auto
-from typing import Dict, Union
+from typing import Dict, Union, List
 from warnings import warn
 
 from ..components.material import Material
 from ..components.resource import Resource
 from ..utils.resource_utils import create_storage_resource
 
 
@@ -54,20 +54,36 @@
 
 class VaryingProcess(Enum):
     """
     The type of process capacity variability
     """
     DETERMINISTIC_CAPACITY = auto()
     """
-    Utilize deterministic data
+    Utilize deterministic data as parameters for capacity
+    """
+    DETERMINISTIC_EXPENDITURE = auto()
+    """
+    Utilize deterministic data as parameters for expenditure
     """
     UNCERTAIN_CAPACITY = auto()
     """
     Generate uncertainty variables
     """
+    UNCERTAIN_EXPENDITURE = auto()
+    """
+    Generate uncertainty variables for expenditure
+    """
+    CERTAIN_CAPACITY = auto()
+    """
+    Use certain parameter for capacity
+    """
+    CERTAIN_EXPENDITURE = auto()
+    """
+    Use certain parameter for expenditure
+    """
 
 
 @dataclass
 class Process:
     """
     Processes convert resources into other resources
 
@@ -79,15 +95,15 @@
         capex (Union[float, dict], None): Capital expenditure per unit basis, can be scaled with capacity. Defaults to None.
         fopex (Union[float, dict], None): Fixed operational expenditure per unit basis, can be scaled with capacity. Defaults to None.
         vopex (Union[float, dict], None): Variable operational expenditure per unit basis, can be scaled with capacity. Defaults to None.
         incidental (float, None): Incidental expenditure. Defaults to None.
         material_cons (Dict[Material, float], optional): Materials consumed per unit basis of production capacity. Defaults to None.
         prod_max (float, optional): Maximum production capacity allowed in a time period of the scheduling scale. Defaults to 0.
         prod_min (float, optional): Minimum production capacity allowed in a time period of the scheduling scale. Defaults to 0.
-        carbon_credit (float, optional): Carbon Credit earned per unit basis of production. Defaults to 0.
+        credit (float, None): credit earned per unit basis of production. Defaults to None.
         basis(str, optional): base units for operation. Defaults to 'unit'.
         gwp (float, optional): global warming potential for settting up facility per unit basis. Defaults to 0.
         land (float, optional): land requirement per unit basis. Defaults to 0.
         trl (str, optional): technology readiness level. Defaults to None.
         block (str, optional): define block for convenience. Defaults to None.
         citation (str, optional): citation for data. Defaults to 'citation needed'.
         lifetime (float, optional): the expected lifetime of process. Defaults to None.
@@ -122,39 +138,54 @@
     fopex: Union[float, dict] = None
     vopex: Union[float, dict] = None
     incidental: float = None
     material_cons: Dict[Material, float] = None
     prod_max: Union[Dict[int, float], float] = 0
     prod_min: float = 0
     basis: str = 'unit'
-    carbon_credit: float = 0
+    credit: float = None
     gwp: float = 0
     land: float = 0
     trl: str = None
     block: str = ''
     citation: str = 'citation needed'
     lifetime: int = None
-    varying: VaryingProcess = None
+    varying: List[VaryingProcess] = None
     p_fail: float = None
     label: str = ''
     storage: Resource = None
     storage_loss: float = 0
     store_max: float = 0
     store_min: float = 0
+    rate_max: Union[Dict[int, float], float] = None
 
     def __post_init__(self):
         """Determines the ProcessMode, CostDynamics, and kicks out dummy resources if process is stores resource
 
         Args:
             processmode (ProcessMode): Determines whether the model is single mode, multi mode, or storage type.
             resource_storage (Resource):  Dummy resource which is stored in the Process.
             conversion_discharge (Dict[Resource, float]): Creates a dictionary with the discharge conversion values (considers storage loss).
             cost_dynamics (CostDynamics): Determines whether the cost scales linearly with the unit capacity, or is a piecewise-linear function.
         """
 
+        if self.varying is None:
+            self.varying = []
+            if (self.capex is not None) or (self.fopex is not None) or (self.vopex is not None):
+                self.varying = self.varying + \
+                    [VaryingProcess.CERTAIN_EXPENDITURE]
+            if self.prod_max > 0:
+                self.varying = self.varying + [VaryingProcess.CERTAIN_CAPACITY]
+
+        if not isinstance(self.varying, list):
+            warn('Provide a list of VaryingProcess enums')
+
+        if self.material_cons is None:
+            self.material_cons = {}
+
         if self.storage is not None:
             self.resource_storage = create_storage_resource(
                 process_name=self.name, resource=self.storage, store_max=self.store_max, store_min=self.store_min)
             self.conversion = {self.storage: -1, self.resource_storage: 1}
             self.conversion_discharge = {
                 self.resource_storage: -1, self.storage: 1*(1 - self.storage_loss)}
             self.processmode = ProcessMode.STORAGE
```

## energiapy/components/resource.py

```diff
@@ -7,38 +7,74 @@
 __license__ = "Open"
 __version__ = "0.0.1"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from dataclasses import dataclass
+from warnings import warn
 from enum import Enum, auto
-from typing import Union
+from typing import Union, List
+
 
 class VaryingResource(Enum):
     """
     Whether the demand or price are varying
     """
     DETERMINISTIC_DEMAND = auto()
     """
-    Utilize deterministic demand data
+    Utilize deterministic demand data as parameters
     """
     DETERMINISTIC_PRICE = auto()
     """
-    Utilize deterministic price data
+    Utilize deterministic price data as parameters
+    """
+    DETERMINISTIC_AVAILABILITY = auto()
+    """
+    Utilize deterministic resource availability as parameters
+    """
+    DETERMINISTIC_REVENUE = auto()
+    """
+    Utilize deterministic resource revenues as parameters
     """
     UNCERTAIN_DEMAND = auto()
     """
-    Utilize uncertainty variables for demand
+    Generate uncertainty variables for demand
     """
     UNCERTAIN_PRICE = auto()
     """
-    Utilize uncertainty variables for price
+    Generate uncertainty variables for price
+    """
+    UNCERTAIN_AVAILABILITY = auto()
+    """
+    Generate uncertainty variables for resource availability
+    """
+    UNCERTAIN_REVENUE = auto()
+    """
+    Generate uncertainty variables for resource revenue
+    """
+    CERTAIN_DEMAND = auto()
+    """Use exact parameter for demand 
+    """
+    CERTAIN_PRICE = auto()
+    """Use exact parameter for price
+    """
+    CERTAIN_AVAILABILITY = auto()
+    """Use exact parameter for availability
+    """
+    CERTAIN_REVENUE = auto()
+    """Use exact parameter for revenue
+    """
+    IMPLICIT = auto()
+    """Produced and utilized implicitly
+    """
+    STORED = auto()
+    """Implicitly generated stored resource
     """
-    
+
 
 @dataclass
 class Resource:
     """
     Object with resource data
 
     Args:
@@ -67,39 +103,60 @@
         For a resource that can be consumed from outside the system, and has a varying purchase price.
 
         >>> CH4 = Resource(name='CH4', cons_max=1000, price=1, basis='kg', label='Natural gas', varying=  VaryingResource.deterministic_price)
 
         For a resource that is produced and needs to meet a fixed demand.
 
         >>> Power = Resource(name='Power', basis='MW', demand = True, label='Power generated', varying = VaryingResource.deterministic_demand)
-
-
     """
-    
+
     name: str
     cons_max: float = 0
     loss: float = 0
     revenue: float = 0
     price: float = 0
     store_max: float = 0
     store_min: float = 0
     sell: bool = False
     demand: bool = False
     basis: str = 'unit'
-    block: Union[str,list,dict] = ''
+    block: Union[str, list, dict] = ''
     citation: str = 'citation needed'
-    varying: VaryingResource = None
+    varying: List[VaryingResource] = None
     label: str = ''
     gwp: float = 0
 
     def __post_init__(self):
         if self.demand is True:
             self.sell = True
- 
+
+        if self.varying is None:
+            self.varying = []
+            if self.cons_max > 0:
+                self.varying = self.varying + \
+                    [VaryingResource.CERTAIN_AVAILABILITY,
+                        VaryingResource.CERTAIN_PRICE]
+
+            if self.demand is True:
+                self.varying = self.varying + \
+                    [VaryingResource.CERTAIN_DEMAND]
+            else:
+                if self.sell is True:
+                    self.varying = self.varying + \
+                        [VaryingResource.CERTAIN_DEMAND]
+
+            if self.revenue is True:
+                self.varying = self.varying + \
+                    [VaryingResource.CERTAIN_REVENUE]
+            if self.varying == []:
+                self.varying = [VaryingResource.IMPLICIT]
+        if not isinstance(self.varying, list):
+            warn('Provide a list of VaryingResource enums')
+
     def __repr__(self):
         return self.name
-  
+
     def __hash__(self):
         return hash(self.name)
-  
+
     def __eq__(self, other):
         return self.name == other.name
```

## energiapy/components/scenario.py

```diff
@@ -1,12 +1,12 @@
 """Cost scenario data class
 """
 
 __author__ = "Rahul Kakodkar"
-__copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
+__copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
@@ -17,32 +17,35 @@
 from pandas import DataFrame
 
 from ..components.location import Location
 from ..components.network import Network
 from ..components.process import ProcessMode, VaryingProcess
 from ..components.resource import Resource, VaryingResource
 from ..components.temporal_scale import TemporalScale
+from ..model.bounds import CapacityBounds
 
 
 @dataclass
 class Scenario:
     """
     Scenario contains the network between location and all the data within.
 
     Args:
         name (str): name of scenario, short ones are better to deal with.
         scales (temporal_scale): scales of the problem
         network (Union[Network, Location]): network object with the locations, transport linakges, and processes (with resources and materials)
-        price_scale_level (int, optional): scale for resource purchase. Defaults to 0.
+        purchase_scale_level (int, optional): scale for resource purchase. Defaults to 0.
         expenditure_scale_level (int, optional): scale for technology expenditure. Defaults to 0.
         scheduling_scale_level (int, optional): scale of production and inventory scheduling. Defaults to 0.
         network_scale_level (int, optional): scale for network decisions such as facility location. Defaults to 0.
         demand_scale_level (int, optional): scale for meeting specific demand for resource. Defaults to 0.
         cluster_wt (dict): cluster weights as a dictionary. {scale: int}. Defaults to None.
         label (str, optional): Longer descriptive label if required. Defaults to ''
+        capacity_bounds (CapacityBounds, optional): bounds on the capacity, useful for multi-period formulations. Defaults to None.
+        annualization_factor (float, optional): the annualization factor for Capex. Defaults to 1.
 
     Example:
         The Scenario can be built over a single location. The network here is specified as a single Location. Considering scales (TemporalScale object for a year, [1, 365, 24]), scheduling, expenditure, and demand are met at an hourly level, and network at an annual level.
 
         >>> Current = Scenario(name= 'current', network= Goa, scales= scales, expenditure_scale_level= 2, scheduling_scale_level= 2, network_scale_level= 0, demand_scale_level= 2, label= 'Current Scenario')
 
         A multilocation Scenario needs a Network to be provided. Here, expenditure (on resource purchase) is determined at a daily scale. price_factor in the Location object needs to be commensurate in scale.
@@ -56,14 +59,16 @@
     expenditure_scale_level: int = 0
     scheduling_scale_level: int = 0
     network_scale_level: int = 0
     demand_scale_level: int = 0
     cluster_wt: dict = None
     demand: Union[Dict[Location, Dict[Resource, float]], float] = None
     label: str = ''
+    capacity_bounds: CapacityBounds = None
+    annualization_factor: float = 1
 
     def __post_init__(self):
         """
         Determines a bunch of handy sets
 
         Args:
             transport_set (set): Set of transport options.
@@ -88,15 +93,16 @@
             store_min (dict): A dictionary with minimum storage per timeperiod in the scheduling scale for each Resource at each Location.
             capacity_factor (dict): A dictionary with Location-wise capacity factors for varying Process objects.
             price_factor (dict): A dictionary with Location-wise cost factors for varying purchase costs of Resource objects.
             demand_factor (dict): A dictionary with Location-wise demand factors for varying demands of Resource objects.
             loc_res_dict (dict): A dictionary with Location-wise availability of Resource objects.
             loc_pro_dict (dict): A dictionary with Location-wise availability of Process objects.
             loc_mat_dict (dict): A dictionary with Location-wise availability of Material objects.
-            price (dict): A dictionary with Location-wise cost of Resource objects
+            price (dict): A dictionary with Location-wise purchase price of Resource objects
+            revenue (dict): A dictionary with Location-wise revenue from selling resource objects
             capex_dict (dict): A dictionary with capital expenditure data for each Process.
             fopex_dict (dict): A dictionary with fixed operational expenditure data for each Process.
             vopex_dict (dict): A dictionary with variable operational expenditure data for each Process.
             incidental_dict (dict): A dictionary with incidental expenditure data for each Process.
             land_dict (dict): A dictionary with land use data for each Process.
             material_gwp_dict (dict): A dictionary with global warming potential values for each Material object.
             resource_gwp_dict (dict): A dictionary with global warming potential values for each Resource object.
@@ -122,253 +128,398 @@
 
         else:
             self.transport_set = set().union(*self.network.transport_dict.values())
             self.source_locations = self.network.source_locations
             self.sink_locations = self.network.sink_locations
             self.transport_dict = self.network.transport_dict
             self.transport_avail_dict = self.network.transport_avail_dict
-            self.location_set = set(self.source_locations + self.sink_locations)
+            self.location_set = set(
+                self.source_locations + self.sink_locations)
             self.trans_max = {j.name: j.trans_max for j in self.transport_set}
-            self.trans_loss = {j.name: j.trans_loss for j in self.transport_set}
-            self.trans_cost = {j.name: j.trans_cost for j in self.transport_set}
-            self.trans_emit = {j.name: j.trans_emit for j in self.transport_set}
+            self.trans_loss = {
+                j.name: j.trans_loss for j in self.transport_set}
+            self.trans_cost = {
+                j.name: j.trans_cost for j in self.transport_set}
+            self.trans_emit = {
+                j.name: j.trans_emit for j in self.transport_set}
             self.distance_dict = self.network.distance_dict
 
-        self.process_set = set().union(*[i.processes_full for i in self.location_set if i.processes_full is not None])
-        self.resource_set = set().union(*[i.resources_full for i in self.location_set if i.resources is not None])
-        self.material_set = set().union(*[i.materials for i in self.location_set if i.materials is not None])
+        self.process_set = set().union(
+            *[i.processes_full for i in self.location_set if i.processes_full is not None])
+        self.resource_set = set().union(
+            *[i.resources_full for i in self.location_set if i.resources is not None])
+        self.material_set = set().union(
+            *[i.materials for i in self.location_set if i.materials is not None])
 
-        self.conversion = {i.name: {j.name: i.conversion[j] if j in i.conversion.keys() \
-            else 0 for j in self.resource_set} for i in self.process_set if i.conversion is not None}
+        self.conversion = {i.name: {j.name: i.conversion[j] if j in i.conversion.keys(
+        ) else 0 for j in self.resource_set} for i in self.process_set if i.conversion is not None}
 
         self.prod_max = {i.name: i.prod_max for i in self.location_set}
-        self.prod_min = {i.name: {j.name: j.prod_min for j in i.processes_full} for i in self.location_set}
-        self.cons_max = {i.name: {j.name: j.cons_max for j in i.resources_full} for i in self.location_set}
-        self.store_max = {i.name: {j.name: j.store_max for j in i.resources_full} for i in self.location_set}
-        self.store_min = {i.name: {j.name: j.store_min for j in i.resources_full} for i in self.location_set}
-        self.capacity_factor = {i.name: i.capacity_factor for i in self.location_set}
+        self.prod_min = {i.name: i.prod_min for i in self.location_set}
+        self.cons_max = {i.name: {
+            j.name: j.cons_max for j in i.resources_full} for i in self.location_set}
+        self.store_max = {i.name: {
+            j.name: j.store_max for j in i.resources_full} for i in self.location_set}
+        self.store_min = {i.name: {
+            j.name: j.store_min for j in i.resources_full} for i in self.location_set}
+        self.capacity_factor = {
+            i.name: i.capacity_factor for i in self.location_set}
         self.price_factor = {i.name: i.price_factor for i in self.location_set}
-        self.demand_factor = {i.name: i.demand_factor for i in self.location_set}
+        self.demand_factor = {
+            i.name: i.demand_factor for i in self.location_set}
         self.capex_factor = {i.name: i.capex_factor for i in self.location_set}
         self.vopex_factor = {i.name: i.vopex_factor for i in self.location_set}
         self.fopex_factor = {i.name: i.fopex_factor for i in self.location_set}
-        self.loc_res_dict = {i.name: {j.name for j in i.resources_full} for i in self.location_set}
-        self.loc_pro_dict = {i.name: {j.name for j in i.processes_full} for i in self.location_set}
-        self.loc_mat_dict = {i.name: {j.name for j in i.materials} for i in self.location_set}
-        self.price = {i.name: i.resource_price for i in self.location_set}  # TODO change to be location wise
+        self.availability_factor = {
+            i.name: i.availability_factor for i in self.location_set}
+        self.revenue_factor = {
+            i.name: i.revenue_factor for i in self.location_set}
+        self.loc_res_dict = {
+            i.name: {j.name for j in i.resources_full} for i in self.location_set}
+        self.loc_pro_dict = {
+            i.name: {j.name for j in i.processes_full} for i in self.location_set}
+        self.loc_mat_dict = {i.name: {j.name for j in i.materials}
+                             for i in self.location_set}
+        # TODO change to be location wise
+        self.price = {i.name: i.resource_price for i in self.location_set}
+        self.revenue = {i.name: i.resource_revenue for i in self.location_set}
         self.capex_dict = {i.name: i.capex for i in self.process_set}
         self.fopex_dict = {i.name: i.fopex for i in self.process_set}
         self.vopex_dict = {i.name: i.vopex for i in self.process_set}
         self.incidental_dict = {i.name: i.incidental for i in self.process_set}
         self.land_dict = {i.name: i.land for i in self.process_set}
-        self.material_gwp_dict = {i.name: {j.name: j.gwp for j in self.material_set} for i in self.location_set}
-        self.resource_gwp_dict = {i.name: {j.name: j.gwp for j in self.resource_set} for i in self.location_set}
-        self.process_gwp_dict = {i.name: {j.name: j.gwp for j in self.process_set} for i in self.location_set}
+        self.material_gwp_dict = {
+            i.name: {j.name: j.gwp for j in self.material_set} for i in self.location_set}
+        self.resource_gwp_dict = {
+            i.name: {j.name: j.gwp for j in self.resource_set} for i in self.location_set}
+        self.process_gwp_dict = {
+            i.name: {j.name: j.gwp for j in self.process_set} for i in self.location_set}
         self.land_cost_dict = {i.name: i.land_cost for i in self.location_set}
         self.fail_factor = {i.name: i.fail_factor for i in self.location_set}
-
-        self.process_resource_dict = {i.name: i.resource_req for i in self.process_set}
-
-        self.process_material_dict = {i.name: {j.name: i.material_cons[j] for j in i.material_cons.keys()} for i in
-                                      self.process_set if i.material_cons is not None}
-
+        self.credit_dict = {i.name: {j.name: i.credit[j] for j in i.credit.keys(
+        )} for i in self.location_set if i.credit is not None}
+        self.process_resource_dict = {
+            i.name: i.resource_req for i in self.process_set}
+
+        # self.process_material_dict = {i.name: {j.name: i.material_cons[j] for j in i.material_cons.keys()} if i.material_cons is not None else None for i in
+        #                               self.process_set}
+        self.process_material_dict = {
+            i.name: {j.name: i.material_cons[j] if j in i.material_cons.keys() else 0 for j in self.material_set} for i in self.process_set}
         multiconversion_dict = dict()
         for i in self.process_set:
             if i.processmode == ProcessMode.MULTI:
-                multiconversion_dict[i.name] = {j: None for j in i.conversion.keys()}
+                multiconversion_dict[i.name] = {
+                    j: None for j in i.conversion.keys()}
                 for k in list(multiconversion_dict[i.name].keys()):
                     multiconversion_dict[i.name][k] = {j.name: i.conversion[k][j] if j in i.conversion[k].keys() else 0
                                                        for j in self.resource_set}
             else:
                 multiconversion_dict[i.name] = {0: None}
                 multiconversion_dict[i.name][0] = {j.name: i.conversion[j] if j in i.conversion.keys() else 0 for j in
                                                    self.resource_set}
 
         self.multiconversion = multiconversion_dict
 
-        self.mode_dict = {i.name: list(self.multiconversion[i.name].keys()) for i in self.process_set}
+        self.mode_dict = {i.name: list(
+            self.multiconversion[i.name].keys()) for i in self.process_set}
 
-        self.set_dict = {
+        set_dict = {
             'resources': [i.name for i in self.resource_set],
+
             'resources_nosell': [i.name for i in self.resource_set if i.sell is False],
             'resources_sell': [i.name for i in self.resource_set if i.sell is True],
+
             'resources_store': [i.name for i in self.resource_set if i.store_max > 0],
+
             'resources_purch': [i.name for i in self.resource_set if i.cons_max > 0],
+
             'resources_varying_demand': [i.name for i in self.resource_set if
-                                         i.varying == VaryingResource.DETERMINISTIC_DEMAND],
-            'resources_varying_price': [i.name for i in self.resource_set if
-                                        i.varying == VaryingResource.DETERMINISTIC_PRICE],
-            'resources_demand': [i.name for i in self.resource_set if i.demand is True],
-            'resources_certain_price': [i.name for i in self.resource_set if (i.varying is None) and (i.cons_max > 0)],
-            'resources_uncertain_price': [i.name for i in self.resource_set if
-                                          i.varying == VaryingResource.UNCERTAIN_PRICE],
+                                         VaryingResource.DETERMINISTIC_DEMAND in i.varying],
             'resources_certain_demand': [i.name for i in self.resource_set if
-                                         (i.varying is None) and (i.demand is True)],
+                                         VaryingResource.CERTAIN_DEMAND in i.varying],
             'resources_uncertain_demand': [i.name for i in self.resource_set if
-                                           i.varying == VaryingResource.UNCERTAIN_DEMAND],
+                                           VaryingResource.UNCERTAIN_DEMAND in i.varying],
+
+            'resources_varying_price': [i.name for i in self.resource_set if
+                                        VaryingResource.DETERMINISTIC_PRICE in i.varying],
+            'resources_certain_price': [i.name for i in self.resource_set if
+                                        VaryingResource.CERTAIN_PRICE in i.varying],
+            'resources_uncertain_price': [i.name for i in self.resource_set if
+                                          VaryingResource.UNCERTAIN_PRICE in i.varying],
+
+            'resources_varying_revenue': [i.name for i in self.resource_set if
+                                          VaryingResource.DETERMINISTIC_REVENUE in i.varying],
+            'resources_certain_revenue': [i.name for i in self.resource_set if
+                                          VaryingResource.CERTAIN_REVENUE in i.varying],
+            'resources_uncertain_revenue': [i.name for i in self.resource_set if
+                                            VaryingResource.UNCERTAIN_REVENUE in i.varying],
+
+            'resources_varying_availability': [i.name for i in self.resource_set if
+                                               VaryingResource.DETERMINISTIC_AVAILABILITY in i.varying],
+            'resources_certain_availability': [i.name for i in self.resource_set if
+                                               VaryingResource.CERTAIN_AVAILABILITY in i.varying],
+            'resources_uncertain_availability': [i.name for i in self.resource_set if
+                                                 VaryingResource.UNCERTAIN_AVAILABILITY in i.varying],
+
+            'resources_demand': [i.name for i in self.resource_set if i.demand is True],
+
+            'resources_implicit': [i.name for i in self.resource_set if VaryingResource.IMPLICIT in i.varying],
+
             'processes': [i.name for i in self.process_set],
+
             'processes_full': list(self.conversion.keys()),
-            'processes_varying': [i.name for i in self.process_set if
-                                  i.varying == VaryingProcess.DETERMINISTIC_CAPACITY],
+
             'processes_failure': [i.name for i in self.process_set if i.p_fail is not None],
+
             'processes_materials': [i.name for i in self.process_set if i.material_cons is not None],
+
             'processes_storage': [i.name for i in self.process_set if i.conversion_discharge is not None],
+
             'processes_multim': [i.name for i in self.process_set if i.processmode == ProcessMode.MULTI],
             'processes_singlem': [i.name for i in self.process_set if
                                   (i.processmode == ProcessMode.SINGLE) or (i.processmode == ProcessMode.STORAGE)],
-            'processes_certain_capacity': [i.name for i in self.process_set if i.varying is None],
+
+            'processes_certain_capacity': [i.name for i in self.process_set if
+                                           VaryingProcess.CERTAIN_CAPACITY in i.varying],
+            'processes_varying_capacity': [i.name for i in self.process_set if
+                                           VaryingProcess.DETERMINISTIC_CAPACITY in i.varying],
             'processes_uncertain_capacity': [i.name for i in self.process_set if
-                                             i.varying == VaryingProcess.UNCERTAIN_CAPACITY],
+                                             VaryingProcess.UNCERTAIN_CAPACITY in i.varying],
+
+            'processes_certain_expenditure': [i.name for i in self.process_set if
+                                              VaryingProcess.CERTAIN_EXPENDITURE in i.varying],
+            'processes_varying_expenditure': [i.name for i in self.process_set if
+                                              VaryingProcess.DETERMINISTIC_EXPENDITURE in i.varying],
+            'processes_uncertain_expenditure': [i.name for i in self.process_set if
+                                                VaryingProcess.UNCERTAIN_EXPENDITURE in i.varying],
+
             'locations': [i.name for i in self.location_set],
             'materials': [i.name for i in self.material_set],
         }
 
         if self.source_locations is not None:
-            self.set_dict['sources'] = [i.name for i in self.source_locations]
+            set_dict['sources'] = [i.name for i in self.source_locations]
         else:
-            self.set_dict['sources'] = []
+            set_dict['sources'] = []
 
         if self.sink_locations is not None:
-            self.set_dict['sinks'] = [i.name for i in self.sink_locations]
+            set_dict['sinks'] = [i.name for i in self.sink_locations]
         else:
-            self.set_dict['sinks'] = []
+            set_dict['sinks'] = []
 
         if self.material_set is not None:
-            self.set_dict['materials'] = [i.name for i in self.material_set]
+            set_dict['materials'] = [i.name for i in self.material_set]
         else:
-            self.set_dict['materials'] = []
+            set_dict['materials'] = []
 
         if self.transport_set is not None:
-            self.set_dict['transports'] = [i.name for i in self.transport_set]
-            self.set_dict['resources_trans'] = [i.name for i in set().union(*[i.resources for i in self.transport_set])]
+            set_dict['transports'] = [i.name for i in self.transport_set]
+            set_dict['resources_trans'] = [i.name for i in set().union(
+                *[i.resources for i in self.transport_set])]
         else:
-            self.set_dict['transports'] = []
-            self.set_dict['resources_trans'] = []
+            set_dict['transports'] = []
+            set_dict['resources_trans'] = []
+
+        self.set_dict = {x: sorted(set_dict[x]) for x in set_dict.keys()}
 
     def make_conversion_df(self) -> DataFrame:
         """makes a DataFrame of the conversion values
 
         Returns:
             DataFrame: DataFrame of conversion values 
         """
         return DataFrame.from_dict(self.conversion).transpose()
 
+    def make_material_df(self) -> DataFrame:
+        """makes a DataFrame of material consumption
+
+        Returns:
+            DataFrame: DataFrame of material consumption 
+        """
+        return DataFrame.from_dict(self.process_material_dict).transpose()
+
     def matrix_form(self):
         """returns matrices for the scenario.
 
         Returns:
             tuple: A, b, c, H, CRa, CRb, F
         """
         demand = self.demand
         if isinstance(demand, dict):
             if isinstance(list(demand.keys())[0], Location):
-                self.demand = {i.name: {j.name: demand[i][j] for j in demand[i].keys()} for i in demand.keys()}
-        print(demand)
+                try:
+                    self.demand = {i.name: {
+                        j.name: demand[i][j] for j in demand[i].keys()} for i in demand.keys()}
+                except:
+                    pass
         if len(self.location_set) > 1:
             print("can only do this for a single location scenario")
         else:
             location = list(self.location_set)[0].name
 
             # find number of different variables
+            # Inv - inventory
+            # S - Sell/Discharge
+            # C - Resource cost
+            # A - Availability
+            # P - Production
 
             n_Inv = len(self.set_dict['resources_store'])
+
             n_Sf = len(self.set_dict['resources_certain_demand'])
-            n_Cf = len(self.set_dict['resources_certain_price'])
-            n_Pf = len(self.set_dict['processes_certain_capacity'])
             n_S = len(self.set_dict['resources_uncertain_demand'])
-            n_C = len(self.set_dict['resources_uncertain_price'])
-            n_P = len(self.set_dict['processes_uncertain_capacity'])
-            n_bal = n_P + n_Pf
-
-            n_vars_fix = n_Inv + n_Sf + n_Cf + n_Pf
-            n_vars_theta = n_S + n_C + n_P
-            n_vars = n_vars_fix + n_vars_theta
 
-            # make b matrix
-            # prod max has 0 because the default mode is 0
-            b_bal = numpy.zeros((n_bal, 1))
-            b_Inv = numpy.array([[self.store_max[location][i]] for i in self.set_dict['resources_store']])
-            b_Sf = numpy.array([[-self.demand[location][i]] for i in self.set_dict['resources_certain_demand']])
-            b_Cf = numpy.array([[self.cons_max[location][i]] for i in self.set_dict['resources_certain_price']])
-            b_Pf = numpy.array([[self.prod_max[location][i][0]] for i in self.set_dict['processes_certain_capacity']])
+            n_Af = len(self.set_dict['resources_certain_availability'])
+            n_A = len(self.set_dict['resources_uncertain_availability'])
 
-            b_S = numpy.array([[-self.demand[location][i]] for i in self.set_dict['resources_uncertain_demand']])
-            b_C = numpy.array([[self.cons_max[location][i]] for i in self.set_dict['resources_uncertain_price']])
-            b_P = numpy.array([[self.prod_max[location][i][0]] for i in self.set_dict['processes_uncertain_capacity']])
-            b_nn = numpy.zeros((n_vars, 1))
+            n_Pf = len(self.set_dict['processes_certain_capacity'])
+            n_P = len(self.set_dict['processes_uncertain_capacity'])
 
-            b_list = [b_bal, b_Inv, b_Sf, b_Cf, b_Pf, b_S, b_C, b_P, b_nn]
+            n_Cf = len(self.set_dict['resources_certain_price'])
+            n_C = len(self.set_dict['resources_uncertain_price'])
 
-            b = numpy.block([[i] for i in b_list if len(i) > 0])
+            n_I = len(self.set_dict['resources_implicit'])
 
-            # make F matrix
+            n_bal = n_P + n_Pf  # number of production processes for resource balance constraint
 
-            F = numpy.zeros((len(b), n_vars_theta))
+            # used to balance implicitly made resources
+            n_bal2 = n_Inv + n_Sf + n_S + n_Af + n_A
 
-            iter_ = 0
-            for i in range(n_S):
-                F[n_bal + n_vars_fix + iter_][i] = self.demand[location][self.set_dict['resources_uncertain_demand'][i]]
-                iter_ += 1
+            n_vars_fix = n_Inv + n_Sf + n_Af + n_Pf  # total number of fixed variables
 
-            iter_ = 0
-            for i in range(n_C):
-                F[n_bal + n_vars_fix + n_S + iter_][n_S + i] = self.cons_max[location][
-                    self.set_dict['resources_uncertain_price'][i]]
-                iter_ += 1
+            n_vars_theta = n_S + n_A + n_P  # total number of theta variables
+
+            n_vars = n_vars_fix + n_vars_theta  # total number of variables
+
+            print('The problem has the following variables:')
+            print(f"Resource inventory level (Inv) x {n_Inv}")
+            print(f"Exact resource discharge (Sf) x {n_Sf}")
+            print(f"Uncertain resource discharge (S) x {n_S}")
+            print(f"Exact resource availability (Af) x {n_Af}")
+            print(f"Uncertain resource availability (A) x {n_A}")
+            print(f"Exact process production (Pf) x {n_Pf}")
+            print(f"Uncertain process production (P) x {n_P}")
+            print(
+                f" For a total of {n_vars} ({n_vars_fix} fixed, and {n_vars_theta} uncertain)")
+
+            # *--------------------------------A--------------------------------------
+            A_bal = numpy.diag(
+                [*[-1] * n_Inv, *[-1] * n_Sf, *[-1] * n_S,  *[1] * n_Af, *[1] * n_A])
+
+            if n_I > 0:  # if implict variables present, add 0 stacks to matrix
+
+                A_bal = numpy.vstack((A_bal, n_I*[[0]*(n_bal2)]))
+
+            conversion_list = self.set_dict['resources_store'] + self.set_dict['resources_certain_demand'] + \
+                self.set_dict['resources_uncertain_demand'] + \
+                self.set_dict['resources_certain_availability'] + \
+                self.set_dict['resources_uncertain_availability'] + \
+                self.set_dict['resources_implicit']
+            column_list = [*['Inv_' + i for i in self.set_dict['resources_store']] +
+                           ['Sf_' + i for i in self.set_dict['resources_certain_demand']] +
+                           ['S_' + i for i in self.set_dict['resources_uncertain_demand']] +
+                           ['Af_' + i for i in self.set_dict['resources_certain_availability']] +
+                           ['A_' + i for i in self.set_dict['resources_uncertain_availability']] +
+                           ['Pf_' + i for i in self.set_dict['processes_certain_capacity']] +
+                           ['P_' + i for i in self.set_dict['processes_uncertain_capacity']]]
+            A_conv = numpy.array([[self.conversion[i][j] for j in conversion_list] for i in
+                                  sorted(self.conversion.keys())]).transpose()
 
-            iter_ = 0
-            for i in range(n_P):
-                F[n_bal + n_vars_fix + n_S + n_C + iter_][n_S + n_C + i] = \
-                self.prod_max[location][self.set_dict['processes_uncertain_capacity'][i]][
-                    0]  # defaults to 0 as mode, using P_m instead of P
-                iter_ += 1
+            A_diag = numpy.diag(
+                [*[-1]*n_Inv, *[-1]*n_Sf, *[-1]*n_S,  *[1]*n_Af, *[1] * n_A, *[1]*n_Pf, *[1]*n_P])
 
-            # make A matrix
-            print(n_Inv, n_Sf, n_Cf, n_S, n_C)
+            A_nn = numpy.eye(n_vars)
 
-            A_bal = numpy.diag([*[-1] * n_Inv, *[-1] * n_Sf, *[1] * n_Cf, *[-1] * n_S, *[1] * n_C])
+            A = numpy.block(
+                [[numpy.block([A_bal, A_conv])], [A_diag], [-A_nn]])
 
-            A_conv = numpy.array([[self.conversion[i][j] for j in self.conversion[i].keys()] for i in
-                                  self.conversion.keys()]).transpose()
+            self.A_df = DataFrame(A, columns=column_list)
 
-            A_diag = numpy.diag(
-                [*[-1] * n_Inv, *[-1] * n_Sf, *[1] * n_Cf, *[1] * n_Pf, *[-1] * n_S, *[1] * n_C, *[1] * n_P])
+            # *-----------------------b matrix ------------------------------------------------
 
-            A_nn = numpy.eye(n_vars)
+            # prod max has 0 because the default mode is 0
+            b_bal = numpy.zeros((n_bal2 + n_I, 1))
+            b_Inv = numpy.array([[self.store_max[location][i]]
+                                for i in self.set_dict['resources_store']])  # fixed storage bound
+            b_Sf = numpy.array([[-self.demand[location][i]]
+                                for i in self.set_dict['resources_certain_demand']])  # fixed demand bound
+            b_S = numpy.array([[-self.demand[location][i]]
+                               for i in self.set_dict['resources_uncertain_demand']])  # uncertain demand
+            b_Af = numpy.array([[self.cons_max[location][i]]
+                                for i in self.set_dict['resources_certain_availability']])  # fixed availability bound
+            b_A = numpy.array([[self.cons_max[location][i]]
+                               for i in self.set_dict['resources_uncertain_availability']])  # uncertain availability
+
+            b_Pf = numpy.array([[self.prod_max[location][i][0]]
+                                for i in self.set_dict['processes_certain_capacity']])  # fixed production bound
+            b_P = numpy.array([[self.prod_max[location][i][0]]
+                               for i in self.set_dict['processes_uncertain_capacity']])  # uncertain production
+
+            b_nn = numpy.zeros((n_vars, 1))  # non zero constraints
+
+            b_list = [b_bal, b_Inv, b_Sf, b_S, b_Af, b_A, b_Pf, b_P, b_nn]
+
+            b = numpy.block([[i]
+                            for i in b_list if len(i) > 0])  # make b matrix
+            self.b_df = DataFrame(b, columns=['rhs'])
 
-            print(A_bal)
+            # *------------------------------- F --------------------------------------
 
-            print(A_conv)
+            F = numpy.zeros((len(b), n_vars_theta))  # make F matrix
 
-            print(A_diag)
+            n_bal3 = n_bal2 + n_I
+            iter_ = 0
+            for i in range(n_S):
+                n = n_Inv + n_Sf
+                F[n_bal3 + n +
+                    iter_][i] = self.demand[location][self.set_dict['resources_uncertain_demand'][i]]
+                iter_ += 1
 
-            print(A_nn)
+            iter_ = 0
+            for i in range(n_A):
+                n = n_Inv + n_Sf + n_S + n_Af
+                F[n_bal3 + n + iter_][n_S + i] = self.cons_max[location][
+                    self.set_dict['resources_uncertain_availability'][i]]
+                iter_ += 1
 
-            A = numpy.block([[numpy.block([A_bal, A_conv])], [A_diag], [-A_nn]])
+            iter_ = 0
+            for i in range(n_P):
+                n = n_Inv + n_Sf + n_S + n_Af + n_A + n_Pf
+                F[n_bal3 + n + iter_][n_S + n_A +
+                                      i] = self.prod_max[location][self.set_dict['processes_uncertain_capacity'][i]][0]
+                # defaults to 0 as mode, using P_m instead of P
+                iter_ += 1
 
-            # make c matrix
+            column_list = [*['Th_' + i for i in self.set_dict['resources_uncertain_demand']] + ['Th_' + i for i in
+                                                                                                self.set_dict['resources_uncertain_availability']] + ['Th_' + i for i in self.set_dict['processes_uncertain_capacity']]]
+            self.F_df = DataFrame(F, columns=column_list)
 
+            # *--------------------------------------c--------------------------------------
             c_Inv = numpy.zeros((n_Inv, 1))
             c_Sf = numpy.zeros((n_Sf, 1))
-            c_Cf = numpy.zeros((n_Cf, 1))
-            c_Pf = numpy.array([[self.capex_dict[i]] for i in self.set_dict['processes_certain_capacity']])
-
             c_S = numpy.zeros((n_S, 1))
-            c_C = numpy.zeros((n_C, 1))
-            c_P = numpy.array([[self.capex_dict[i]] for i in self.set_dict['processes_uncertain_capacity']])
 
-            c_list = [c_Inv, c_Sf, c_Cf, c_Pf, c_S, c_C, c_P]
+            c_Af = numpy.zeros((n_Af, 1))
+            c_A = numpy.zeros((n_A, 1))
+
+            c_Pf = numpy.array([[self.capex_dict[i]]
+                                for i in self.set_dict['processes_certain_capacity']])
+            c_P = numpy.array([[self.capex_dict[i]]
+                               for i in self.set_dict['processes_uncertain_capacity']])
+            c_list = [c_Inv, c_Sf,  c_S, c_Af,  c_A, c_Pf, c_P]
             c = numpy.block([[i] for i in c_list if len(i) > 0])
 
-            # make H matrix
+            # *-------------------------------------H----------------------------------------
 
             H = numpy.zeros((A.shape[1], F.shape[1]))
 
-            # make critical regions
+            # *----------------------------------critical regions---------------------------
 
-            CRa = numpy.vstack((numpy.eye(n_vars_theta), -numpy.eye(n_vars_theta)))
-            CRb = numpy.array([*[1] * n_vars_theta, *[0] * n_vars_theta]).reshape(n_vars_theta * 2, 1)
+            CRa = numpy.vstack(
+                (numpy.eye(n_vars_theta), -numpy.eye(n_vars_theta)))
+            CRb = numpy.array([*[1] * n_vars_theta, *[0] *
+                               n_vars_theta]).reshape(n_vars_theta * 2, 1)
 
             return A, b, c, H, CRa, CRb, F
 
     def __repr__(self):
         return self.name
```

## energiapy/model/formulate.py

```diff
@@ -7,105 +7,138 @@
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from enum import Enum, auto
-from typing import Set, Dict
+from typing import Set
 
-from pyomo.environ import ConcreteModel
+from pyomo.environ import ConcreteModel, Suffix
 
 from ..components.scenario import Scenario
-from ..components.resource import Resource
+from ..components.scenario import Resource
+from .constraints.constraints import Constraints
 
 from .constraints.cost import (
     constraint_location_capex,
     constraint_location_fopex,
     constraint_location_incidental,
-    constraint_location_land_cost,
+    constraint_land_location_cost,
     constraint_location_vopex,
     constraint_network_capex,
     constraint_network_fopex,
     constraint_network_incidental,
-    constraint_network_land_cost,
+    constraint_land_network_cost,
     constraint_network_vopex,
     constraint_process_capex,
     constraint_process_fopex,
     constraint_process_incidental,
-    constraint_process_land_cost,
+    constraint_land_process_cost,
     constraint_process_vopex,
     constraint_transport_cost,
     constraint_transport_cost_network,
     constraint_transport_imp_cost,
+    constraint_network_cost
 )
 from .constraints.emission import (
     constraint_global_warming_potential_location,
     constraint_global_warming_potential_material,
     constraint_global_warming_potential_network,
     constraint_global_warming_potential_network_reduction,
     constraint_global_warming_potential_process,
     constraint_global_warming_potential_resource,
 )
 from .constraints.failure import constraint_nameplate_production_failure
 from .constraints.inventory import (
-    constraint_min_storage_facility,
     constraint_nameplate_inventory,
-    constraint_storage_facility,
+    constraint_storage_max,
+    constraint_storage_min,
 )
 from .constraints.land import (
-    constraint_location_land,
-    constraint_location_land_restriction,
-    constraint_network_land,
-    constraint_process_land,
+    constraint_land_location,
+    constraint_land_location_restriction,
+    constraint_land_network,
+    constraint_land_process,
 )
 from .constraints.mode import (
     constraint_production_mode,
     constraint_production_mode_binary,
     constraint_production_mode_facility,
 )
 from .constraints.production import (
-    constraint_min_production_facility,
     constraint_nameplate_production,
-    constraint_production_facility,
+    constraint_production_max,
+    constraint_production_min
 )
 from .constraints.resource_balance import (
     constraint_demand,
     constraint_inventory_balance,
     constraint_location_consumption,
+    constraint_location_revenue,
     constraint_location_discharge,
     constraint_location_production,
     constraint_location_purchase,
     constraint_network_consumption,
+    constraint_network_revenue,
     constraint_network_discharge,
     constraint_network_production,
     constraint_network_purchase,
     constraint_resource_consumption,
     constraint_resource_purchase,
+    constraint_resource_revenue
 )
 from .constraints.transport import (
     constraint_transport_balance,
     constraint_transport_exp_UB,
     constraint_transport_export,
     constraint_transport_imp_UB,
     constraint_transport_import,
 )
 from .constraints.uncertain import (
     constraint_uncertain_process_capacity,
     constraint_uncertain_resource_demand,
 )
-from .objectives import cost_objective, demand_objective
+from .constraints.network import (
+    constraint_storage_facility,
+    constraint_production_facility,
+    constraint_min_storage_facility,
+    constraint_min_production_facility,
+    constraint_min_capacity_facility
+)
+from .constraints.credit import (
+    constraint_credit_process,
+    constraint_credit_location,
+    constraint_credit_network
+)
+from .constraints.material import (
+    constraint_material_process,
+    constraint_material_location,
+    constraint_material_network
+)
+from .objectives import (
+    objective_cost,
+    objective_discharge_max,
+    objective_discharge_min,
+    objective_profit,
+    objective_gwp_min
+)
+
 from .sets import generate_sets
 from .variables.binary import generate_network_binary_vars
 from .variables.cost import generate_costing_vars
 from .variables.mode import generate_mode_vars
 from .variables.network import generate_network_vars
 from .variables.schedule import generate_scheduling_vars
 from .variables.transport import generate_transport_vars
 from .variables.uncertain import generate_uncertainty_vars
+from .variables.credit import generate_credit_vars
+from .variables.land import generate_land_vars
+from .variables.emission import generate_emission_vars
+from .variables.material import generate_material_vars
 
 
 class ModelClass(Enum):
     """Class of model
     """
     MIP = auto()
     """
@@ -113,74 +146,79 @@
     """
     MPLP = auto()
     """
     multi-parametric linear programming
     """
 
 
-class Constraints(Enum):
-    """Class of constraints
-    """
-    COST = auto()
-    EMISSION = auto()
-    FAILURE = auto()
-    INVENTORY = auto()
-    LAND = auto()
-    PRODUCTION = auto()
-    RESOURCE_BALANCE = auto()
-    TRANSPORT = auto()
-    UNCERTAIN = auto()
-    MODE = auto()
-    LIFECYCLE = auto()
-
 class Objective(Enum):
     """
     Objective type
     """
     COST = auto()
     """
     Minimize cost
     """
-    DEMAND = auto()
+    PROFIT = auto()
+    """
+    Maximize profit
+    """
+    MIN_DISCHARGE = auto()
+    """
+    Minimize discharge of particular resource
     """
-    Maximize demand
+    MAX_DISCHARGE = auto()
+    """
+    Minimize discharge of particular resource
+    """
+    MIN_GWP = auto()
+    """
+    Minimize global warming potential across network (includes resource, material, process emissions)
     """
 
 
 def formulate(scenario: Scenario, constraints: Set[Constraints] = None, objective: Objective = None,
               write_lpfile: bool = False, gwp: float = None, land_restriction: float = None,
-              gwp_reduction_pct: float = None, model_class: ModelClass = ModelClass.MIP) -> ConcreteModel:
-    """formulates a model
+              gwp_reduction_pct: float = None, model_class: ModelClass = ModelClass.MIP, objective_resource: Resource = None) -> ConcreteModel:
+    """formulates a model. Constraints need to be declared in order
 
     Args:
         scenario (Scenario): scenario to formulate model over
         constraints (Set[Constraints], optional): constraints to include. Defaults to None
         objective (Objective, optional): objective. Defaults to None
         write_lpfile (bool, False): write out a .LP file. Uses scenario.name as name.
-        demand (float, optional): demand level. Defaults to 0.
+        gwp (float, optional): _description_. Defaults to None.
         land_restriction (float, optional): restrict land usage. Defaults to 10**9.
+        gwp_reduction_pct (float, optional): percentage reduction in gwp required. Defaults to None.
         model_class (ModelClass, optional): class of model [MIP, mpLP]. Defaults to ModelClass.MIP
 
+
     Constraints include:
-            Constraints.cost
-            Constraints.emission
-            Constraints.failure
-            Constraints.inventory
-            Constraints.land
-            Constraints.production
-            Constraints.resource_balance
-            Constraints.transport
-            Constraints.uncertain
+            Constraints.COST
+            Constraints.EMISSION
+            Constraints.FAILURE
+            Constraints.INVENTORY
+            Constraints.LAND
+            Constraints.PRODUCTION
+            Constraints.RESOURCE_BALANCE
+            Constraints.TRANSPORT
+            Constraints.UNCERTAIN
+            Constraints.NETWORK
+            Constraints.MODE
+            Constraints.CREDIT
+            Constraints.MATERIAL
 
     Objectives include:
-            Objectives.cost
-            Objectives.demand
+            Objectives.COST
+            Objectives.PROFIT
+            Objectives.MIN_DISCHARGE
+            Objectives.MAX_DISCHARGE
 
     Returns:
-        ConcreteModel: instance
+        ConcreteModel: pyomo instance
     """
 
     demand = scenario.demand
     if isinstance(demand, dict):
         demand = {i.name: {j.name: demand[i][j]
                            for j in demand[i].keys()} for i in demand.keys()}
 
@@ -189,51 +227,35 @@
         instance = ConcreteModel()
         generate_sets(instance=instance, scenario=scenario)
 
         generate_scheduling_vars(
             instance=instance, scale_level=scenario.scheduling_scale_level, mode_dict=scenario.mode_dict)
         generate_network_vars(
             instance=instance, scale_level=scenario.network_scale_level)
-        generate_network_binary_vars(
-            instance=instance, scale_level=scenario.network_scale_level)
         generate_costing_vars(instance=instance)
 
         if Constraints.UNCERTAIN in constraints:
             generate_uncertainty_vars(
                 instance=instance, scale_level=scenario.scheduling_scale_level)
 
             constraint_uncertain_process_capacity(
                 instance=instance, capacity=scenario.prod_max, network_scale_level=scenario.network_scale_level)
             constraint_uncertain_resource_demand(
                 instance=instance, demand=demand, scheduling_scale_level=scenario.scheduling_scale_level)
 
-        if Constraints.MODE in constraints:
-            generate_mode_vars(
-                instance=instance, scale_level=scenario.scheduling_scale_level, mode_dict=scenario.mode_dict)
-
-            constraint_production_mode(instance=instance, mode_dict=scenario.mode_dict,
-                                       scheduling_scale_level=scenario.scheduling_scale_level)
-            constraint_production_mode_facility(instance=instance, prod_max=scenario.prod_max,
-                                                loc_pro_dict=scenario.loc_pro_dict,
-                                                scheduling_scale_level=scenario.scheduling_scale_level)
-            constraint_production_mode_binary(instance=instance, mode_dict=scenario.mode_dict,
-                                              scheduling_scale_level=scenario.scheduling_scale_level,
-                                              network_scale_level=scenario.network_scale_level)
-
         if len(scenario.location_set) > 1:
             generate_transport_vars(instance=instance)
 
         if Constraints.COST in constraints:
             constraint_process_capex(instance=instance, capex_dict=scenario.capex_dict,
-                                     network_scale_level=scenario.expenditure_scale_level, capex_factor=scenario.capex_factor)
+                                     network_scale_level=scenario.expenditure_scale_level, capex_factor=scenario.capex_factor, annualization_factor=scenario.annualization_factor)
             constraint_process_fopex(instance=instance, fopex_dict=scenario.fopex_dict,
                                      network_scale_level=scenario.expenditure_scale_level, fopex_factor=scenario.fopex_factor)
             constraint_process_vopex(instance=instance, vopex_dict=scenario.vopex_dict,
                                      network_scale_level=scenario.expenditure_scale_level, vopex_factor=scenario.vopex_factor)
-
             constraint_process_incidental(instance=instance, incidental_dict=scenario.incidental_dict,
                                           network_scale_level=scenario.network_scale_level)
 
             constraint_location_capex(
                 instance=instance, network_scale_level=scenario.network_scale_level)
             constraint_location_fopex(
                 instance=instance, network_scale_level=scenario.network_scale_level)
@@ -249,90 +271,115 @@
             constraint_network_vopex(
                 instance=instance, network_scale_level=scenario.network_scale_level)
 
             constraint_network_incidental(
                 instance=instance, network_scale_level=scenario.network_scale_level)
 
         if Constraints.EMISSION in constraints:
+            generate_emission_vars(
+                instance=instance, scale_level=scenario.network_scale_level)
+
             constraint_global_warming_potential_process(
                 instance=instance, process_gwp_dict=scenario.process_gwp_dict,
                 network_scale_level=scenario.network_scale_level)
 
             constraint_global_warming_potential_resource(
                 instance=instance, resource_gwp_dict=scenario.resource_gwp_dict,
                 network_scale_level=scenario.network_scale_level)
 
-            constraint_global_warming_potential_material(
-                instance=instance, material_gwp_dict=scenario.material_gwp_dict,
-                process_material_dict=scenario.process_material_dict, network_scale_level=scenario.network_scale_level)
-
             constraint_global_warming_potential_location(
                 instance=instance, network_scale_level=scenario.network_scale_level)
 
             constraint_global_warming_potential_network(
                 instance=instance, network_scale_level=scenario.network_scale_level)
 
+            if Constraints.MATERIAL in constraints:
+
+                constraint_global_warming_potential_material(
+                    instance=instance, material_gwp_dict=scenario.material_gwp_dict,
+                    process_material_dict=scenario.process_material_dict, network_scale_level=scenario.network_scale_level)
+
         if Constraints.FAILURE in constraints:
             constraint_nameplate_production_failure(instance=instance, fail_factor=scenario.fail_factor,
                                                     network_scale_level=scenario.network_scale_level,
                                                     scheduling_scale_level=scenario.scheduling_scale_level)
 
         if Constraints.INVENTORY in constraints:
             constraint_nameplate_inventory(instance=instance, loc_res_dict=scenario.loc_res_dict,
                                            network_scale_level=scenario.network_scale_level,
                                            scheduling_scale_level=scenario.scheduling_scale_level)
 
-            constraint_storage_facility(instance=instance, store_max=scenario.store_max,
-                                        loc_res_dict=scenario.loc_res_dict,
-                                        network_scale_level=scenario.network_scale_level)
-
-            constraint_min_storage_facility(instance=instance, store_min=scenario.store_min,
-                                            loc_res_dict=scenario.loc_res_dict,
-                                            network_scale_level=scenario.network_scale_level)
+            constraint_storage_max(instance=instance, store_max=scenario.store_max,
+                                   loc_res_dict=scenario.loc_res_dict,
+                                   network_scale_level=scenario.network_scale_level)
+
+            constraint_storage_min(instance=instance, store_min=scenario.store_min,
+                                   loc_res_dict=scenario.loc_res_dict,
+                                   network_scale_level=scenario.network_scale_level)
 
         if Constraints.PRODUCTION in constraints:
+
+            constraint_production_mode(instance=instance, mode_dict=scenario.mode_dict,
+                                       scheduling_scale_level=scenario.scheduling_scale_level)
+
             constraint_nameplate_production(instance=instance, capacity_factor=scenario.capacity_factor,
                                             loc_pro_dict=scenario.loc_pro_dict,
                                             network_scale_level=scenario.network_scale_level,
                                             scheduling_scale_level=scenario.scheduling_scale_level)
-            constraint_production_facility(instance=instance, prod_max=scenario.prod_max,
-                                           loc_pro_dict=scenario.loc_pro_dict,
-                                           network_scale_level=scenario.network_scale_level)
-            constraint_min_production_facility(instance=instance, prod_min=scenario.prod_min,
-                                               loc_pro_dict=scenario.loc_pro_dict,
-                                               network_scale_level=scenario.network_scale_level)
+
+            constraint_production_max(instance=instance, prod_max=scenario.prod_max,
+                                      loc_pro_dict=scenario.loc_pro_dict,
+                                      network_scale_level=scenario.network_scale_level)
+
+            constraint_production_min(instance=instance, prod_min=scenario.prod_min,
+                                      loc_pro_dict=scenario.loc_pro_dict,
+                                      network_scale_level=scenario.network_scale_level)
 
         if Constraints.LAND in constraints:
-            constraint_process_land(instance=instance, land_dict=scenario.land_dict,
+            generate_land_vars(
+                instance=instance, scale_level=scenario.network_scale_level)
+
+            constraint_land_process(instance=instance, land_dict=scenario.land_dict,
                                     network_scale_level=scenario.network_scale_level)
-            constraint_location_land(
+            constraint_land_location(
                 instance=instance, network_scale_level=scenario.network_scale_level)
-            constraint_network_land(
+            constraint_land_network(
                 instance=instance, network_scale_level=scenario.network_scale_level)
 
-            constraint_process_land_cost(instance=instance, land_dict=scenario.land_dict,
+            constraint_land_process_cost(instance=instance, land_dict=scenario.land_dict,
                                          land_cost_dict=scenario.land_cost_dict,
                                          network_scale_level=scenario.network_scale_level)
-            constraint_location_land_cost(
+            constraint_land_location_cost(
                 instance=instance, network_scale_level=scenario.network_scale_level)
-            constraint_network_land_cost(
+            constraint_land_network_cost(
                 instance=instance, network_scale_level=scenario.network_scale_level)
 
             if land_restriction is not None:
-                constraint_location_land_restriction(
+                constraint_land_location_restriction(
                     instance=instance, network_scale_level=scenario.network_scale_level,
                     land_restriction=land_restriction)
 
+        if Constraints.CREDIT in constraints:
+            generate_credit_vars(
+                instance=instance, scale_level=scenario.network_scale_level)
+
+            constraint_credit_process(instance=instance, credit_dict=scenario.credit_dict,
+                                      network_scale_level=scenario.network_scale_level)
+            constraint_credit_location(
+                instance=instance, network_scale_level=scenario.network_scale_level)
+            constraint_credit_network(
+                instance=instance, network_scale_level=scenario.network_scale_level)
+
         if Constraints.RESOURCE_BALANCE in constraints:
             constraint_inventory_balance(instance=instance, scheduling_scale_level=scenario.scheduling_scale_level,
                                          multiconversion=scenario.multiconversion, mode_dict=scenario.mode_dict)
 
             constraint_resource_consumption(instance=instance, loc_res_dict=scenario.loc_res_dict,
                                             cons_max=scenario.cons_max,
-                                            scheduling_scale_level=scenario.scheduling_scale_level)
+                                            scheduling_scale_level=scenario.scheduling_scale_level, availability_factor=scenario.availability_factor)
 
             constraint_resource_purchase(instance=instance, price_factor=scenario.price_factor, price=scenario.price,
                                          loc_res_dict=scenario.loc_res_dict,
                                          scheduling_scale_level=scenario.scheduling_scale_level,
                                          purchase_scale_level=scenario.purchase_scale_level)
 
             constraint_location_production(
@@ -374,34 +421,124 @@
                 constraint_transport_imp_cost(instance=instance, scheduling_scale_level=scenario.scheduling_scale_level,
                                               trans_cost=scenario.trans_cost, distance_dict=scenario.distance_dict)
                 constraint_transport_cost(
                     instance=instance, scheduling_scale_level=scenario.scheduling_scale_level)
                 constraint_transport_cost_network(
                     instance=instance, network_scale_level=scenario.network_scale_level)
 
+        if Constraints.NETWORK in constraints:
+            generate_network_binary_vars(
+                instance=instance, scale_level=scenario.network_scale_level)
+
+            constraint_storage_facility(instance=instance, store_max=scenario.store_max,
+                                        loc_res_dict=scenario.loc_res_dict,
+                                        network_scale_level=scenario.network_scale_level)
+
+            constraint_production_facility(instance=instance, prod_max=scenario.prod_max,
+                                           loc_pro_dict=scenario.loc_pro_dict,
+                                           network_scale_level=scenario.network_scale_level)
+
+            constraint_min_production_facility(instance=instance, prod_min=scenario.prod_min,
+                                               loc_pro_dict=scenario.loc_pro_dict,
+                                               network_scale_level=scenario.network_scale_level)
+
+            constraint_min_storage_facility(instance=instance, store_min=scenario.store_min,
+                                            loc_res_dict=scenario.loc_res_dict,
+                                            network_scale_level=scenario.network_scale_level)
+
+            instance.del_component(instance.constraint_storage_min)
+            instance.del_component(instance.constraint_production_min)
+
+        if Constraints.MODE in constraints:
+            generate_mode_vars(
+                instance=instance, scale_level=scenario.scheduling_scale_level, mode_dict=scenario.mode_dict)
+
+            constraint_production_mode_facility(instance=instance, prod_max=scenario.prod_max,
+                                                loc_pro_dict=scenario.loc_pro_dict,
+                                                scheduling_scale_level=scenario.scheduling_scale_level)
+            constraint_production_mode_binary(instance=instance, mode_dict=scenario.mode_dict,
+                                              scheduling_scale_level=scenario.scheduling_scale_level,
+                                              network_scale_level=scenario.network_scale_level)
+
+        if Constraints.MATERIAL in constraints:
+            generate_material_vars(
+                instance=instance, scale_level=scenario.network_scale_level)
+
+            constraint_material_process(
+                instance=instance, process_material_dict=scenario.process_material_dict, network_scale_level=scenario.network_scale_level)
+            constraint_material_location(
+                instance=instance, network_scale_level=scenario.network_scale_level)
+            constraint_material_network(
+                instance=instance, network_scale_level=scenario.network_scale_level)
+
         if gwp is not None:
             constraint_global_warming_potential_network_reduction(
                 instance=instance, network_scale_level=scenario.network_scale_level,
                 gwp_reduction_pct=gwp_reduction_pct, gwp=gwp)
 
         if objective == Objective.COST:
             constraint_demand(instance=instance, demand_scale_level=scenario.demand_scale_level,
                               scheduling_scale_level=scenario.scheduling_scale_level, demand=demand,
-                              demand_factor=scenario.demand_factor)
+                              demand_factor=scenario.demand_factor, loc_res_dict=scenario.loc_res_dict)
 
-            cost_objective(instance=instance,
-                           network_scale_level=scenario.network_scale_level)
+            objective_cost(
+                instance=instance, network_scale_level=scenario.network_scale_level, constraints=constraints)
 
-        if objective == Objective.DEMAND:
-            demand_objective(instance=instance,
-                             network_scale_level=scenario.network_scale_level)
+        if objective == Objective.PROFIT:
+            constraint_resource_revenue(instance=instance, loc_res_dict=scenario.loc_res_dict, revenue=scenario.revenue,
+                                        demand_scale_level=scenario.demand_scale_level, revenue_factor=scenario.revenue_factor)
+            constraint_location_revenue(
+                instance=instance, network_scale_level=scenario.network_scale_level, cluster_wt=scenario.cluster_wt)
+            constraint_network_revenue(
+                instance=instance, network_scale_level=scenario.network_scale_level)
+            objective_profit(
+                instance=instance, network_scale_level=scenario.network_scale_level, constraints=constraints)
+
+        if objective == Objective.MIN_DISCHARGE:
+            constraint_demand(instance=instance, demand_scale_level=scenario.demand_scale_level,
+                              scheduling_scale_level=scenario.scheduling_scale_level, demand=demand,
+                              demand_factor=scenario.demand_factor, loc_res_dict=scenario.loc_res_dict)
+
+            constraint_network_cost(
+                instance=instance, network_scale_level=scenario.network_scale_level, constraints=constraints)
+
+            objective_discharge_min(instance=instance, resource=objective_resource,
+                                    network_scale_level=scenario.network_scale_level)
+
+        if objective == Objective.MAX_DISCHARGE:
+            constraint_demand(instance=instance, demand_scale_level=scenario.demand_scale_level,
+                              scheduling_scale_level=scenario.scheduling_scale_level, demand=demand,
+                              demand_factor=scenario.demand_factor, loc_res_dict=scenario.loc_res_dict)
+
+            constraint_network_cost(
+                instance=instance, network_scale_level=scenario.network_scale_level, constraints=constraints)
+
+            objective_discharge_max(instance=instance, resource=objective_resource,
+                                    network_scale_level=scenario.network_scale_level)
+
+        if objective == Objective.MIN_GWP:
+            constraint_demand(instance=instance, demand_scale_level=scenario.demand_scale_level,
+                              scheduling_scale_level=scenario.scheduling_scale_level, demand=demand,
+                              demand_factor=scenario.demand_factor, loc_res_dict=scenario.loc_res_dict)
+
+            constraint_network_cost(
+                instance=instance, network_scale_level=scenario.network_scale_level, constraints=constraints)
+
+            objective_gwp_min(
+                instance=instance, network_scale_level=scenario.network_scale_level)
+
+        if scenario.capacity_bounds is not None:
+            constraint_min_capacity_facility(instance=instance, loc_pro_dict=scenario.loc_pro_dict,
+                                             network_scale_level=scenario.network_scale_level, capacity_bounds=scenario.capacity_bounds)
 
         if write_lpfile is True:
             instance.write(f'{scenario.name}.lp')
 
+        instance.dual = Suffix(direction=Suffix.IMPORT_EXPORT)
+
         return instance
 
     if model_class is ModelClass.MPLP:
         A, b, c, H, CRa, CRb, F = scenario.matrix_form()
 
         matrix_dict = {'A': A, 'b': b, 'c': c,
                        'H': H, 'CRa': CRa, 'CRb': CRb, 'F': F}
```

## energiapy/model/objectives.py

```diff
@@ -7,69 +7,87 @@
 __license__ = "Open"
 __version__ = "0.0.1"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from itertools import product
+from typing import Set
 
 from pyomo.environ import ConcreteModel, Objective, maximize
 
 from ..utils.latex_utils import constraint_latex_render
 from ..utils.scale_utils import scale_tuple
+from ..components.resource import Resource
+from ..model.constraints.constraints import Constraints
 
 
-def cost_objective(instance: ConcreteModel, network_scale_level: int = 0) -> Objective:
+def objective_cost(instance: ConcreteModel, constraints: Set[Constraints], network_scale_level: int = 0) -> Objective:
     """Objective to minimize total cost
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Objective: cost objective
     """
-    scale_iter = scale_tuple(instance=instance, scale_levels=network_scale_level + 1)
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
 
-    def cost_objective_rule(instance):
+    def objective_cost_rule(instance):
         capex = sum(instance.Capex_network[scale_] for scale_ in scale_iter)
         vopex = sum(instance.Vopex_network[scale_] for scale_ in scale_iter)
         fopex = sum(instance.Fopex_network[scale_] for scale_ in scale_iter)
-        incidental = sum(instance.Incidental_network[scale_] for scale_ in scale_iter)
+        incidental = sum(
+            instance.Incidental_network[scale_] for scale_ in scale_iter)
 
         cost_purch = sum(instance.B_network[resource_, scale_] for resource_, scale_ in
                          product(instance.resources_purch, scale_iter))
 
-        land_cost = sum(instance.Land_cost_network[scale_] for scale_ in scale_iter)
+        if Constraints.LAND in constraints:
+            land_cost = sum(
+                instance.Land_cost_network[scale_] for scale_ in scale_iter)
+        else:
+            land_cost = 0
+
+        if Constraints.CREDIT in constraints:
+            credit = sum(
+                instance.Credit_network[scale_] for scale_ in scale_iter)
+        else:
+            credit = 0
 
         if len(instance.locations) > 1:
             cost_trans = sum(instance.Trans_cost_network[transport_, scale_] for transport_, scale_ in
                              product(instance.transports, scale_iter))
         else:
             cost_trans = 0
-        return capex + vopex + fopex + cost_purch + cost_trans + incidental + land_cost
+        return capex + vopex + fopex + cost_purch + cost_trans + incidental + land_cost - credit
 
-    instance.cost_objective = Objective(rule=cost_objective_rule, doc='total cost')
-    constraint_latex_render(cost_objective_rule)
-    return instance.cost_objective
+    instance.objective_cost = Objective(
+        rule=objective_cost_rule, doc='total cost')
+    constraint_latex_render(objective_cost_rule)
+    return instance.objective_cost
 
 
-def uncertainty_cost_objective(instance: ConcreteModel, penalty: float, network_scale_level: int = 0,
+def objective_uncertainty_cost(instance: ConcreteModel, penalty: float, network_scale_level: int = 0,
                                uncertainty_scale_level: int = 0) -> Objective:
     """Objective to minimize total cost
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Objective: cost objective
     """
-    scale_iter = scale_tuple(instance=instance, scale_levels=network_scale_level + 1)
-    scale_iter_uncertainty = scale_tuple(instance=instance, scale_levels=uncertainty_scale_level + 1)
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
+    scale_iter_uncertainty = scale_tuple(
+        instance=instance, scale_levels=uncertainty_scale_level + 1)
 
     def uncertainty_cost_objective_rule(instance):
         capex = sum(instance.Capex_network[scale_] for scale_ in scale_iter)
         vopex = sum(instance.Vopex_network[scale_] for scale_ in scale_iter)
         fopex = sum(instance.Fopex_network[scale_] for scale_ in scale_iter)
         cost_purch = sum(instance.B_network[resource_, scale_] for resource_, scale_ in
                          product(instance.resources_purch, scale_iter))
@@ -84,26 +102,143 @@
 
     instance.uncertainty_cost_objective = Objective(rule=uncertainty_cost_objective_rule,
                                                     doc='total purchase from network')
     constraint_latex_render(uncertainty_cost_objective_rule)
     return instance.uncertainty_cost_objective
 
 
-def demand_objective(instance: ConcreteModel, network_scale_level: int = 0) -> Objective:
-    """Objective to maximize total discharge
+# def objective_discharge_max(instance: ConcreteModel, network_scale_level: int = 0) -> Objective:
+#     """Objective to maximize total discharge
+
+#     Args:
+#         instance (ConcreteModel): pyomo instance
+#         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+#     Returns:
+#         Objective: cost objective
+#     """
+#     scale_iter = scale_tuple(instance=instance, scale_levels=network_scale_level + 1)
+
+#     def demand_objective_rule(instance):
+#         return sum(instance.S_network[resource_, scale_] for resource_, scale_ in
+#                    product(instance.resources_demand, scale_iter))
+
+#     instance.demand_objective = Objective(rule=demand_objective_rule, doc='total purchase from network', sense=maximize)
+#     # constraint_latex_render(cost_objective_rule)
+#     return instance.demand_objective
+
+
+def objective_discharge_min(instance: ConcreteModel, resource: Resource, network_scale_level: int = 0, ) -> Objective:
+    """Minimize discharge of a particular resource
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Objective: cost objective
+        Objective: objective_discharge_min
     """
-    scale_iter = scale_tuple(instance=instance, scale_levels=network_scale_level + 1)
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
+
+    def objective_discharge_min_rule(instance, *scale_list):
+        return sum(instance.S_network[resource.name, scale_] for scale_ in scale_iter)
+
+    instance.objective_discharge_min = Objective(
+        rule=objective_discharge_min_rule, doc='minimize total discharge from specific_network')
+    constraint_latex_render(objective_discharge_min_rule)
+    return instance.objective_discharge_min
+
+
+def objective_discharge_max(instance: ConcreteModel, resource: Resource, network_scale_level: int = 0, ) -> Objective:
+    """Maximize discharge of a particular resource
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Objective: objective_discharge_max
+    """
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
+
+    def objective_discharge_max_rule(instance, *scale_list):
+        return sum(instance.S_network[resource.name, scale_] for scale_ in scale_iter)
+
+    instance.objective_discharge_max = Objective(
+        rule=objective_discharge_max_rule, sense=maximize, doc='maximize total discharge from specific_network')
+    constraint_latex_render(objective_discharge_max_rule)
+    return instance.objective_discharge_max
+
+
+def objective_profit(instance: ConcreteModel, constraints: Set[Constraints], network_scale_level: int = 0) -> Objective:
+    """Objective to maximize total profit
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Objective: profit objective
+    """
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
+
+    def objective_profit_rule(instance):
+        capex = sum(instance.Capex_network[scale_] for scale_ in scale_iter)
+        vopex = sum(instance.Vopex_network[scale_] for scale_ in scale_iter)
+        fopex = sum(instance.Fopex_network[scale_] for scale_ in scale_iter)
+        incidental = sum(
+            instance.Incidental_network[scale_] for scale_ in scale_iter)
+
+        cost_purch = sum(instance.B_network[resource_, scale_] for resource_, scale_ in
+                         product(instance.resources_purch, scale_iter))
+
+        revenue = sum(instance.R_network[resource_, scale_] for resource_, scale_ in
+                      product(instance.resources_sell, scale_iter))
+
+        if Constraints.LAND in constraints:
+            land_cost = sum(
+                instance.Land_cost_network[scale_] for scale_ in scale_iter)
+        else:
+            land_cost = 0
+
+        if Constraints.CREDIT in constraints:
+            credit = sum(
+                instance.Credit_network[scale_] for scale_ in scale_iter)
+        else:
+            credit = 0
+
+        if len(instance.locations) > 1:
+            cost_trans = sum(instance.Trans_cost_network[transport_, scale_] for transport_, scale_ in
+                             product(instance.transports, scale_iter))
+        else:
+            cost_trans = 0
+        return -(capex + vopex + fopex + cost_purch + cost_trans + incidental + land_cost) + credit + revenue
+
+    instance.objective_profit = Objective(
+        rule=objective_profit_rule, sense=maximize, doc='total profit')
+    constraint_latex_render(objective_profit_rule)
+    return instance.objective_profit
+
+
+def objective_gwp_min(instance: ConcreteModel, network_scale_level: int = 0, ) -> Objective:
+    """Minimize gwp at network level
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Objective: objective_gwp_min
+    """
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
+
+    def objective_gwp_min_rule(instance, *scale_list):
+        return sum(instance.global_warming_potential_network[scale_] for scale_ in scale_iter)
 
-    def demand_objective_rule(instance):
-        return sum(instance.S_network[resource_, scale_] for resource_, scale_ in
-                   product(instance.resources_demand, scale_iter))
-
-    instance.demand_objective = Objective(rule=demand_objective_rule, doc='total purchase from network', sense=maximize)
-    # constraint_latex_render(cost_objective_rule)
-    return instance.demand_objective
+    instance.objective_gwp_min = Objective(
+        rule=objective_gwp_min_rule, doc='minimize total gwp for network')
+    constraint_latex_render(objective_gwp_min_rule)
+    return instance.objective_gwp_min
```

## energiapy/model/sets.py

```diff
@@ -8,122 +8,146 @@
 __version__ = "0.0.1"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from ..components.scenario import Scenario
 from pyomo.environ import ConcreteModel, Set
-from itertools import product
 
 
 def generate_sets(instance: ConcreteModel, scenario: Scenario):
     """Generates pyomo sets based on declared lists.
 
     Creates the following sets:
 
     processes: Set of all processes
-    
+
     processes_full: 'Set of all processes including dummy discharge'
-    
+
     resources: Set of all resources
 
     resources_nosell: Set of non-dischargeable resources
-    
+
     resources_sell: Set of dischargeable resources
-    
+
     resources_store: Set of storeable resources
-    
+
     resources_purch: Set of purchased resources  
-    
+
     resources_varying: Set of resources with varying purchase price
-    
+
     resources_demand: Set of resources with exact demand
 
     resources_transport: Set of resource which can be transported
-    
+
     processes_varying: Set of processes with varying capacity
-    
+
     processes_failure: Set of processes which can fail
-    
+
     processes_materials: Set of processes with material requirements
-    
+
     processes_storage: Set of storage process
-    
+
     processes_multim: Set of processes with multiple modes
-    
+
     processes_singlem: Set of processes with multiple modes
-    
+
     locations: Set of locations
 
     sources: Set of locations which act as sources
 
     sinks: Set of locations which act as sinks
 
     materials: Set of materials
 
     transports: Set of transportation options
 
-    
-    
+
+
     scales: Set of scales
-    
+
 
     Args:
         instance (ConcreteModel): pyomo instance
         scenario (Scenario): scenario
-        
+
     """
 
-    instance.scales = Set(scenario.scales.list, initialize=scenario.scales.scale, doc='set of scales')
+    instance.scales = Set(scenario.scales.list,
+                          initialize=scenario.scales.scale, doc='set of scales')
 
     sets = scenario.set_dict
 
-    instance.processes = Set(initialize=sets['processes'], doc='Set of processes')
+    instance.processes = Set(
+        initialize=sets['processes'], doc='Set of processes')
     instance.processes_full = Set(initialize=sets['processes_full'],
                                   doc='Set of all processes including dummy discharge')
-    instance.resources = Set(initialize=sets['resources'], doc='Set of resources')
-    instance.resources_nosell = Set(initialize=sets['resources_nosell'], doc='Set of non-dischargeable resources')
-    instance.resources_sell = Set(initialize=sets['resources_sell'], doc='Set of dischargeable resources')
-    instance.resources_store = Set(initialize=sets['resources_store'], doc='Set of storeable resources')
-    instance.resources_purch = Set(initialize=sets['resources_purch'], doc='Set of purchased resources')
+    instance.resources = Set(
+        initialize=sets['resources'], doc='Set of resources')
+    instance.resources_nosell = Set(
+        initialize=sets['resources_nosell'], doc='Set of non-dischargeable resources')
+    instance.resources_sell = Set(
+        initialize=sets['resources_sell'], doc='Set of dischargeable resources')
+    instance.resources_store = Set(
+        initialize=sets['resources_store'], doc='Set of storeable resources')
+    instance.resources_purch = Set(
+        initialize=sets['resources_purch'], doc='Set of purchased resources')
     instance.resources_varying_price = Set(initialize=sets['resources_varying_price'],
                                            doc='Set of resources with varying purchase price')
+    instance.resources_varying_revenue = Set(initialize=sets['resources_varying_revenue'],
+                                           doc='Set of resources with varying purchase revenue')
     instance.resources_varying_demand = Set(initialize=sets['resources_varying_demand'],
                                             doc='Set of resources with varying purchase price')
-    instance.resources_demand = Set(initialize=sets['resources_demand'], doc='Set of resources with exact demand')
-    instance.processes_varying = Set(initialize=sets['processes_varying'], doc='Set of processes with varying capacity')
-    instance.processes_failure = Set(initialize=sets['processes_failure'], doc='Set of processes which can fail')
+    instance.resources_demand = Set(
+        initialize=sets['resources_demand'], doc='Set of resources with exact demand')
+    instance.processes_varying_capacity = Set(
+        initialize=sets['processes_varying_capacity'], doc='Set of processes with varying capacity')
+    instance.processes_varying_expenditure = Set(
+        initialize=sets['processes_varying_expenditure'], doc='Set of processes with varying expenditure')
+    instance.processes_failure = Set(
+        initialize=sets['processes_failure'], doc='Set of processes which can fail')
     instance.processes_materials = Set(initialize=sets['processes_materials'],
                                        doc='Set of processes with material requirements')
-    instance.processes_storage = Set(initialize=sets['processes_storage'], doc='Set of storage process')
-    instance.processes_multim = Set(initialize=sets['processes_multim'], doc='Set of processes with multiple modes')
-    instance.processes_singlem = Set(initialize=sets['processes_singlem'], doc='Set of processes with multiple modes')
-    instance.locations = Set(initialize=sets['locations'], doc='Set of locations')
+    instance.processes_storage = Set(
+        initialize=sets['processes_storage'], doc='Set of storage process')
+    instance.processes_multim = Set(
+        initialize=sets['processes_multim'], doc='Set of processes with multiple modes')
+    instance.processes_singlem = Set(
+        initialize=sets['processes_singlem'], doc='Set of processes with multiple modes')
+    instance.locations = Set(
+        initialize=sets['locations'], doc='Set of locations')
 
     instance.resources_uncertain_price = Set(initialize=sets['resources_uncertain_price'],
                                              doc='Set of resources with uncertain purchase price')
+    instance.resources_uncertain_revenue = Set(initialize=sets['resources_uncertain_revenue'],
+                                            doc='Set of resources with uncertain purchase revenue')
     instance.resources_uncertain_demand = Set(initialize=sets['resources_uncertain_demand'],
                                               doc='Set of resources with uncertain demand')
     instance.processes_uncertain_capacity = Set(initialize=sets['processes_uncertain_capacity'],
                                                 doc='Set of processes with uncertain capacity')
 
     mode_lens = []
     for j in scenario.location_set:
         for i in scenario.process_set:
             if i.name in scenario.loc_pro_dict[j.name]:
                 mode_lens.append(len(scenario.prod_max[j.name][i.name].keys()))
 
-    instance.modes = Set(initialize=list(range(max(mode_lens))), doc='Set of process modes')
+    instance.modes = Set(initialize=list(
+        range(max(mode_lens))), doc='Set of process modes')
 
     if scenario.source_locations is not None:
-        instance.sources = Set(initialize=sets['sources'], doc='Set of sources')
+        instance.sources = Set(
+            initialize=sets['sources'], doc='Set of sources')
 
     if scenario.sink_locations is not None:
         instance.sinks = Set(initialize=sets['sinks'], doc='Set of sinks')
 
     if len(scenario.material_set) > 0:
-        instance.materials = Set(initialize=sets['materials'], doc='Set of materials')
+        instance.materials = Set(
+            initialize=sets['materials'], doc='Set of materials')
 
     if scenario.transport_set is not None:
-        instance.transports = Set(initialize=sets['transports'], doc='Set of transports')
-        instance.resources_trans = Set(initialize=sets['resources_trans'], doc='Set of transportable resources')
+        instance.transports = Set(
+            initialize=sets['transports'], doc='Set of transports')
+        instance.resources_trans = Set(
+            initialize=sets['resources_trans'], doc='Set of transportable resources')
     return
```

## energiapy/model/solve.py

```diff
@@ -1,36 +1,56 @@
-# %%
-"""pyomo_solve
+"""solve
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "Open"
 __version__ = "0.0.1"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 import logging
-
+from warnings import warn
 from pyomo.environ import ConcreteModel, Constraint, Objective, SolverFactory, Var
 from pyomo.util.infeasible import (
     log_close_to_bounds,
     log_infeasible_bounds,
     log_infeasible_constraints,
 )
 
 from ..components.result import Result
 from ..components.scenario import Scenario
 
 
-def solve(instance: ConcreteModel, solver: str, name: str, scenario: Scenario = None, saveformat: str = None, print_solversteps: bool = True) -> Result:
-    output = SolverFactory(solver, solver_io='python').solve(
-        instance, tee=print_solversteps)
+def solve(instance: ConcreteModel, solver: str, name: str, interface: str = 'pyomo', scenario: Scenario = None, saveformat: str = None, print_solversteps: bool = True, log: bool = False) -> Result:
+    """solves a model instance, scenario needs to be provided
+
+    Args:
+        instance (ConcreteModel): Pyomo instance
+        solver (str): solver, e.g. gurobi, BARON, ANTIGONE, CPLEX
+        name (str): name for results
+        interface (str, optional): Currently, pyomo's native and gams is available. Defaults to 'pyomo'.
+        scenario (Scenario, optional): scenario. Defaults to None.
+        saveformat (str, optional): .pkl, .json, .txt. Defaults to None.
+        print_solversteps (bool, optional):. Defaults to True.
+        log (bool, optional): Log nearbounds in case of optimal, and violations if infeasible. Defaults to False
+
+    Returns:
+        Result: _description_
+    """
+    if interface == 'pyomo':
+        output = SolverFactory(solver, solver_io='python').solve(
+            instance, tee=print_solversteps)
+
+    if interface == 'gams':
+        warn('Ensure GAMS is installed on system and PATH is set')
+        output = SolverFactory('gams').solve(
+            instance, solver=solver, tee=print_solversteps)
 
     if scenario is None:
         components_dict = {}
     else:
         components_dict = {
             'processes': {i.name: i.__dict__ for i in scenario.process_set},
             'resources': {i.name: i.__dict__ for i in scenario.resource_set},
@@ -66,39 +86,36 @@
 
         output_dict = {**solution_dict, **vars_dict, **obj_dict}
 
         model_cons = [i for i in instance.component_objects()
                       if i.ctype == Constraint]
 
         if solution_dict['n_binvars'] > 0:
-            duals_dict = {}
+            duals_dict = dict()
         else:
             index_dict = {c: list(c.index_set()) for c in model_cons}
             duals_dict = {cons.name: {index: instance.dual[cons[index]] for index
                                       in index_dict[cons]} for cons in model_cons}
 
-        logging.basicConfig(
-            filename=f"{scenario.name}_nearbound.log", encoding='utf-8', level=logging.INFO)
-        log_close_to_bounds(instance)
+        if log is True:
+            logging.basicConfig(
+                filename=f"{scenario.name}_nearbound.log", encoding='utf-8', level=logging.INFO)
+            log_close_to_bounds(instance)
 
     else:
         output_dict = solution_dict
         duals_dict = {}
 
-        logging.basicConfig(
-            filename=f"{scenario.name}_infeasible.log", encoding='utf-8', level=logging.INFO)
-        log_infeasible_bounds(instance)
-        log_infeasible_constraints(instance)
-        log_close_to_bounds(instance)
+        if log is True:
+            logging.basicConfig(
+                filename=f"{scenario.name}_infeasible.log", encoding='utf-8', level=logging.INFO)
+            log_infeasible_bounds(instance)
+            log_infeasible_constraints(instance)
+            log_close_to_bounds(instance)
 
     results = Result(name=name, components=components_dict,
                      output=output_dict, duals=duals_dict)
 
     if saveformat is not None:
         results.saveoutputs(name + saveformat)
 
     return results
-
-# %%
-
-
-# %
```

## energiapy/model/constraints/chance.py

```diff
@@ -1,13 +1,49 @@
-"""pyomo chance constraints
+"""chance constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
+# from typing import Union, Dict
 
+# from pyomo.environ import ConcreteModel, Constraint
+
+# from ...utils.latex_utils import constraint_latex_render
+# from ...utils.scale_utils import scale_list, scale_tuple
+# from ...fitting.dist import fit
+# from ...utils.data_utils import min_max
+
+
+# def constraint_demand_chance(instance: ConcreteModel, demand_factor:dict, guarantee: float, dist:str = 'norm', demand_scale_level: int = 0, scheduling_scale_level: int = 0,loc_res_dict: dict = None, ) -> Constraint:
+
+#     # scales = scale_list(instance= instance, scale_levels = demand_scale_level+1)
+#     scales = scale_list(instance=instance,
+#                         scale_levels=len(instance.scales))
+#     scale_iter = scale_tuple(
+#         instance=instance, scale_levels=scheduling_scale_level + 1)
+
+#     if loc_res_dict is None:
+#         loc_res_dict = dict()
+
+#     def norm_constant(p, mu, sigma):
+#         x = mu + erf(1 / sqrt(2) * p) * sigma * sqrt(2)
+#         return 1 / (sigma * sqrt(2 * pi)) * exp(-(x - mu)**2 / (2 * sigma**2))
+
+#         data = demand_factor[location].to_numpy()
+#         data = min_max(data)
+#         fit_summary = fit(data)
+#         mu = fit_summary.loc[dist]['loc']
+#         sigma = fit_summary.loc[dist]['scale']
+#         c= norm_constant(guarantee, mu, sigma)
+
+
+#     def demand_chance_rule(instance, location, resource, *scale_list):
+
+#     constraint_latex_render(demand_chance_rule)
+#     return instance.constraint_demand
```

## energiapy/model/constraints/cost.py

```diff
@@ -1,26 +1,28 @@
-"""pyomo cost constraints
+"""cost constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from enum import Enum, auto
 from itertools import product
+from typing import Set
 
 from pyomo.environ import ConcreteModel, Constraint
 
 from ...utils.latex_utils import constraint_latex_render
 from ...utils.scale_utils import scale_list, scale_tuple
+from .constraints import Constraints
 
 
 class Costdynamics(Enum):
     constant = auto()
     pwl = auto()
     scaled = auto()
     wind = auto()  # TODO allow user to give equation
@@ -67,19 +69,19 @@
     """
     scales = scale_list(instance=instance,
                         scale_levels=scheduling_scale_level+1)
 
     def transport_imp_cost_rule(instance, sink, source, resource, transport, *scale_list):
         if trans_cost is None:
             return Constraint.Skip
-
-        if distance_dict is None:
-            return Constraint.Skip
-
-        return instance.Trans_imp_cost[sink, source, resource, transport, scale_list[:scheduling_scale_level+1]] == trans_cost[transport]*distance_dict[(source, sink)]*instance.Trans_imp[sink, source, resource, transport, scale_list[:scheduling_scale_level+1]]
+        else:
+            if distance_dict is None:
+                return Constraint.Skip
+            else:
+                return instance.Trans_imp_cost[sink, source, resource, transport, scale_list[:scheduling_scale_level+1]] == trans_cost[transport]*distance_dict[(source, sink)]*instance.Trans_imp[sink, source, resource, transport, scale_list[:scheduling_scale_level+1]]
 
     instance.constraint_transport_imp_cost = Constraint(instance.sinks, instance.sources, instance.resources_trans,
                                                         instance.transports, *scales, rule=transport_imp_cost_rule, doc='import of resource from sink to source')
 
     constraint_latex_render(transport_imp_cost_rule)
     return instance.constraint_transport_imp_cost
 
@@ -116,25 +118,25 @@
         network_scale_level (int, optional): scale for network decisions. Defaults to 0.
 
     Returns:
         Constraint: transport_cost_network
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
     scale_iter = scale_tuple(
-        instance=instance, scale_levels=instance.scales.__len__())
+        instance=instance, scale_levels=len(instance.scales))
 
     def transport_cost_network_rule(instance, transport, *scale_list):
         return instance.Trans_cost_network[transport, scale_list] == sum(instance.Trans_cost[transport, scale_] for scale_ in scale_iter)
     instance.constraint_transport_cost_network = Constraint(
         instance.transports, *scales, rule=transport_cost_network_rule, doc='total transport cost across scale')
     constraint_latex_render(transport_cost_network_rule)
     return instance.constraint_transport_cost_network
 
 
-def constraint_process_capex(instance: ConcreteModel, capex_dict: dict, network_scale_level: int = 0, annualization_factor: float = 1, capex_factor: dict = None, cost_dynamics: Costdynamics = Costdynamics.constant) -> Constraint:
+def constraint_process_capex(instance: ConcreteModel, capex_dict: dict, network_scale_level: int = 0, annualization_factor: float = 1, capex_factor: dict = None, cost_dynamics: Costdynamics = Costdynamics.constant, loc_pro_dict: dict = None) -> Constraint:
     """Capital expenditure for each process at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         capex_dict (dict): capex at location
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
         annualization_factor (float, optional): Annual depreciation of asset. Defaults to 1.
@@ -143,34 +145,36 @@
         Constraint: process_capex
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
 
     def process_capex_rule(instance, location, process, *scale_list):
         if capex_dict[process] is not None:
             if capex_factor[location] is not None:
-                return instance.Capex_process[location, process, scale_list] == annualization_factor*capex_factor[location][process][scale_list]*capex_dict[process]*instance.Cap_P[location, process, scale_list]
+                if process in list(capex_factor[location].keys()):
+                    return instance.Capex_process[location, process, scale_list] == annualization_factor*capex_factor[location][process][scale_list]*capex_dict[process]*instance.Cap_P[location, process, scale_list]
+                else:
+                    return instance.Capex_process[location, process, scale_list] == annualization_factor*capex_dict[process]*instance.Cap_P[location, process, scale_list]
             else:
                 return instance.Capex_process[location, process, scale_list] == annualization_factor*capex_dict[process]*instance.Cap_P[location, process, scale_list]
         else:
             return instance.Capex_process[location, process, scale_list] == 0
     instance.constraint_process_capex = Constraint(
         instance.locations, instance.processes, *scales, rule=process_capex_rule, doc='total purchase from network')
 
     constraint_latex_render(process_capex_rule)
     return instance.constraint_process_capex
 
 
-def constraint_process_incidental(instance: ConcreteModel, incidental_dict: dict, network_scale_level: int = 0, annualization_factor: float = 1, cost_dynamics: Costdynamics = Costdynamics.constant) -> Constraint:
+def constraint_process_incidental(instance: ConcreteModel, incidental_dict: dict, network_scale_level: int = 0, cost_dynamics: Costdynamics = Costdynamics.constant, loc_pro_dict: dict = None) -> Constraint:
     """Capital expenditure for each process at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         capex_dict (dict): capex at location
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
-        annualization_factor (float, optional): Annual depreciation of asset. Defaults to 1.
 
     Returns:
         Constraint: process_capex
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
 
     def process_incidental_rule(instance, location, process, *scale_list):
@@ -181,15 +185,15 @@
     instance.constraint_process_incidental = Constraint(
         instance.locations, instance.processes, *scales, rule=process_incidental_rule, doc='total incidental costs from processes')
 
     constraint_latex_render(process_incidental_rule)
     return instance.constraint_process_incidental
 
 
-def constraint_process_fopex(instance: ConcreteModel, fopex_dict: dict, network_scale_level: int = 0, fopex_factor: dict = None, annualization_factor: float = 1) -> Constraint:
+def constraint_process_fopex(instance: ConcreteModel, fopex_dict: dict, network_scale_level: int = 0, fopex_factor: dict = None, annualization_factor: float = 1, loc_pro_dict: dict = None) -> Constraint:
     """Fixed operational expenditure for each process at location in network
     Args:
         instance (ConcreteModel): pyomo instance
         fopex_dict (dict): fixed opex at location
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
         annualization_factor (float, optional): Annual depreciation of asset. Defaults to 1.
 
@@ -208,15 +212,15 @@
             return instance.Fopex_process[location, process, scale_list] == 0
     instance.constraint_process_fopex = Constraint(
         instance.locations, instance.processes, *scales, rule=process_fopex_rule, doc='total purchase from network')
     constraint_latex_render(process_fopex_rule)
     return instance.constraint_process_fopex
 
 
-def constraint_process_vopex(instance: ConcreteModel, vopex_dict: dict, network_scale_level: int = 0, vopex_factor: dict = None) -> Constraint:
+def constraint_process_vopex(instance: ConcreteModel, vopex_dict: dict, network_scale_level: int = 0, vopex_factor: dict = None, loc_pro_dict: dict = None) -> Constraint:
     """Fixed operational expenditure for each process at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
@@ -398,67 +402,115 @@
         return instance.Fopex_network[scale_list] == sum(instance.Fopex_location[location_, scale_list] for location_ in instance.locations)
     instance.constraint_network_fopex = Constraint(
         *scales, rule=network_fopex_rule, doc='total purchase from network')
     constraint_latex_render(network_fopex_rule)
     return instance.constraint_network_fopex
 
 
-def constraint_process_land_cost(instance: ConcreteModel, land_dict: dict, land_cost_dict: dict, network_scale_level: int = 0) -> Constraint:
+def constraint_land_process_cost(instance: ConcreteModel, land_dict: dict, land_cost_dict: dict, network_scale_level: int = 0) -> Constraint:
     """Land cost for each process at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         land_dict (dict): land required at location
         land_cost_dict (dict): land cost at location
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: process_land
+        Constraint: land_process
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
 
-    def process_land_cost_rule(instance, location, process, *scale_list):
+    def land_process_cost_rule(instance, location, process, *scale_list):
         return instance.Land_cost_process[location, process, scale_list] == land_cost_dict[location]*land_dict[process]*instance.Cap_P[location, process, scale_list]
-    instance.constraint_process_land_cost = Constraint(
-        instance.locations, instance.processes, *scales, rule=process_land_cost_rule, doc='land cost for process at location')
-    constraint_latex_render(process_land_cost_rule)
-    return instance.constraint_process_land_cost
+    instance.constraint_land_process_cost = Constraint(
+        instance.locations, instance.processes, *scales, rule=land_process_cost_rule, doc='land cost for process at location')
+    constraint_latex_render(land_process_cost_rule)
+    return instance.constraint_land_process_cost
 
 
-def constraint_location_land_cost(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
+def constraint_land_location_cost(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
     """Land cost each location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: location_land_cost
+        Constraint: land_location_cost
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
 
-    def location_land_cost_rule(instance, location, *scale_list):
+    def land_location_cost_rule(instance, location, *scale_list):
         return instance.Land_cost_location[location, scale_list] == sum(instance.Land_cost_process[location, process_, scale_list] for process_ in instance.processes)
-    instance.constraint_location_land_cost = Constraint(
-        instance.locations, *scales, rule=location_land_cost_rule, doc='land cost at location')
-    constraint_latex_render(location_land_cost_rule)
-    return instance.constraint_location_land_cost
+    instance.constraint_land_location_cost = Constraint(
+        instance.locations, *scales, rule=land_location_cost_rule, doc='land cost at location')
+    constraint_latex_render(land_location_cost_rule)
+    return instance.constraint_land_location_cost
 
 
-def constraint_network_land_cost(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
+def constraint_land_network_cost(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
     """Land cost by network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: network_land_cost
+        Constraint: land_network_cost
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
 
-    def network_land_cost_rule(instance, *scale_list):
+    def land_network_cost_rule(instance, *scale_list):
         return instance.Land_cost_network[scale_list] == sum(instance.Land_cost_location[location_, scale_list] for location_ in instance.locations)
-    instance.constraint_network_land_cost = Constraint(
-        *scales, rule=network_land_cost_rule, doc='land cost for process')
-    constraint_latex_render(network_land_cost_rule)
-    return instance.constraint_network_land_cost
+    instance.constraint_land_network_cost = Constraint(
+        *scales, rule=land_network_cost_rule, doc='land cost for process')
+    constraint_latex_render(land_network_cost_rule)
+    return instance.constraint_land_network_cost
+
+
+def constraint_network_cost(instance: ConcreteModel, constraints=Set[Constraints], network_scale_level: int = 0) -> Constraint:
+    """Total network costs
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Constraint: total network cost
+    """
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=network_scale_level + 1)
+
+    def constraint_network_cost_rule(instance):
+        capex = sum(instance.Capex_network[scale_] for scale_ in scale_iter)
+        vopex = sum(instance.Vopex_network[scale_] for scale_ in scale_iter)
+        fopex = sum(instance.Fopex_network[scale_] for scale_ in scale_iter)
+        incidental = sum(
+            instance.Incidental_network[scale_] for scale_ in scale_iter)
+
+        cost_purch = sum(instance.B_network[resource_, scale_] for resource_, scale_ in
+                         product(instance.resources_purch, scale_iter))
+
+        if Constraints.LAND in constraints:
+            land_cost = sum(
+                instance.Land_cost_network[scale_] for scale_ in scale_iter)
+        else:
+            land_cost = 0
+
+        if Constraints.CREDIT in constraints:
+            credit = sum(
+                instance.Credit_network[scale_] for scale_ in scale_iter)
+        else:
+            credit = 0
+
+        if len(instance.locations) > 1:
+            cost_trans = sum(instance.Trans_cost_network[transport_, scale_] for transport_, scale_ in
+                             product(instance.transports, scale_iter))
+        else:
+            cost_trans = 0
+        return instance.Cost == capex + vopex + fopex + cost_purch + cost_trans + incidental + land_cost + credit
+
+    instance.constraint_network_cost = Constraint(
+        rule=constraint_network_cost_rule, doc='total network cost')
+    constraint_latex_render(constraint_network_cost_rule)
+    return instance.constraint_network_cost
```

## energiapy/model/constraints/emission.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo emission constraints
+"""emission constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -91,15 +91,15 @@
 
     Returns:
         Constraint: global_warming_potential_material
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
 
     def global_warming_potential_material_rule(instance, location, process,  *scale_list):
-        return instance.global_warming_potential_material[location, process, scale_list] == sum(process_material_dict[process][material]*material_gwp_dict[location][material] for material in process_material_dict[process].keys()) * instance.Cap_P[location, process, scale_list]
+        return instance.global_warming_potential_material[location, process, scale_list] == sum(process_material_dict[process][material]*material_gwp_dict[location][material] for material in instance.materials) * instance.Cap_P[location, process, scale_list]
     instance.constraint_global_warming_potential_material = Constraint(
         instance.locations, instance.processes_materials, *scales, rule=global_warming_potential_material_rule, doc='global warming potential for the each material')
     constraint_latex_render(global_warming_potential_material_rule)
     return instance.constraint_global_warming_potential_material
 
 
 def constraint_global_warming_potential_resource(instance: ConcreteModel, resource_gwp_dict: dict, network_scale_level: int = 0) -> Constraint:
@@ -188,7 +188,28 @@
 
     def global_warming_potential_network_reduction_rule(instance, *scale_list):
         return instance.global_warming_potential_network[scale_list] <= gwp*(1 - gwp_reduction_pct/100)
     instance.constraint_global_warming_potential_network_reduction = Constraint(
         *scales, rule=global_warming_potential_network_reduction_rule, doc='global warming potential for the whole network')
     constraint_latex_render(global_warming_potential_network_reduction_rule)
     return instance.constraint_global_warming_potential_network_reduction
+
+
+def constraint_global_warming_potential_network_bound(instance: ConcreteModel, gwp_bound: float, network_scale_level: int = 0) -> Constraint:
+    """Required bound in global warming potential at network level
+
+    Args:
+        instance (ConcreteModel): pyomo model instance
+        network_scale_level (int, optional): scale for network decisions. Defaults to 0.
+        gwp_bound_pct (float, optional): GWP bound required. Defaults to 0.
+        gwp (float, optional): Base Case (Current) GWP. Defaults to 0.
+
+    Returns:
+        Constraint: global_warming_potential_network_bound
+    """
+    scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
+
+    def global_warming_potential_network_bound_rule(instance, *scale_list):
+        return instance.global_warming_potential_network[scale_list] <= gwp_bound
+    constraint_latex_render(global_warming_potential_network_bound_rule)
+    return Constraint(
+        *scales, rule=global_warming_potential_network_bound_rule, doc='global warming potential bound for the whole network')
```

## energiapy/model/constraints/failure.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo failure constraints
+"""failure constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -31,21 +31,19 @@
         Constraint: nameplate_production_failure
     """
 
     if fail_factor is None:
         fail_factor = dict()
 
     scales = scale_list(instance=instance,
-                        scale_levels=instance.scales.__len__())
+                        scale_levels=len(instance.scales))
 
     def nameplate_production_failure_rule(instance, location, process, *scale_list):
         if process in instance.processes_failure:
-            return instance.P[location, process, scale_list[:scheduling_scale_level+1]] <= \
-                fail_factor[location][process][scale_list[:scheduling_scale_level+1]] * \
-                instance.Cap_P[location, process,
-                               scale_list[:network_scale_level+1]]
+            return instance.P[location, process, scale_list[:scheduling_scale_level+1]] <= fail_factor[location][process][scale_list[:scheduling_scale_level+1]] * instance.Cap_P[location, process,
+                                                                                                                                                                                  scale_list[:network_scale_level+1]]
         else:
             return instance.P[location, process, scale_list[:scheduling_scale_level+1]] <= instance.Cap_P[location, process, scale_list[:network_scale_level+1]]
     instance.constraint_nameplate_production_failure = Constraint(
         instance.locations, instance.processes, *scales, rule=nameplate_production_failure_rule, doc='nameplate production capacity constraint')
     constraint_latex_render(nameplate_production_failure_rule)
     return instance.constraint_nameplate_production_failure
```

## energiapy/model/constraints/integer_cuts.py

```diff
@@ -1,42 +1,85 @@
-"""pyomo integer cuts
+"""integer cuts
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "Open"
 __version__ = "0.0.1"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
-# from pyomo.environ import ConcreteModel, Constraint
-# from ...utils.latex_utils import constraint_latex_render
-# from ...utils.scale_utils import scale_list
-# from ...utils.scale_utils import scale_pyomo_set
-# from ...utils.scale_utils import scale_tuple
-# from ...components.location import Location
-# from itertools import product
-# from typing import Union
-# from enum import Enum, auto
-
-
-# def constraint_block_integer_cut(instance: ConcreteModel, network_scale_level: int, location: Location, block: 'str', number:int = 1) -> Constraint:
-#     """Ensures atleast n components in block are set
-
-#     Args:
-#         instance (ConcreteModel): pyomo instance
-#         block (str): block over which to apply constraint
-#     Returns:
-#         Constraint: block_integer_cut
-#     """
-#     scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
-
-#     def block_integer_cut_rule(instance, location, *scale_list):
-#         return sum(instance.X_P[location, i, scale_list] for i in process_set) == number
-#     instance.constraint_block_integer_cut = Constraint(
-#         instance.locations, *scales, rule=block_integer_cut_rule, doc='block integer cut')
-#     constraint_latex_render(block_integer_cut_rule)
-#     return instance.constraint_block_integer_cut
+from pyomo.environ import ConcreteModel, Constraint
+from ...utils.latex_utils import constraint_latex_render
+from ...utils.scale_utils import scale_list
+from ...components.location import Location
+
+
+def constraint_block_integer_cut_max(instance: ConcreteModel, network_scale_level: int, location: Location, block: 'str', process_set: set, number: int = 1) -> Constraint:
+    """maximum number of processes from a block that can be set up at a location
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int): scale for network level decisions 
+        location (Location): location at which to impose integer cut
+        block (str): process block over which to apply integer cuts
+        process_set (set): set of all processes in scenario
+        number (int, optional): maximum number of process in block allowed. Defaults to 1.
+
+    Returns:
+        Constraint: block_integer_cut_max
+    """
+    scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
+
+    def block_integer_cut_max_rule(instance, *scale_list):
+        return sum(instance.X_P[location.name, i.name, scale_list] for i in process_set if i.block == block) <= number
+    constraint_latex_render(block_integer_cut_max_rule)
+
+    return Constraint(scales, rule=block_integer_cut_max_rule, doc=f'block integer cut for {block}')
+
+
+def constraint_block_integer_cut_min(instance: ConcreteModel, network_scale_level: int, location: Location, block: 'str', process_set: set, number: int = 1) -> Constraint:
+    """minimum number of processes from a block that can be set up at a location
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int): scale for network level decisions 
+        location (Location): location at which to impose integer cut
+        block (str): process block over which to apply integer cuts
+        process_set (set): set of all processes in scenario
+        number (int, optional): minimum number of process in block allowed. Defaults to 1.
+
+    Returns:
+        Constraint: block_integer_cut_min
+    """
+    scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
+
+    def block_integer_cut_min_rule(instance, *scale_list):
+        return sum(instance.X_P[location.name, i.name, scale_list] for i in process_set if i.block == block) >= number
+    constraint_latex_render(block_integer_cut_min_rule)
+
+    return Constraint(scales, rule=block_integer_cut_min_rule, doc=f'block integer cut for {block}')
+
+
+def constraint_block_integer_cut(instance: ConcreteModel, network_scale_level: int, location: Location, block: 'str', process_set: set, number: int = 1) -> Constraint:
+    """exact number of processes from a block to be set up at a location
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int): scale for network level decisions 
+        location (Location): location at which to impose integer cut
+        block (str): process block over which to apply integer cuts
+        process_set (set): set of all processes in scenario
+        number (int, optional): number of process in block to be established. Defaults to 1.
+
+    Returns:
+        Constraint: block_integer_cut
+    """
+    scales = scale_list(instance=instance, scale_levels=network_scale_level+1)
+
+    def block_integer_cut_rule(instance, *scale_list):
+        return sum(instance.X_P[location.name, i.name, scale_list] for i in process_set if i.block == block) == number
+    constraint_latex_render(block_integer_cut_rule)
 
-# TODO make integer cuts file separate from formulate
+    return Constraint(scales, rule=block_integer_cut_rule, doc=f'block integer cut for {block}')
```

## energiapy/model/constraints/inventory.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo inventory constraints
+"""inventory constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -12,50 +12,14 @@
 
 from pyomo.environ import ConcreteModel, Constraint
 
 from ...utils.latex_utils import constraint_latex_render
 from ...utils.scale_utils import scale_list
 
 
-def constraint_storage_facility(instance: ConcreteModel, store_max: dict, loc_res_dict: dict = None,
-                                network_scale_level: int = 0) -> Constraint:
-    """Determines where storage facility of certain capacity is inserted at location in network
-
-    Args:
-        instance (ConcreteModel): pyomo instance
-        store_max (dict): maximum storage capacity of resource at location
-        loc_res_dict (dict, optional): storage facilities for resource available at location. Defaults to {}.
-        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
-
-    Returns:
-        Constraint: storage_facility
-    """
-
-    if loc_res_dict is None:
-        loc_res_dict = dict()
-
-    scales = scale_list(instance=instance,
-                        scale_levels=network_scale_level + 1)
-
-    def storage_facility_rule(instance, location, resource, *scale_list):
-        if resource in loc_res_dict[location]:
-            return instance.Cap_S[location, resource, scale_list[:network_scale_level + 1]] <= store_max[location][
-                resource] * \
-                instance.X_S[location, resource,
-                scale_list[:network_scale_level + 1]]
-        else:
-            return instance.Cap_S[location, resource, scale_list[:network_scale_level + 1]] == 0
-
-    instance.constraint_storage_facility = Constraint(
-        instance.locations, instance.resources_store, *scales, rule=storage_facility_rule,
-        doc='storage facility sizing and location')
-    constraint_latex_render(storage_facility_rule)
-    return instance.constraint_storage_facility
-
-
 def constraint_storage_facility_affix(instance: ConcreteModel, affix_storage_cap: dict, loc_res_dict: dict = None,
                                       network_scale_level: int = 0) -> Constraint:
     """Determines where storage facility of certain capacity is inserted at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         store_max (dict): maximum storage capacity of resource at location
@@ -122,49 +86,47 @@
     instance.constraint_storage_facility_fix = Constraint(
         instance.locations, instance.resources_store, *scales, rule=storage_facility_fix_rule,
         doc='storage facility sizing and location')
     constraint_latex_render(storage_facility_fix_rule)
     return instance.constraint_storage_facility_fix
 
 
-def constraint_min_storage_facility(instance: ConcreteModel, store_min: dict, loc_res_dict: dict = None,
+def constraint_storage_min(instance: ConcreteModel, store_min: dict, loc_res_dict: dict = None,
                                     network_scale_level: int = 0) -> Constraint:
-    """Determines where storage facility of certain capacity is inserted at location in network
+    """Restricits storage capacity to minimum (store_min)
 
     Args:
         instance (ConcreteModel): pyomo instance
         store_max (dict): maximum storage capacity of resource at location
         loc_res_dict (dict, optional): storage facilities for resource available at location. Defaults to {}.
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
 
     Returns:
-        Constraint: min_storage_facility
+        Constraint: storage_min
     """
 
     if loc_res_dict is None:
         loc_res_dict = dict()
 
     scales = scale_list(instance=instance,
                         scale_levels=network_scale_level + 1)
 
-    def min_storage_facility_rule(instance, location, resource, *scale_list):
+    def storage_min_rule(instance, location, resource, *scale_list):
         if resource in loc_res_dict[location]:
             return instance.Cap_S[location, resource, scale_list[:network_scale_level + 1]] >= store_min[location][
-                resource] * \
-                instance.X_S[location, resource,
-                scale_list[:network_scale_level + 1]]
+                resource]
         else:
             return Constraint.Skip
 
-    instance.constraint_min_storage_facility = Constraint(
-        instance.locations, instance.resources_store, *scales, rule=min_storage_facility_rule,
-        doc='storage facility sizing and location')
-    constraint_latex_render(min_storage_facility_rule)
-    return instance.constraint_min_storage_facility
+    instance.constraint_storage_min = Constraint(
+        instance.locations, instance.resources_store, *scales, rule=storage_min_rule,
+        doc='storage facility sizing-min')
+    constraint_latex_render(storage_min_rule)
+    return instance.constraint_storage_min
 
 
 def constraint_nameplate_inventory(instance: ConcreteModel, loc_res_dict: dict = None, network_scale_level: int = 0,
                                    scheduling_scale_level: int = 0) -> Constraint:
     """Determines storage capacity utilization for resource at location in network and capacity of facilities
 
     Args:
@@ -191,7 +153,41 @@
             return instance.Inv[location, resource, scale_list[:scheduling_scale_level + 1]] <= 0
 
     instance.constraint_nameplate_inventory = Constraint(
         instance.locations, instance.resources_store, *scales, rule=nameplate_inventory_rule,
         doc='nameplate inventory capacity constraint')
     constraint_latex_render(nameplate_inventory_rule)
     return instance.constraint_nameplate_inventory
+
+
+def constraint_storage_max(instance: ConcreteModel, store_max: dict, loc_res_dict: dict = None,
+                                network_scale_level: int = 0) -> Constraint:
+    """Determines where storage facility of certain capacity is inserted at location in network
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        store_max (dict): maximum storage capacity of resource at location
+        loc_res_dict (dict, optional): storage facilities for resource available at location. Defaults to {}.
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Constraint: storage_max
+    """
+
+    if loc_res_dict is None:
+        loc_res_dict = dict()
+
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
+
+    def storage_max_rule(instance, location, resource, *scale_list):
+        if resource in loc_res_dict[location]:
+            return instance.Cap_S[location, resource, scale_list[:network_scale_level + 1]] <= store_max[location][
+                resource]
+        else:
+            return instance.Cap_S[location, resource, scale_list[:network_scale_level + 1]] == 0
+
+    instance.constraint_storage_max = Constraint(
+        instance.locations, instance.resources_store, *scales, rule=storage_max_rule,
+        doc='storage facility sizing')
+    constraint_latex_render(storage_max_rule)
+    return instance.constraint_storage_max
```

## energiapy/model/constraints/land.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo land constraints
+"""land constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -12,94 +12,94 @@
 
 from pyomo.environ import ConcreteModel, Constraint
 
 from ...utils.latex_utils import constraint_latex_render
 from ...utils.scale_utils import scale_list
 
 
-def constraint_process_land(instance: ConcreteModel, land_dict: dict, network_scale_level: int = 0) -> Constraint:
+def constraint_land_process(instance: ConcreteModel, land_dict: dict, network_scale_level: int = 0) -> Constraint:
     """Land required for each process at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         land_dict (dict): land required at location
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: process_land
+        Constraint: land_process
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
 
-    def process_land_rule(instance, location, process, *scale_list):
+    def land_process_rule(instance, location, process, *scale_list):
         return instance.Land_process[location, process, scale_list] == land_dict[process] * instance.Cap_P[
             location, process, scale_list]
 
-    instance.constraint_process_land = Constraint(
-        instance.locations, instance.processes, *scales, rule=process_land_rule, doc='land required for process')
-    constraint_latex_render(process_land_rule)
-    return instance.constraint_process_land
+    instance.constraint_land_process = Constraint(
+        instance.locations, instance.processes, *scales, rule=land_process_rule, doc='land required for process')
+    constraint_latex_render(land_process_rule)
+    return instance.constraint_land_process
 
 
-def constraint_location_land(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
+def constraint_land_location(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
     """Land required at each location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: location_land
+        Constraint: land_location
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
 
-    def location_land_rule(instance, location, *scale_list):
+    def land_location_rule(instance, location, *scale_list):
         return instance.Land_location[location, scale_list] == sum(
             instance.Land_process[location, process_, scale_list] for process_ in instance.processes)
 
-    instance.constraint_location_land = Constraint(
-        instance.locations, *scales, rule=location_land_rule, doc='land required for process')
-    constraint_latex_render(location_land_rule)
-    return instance.constraint_location_land
+    instance.constraint_land_location = Constraint(
+        instance.locations, *scales, rule=land_location_rule, doc='land required for process')
+    constraint_latex_render(land_location_rule)
+    return instance.constraint_land_location
 
 
-def constraint_network_land(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
+def constraint_land_network(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
     """Land required by network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: network_land
+        Constraint: land_network
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
 
-    def network_land_rule(instance, *scale_list):
+    def land_network_rule(instance, *scale_list):
         return instance.Land_network[scale_list] == sum(
             instance.Land_location[location_, scale_list] for location_ in instance.locations)
 
-    instance.constraint_network_land = Constraint(
-        *scales, rule=network_land_rule, doc='land required for process')
-    constraint_latex_render(network_land_rule)
-    return instance.constraint_network_land
+    instance.constraint_land_network = Constraint(
+        *scales, rule=land_network_rule, doc='land required for process')
+    constraint_latex_render(land_network_rule)
+    return instance.constraint_land_network
 
 
-def constraint_location_land_restriction(instance: ConcreteModel, network_scale_level: int = 0,
+def constraint_land_location_restriction(instance: ConcreteModel, network_scale_level: int = 0,
                                          land_restriction: float = 0) -> Constraint:
     """Land required at each location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
-        Constraint: location_land
+        Constraint: land_location
     """
     scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
 
-    def location_land_restriction_rule(instance, location, *scale_list):
+    def land_location_restriction_rule(instance, location, *scale_list):
         return instance.Land_location[location, scale_list] <= land_restriction
 
-    instance.constraint_location_land_restriction = Constraint(
-        instance.locations, *scales, rule=location_land_restriction_rule, doc='land required for process')
-    constraint_latex_render(location_land_restriction_rule)
-    return instance.constraint_location_land_restriction
+    instance.constraint_land_location_restriction = Constraint(
+        instance.locations, *scales, rule=land_location_restriction_rule, doc='land required for process')
+    constraint_latex_render(land_location_restriction_rule)
+    return instance.constraint_land_location_restriction
```

## energiapy/model/constraints/lifecyle.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo life cycle constraints
+"""life cycle constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Swaminathan Sundar", "Efstratios N. Pistikopoulos"]
 __license__ = "Open"
 __version__ = "0.0.1"
```

## energiapy/model/constraints/mode.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo production constraints
+"""production mode constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -62,30 +62,69 @@
 
     scales = scale_list(instance=instance,
                         scale_levels=scheduling_scale_level + 1)
 
     def production_mode_facility_rule(instance, location, process, mode, *scale_list):
         if process in loc_pro_dict[location]:
             if mode <= list(prod_max[location][process].keys())[-1:][0]:
-                return instance.Cap_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] <= \
-                    prod_max[location][process][mode] * \
-                    instance.X_P_m[location, process, mode,
-                    scale_list[:scheduling_scale_level + 1]]
-
-            return Constraint.Skip
-
-        return instance.Cap_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] == 0
+                return instance.Cap_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] <= prod_max[location][process][mode] * instance.X_P_m[location, process, mode,
+                                                                                                                                                                scale_list[:scheduling_scale_level + 1]]
+            else:
+                return Constraint.Skip
+        else:
+            return instance.Cap_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] == 0
 
     instance.constraint_production_mode_facility = Constraint(
-        instance.locations, instance.processes, instance.modes, *scales, rule=production_mode_facility_rule,
+        instance.locations, instance.processes, instance.modes, *
+        scales, rule=production_mode_facility_rule,
         doc='production facility sizing and location')
     constraint_latex_render(production_mode_facility_rule)
     return instance.constraint_production_mode_facility
 
 
+
+def constraint_min_production_mode_facility(instance: ConcreteModel, prod_min: dict, loc_pro_dict: dict = None,
+                                        scheduling_scale_level: int = 0) -> Constraint:
+    """Determines where production facility of certain capacity is mode for process at location in schedule
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        prod_min (dict): minimum production of process at location
+        loc_pro_dict (dict, optional): production facilities avaiable at location. Defaults to {}.
+        scheduling_scale_level (int, optional): scale of scheduling decisions. Defaults to 0.
+
+    Returns:
+        Constraint: production_facility_mode
+    """
+
+    if loc_pro_dict is None:
+        loc_pro_dict = dict()
+
+    scales = scale_list(instance=instance,
+                        scale_levels=scheduling_scale_level + 1)
+
+    def min_production_mode_facility_rule(instance, location, process, mode, *scale_list):
+        if process in loc_pro_dict[location]:
+            if mode <= list(prod_min[location][process].keys())[-1:][0]:
+                return instance.Cap_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] >= prod_min[location][process][mode] * instance.X_P_m[location, process, mode,
+                                                                                                                                                                scale_list[:scheduling_scale_level + 1]]
+            else:
+                return Constraint.Skip
+        else:
+            return instance.Cap_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] == 0
+
+    instance.constraint_min_production_mode_facility = Constraint(
+        instance.locations, instance.processes, instance.modes, *
+        scales, rule=min_production_mode_facility_rule,
+        doc='production facility sizing and location')
+    constraint_latex_render(min_production_mode_facility_rule)
+    return instance.constraint_min_production_mode_facility
+
+
+
 def constraint_production_mode_binary(instance: ConcreteModel, mode_dict: dict, scheduling_scale_level: int = 0,
                                       network_scale_level: int = 0) -> Constraint:
     """The sum of production through all modes equals production at scheduling scale
 
     Args:
         instance (ConcreteModel): pyomo model instance
         mode_dict (dict): dictionary with modes available for process
@@ -101,11 +140,12 @@
 
     def production_mode_binary_rule(instance, location, process, *scale_list):
         return instance.X_P[location, process, scale_list[:network_scale_level + 1]] == sum(
             instance.X_P_m[location, process, mode, scale_list[:scheduling_scale_level + 1]] for mode in
             mode_dict[process])
 
     instance.constraint_production_mode_binary = Constraint(
-        instance.locations, instance.processes, *scales, rule=production_mode_binary_rule,
+        instance.locations, instance.processes, *
+        scales, rule=production_mode_binary_rule,
         doc='production mode binary sum constraint')
     constraint_latex_render(production_mode_binary_rule)
     return instance.constraint_production_mode_binary
```

## energiapy/model/constraints/production.py

```diff
@@ -1,59 +1,25 @@
-"""pyomo production constraints
+"""production constraints
 """
 
 __author__ = "Rahul Kakodkar"
-__copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
+__copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from pyomo.environ import ConcreteModel, Constraint
 
 from ...utils.latex_utils import constraint_latex_render
 from ...utils.scale_utils import scale_list
 
 
-def constraint_production_facility(instance: ConcreteModel, prod_max: dict, loc_pro_dict: dict = None,
-                                   network_scale_level: int = 0) -> Constraint:
-    """Determines where production facility of certain capacity is inserted at location in network
-
-    Args:
-        instance (ConcreteModel): pyomo instance
-        prod_max (dict): maximum production of process at location
-        loc_pro_dict (dict, optional): production facilities avaiable at location. Defaults to {}.
-        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
-
-    Returns:
-        Constraint: production_facility
-    """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
-
-    def production_facility_rule(instance, location, process, *scale_list):
-        if loc_pro_dict is not None:
-            if process in loc_pro_dict[location]:
-                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] <= \
-                    prod_max[location][process][list(prod_max[location][process].keys())[-1:][0]] * \
-                    instance.X_P[location, process,
-                    scale_list[:network_scale_level + 1]]
-            else:
-                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == 0
-        else:
-            return Constraint.Skip
-
-    instance.constraint_production_facility = Constraint(
-        instance.locations, instance.processes, *scales, rule=production_facility_rule,
-        doc='production facility sizing and location')
-    constraint_latex_render(production_facility_rule)
-    return instance.constraint_production_facility
-
-
 def constraint_production_facility_affix(instance: ConcreteModel, affix_production_cap: dict, loc_pro_dict: dict = None,
                                          network_scale_level: int = 0) -> Constraint:
     """affixes the capacity of production facilities
 
     Args:
         instance (ConcreteModel): pyomo instance
         prod_max (dict): maximum production of process at location
@@ -63,28 +29,29 @@
     Returns:
         Constraint: production_facility_affix
     """
 
     if loc_pro_dict is None:
         loc_pro_dict = dict()
 
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
     def production_facility_affix_rule(instance, location, process, *scale_list):
         if process in loc_pro_dict[location]:
             if affix_production_cap[location, process, scale_list[:network_scale_level + 1][0]] > 0.0:
-                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] \
-                    == affix_production_cap[location, process, scale_list[:network_scale_level + 1][0]]
+                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == affix_production_cap[location, process, scale_list[:network_scale_level + 1][0]]
             else:
                 return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] >= 0.0
         else:
             return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == 0
 
     instance.constraint_production_facility_affix = Constraint(
-        instance.locations, instance.processes, *scales, rule=production_facility_affix_rule,
+        instance.locations, instance.processes, *
+        scales, rule=production_facility_affix_rule,
         doc='production facility sizing and location')
     constraint_latex_render(production_facility_affix_rule)
     return instance.constraint_production_facility_affix
 
 
 def constraint_production_facility_fix(instance: ConcreteModel, prod_max: dict, production_binaries: dict,
                                        loc_pro_dict: dict = None, network_scale_level: int = 0) -> Constraint:
@@ -99,104 +66,140 @@
     Returns:
         Constraint: production_facility_fix
     """
 
     if loc_pro_dict is None:
         loc_pro_dict = dict()
 
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
     def production_facility_fix_rule(instance, location, process, *scale_list):
         if process in loc_pro_dict[location]:
             return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] <= prod_max[location][
                 process] * \
                 production_binaries[(
                     location, process, *scale_list[:network_scale_level + 1])]
-
-        return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == 0
+        else:
+            return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == 0
 
     instance.constraint_production_facility_fix = Constraint(
-        instance.locations, instance.processes, *scales, rule=production_facility_fix_rule,
+        instance.locations, instance.processes, *
+        scales, rule=production_facility_fix_rule,
         doc='production facility sizing and location')
     constraint_latex_render(production_facility_fix_rule)
     return instance.constraint_production_facility_fix
 
 
-def constraint_min_production_facility(instance: ConcreteModel, prod_min: dict, loc_pro_dict: dict = None,
-                                       network_scale_level: int = 0) -> Constraint:
-    """Determines where production facility of certain capacity is inserted at location in network
+def constraint_nameplate_production(instance: ConcreteModel, capacity_factor: dict = None, loc_pro_dict: dict = None,
+                                    network_scale_level: int = 0, scheduling_scale_level: int = 0) -> Constraint:
+    """Determines production capacity utilization of facilities at location in network and capacity of facilities
 
     Args:
         instance (ConcreteModel): pyomo instance
-        prod_max (dict): maximum production of process at location
+        capacity_factor (dict, optional): uncertain capacity availability training data. Defaults to {}.
         loc_pro_dict (dict, optional): production facilities avaiable at location. Defaults to {}.
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+        scheduling_scale_level (int, optional): scale of scheduling decisions. Defaults to 0.
 
     Returns:
-        Constraint: min_production_facility
+        Constraint: nameplate_production
     """
 
+    if capacity_factor is None:
+        capacity_factor = dict()
+
     if loc_pro_dict is None:
         loc_pro_dict = dict()
 
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=len(instance.scales))
 
-    def min_production_facility_rule(instance, location, process, *scale_list):
+    def nameplate_production_rule(instance, location, process, *scale_list):
 
         if process not in loc_pro_dict[location]:
-            return Constraint.Skip
+            return instance.P[location, process, scale_list[:scheduling_scale_level + 1]] == 0
 
-        return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] >= prod_min[location][
-            process] * \
-            instance.X_P[location, process,
-            scale_list[:network_scale_level + 1]]
+        else:
+            if process not in instance.processes_varying_capacity:
+                return instance.P[location, process, scale_list[:scheduling_scale_level + 1]] <= instance.Cap_P[
+                    location, process, scale_list[:network_scale_level + 1]]
+            else:
+                return instance.P[location, process, scale_list[:scheduling_scale_level + 1]] <= capacity_factor[location][process][scale_list[:scheduling_scale_level + 1]] * instance.Cap_P[location, process,
+                                                                                                                                                                                              scale_list[:network_scale_level + 1]]
 
-    instance.constraint_min_production_facility = Constraint(
-        instance.locations, instance.processes, *scales, rule=min_production_facility_rule,
-        doc='production facility sizing and location')
-    constraint_latex_render(min_production_facility_rule)
-    return instance.constraint_min_production_facility
+    instance.constraint_nameplate_production = Constraint(
+        instance.locations, instance.processes, *
+        scales, rule=nameplate_production_rule,
+        doc='nameplate production capacity constraint')
+    constraint_latex_render(nameplate_production_rule)
+    return instance.constraint_nameplate_production
 
 
-def constraint_nameplate_production(instance: ConcreteModel, capacity_factor: dict = None, loc_pro_dict: dict = None,
-                                    network_scale_level: int = 0, scheduling_scale_level: int = 0) -> Constraint:
-    """Determines production capacity utilization of facilities at location in network and capacity of facilities
+def constraint_production_max(instance: ConcreteModel, prod_max: dict, loc_pro_dict: dict = None,
+                              network_scale_level: int = 0) -> Constraint:
+    """Restricts maximum capacity realized to cap_max, binary network constraints can override
 
     Args:
         instance (ConcreteModel): pyomo instance
-        capacity_factor (dict, optional): uncertain capacity availability training data. Defaults to {}.
+        prod_max (dict): maximum production of process at location
         loc_pro_dict (dict, optional): production facilities avaiable at location. Defaults to {}.
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
-        scheduling_scale_level (int, optional): scale of scheduling decisions. Defaults to 0.
 
     Returns:
-        Constraint: nameplate_production
+        Constraint: production_max
     """
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
-    if capacity_factor is None:
-        capacity_factor = dict()
+    def production_max_rule(instance, location, process, *scale_list):
+        if loc_pro_dict is not None:
+            if process in loc_pro_dict[location]:
+                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] <= prod_max[location][process][list(prod_max[location][process].keys())[-1:][0]]
+            else:
+                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == 0
+        else:
+            return Constraint.Skip
+
+    instance.constraint_production_max = Constraint(
+        instance.locations, instance.processes, *scales, rule=production_max_rule,
+        doc='production facility sizing')
+    constraint_latex_render(production_max_rule)
+    return instance.constraint_production_max
+
+
+def constraint_production_min(instance: ConcreteModel, prod_min: dict, loc_pro_dict: dict = None,
+                              network_scale_level: int = 0) -> Constraint:
+    """Restricts minimum capacity of production facility to prod_min
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        prod_max (dict): maximum production of process at location
+        loc_pro_dict (dict, optional): production facilities avaiable at location. Defaults to {}.
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Constraint: production_min
+    """
 
     if loc_pro_dict is None:
         loc_pro_dict = dict()
 
     scales = scale_list(instance=instance,
-                        scale_levels=instance.scales.__len__())
+                        scale_levels=network_scale_level + 1)
 
-    def nameplate_production_rule(instance, location, process, *scale_list):
+    def production_min_rule(instance, location, process, *scale_list):
 
-        if process not in loc_pro_dict[location]:
+        if loc_pro_dict is not None:
+            if process in loc_pro_dict[location]:
+                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] >= prod_min[location][process][list(prod_min[location][process].keys())[-1:][0]]
+            else:
+                return instance.Cap_P[location, process, scale_list[:network_scale_level + 1]] == 0
+        else:
             return Constraint.Skip
 
-        if process not in instance.processes_varying:
-            return instance.P[location, process, scale_list[:scheduling_scale_level + 1]] <= instance.Cap_P[
-                location, process, scale_list[:network_scale_level + 1]]
-
-        return instance.P[location, process, scale_list[:scheduling_scale_level + 1]] <= \
-            capacity_factor[location][process][scale_list[:scheduling_scale_level + 1]] * \
-            instance.Cap_P[location, process,
-            scale_list[:network_scale_level + 1]]
-
-    instance.constraint_nameplate_production = Constraint(
-        instance.locations, instance.processes, *scales, rule=nameplate_production_rule,
-        doc='nameplate production capacity constraint')
-    constraint_latex_render(nameplate_production_rule)
-    return instance.constraint_nameplate_production
+    instance.constraint_production_min = Constraint(
+        instance.locations, instance.processes, *
+        scales, rule=production_min_rule,
+        doc='production facility sizing and location')
+    constraint_latex_render(production_min_rule)
+    return instance.constraint_production_min
```

## energiapy/model/constraints/resource_balance.py

```diff
@@ -1,29 +1,31 @@
-"""pyomo resource balance constraints
+"""resource balance constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
-from typing import Union
+from typing import Union, Dict
 
 from pyomo.environ import ConcreteModel, Constraint
 
 from ...utils.latex_utils import constraint_latex_render
 from ...utils.scale_utils import scale_list, scale_tuple
+from ...components.resource import Resource
+from ...components.location import Location
 
 
 def constraint_resource_consumption(instance: ConcreteModel, loc_res_dict: dict = None, cons_max: dict = None,
-                                    scheduling_scale_level: int = 0) -> Constraint:
+                                    scheduling_scale_level: int = 0, availability_factor: dict = None) -> Constraint:
     """Determines consumption of resource at location in network
 
     Args:
         instance (ConcreteModel): pyomo instance
         loc_res_dict (dict, optional): storage facilities for resource available at location. Defaults to {}.
         cons_max (dict, optional): maximum allowed consumption of resource at location. Defaults to {}.
         scheduling_scale_level (int, optional): scale of scheduling decisions. Defaults to 0.
@@ -35,25 +37,28 @@
     if loc_res_dict is None:
         loc_res_dict = dict()
 
     if cons_max is None:
         cons_max = dict()
 
     scales = scale_list(instance=instance,
-                        scale_levels=instance.scales.__len__())
+                        scale_levels=len(instance.scales))
 
     def resource_consumption_rule(instance, location, resource, *scale_list):
         if resource in loc_res_dict[location]:
-            return instance.C[location, resource, scale_list[:scheduling_scale_level + 1]] <= cons_max[location][
-                resource]
+            if availability_factor[location] is None:
+                return instance.C[location, resource, scale_list[:scheduling_scale_level + 1]] <= cons_max[location][resource]
+            else:
+                return instance.C[location, resource, scale_list[:scheduling_scale_level + 1]] <= availability_factor[location][resource][scale_list[:scheduling_scale_level + 1]]*cons_max[location][resource]
         else:
             return instance.C[location, resource, scale_list[:scheduling_scale_level + 1]] <= 0
 
     instance.constraint_resource_consumption = Constraint(
-        instance.locations, instance.resources_purch, *scales, rule=resource_consumption_rule,
+        instance.locations, instance.resources_purch, *
+        scales, rule=resource_consumption_rule,
         doc='resource consumption')
     constraint_latex_render(resource_consumption_rule)
     return instance.constraint_resource_consumption
 
 
 def constraint_resource_purchase(instance: ConcreteModel, price_factor: dict = None, price: dict = None,
                                  loc_res_dict: dict = None, scheduling_scale_level: int = 0,
@@ -76,38 +81,78 @@
 
     if price_factor is None:
         price_factor = dict()
 
     if price is None:
         price = dict()
 
-    scales = scale_list(instance=instance,
-                        scale_levels=instance.scales.__len__())
+    scales = scale_list(instance=instance, scale_levels=len(instance.scales))
 
     def resource_purchase_rule(instance, location, resource, *scale_list):
         if resource in instance.resources_varying_price.intersection(loc_res_dict[location]):
-            return instance.B[location, resource, scale_list[:scheduling_scale_level + 1]] == price[location][
-                resource] * \
-                price_factor[location][resource][scale_list[:purchase_scale_level + 1]] * \
-                instance.C[location, resource,
-                scale_list[:scheduling_scale_level + 1]]
+            return instance.B[location, resource, scale_list[:scheduling_scale_level + 1]] == price[location][resource]*price_factor[location][resource][scale_list[:purchase_scale_level + 1]] * instance.C[location, resource, scale_list[:scheduling_scale_level + 1]]
         else:
             if resource in instance.resources_purch.intersection(loc_res_dict[location]):
                 return instance.B[location, resource, scale_list[:scheduling_scale_level + 1]] == price[location][
                     resource] * instance.C[location, resource, scale_list[:scheduling_scale_level + 1]]
             else:
                 return instance.B[location, resource, scale_list[:scheduling_scale_level + 1]] == 0
 
     instance.constraint_resource_purchase = Constraint(
-        instance.locations, instance.resources_purch, *scales, rule=resource_purchase_rule,
+        instance.locations, instance.resources_purch, *
+        scales, rule=resource_purchase_rule,
         doc='expenditure on purchase of resource')
     constraint_latex_render(resource_purchase_rule)
     return instance.constraint_resource_purchase
 
 
+def constraint_resource_revenue(instance: ConcreteModel, revenue_factor: dict = None, revenue: dict = None,
+                                loc_res_dict: dict = None, demand_scale_level: int = 0) -> Constraint:
+    """Determines revenue resource at location in network at the scheduling/expenditure scale
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        revenue_factor (dict, optional): uncertain revenue training data. Defaults to {}.
+        revenue (dict, optional): base revenue of resource. Defaults to {}.
+        demand_scale_level (int, optional): scale of scheduling decisions. Defaults to 0.
+
+
+    Returns:
+        Constraint: resource_revenue
+    """
+
+    if loc_res_dict is None:
+        loc_res_dict = dict()
+
+    if revenue_factor is None:
+        revenue_factor = dict()
+
+    if revenue is None:
+        revenue = dict()
+
+    scales = scale_list(instance=instance, scale_levels=len(instance.scales))
+
+    def resource_revenue_rule(instance, location, resource, *scale_list):
+        if resource in instance.resources_varying_revenue.intersection(loc_res_dict[location]):
+            return instance.R[location, resource, scale_list[:demand_scale_level + 1]] == revenue[location][resource]*revenue_factor[location][resource][scale_list[:demand_scale_level + 1]] * instance.S[location, resource, scale_list[:demand_scale_level + 1]]
+        else:
+            if resource in instance.resources_sell.intersection(loc_res_dict[location]):
+                return instance.R[location, resource, scale_list[:demand_scale_level + 1]] == revenue[location][
+                    resource] * instance.S[location, resource, scale_list[:demand_scale_level + 1]]
+            else:
+                return instance.R[location, resource, scale_list[:demand_scale_level + 1]] == 0
+
+    instance.constraint_resource_revenue = Constraint(
+        instance.locations, instance.resources_sell, *
+        scales, rule=resource_revenue_rule,
+        doc='revenue of resource')
+    constraint_latex_render(resource_revenue_rule)
+    return instance.constraint_resource_revenue
+
+
 def constraint_inventory_balance(instance: ConcreteModel, scheduling_scale_level: int = 0,
                                  multiconversion: dict = None, mode_dict: dict = None,
                                  cluster_wt: dict = None) -> Constraint:
     """balances resource across the scheduling horizon
     Mass balance in any temporal discretization has the following within their respective sets:
     - consumption for resources that can be purchased
     - produced for resources produced in the system. [conversion * nameplate capacity]
@@ -133,127 +178,138 @@
     if multiconversion is None:
         multiconversion = dict()
 
     if mode_dict is None:
         mode_dict = dict()
 
     scales = scale_list(instance=instance,
-                        scale_levels=instance.scales.__len__())
+                        scale_levels=len(instance.scales))
     scale_iter = scale_tuple(
-        instance=instance, scale_levels=instance.scales.__len__())
+        instance=instance, scale_levels=len(instance.scales))
 
     def inventory_balance_rule(instance, location, resource, *scale_list):
         if resource in instance.resources_purch:
             consumption = instance.C[location, resource,
-            scale_list[:scheduling_scale_level + 1]]
+                                     scale_list[:scheduling_scale_level + 1]]
         else:
             consumption = 0
 
         if resource in instance.resources_store:
             if scale_list[:scheduling_scale_level + 1] != scale_iter[0]:
                 storage = instance.Inv[location, resource, scale_list[:scheduling_scale_level + 1]] \
-                          - instance.Inv[location, resource, scale_iter[scale_iter.index(
-                    scale_list[:scheduling_scale_level + 1]) - 1]]
+                    - instance.Inv[location, resource, scale_iter[scale_iter.index(
+                        scale_list[:scheduling_scale_level + 1]) - 1]]
             else:
                 storage = instance.Inv[location, resource,
-                scale_list[:scheduling_scale_level + 1]]
+                                       scale_list[:scheduling_scale_level + 1]]
         else:
             storage = 0
 
         if resource in instance.resources_sell:
             discharge = instance.S[location, resource,
-            scale_list[:scheduling_scale_level + 1]]
+                                   scale_list[:scheduling_scale_level + 1]]
         else:
             discharge = 0
 
         if len(instance.locations) > 1:
             if resource in instance.resources_trans:
                 transport = sum(
                     instance.Imp[location, source_, resource, scale_list[:scheduling_scale_level + 1]] for source_ in
                     instance.sources if source_ != location if location in instance.sinks) \
-                            - sum(
+                    - sum(
                     instance.Exp[location, sink_, resource, scale_list[:scheduling_scale_level + 1]] for sink_ in
                     instance.sinks if sink_ != location if location in instance.sources)
             else:
                 transport = 0
         else:
             transport = 0
 
         # produced = sum(conversion[process][resource]*instance.P[location, process, scale_list[:scheduling_scale_level+1]] for process in instance.processes_singlem) \
         #     + sum(instance.P[location, process, scale_list[:scheduling_scale_level+1]] for process in instance.processes_multim)
 
         produced = sum(sum(multiconversion[process][mode][resource] * instance.P_m[location, process, mode,
-        scale_list[:scheduling_scale_level + 1]] for mode in mode_dict[process]) for process in
+                                                                                   scale_list[:scheduling_scale_level + 1]] for mode in mode_dict[process]) for process in
                        instance.processes_full)  # includes processes + discharge
 
-        weight = lambda x: 1 if cluster_wt is None else cluster_wt[x]
+        def weight(x): return 1 if cluster_wt is None else cluster_wt[x]
 
         return weight(scale_list[:scheduling_scale_level + 1]) * (
-                    consumption + produced - discharge + transport) == storage
+            consumption + produced - discharge + transport) == storage
 
     instance.constraint_inventory_balance = Constraint(
         instance.locations, instance.resources, *scales, rule=inventory_balance_rule,
         doc='mass balance across scheduling scale')
     constraint_latex_render(inventory_balance_rule)
     return instance.constraint_inventory_balance
 
 
 def constraint_demand(instance: ConcreteModel, demand: Union[dict, float], demand_factor: Union[dict, float],
                       demand_scale_level: int = 0, scheduling_scale_level: int = 0,
-                      cluster_wt: dict = None) -> Constraint:
+                      cluster_wt: dict = None, loc_res_dict: dict = None) -> Constraint:
     """Ensures that demand for resource is met at chosen temporal scale
 
     Args:
         instance (ConcreteModel): pyomo instance
         demand_scale_level (int, optional): scale of demand decisions. Defaults to 0.
         scheduling_scale_level (int, optional): scale of scheduling decisions. Defaults to 0.
         demand_dict (dict, optional): demand at location. Defaults to {}.
 
     Returns:
         Constraint: demand
     """
-    # scales = scale_list(instance= instance, scale_levels = demand_scale_level+1)
-    scales = scale_list(instance=instance,
-                        scale_levels=instance.scales.__len__())
+    scales = scale_list(instance=instance, scale_levels=demand_scale_level+1)
+    # scales = scale_list(instance=instance,
+    #                     scale_levels=len(instance.scales))
     scale_iter = scale_tuple(
         instance=instance, scale_levels=scheduling_scale_level + 1)
 
+    if loc_res_dict is None:
+        loc_res_dict = dict()
+
     def demand_rule(instance, location, resource, *scale_list):
 
         if demand_factor[location] is not None:
             if isinstance(demand_factor[location][list(demand_factor[location])[0]], (float, int)):
                 discharge = sum(instance.S[location, resource_, scale_list[:scheduling_scale_level + 1]] for
                                 resource_ in instance.resources_demand)
             else:
                 discharge = sum(instance.S[location, resource, scale_] for scale_ in scale_iter if scale_[
-                                                                                                   :scheduling_scale_level + 1] == scale_list)
+                    :demand_scale_level + 1] == scale_list)
 
             if isinstance(demand, dict):
-                demandtarget = demand[location][resource] * \
-                               demand_factor[location][resource][scale_list[:demand_scale_level + 1]]
+                if resource in loc_res_dict[location]:
+                    if resource in demand_factor[location].keys():
+                        demandtarget = demand[location][resource] * \
+                            demand_factor[location][resource][scale_list[:demand_scale_level + 1]]
+                    else:
+                        demandtarget = demand[location][resource]
+                else:
+                    demandtarget = 0
             else:
-                demandtarget = demand * \
-                               demand_factor[location][resource][scale_list[:demand_scale_level + 1]]
-
+                if resource in loc_res_dict[location]:
+                    demandtarget = demand * \
+                        demand_factor[location][resource][scale_list[:demand_scale_level + 1]]
+                else:
+                    demandtarget = 0
         else:
             # TODO - doesn't meet demand in first timeperiod
             discharge = sum(instance.S[location, resource, scale_] for scale_ in scale_iter if scale_[
-                                                                                               :scheduling_scale_level + 1] == scale_list)
+                :demand_scale_level + 1] == scale_list)
 
             if isinstance(demand, dict):
                 demandtarget = demand[location][resource]
-
             else:
                 demandtarget = demand
 
         return discharge >= demandtarget
 
     if len(instance.locations) > 1:
         instance.constraint_demand = Constraint(
             instance.sinks, instance.resources_demand, *scales, rule=demand_rule, doc='specific demand for resources')
+
     else:
         instance.constraint_demand = Constraint(
             instance.locations, instance.resources_demand, *scales, rule=demand_rule,
             doc='specific demand for resources')
     constraint_latex_render(demand_rule)
     return instance.constraint_demand
 
@@ -266,20 +322,21 @@
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: location_production
     """
 
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
     scale_iter = scale_tuple(
-        instance=instance, scale_levels=instance.scales.__len__())
+        instance=instance, scale_levels=len(instance.scales))
 
     def location_production_rule(instance, location, process, *scale_list):
-        weight = lambda x: 1 if cluster_wt is None else cluster_wt[x]
+        def weight(x): return 1 if cluster_wt is None else cluster_wt[x]
         return instance.P_location[location, process, scale_list] == sum(
             weight(scale_) * instance.P[location, process, scale_] for scale_ in scale_iter)
 
     instance.constraint_location_production = Constraint(
         instance.locations, instance.processes, *scales, rule=location_production_rule,
         doc='total production at location')
     constraint_latex_render(location_production_rule)
@@ -293,26 +350,28 @@
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: location_discharge
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
     scale_iter = scale_tuple(
-        instance=instance, scale_levels=instance.scales.__len__())
+        instance=instance, scale_levels=len(instance.scales))
 
     def location_discharge_rule(instance, location, resource, *scale_list):
-        weight = lambda x: 1 if cluster_wt is None else cluster_wt[x]
+        def weight(x): return 1 if cluster_wt is None else cluster_wt[x]
 
         return instance.S_location[location, resource, scale_list] == sum(
             weight(scale_) * instance.S[location, resource, scale_] for scale_ in scale_iter)
 
     instance.constraint_location_discharge = Constraint(
-        instance.locations, instance.resources_sell, *scales, rule=location_discharge_rule,
+        instance.locations, instance.resources_sell, *
+        scales, rule=location_discharge_rule,
         doc='total discharge at location')
     constraint_latex_render(location_discharge_rule)
     return instance.constraint_location_discharge
 
 
 def constraint_location_consumption(instance: ConcreteModel, cluster_wt: dict,
                                     network_scale_level: int = 0) -> Constraint:
@@ -321,26 +380,28 @@
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: location_consumption
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
     scale_iter = scale_tuple(
-        instance=instance, scale_levels=instance.scales.__len__())
+        instance=instance, scale_levels=len(instance.scales))
 
     def location_consumption_rule(instance, location, resource, *scale_list):
-        weight = lambda x: 1 if cluster_wt is None else cluster_wt[x]
+        def weight(x): return 1 if cluster_wt is None else cluster_wt[x]
 
         return instance.C_location[location, resource, scale_list] == sum(
             weight(scale_) * instance.C[location, resource, scale_] for scale_ in scale_iter)
 
     instance.constraint_location_consumption = Constraint(
-        instance.locations, instance.resources_purch, *scales, rule=location_consumption_rule,
+        instance.locations, instance.resources_purch, *
+        scales, rule=location_consumption_rule,
         doc='total consumption at location')
     constraint_latex_render(location_consumption_rule)
     return instance.constraint_location_consumption
 
 
 def constraint_location_purchase(instance: ConcreteModel, cluster_wt: dict, network_scale_level: int = 0) -> Constraint:
     """Determines total resource purchase expenditure at locations in network
@@ -348,44 +409,74 @@
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: location_purchase
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
     scale_iter = scale_tuple(
-        instance=instance, scale_levels=instance.scales.__len__())
+        instance=instance, scale_levels=len(instance.scales))
 
     def location_purchase_rule(instance, location, resource, *scale_list):
-        weight = lambda x: 1 if cluster_wt is None else cluster_wt[x]
+        def weight(x): return 1 if cluster_wt is None else cluster_wt[x]
 
         return instance.B_location[location, resource, scale_list] == sum(
             weight(scale_) * instance.B[location, resource, scale_] for scale_ in scale_iter)
 
     instance.constraint_location_purchase = Constraint(
-        instance.locations, instance.resources_purch, *scales, rule=location_purchase_rule,
+        instance.locations, instance.resources_purch, *
+        scales, rule=location_purchase_rule,
         doc='total purchase at location')
     constraint_latex_render(location_purchase_rule)
     return instance.constraint_location_purchase
 
 
-# *-------------------------Network scale mass balance calculation constraints--------------------------
+def constraint_location_revenue(instance: ConcreteModel, cluster_wt: dict, network_scale_level: int = 0) -> Constraint:
+    """Determines total resource revenue at locations in network
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Constraint: location_revenue
+    """
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
+    scale_iter = scale_tuple(
+        instance=instance, scale_levels=len(instance.scales))
+
+    def location_revenue_rule(instance, location, resource, *scale_list):
+        def weight(x): return 1 if cluster_wt is None else cluster_wt[x]
+
+        return instance.R_location[location, resource, scale_list] == sum(
+            weight(scale_) * instance.R[location, resource, scale_] for scale_ in scale_iter)
+
+    instance.constraint_location_revenue = Constraint(
+        instance.locations, instance.resources_sell, *
+        scales, rule=location_revenue_rule,
+        doc='total revenue at location')
+    constraint_latex_render(location_revenue_rule)
+    return instance.constraint_location_revenue
+
 
 def constraint_network_production(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
     """Determines total production utilization across network
 
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: network_production
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
     def network_production_rule(instance, process, *scale_list):
         return instance.P_network[process, scale_list] == sum(
             instance.P_location[location_, process, scale_list] for location_ in instance.locations)
 
     instance.constraint_network_production = Constraint(
         instance.processes, *scales, rule=network_production_rule, doc='total production from network')
@@ -399,15 +490,16 @@
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: network_discharge
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
     def network_discharge_rule(instance, resource, *scale_list):
         return instance.S_network[resource, scale_list] == sum(
             instance.S_location[location_, resource, scale_list] for location_ in instance.locations)
 
     instance.constraint_network_discharge = Constraint(
         instance.resources_sell, *scales, rule=network_discharge_rule, doc='total discharge from network')
@@ -421,15 +513,16 @@
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: network_consumption
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
     def network_consumption_rule(instance, resource, *scale_list):
         return instance.C_network[resource, scale_list] == sum(
             instance.C_location[location_, resource, scale_list] for location_ in instance.locations)
 
     instance.constraint_network_consumption = Constraint(
         instance.resources_purch, *scales, rule=network_consumption_rule, doc='total consumption from network')
@@ -443,17 +536,92 @@
     Args:
         instance (ConcreteModel): pyomo instance
         network_scale_level (int, optional): scale of network decisions. Defaults to 0.
 
     Returns:
         Constraint: network_purchase
     """
-    scales = scale_list(instance=instance, scale_levels=network_scale_level + 1)
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
 
     def network_purchase_rule(instance, resource, *scale_list):
         return instance.B_network[resource, scale_list] == sum(
             instance.B_location[location_, resource, scale_list] for location_ in instance.locations)
 
     instance.constraint_network_purchase = Constraint(
         instance.resources_purch, *scales, rule=network_purchase_rule, doc='total purchase from network')
     constraint_latex_render(network_purchase_rule)
     return instance.constraint_network_purchase
+
+
+def constraint_network_revenue(instance: ConcreteModel, network_scale_level: int = 0) -> Constraint:
+    """Determines total revenue expenditure on resource across network
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        network_scale_level (int, optional): scale of network decisions. Defaults to 0.
+
+    Returns:
+        Constraint: network_revenue
+    """
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
+
+    def network_revenue_rule(instance, resource, *scale_list):
+        return instance.R_network[resource, scale_list] == sum(
+            instance.R_location[location_, resource, scale_list] for location_ in instance.locations)
+
+    instance.constraint_network_revenue = Constraint(
+        instance.resources_sell, *scales, rule=network_revenue_rule, doc='total revenue from network')
+    constraint_latex_render(network_revenue_rule)
+    return instance.constraint_network_revenue
+
+
+def constraint_specific_network_discharge(instance: ConcreteModel, bounds: Dict[Resource, float], network_scale_level: int = 0, ) -> Constraint:
+    """Determines total resource discharged across specificnetwork
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        specific_network_scale_level (int, optional): scale of specific_network decisions. Defaults to 0.
+
+    Returns:
+        Constraint: specific_network_discharge
+    """
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
+    resource_list = [i.name for i in bounds.keys()]
+    bounds_dict = {i.name: bounds[i] for i in bounds.keys()}
+
+    def specific_network_discharge_rule(instance, resource, *scale_list):
+        if resource in resource_list:
+            return instance.S_network[resource, scale_list] <= bounds_dict[resource]
+        else:
+            return Constraint.Skip
+
+    constraint_latex_render(specific_network_discharge_rule)
+    return Constraint(instance.resources_sell, *scales, rule=specific_network_discharge_rule, doc='restrict discharge of resource at network level')
+
+
+def constraint_specific_location_discharge(instance: ConcreteModel, location: Location, bounds: Dict[Resource, float], network_scale_level: int = 0, ) -> Constraint:
+    """Determines total resource discharged across specific location
+
+    Args:
+        instance (ConcreteModel): pyomo instance
+        location (Location): location
+        specific_location_scale_level (int, optional): scale of specific_location decisions. Defaults to 0.
+
+    Returns:
+        Constraint: specific_location_discharge
+    """
+    scales = scale_list(instance=instance,
+                        scale_levels=network_scale_level + 1)
+    resource_list = [i.name for i in bounds.keys()]
+    bounds_dict = {i.name: bounds[i] for i in bounds.keys()}
+
+    def specific_location_discharge_rule(instance, resource, *scale_list):
+        if resource in resource_list:
+            return instance.S_location[location.name, resource, scale_list] <= bounds_dict[resource]
+        else:
+            return Constraint.Skip
+
+    constraint_latex_render(specific_location_discharge_rule)
+    return Constraint(instance.resources_sell, *scales, rule=specific_location_discharge_rule, doc='restrict discharge of resource at location level')
```

## energiapy/model/constraints/transport.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo transport constraints
+"""transport constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
```

## energiapy/model/constraints/uncertain.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo uncertain constraints
+"""uncertain constraints
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
```

## energiapy/model/variables/binary.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo binary variables
+"""binary variables
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
```

## energiapy/model/variables/cost.py

```diff
@@ -7,14 +7,15 @@
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
-from pyomo.environ import Binary, ConcreteModel, Var
+from pyomo.environ import ConcreteModel, Var, NonNegativeReals
 
 
 def generate_costing_vars(instance: ConcreteModel):
-    instance.cost_segments = Var(
-        instance.locations, instance.processes, within=Binary, doc='Segment for costing')
+    # instance.cost_segments = Var(
+    #     instance.locations, instance.processes, within=Binary, doc='Segment for costing')
+    instance.Cost = Var(within=NonNegativeReals, doc='Total cost')
     return
```

## energiapy/model/variables/mode.py

```diff
@@ -1,40 +1,41 @@
 # %%.
-"""pyomo scheduling variables
+"""mode-based production variables
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
+from itertools import product
 from pyomo.environ import Binary, ConcreteModel, NonNegativeReals, Var
 
 
 def generate_mode_vars(instance: ConcreteModel, scale_level: int = 0, mode_dict: dict = None):
     """declares pyomo variables for mode based production at the chosen scale:
 
     P_m: Production within a mode
 
     X_P_m: Production mode binary variable, 1 if process is in mode
 
+    X_P_mm: 1, if there is a mode transition from m to m' in a time period
 
 
     Args:
         instance (ConcreteModel): pyomo instance
         scale_level (int, optional):  scale for scheduling variables. Defaults to 0.
     """
 
     if mode_dict is None:
         mode_dict = dict()
-
-    instance.P_m = Var(instance.locations, [(i, j) for i in mode_dict.keys(
-    ) for j in mode_dict[i]], instance.scales_scheduling, within=NonNegativeReals, doc='Production modes')
     instance.X_P_m = Var(instance.locations, [(i, j) for i in mode_dict.keys(
     ) for j in mode_dict[i]], instance.scales_scheduling, within=Binary, doc='Production mode binaries')
     instance.Cap_P_m = Var(instance.locations, [(i, j) for i in mode_dict.keys(
-    ) for j in mode_dict[i]], instance.scales_scheduling, within=Binary, doc='Production mode binaries')
+    ) for j in mode_dict[i]], instance.scales_scheduling, within=NonNegativeReals, doc='Production mode capacity')
+    instance.X_P_mm = Var(instance.locations, [(i, j) for i in mode_dict.keys() for j in product(
+        mode_dict[i], mode_dict[i])], instance.scales_scheduling, within=Binary, doc="Production mode transition binaries")
     return
```

## energiapy/model/variables/network.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo network variables
+"""network variables
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -25,40 +25,30 @@
     instance.scales_network = scale_pyomo_set(
         instance=instance, scale_level=scale_level)
     instance.Cap_P = Var(instance.locations, instance.processes,
                          instance.scales_network, within=NonNegativeReals, doc='Process Capacity')
     instance.Cap_S = Var(instance.locations, instance.resources_store,
                          instance.scales_network, within=NonNegativeReals, doc='Storage Capacity')
 
-    instance.Land_process = Var(instance.locations, instance.processes,
-                                instance.scales_network, within=NonNegativeReals, doc='Land cost by Process')
-    instance.Land_location = Var(instance.locations, instance.scales_network,
-                                 within=NonNegativeReals, doc='Land used at location')
-    instance.Land_network = Var(
-        instance.scales_network, within=NonNegativeReals, doc='Land used at network')
-
-    instance.Land_cost_process = Var(instance.locations, instance.processes,
-                                     instance.scales_network, within=NonNegativeReals, doc='Land used by Process')
-    instance.Land_cost_location = Var(
-        instance.locations, instance.scales_network, within=NonNegativeReals, doc='Land cost at location')
-    instance.Land_cost_network = Var(
-        instance.scales_network, within=NonNegativeReals, doc='Land cost at network')
-
     instance.P_location = Var(instance.locations, instance.processes, instance.scales_network,
                               within=NonNegativeReals, doc='Total production at location')
     instance.S_location = Var(instance.locations, instance.resources_sell, instance.scales_network,
                               within=NonNegativeReals, doc='Total resource discharge at location')
+    instance.R_location = Var(instance.locations, instance.resources_sell, instance.scales_network,
+                              within=NonNegativeReals, doc='Total revenue from resource discharge at location')
     instance.C_location = Var(instance.locations, instance.resources_purch, instance.scales_network,
                               within=NonNegativeReals, doc='Total resource consumption at location')
     instance.B_location = Var(instance.locations, instance.resources_purch, instance.scales_network,
                               within=NonNegativeReals, doc='Total resource purchase at location')
     instance.P_network = Var(instance.processes, instance.scales_network,
                              within=NonNegativeReals, doc='Total production from network')
     instance.S_network = Var(instance.resources_sell, instance.scales_network,
                              within=NonNegativeReals, doc='Total resource discharge from network')
+    instance.R_network = Var(instance.resources_sell, instance.scales_network,
+                             within=NonNegativeReals, doc='Total revenue from resource discharge from network')
     instance.C_network = Var(instance.resources_purch, instance.scales_network,
                              within=NonNegativeReals, doc='Total resource consumption from network')
     instance.B_network = Var(instance.resources_purch, instance.scales_network,
                              within=NonNegativeReals, doc='Total resource purchase from network')
     if len(instance.locations) > 1:
         instance.Trans_cost_network = Var(instance.transports, instance.scales_network,
                                           within=NonNegativeReals, doc='cost of transportation for transport mode')
@@ -84,25 +74,8 @@
         instance.scales_network, within=NonNegativeReals, doc='Fixed Opex at network scale')
     instance.Vopex_network = Var(
         instance.scales_network, within=NonNegativeReals, doc='Variable Opex at network scale')
     instance.Capex_network = Var(
         instance.scales_network, within=NonNegativeReals, doc='Capex at network scale')
     instance.Incidental_network = Var(
         instance.scales_network, within=NonNegativeReals, doc='Incidental at network scale')
-
-    instance.carbon_emission_network = Var(
-        instance.scales_network, within=NonNegativeReals, doc='Carbon emissions across network at network_scale')
-    instance.carbon_emission_location = Var(instance.locations, instance.scales_network,
-                                            within=NonNegativeReals, doc='Carbon emissions at location at network_scale')
-
-    instance.global_warming_potential_location = Var(
-        instance.locations, instance.scales_network, within=NonNegativeReals, doc='global warming potential caused at each location')
-    instance.global_warming_potential_network = Var(
-        instance.scales_network, within=NonNegativeReals, doc='global warming potential caused at network scale')
-    instance.global_warming_potential_process = Var(
-        instance.locations, instance.processes, instance.scales_network, within=NonNegativeReals, doc='global warming potential caused by each process')
-    instance.global_warming_potential_resource = Var(
-        instance.locations, instance.resources_purch, instance.scales_network, within=NonNegativeReals, doc='global warming potential caused by each resource')
-    instance.global_warming_potential_material = Var(instance.locations, instance.processes_materials,
-                                                     instance.scales_network, within=NonNegativeReals, doc='global warming potential caused by each material')
-
     return
```

## energiapy/model/variables/schedule.py

```diff
@@ -1,9 +1,9 @@
 # %%.
-"""pyomo scheduling variables
+"""scheduling variables
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -19,14 +19,15 @@
 def generate_scheduling_vars(instance: ConcreteModel, scale_level: int = 0, mode_dict: dict = None):
     """declares pyomo variables for scheduling at the chosen scales
 
 
     Args:
         instance (ConcreteModel): pyomo instance
         scale_level (int, optional):  scale for scheduling variables. Defaults to 0.
+        mode_dict (dict, optional): dictionary with mode information of processes. Defaults to None.
     """
 
     if mode_dict is None:
         mode_dict = dict()
 
     instance.scales_scheduling = scale_pyomo_set(
         instance=instance, scale_level=scale_level)
@@ -34,16 +35,19 @@
                      instance.scales_scheduling, within=NonNegativeReals, doc='Production')
     instance.B = Var(instance.locations, instance.resources_purch,
                      instance.scales_scheduling, within=NonNegativeReals, doc='Purchase Expenditure')
     instance.C = Var(instance.locations, instance.resources_purch,
                      instance.scales_scheduling, within=NonNegativeReals, doc='Resource Consumption')
     instance.S = Var(instance.locations, instance.resources_sell,
                      instance.scales_scheduling, within=NonNegativeReals, doc='Resource Dispensed/Sold')
+    instance.R = Var(instance.locations, instance.resources_sell,
+                     instance.scales_scheduling, within=NonNegativeReals, doc='Revenue from resource Sold')
     instance.Inv = Var(instance.locations, instance.resources_store,
                        instance.scales_scheduling, within=NonNegativeReals, doc='Resource Inventory')
     if len(instance.locations) > 1:
         instance.Imp = Var(instance.sinks, instance.sources, instance.resources_trans,
                            instance.scales_scheduling, within=NonNegativeReals, doc='Resource import')
         instance.Exp = Var(instance.sources, instance.sinks, instance.resources_trans,
                            instance.scales_scheduling, within=NonNegativeReals, doc='Resource export')
-
+    instance.P_m = Var(instance.locations, [(i, j) for i in mode_dict.keys(
+    ) for j in mode_dict[i]], instance.scales_scheduling, within=NonNegativeReals, doc='Production modes')
     return
```

## energiapy/model/variables/transport.py

```diff
@@ -1,8 +1,8 @@
-"""pyomo transport variables
+"""transport variables
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
```

## energiapy/model/variables/uncertain.py

```diff
@@ -1,9 +1,9 @@
 
-"""pyomo variables
+"""uncertainty variables
 """
 
 __author__ = "Rahul Kakodkar"
 __copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
 __version__ = "1.0.5"
@@ -21,19 +21,15 @@
 
     Args:
         instance (ConcreteModel): pyomo instance
         scale_level (int, optional): scale for uncertainty. Defaults to 0.
     """
     instance.scales_uncertainty = scale_pyomo_set(
         instance, scale_level=scale_level)
-    # instance.Demand_slack = Var(instance.locations, instance.scales_uncertainty, within = NonNegativeReals, doc = 'demand slack')
+
     instance.resource_demand_uncertainty = Var(instance.locations, instance.resources_uncertain_demand,
                                                instance.scales_uncertainty, within=NonNegativeReals, doc='resource demand uncertainty')
     instance.resource_price_uncertainty = Var(instance.locations, instance.resources_uncertain_price,
                                               instance.scales_uncertainty, within=NonNegativeReals, doc='resource price uncertainty')
     instance.process_capacity_uncertainty = Var(instance.locations, instance.processes_uncertain_capacity,
                                                 instance.scales_uncertainty, within=NonNegativeReals, doc='process capacity uncertainty')
-    # instance.Delta_Cost_R = Var(instance.locations, instance.resources_varying, instance.scales_uncertainty, within= NonNegativeReals, doc= 'uncertain purchase price')
-    # instance.Delta_Cap_P = Var(instance.locations, instance.processes_varying, instance.scales_uncertainty, bounds = (0, 200), within= NonNegativeReals, doc= 'uncertain resource availability')
-    # instance.Delta_Cap_P_location = Var(instance.locations, instance.processes_varying, instance.scales_network, within= NonNegativeReals, doc= 'uncertain resource availability - network scale at location')
-    # instance.Delta_Cap_P_network = Var(instance.processes_varying, instance.scales_network, within= NonNegativeReals, doc= 'uncertain resource availability - network scale')
     return
```

## energiapy/plot/plot_fit.py

```diff
@@ -9,15 +9,15 @@
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 import matplotlib.pyplot as plt
 from matplotlib import rc
 
-import pandas 
+import pandas
 import scipy
 import numpy
 
 from ..utils.data_utils import min_max
 
 
 def distribution(fit_summary: pandas.DataFrame, fit_type: 'str', fig_size: tuple = (8, 6), font_size: int = 16, color: str = 'steelblue'):
@@ -31,15 +31,15 @@
         color (str, optional): Defaults to 'steelblue'.
     """
 
     x = numpy.linspace (0, 1, 200)
 
     if fit_type == 'norm':
         y = scipy.stats.norm.pdf(x, loc= fit_summary['params'][fit_type][0], scale= fit_summary['params'][fit_type][1])
-        
+
     if fit_type == 'expon':
         y = scipy.stats.expon.pdf(x, loc= fit_summary['params'][fit_type][0], scale= fit_summary['params'][fit_type][1])
 
     if fit_type == 'uniform':
         y = scipy.stats.uniform.pdf(x, loc= fit_summary['params'][fit_type][0], scale= fit_summary['params'][fit_type][1])
 
     if fit_type == 'pareto':
@@ -73,15 +73,15 @@
     ax.set_title(f"{fit_type} distribution")
     plt.grid(alpha = 0.4)
     plt.rcdefaults()
 
     return
 
 
-def histogram(data: numpy.ndarray, fig_size: tuple = (8, 6), font_size: int = 16, color: str = 'steelblue'): 
+def histogram(data: numpy.ndarray, fig_size: tuple = (8, 6), font_size: int = 16, color: str = 'steelblue'):
     """Plots a histogram of time-series data
 
     Args:
         data (numpy.array): time-series data
         fig_size (tuple, optional): Defaults to (8, 6).
         font_size (int, optional): Defaults to 16.
         color (str, optional): Defaults to 'steelblue'.
```

## energiapy/plot/plot_scenario.py

```diff
@@ -45,35 +45,35 @@
     plt.ylabel("Normalized capacity factor")
     plt.xlabel("Scheduling Horizon")
     plt.grid(alpha=0.3)
     plt.rcdefaults()
     return
 
 
-def cost_factor(scenario: Scenario, resource: Resource, location: Location, fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue', usetex: bool = False):
-    """generates a plot for varying cost factor of resource
+def price_factor(scenario: Scenario, resource: Resource, location: Location, fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue', usetex: bool = False):
+    """generates a plot for varying price factor for purchase of resource
 
     Args:
         scenario (Scenario): scenario energiapy object
         resource (Resource): resource energiapy object
         location (Location): location energiapy object
         font_size (int, optional): font size. Defaults to 16.
         fig_size (tuple, optional): figure size. Defaults to (12,6).
         color (str, optional): color of plot. Defaults to 'blue'.
         usetex (bool, optional): False, if using latex font, need Tex set up (prone to errors). Defaults to 'False'.
     """
     rc('font', **{'family': 'serif',
        'serif': ['Computer Modern'], 'size': font_size})
     rc('text', usetex=False)
     fig, ax = plt.subplots(figsize=fig_size)
-    y_ = list(scenario.cost_factor[location.name][resource.name].values())
+    y_ = list(scenario.price_factor[location.name][resource.name].values())
     x_ = list(range(len(y_)))
     ax.plot(x_, y_, linewidth=0.5, color=color)
     ax = axis_formatter(axes=ax, xcord=x_, axis_labels='M')
-    plt.title(f'Cost factor for {resource.label} in {location.label}')
+    plt.title(f'Price factor for {resource.label} in {location.label}')
     plt.ylabel("Normalized cost factor")
     plt.xlabel("Scheduling Horizon")
     plt.grid(alpha=0.3)
     plt.rcdefaults()
     return
 
 
@@ -101,16 +101,17 @@
     plt.title(f'Demand factor for {resource.label} in {location.label}')
     plt.ylabel("Normalized demand factor")
     plt.xlabel("Scheduling Horizon")
     plt.grid(alpha=0.3)
     plt.rcdefaults()
     return
 
+
 def capex_factor(scenario: Scenario, process: Process, location: Location,
-                  fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue'):
+                 fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue'):
     """generates a plot for varying technology capital expenditure
 
     Args:
         scenario (Scenario): scenario energiapy object
         process (Process): process energiapy object
         location (Location): location energiapy object
         font_size (int, optional): font size. Defaults to 16.
@@ -129,16 +130,17 @@
     plt.title(f'Capex factor for {process.label} in {location.label}')
     plt.ylabel("Normalized capex factor")
     plt.xlabel("Scheduling Horizon")
     plt.grid(alpha=0.3)
     plt.rcdefaults()
     return
 
+
 def vopex_factor(scenario: Scenario, process: Process, location: Location,
-                  fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue'):
+                 fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue'):
     """generates a plot for varying technology variable operational expenditure
 
     Args:
         scenario (Scenario): scenario energiapy object
         process (Process): process energiapy object
         location (Location): location energiapy object
         font_size (int, optional): font size. Defaults to 16.
@@ -157,16 +159,17 @@
     plt.title(f'Vopex factor for {process.label} in {location.label}')
     plt.ylabel("Normalized vopex factor")
     plt.xlabel("Scheduling Horizon")
     plt.grid(alpha=0.3)
     plt.rcdefaults()
     return
 
+
 def fopex_factor(scenario: Scenario, process: Process, location: Location,
-                  fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue'):
+                 fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue'):
     """generates a plot for varying technology fixed operational expenditure
 
     Args:
         scenario (Scenario): scenario energiapy object
         process (Process): process energiapy object
         location (Location): location energiapy object
         font_size (int, optional): font size. Defaults to 16.
@@ -184,7 +187,67 @@
     ax = axis_formatter(axes=ax, xcord=x_, axis_labels='M')
     plt.title(f'Fopex factor for {process.label} in {location.label}')
     plt.ylabel("Normalized fopex factor")
     plt.xlabel("Scheduling Horizon")
     plt.grid(alpha=0.3)
     plt.rcdefaults()
     return
+
+
+def availability_factor(scenario: Scenario, resource: Resource, location: Location,
+                        fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue', usetex: bool = False):
+    """generates a plot for varying availability factor of resource
+
+    Args:
+        scenario (Scenario): scenario energiapy object
+        resource (Resource): resource energiapy object
+        location (Location): location energiapy object
+        font_size (int, optional): font size. Defaults to 16.
+        fig_size (tuple, optional): figure size. Defaults to (12,6).
+        color (str, optional): color of plot. Defaults to 'blue'.
+        usetex (bool, optional): False, if using latex font, need Tex set up (prone to errors). Defaults to 'False'.
+    """
+    rc('font', **{'family': 'serif',
+       'serif': ['Computer Modern'], 'size': font_size})
+    rc('text', usetex=False)
+    fig, ax = plt.subplots(figsize=fig_size)
+    y_ = list(
+        scenario.availability_factor[location.name][resource.name].values())
+    x_ = list(range(len(y_)))
+    ax.plot(x_, y_, linewidth=0.5, color=color)
+    ax = axis_formatter(axes=ax, xcord=x_, axis_labels='M')
+    plt.title(f'Demand factor for {resource.label} in {location.label}')
+    plt.ylabel("Normalized availability factor")
+    plt.xlabel("Scheduling Horizon")
+    plt.grid(alpha=0.3)
+    plt.rcdefaults()
+    return
+
+
+def revenue_factor(scenario: Scenario, resource: Resource, location: Location,
+                   fig_size: tuple = (12, 6), font_size: int = 16, color: str = 'blue', usetex: bool = False):
+    """generates a plot for varying revenue factor of resource
+
+    Args:
+        scenario (Scenario): scenario energiapy object
+        resource (Resource): resource energiapy object
+        location (Location): location energiapy object
+        font_size (int, optional): font size. Defaults to 16.
+        fig_size (tuple, optional): figure size. Defaults to (12,6).
+        color (str, optional): color of plot. Defaults to 'blue'.
+        usetex (bool, optional): False, if using latex font, need Tex set up (prone to errors). Defaults to 'False'.
+    """
+    rc('font', **{'family': 'serif',
+       'serif': ['Computer Modern'], 'size': font_size})
+    rc('text', usetex=False)
+    fig, ax = plt.subplots(figsize=fig_size)
+    y_ = list(
+        scenario.revenue_factor[location.name][resource.name].values())
+    x_ = list(range(len(y_)))
+    ax.plot(x_, y_, linewidth=0.5, color=color)
+    ax = axis_formatter(axes=ax, xcord=x_, axis_labels='M')
+    plt.title(f'Demand factor for {resource.label} in {location.label}')
+    plt.ylabel("Normalized revenue factor")
+    plt.xlabel("Scheduling Horizon")
+    plt.grid(alpha=0.3)
+    plt.rcdefaults()
+    return
```

## energiapy/utils/data_utils.py

```diff
@@ -9,14 +9,15 @@
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 import json
 import pickle
 from itertools import product
+from typing import Union
 
 import numpy
 import pandas
 
 from ..components.result import Result
 
 
@@ -286,42 +287,44 @@
         print('WARNING: Loading non-optimal results')
     results = Result(name=filename.split('.')[
                      0], output=results_dict['output'], components=results_dict['components'], duals=results_dict['duals'])
 
     return results
 
 
-def remove_outliers(data: pandas.DataFrame, sd_cuttoff: int = 2) -> pandas.DataFrame:
+def remove_outliers(data: pandas.DataFrame, sd_cuttoff: int = 2, mean_range: int = 1) -> pandas.DataFrame:
     """Removes outliers upto chosen standard deviations
-    fixes data as the mean of data around the point
+    fixes data as the mean of data points on both sides of the point
     Args:
         data (pandas.DataFrame): input data
         sd_cuttoff (int, optional): data upto integer number of standard deviations. Defaults to 2.
-
+        mean_range: (int, optional): number of data points on either sides to average over
     Returns:
         pandas.DataFrame: data sans outliers
     """
     data_mean, data_std = data.mean(), data.std()
     # identify outliers
-    cut_off = data_std * 3
+    cut_off = data_std * sd_cuttoff
     lower, upper = data_mean - cut_off, data_mean + cut_off
     for i in range(len(data)):
         x = data.iloc[i].values[0]
         if x < float(lower) or x > float(upper):
-            data.iloc[i] = (data.iloc[i-1] + data.iloc[i+1])/2
+            data.iloc[i] = (sum(data.iloc[i-(j+1)] for j in range(mean_range)) +
+                            sum(data.iloc[i+(j+1)] for j in range(mean_range)))/2*mean_range
 
     return data
 
-def min_max(data: numpy.array) -> numpy.array:
+
+def min_max(data: Union[numpy.array, pandas.DataFrame]) -> Union[numpy.array, pandas.DataFrame]:
     """min max for data
 
     Args:
         data (numpy.array): time-series data 
 
     Returns:
-        numpy.array: min-maxed data array
+        Union[numpy.array, pandas.DataFrame]: min-maxed data array
     """
     min_data = numpy.min(data)
     max_data = numpy.max(data)
     data = (data - numpy.min(data)) / (max_data - min_data)
 
-    return data
+    return data
```

## energiapy/utils/nsrdb_utils.py

```diff
@@ -1,15 +1,15 @@
 """pvlib utils
 """
 
 __author__ = "Rahul Kakodkar"
-__copyright__ = "Copyright 2022, Multi-parametric Optimization & Control Lab"
+__copyright__ = "Copyright 2023, Multi-parametric Optimization & Control Lab"
 __credits__ = ["Rahul Kakodkar", "Efstratios N. Pistikopoulos"]
 __license__ = "MIT"
-__version__ = "1.0.5"
+__version__ = "1.1.0"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from typing import List, Tuple, Union
 
 import h5pyd
@@ -29,15 +29,15 @@
         lat_lon (Tuple[float], optional): (latitude, longitude) to fetch closest data point. Defaults to None.
         state (str, optional): capitalized state name, e.g. 'Texas' . Defaults to ''.
         county (str, optional): capitalized county name, e.g. 'Brazos' . Defaults to ''.
         resolution (str, optional): choose from 'halfhourly', 'hourly', 'daily'. Defaults to ''.
         get (str, optional): Defaults to 'max-population'. From within county choose the data point that matches one of the following. 'max-population', 'max-elevation', 'max-landcover' 'min-population', 'min-elevation', 'min-landcover'
 
     Returns:
-        pandas.DataFrame, tuple: Dataframe with data, (latitude, longitude)
+        pandas.DataFrame, tuple: Dataframe with output data, (latitude, longitude)
     """
 
     # fetches nsrdb data for the year
     nsrdb_data = h5pyd.File(f"/nrel/nsrdb/v3/nsrdb_{str(year)}.h5", 'r')
     time_index = pandas.to_datetime(nsrdb_data['time_index'][...].astype(str))
 
     if lat_lon is not None:
@@ -88,18 +88,26 @@
     timestep_dict = {
         'halfhourly': 1,  # native data set at 30 mins
         'hourly': 2,  # averages over the hour
         'daily': 48,  # averages over the day
     }
     averaged_output = pandas.DataFrame()
 
+    psm_scale_dict = {
+        attr: nsrdb_data[attr].attrs['psm_scale_factor'] for attr in attrs}
+
     for attr in attrs:
         full_output = nsrdb_data[attr][:, idx]  # native data set at 30 mins
         averaged_output[attr] = numpy.average(
             full_output.reshape(-1, timestep_dict[resolution]), axis=1)  # averages over resolution
     averaged_output = averaged_output.set_index(
         time_index[::timestep_dict[resolution]])
 
+    for attr in attrs:
+        averaged_output[attr] = averaged_output[attr]/psm_scale_dict[attr]
+
     if save is not None:
         averaged_output.to_csv(save + '.csv')
 
-    return lat_lon, averaged_output, full_output
+    return lat_lon, averaged_output
+
+
```

## energiapy/utils/process_utils.py

```diff
@@ -19,10 +19,10 @@
 
     Args:
         process (Process): Dummy process name derived from storage process
     Returns:
         Process: Dummy process for storage
     """
     process_dummy = Process(name=process.name+'_discharge', conversion=process.conversion_discharge, prod_min=process.prod_min,
-                            prod_max=process.prod_max, introduce=process.introduce, retire=process.retire, capex=0, vopex=0, fopex=0,
+                            prod_max=process.prod_max, introduce=process.introduce, retire=process.retire, capex=0, vopex=process.vopex, fopex=0,
                             lifetime=process.lifetime, label=process.label + '_storage')
     return process_dummy
```

## energiapy/utils/resource_utils.py

```diff
@@ -7,27 +7,27 @@
 __license__ = "MIT"
 __version__ = "1.0.5"
 __maintainer__ = "Rahul Kakodkar"
 __email__ = "cacodcar@tamu.edu"
 __status__ = "Production"
 
 from ..components.resource import Resource
+from ..components.resource import VaryingResource
 
 
-
-def create_storage_resource(process_name:str, resource: Resource, store_max: float = 0, store_min: float = 0) -> Resource:
+def create_storage_resource(process_name: str, resource: Resource, store_max: float = 0, store_min: float = 0) -> Resource:
     """Creates a dummy resource for storage, used if process is storage type
 
     Args:
         resource (Resource): Dummy resource name derived from stored resource
         store_max (float, optional): Maximum amount of resource that can be stored. Defaults to 0.
         store_min (float, optional): Minimum amount of resource that can be stored. Defaults to 0.
 
     Returns:
         Resource: Dummy resource for storage
     """
     # print(resource.block)
     # print(resource.name)
-    resource_dummy = Resource(name= f"{process_name}_{resource.name}_stored", loss= resource.loss, store_max= store_max, store_min= store_min, basis= resource.basis, block= resource.block, label= resource.label+f"{process_name}(stored)")
-    
-    return resource_dummy
+    resource_dummy = Resource(name=f"{process_name}_{resource.name}_stored", loss=resource.loss, store_max=store_max, store_min=store_min,
+                              basis=resource.basis, block=resource.block, label=resource.label+f"{process_name}(stored)", varying=[VaryingResource.STORED])
 
+    return resource_dummy
```

## energiapy/utils/scale_utils.py

```diff
@@ -51,15 +51,15 @@
     list_ = list(product(*data))
     return list_
 
 
 def scale_changer(input_dict: dict, scales: TemporalScale, scale_level: int) -> dict:
     """changes the scales form datetime to tuples
     """
-    df = pandas.concat([pandas.DataFrame(input_dict[list(input_dict.keys())[i]])
+    df = pandas.concat([pandas.DataFrame(input_dict[list(input_dict.keys())[i]]).reset_index(drop = True)
                         for i in range(len(input_dict.keys()))], axis=1)
     # df['hour'] = pandas.to_datetime(df.index, errors='coerce').strftime("%H")
     # df['day'] = pandas.to_datetime(df.index, errors='coerce').strftime("%j")
     # df['year'] = pandas.to_datetime(df.index, errors='coerce').strftime("%Y")
     # c = df['day']
     # if scales.start_zero is not None:
     #     df['scales'] = [(int(i)  - scales.start_zero, int(j) - 1, int(k)) \
```

## Comparing `energiapy-1.0.6.dist-info/LICENSE` & `energiapy-1.0.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `energiapy-1.0.6.dist-info/METADATA` & `energiapy-1.0.7.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: energiapy
-Version: 1.0.6
+Version: 1.0.7
 Summary: Python-based energy systems modeling and optimization tool
 Home-page: https://github.com/TAMUparametric/energiapy
 Author: Rahul Kakodkar
 Author-email: cacodcar@tamu.edu
 License: MIT
 Description-Content-Type: text/markdown
 License-File: LICENSE
@@ -128,8 +128,10 @@
 
 1. math utilities for calculating euclidean distances, generation connectivity matrices, etc.
 2. generating dataframes with missing data fixed (weekends, public holidays) for time-series data such as resource price
 3. function to fetch weather data at an appropriate resolution from [NREL NSRDB](https://nsrdb.nrel.gov/) for any county
    in the US
 4. latex constraints writer for model documentation
 
+Direct any communication to Rahul Kakodkar (cacodcar@tamu.edu)  
+
```

## Comparing `energiapy-1.0.6.dist-info/RECORD` & `energiapy-1.0.7.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,67 +1,79 @@
 energiapy/__init__.py,sha256=tY2BeXmkbjHsyYFigdhNWD-n839COgwzwCfs151tEEI,346
 energiapy/aggregation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-energiapy/aggregation/ahc.py,sha256=nOeuzAa4Yq9IqN5Qz6VxnSOFXmfjkf11b4tUgkddglY,11235
+energiapy/aggregation/ahc.py,sha256=efYhSvezwpUmSGaMFpGlZtXtvRKpOx8_cNRNIoc08l4,11211
 energiapy/aggregation/dtw.py,sha256=jYzlL5PntxxXACH80LGa5xs9ABvu5lLQnuOAXv7iAR4,6110
-energiapy/aggregation/kmeans.py,sha256=8qUZZDDU9Z6XYUYqpteFGsas4G9AyRhZHmbBDvYp_AQ,3507
+energiapy/aggregation/kmeans.py,sha256=beDvp-E1lPCCxad7IrjPW5w7GzquwOLJKdiVMO8kuQ8,3503
 energiapy/aggregation/reduce_scenario.py,sha256=7Uc5Cd4kkTWA9VoDnu8q7odRd6ng9HZT2g9zRHD0GFU,5064
 energiapy/components/__init__.py,sha256=dKuD3ZP83FChj8IBcHJfLCsIgf3P6FgsNH-05n1bTFI,357
-energiapy/components/location.py,sha256=lvbgIoUa-U5Y_2wn3uiaWdUz6X7IX4KZjmWyh2m2sjM,11242
+energiapy/components/location.py,sha256=uD5tN4qXtzWISnf1JcAwXxCiPiJ-75FdoGuv9kNi7_g,13865
 energiapy/components/material.py,sha256=8n35b0rKb2kS3gSbqsZSTEPG9IR-gAAUAc4oJjjFU0A,1869
-energiapy/components/network.py,sha256=TN-9Xg3_dX9Qnwz5BybZScjsSlgcar9x-S-jdgehCIc,4650
-energiapy/components/process.py,sha256=OGX2Hh0OVjPylO6cY446hw8hBy-RRqCUSj6oGfPs2NM,8028
-energiapy/components/resource.py,sha256=F2F3NoE4yaxvvUAZGnO9thX4cQoxiNn9IG88iUs9svQ,3952
+energiapy/components/network.py,sha256=fYH5D_cCv4dTzKZr4bp2UamGuOVJLoPKso7TZt41m_8,5240
+energiapy/components/process.py,sha256=TUe6uZe1wpZjAM9MDY_pew0fhmxiaY37UbWBtyOI7d0,9088
+energiapy/components/resource.py,sha256=Q6iqq73UtZE7WaxBONPuYwvzNF0BZaA5IMlGZ1jQfII,5862
 energiapy/components/result.py,sha256=kjxinDdqg0Hy2n6CyF5YCxg0s8xq9FZJ7QMAx9uVjhk,5521
-energiapy/components/scenario.py,sha256=8XfPnb4-Qh3TCQvruInIMBhzZMtWQzJFTVF8iM6dUkk,21830
+energiapy/components/scenario.py,sha256=yCpvz9f3DTpA40sJd80QW3UhvRR6eAvpUhICNUZbDJo,29561
 energiapy/components/temporal_scale.py,sha256=tLyXOWJyZ-siL7RikRWVYMjDxqto0VDHAxuA7_9RwCs,2342
 energiapy/components/transport.py,sha256=GMgpRsFUMSc1YSqDUuGxFKzfDTJOKmgjxtKZdKIJirI,2487
+energiapy/conversion/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+energiapy/conversion/photovoltaic.py,sha256=TQP5F8SFYNDk8IMSXdrKnisWmLRtDqCz4pnnd2JYYaI,2857
+energiapy/conversion/windmill.py,sha256=8lPiSeUmbLYHpBcysefbq1TYv-iYUViBkeje5JS1GZQ,3783
 energiapy/fitting/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 energiapy/fitting/dist.py,sha256=OxIw9u1ZyfuEE6CBe6C98eDwfvlseFGS7_LwFoPppiU,942
 energiapy/graph/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 energiapy/graph/graph.py,sha256=Gs3m4ww2ky9BDUHwrM2ke5o69-Swcgpt2S35T2iFr-M,3651
 energiapy/model/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-energiapy/model/formulate.py,sha256=Ocpw4aVtQHYv7qIKa7zXzLdWUCTHkMeRmo07KLL8lgo,19677
-energiapy/model/objectives.py,sha256=WQeHwg-oWiotBMA_L6Hwa30s4ixdoBciz2UVg6y3Z4U,4867
-energiapy/model/sets.py,sha256=8ZSGXXrh_s0-2OYu18LsMVVCBsaGMXNxOZkNkgAowqc,5784
-energiapy/model/solve.py,sha256=GD-6DPShyIqRlHLg263xGQP_TAcT459ltaQP5009Rqc,3763
+energiapy/model/bounds.py,sha256=kqlZGm2L_T9h_yFkL_m0LIs6itdcPqnRY9Fj8n6zf24,1177
+energiapy/model/formulate.py,sha256=gepzUYVJt_31HHerg3XWVRkccBOoymeOhnQkZlXVP8Q,26799
+energiapy/model/objectives.py,sha256=9UjgR_c9lOUXO3Lbl5gzKvaXAGhC9K_LxF-NbxKNpv4,10207
+energiapy/model/sets.py,sha256=wcMnVqTF_48bcmgHRsgkgp3PAKHzeWe-C6GCgv6K90w,6464
+energiapy/model/solve.py,sha256=Pe07WKn3aYjZhoVOgIQ2wVUEQiDG6zoBfiR3FxAoxss,4848
 energiapy/model/constraints/__init__.py,sha256=My7nmKFdvXcir2V_XBVND9-aaRxMsUOO83J4kX3k_q4,364
-energiapy/model/constraints/chance.py,sha256=kn-60GhrgiYZQN92hp7pdgqBl23nLp9T1cAvy1xPVDk,354
-energiapy/model/constraints/cost.py,sha256=tnWB3a2Gu9qscTi1rOv1FZHR9HOpQ_PDambu-9-zKEk,23040
-energiapy/model/constraints/emission.py,sha256=I5t84FB9ZEUjEEkDksvgD_KDo3gVTX5hjwdXv2s9KKk,10496
-energiapy/model/constraints/failure.py,sha256=qA3l5oE-b6am6qRM6NC7jZBYlITYD_52ZQ6yhysOuis,2467
-energiapy/model/constraints/integer_cuts.py,sha256=fiRM7CjbvOpgrmDTPQkBoT3EYMFba4uNaXIhHbumYEk,1717
-energiapy/model/constraints/inventory.py,sha256=AN52_rEDTVwIhqmU5vXDbokhVUuD3DCQTJ50e-D2rmU,9045
-energiapy/model/constraints/land.py,sha256=R0go3ajPskyrSuH797wAjcaFR9TKWOsork9EoFR5kS0,4293
-energiapy/model/constraints/lifecyle.py,sha256=SzDUXTx11RNylR1_mCS16XQMyneutOHQfBTt3lYYH7o,784
-energiapy/model/constraints/mode.py,sha256=xaT0B6WK5XHcGCsK_KQ9PsVtUIpNqX0PqjDy204jDAg,5045
-energiapy/model/constraints/production.py,sha256=NCcH4S54XSCMTwbzaYBBVbyf6QaX4RXLB0gRFjfHq2s,9433
-energiapy/model/constraints/resource_balance.py,sha256=GbNhIauiOmqAcifNvKAsvJoAracHEuNdhpicL-oQ208,21310
-energiapy/model/constraints/transport.py,sha256=X73u3FIqAALGz_A2JrbR64tgNVzRFle0AMpOcekUxvo,8757
-energiapy/model/constraints/uncertain.py,sha256=tRF_nmy7cnyyqqjsh9vdxz52nUOUVsOSHxjNGL6KAJU,3133
+energiapy/model/constraints/chance.py,sha256=h3JtfWDUkzilaCsCbolzcyCxMAYJyzwj0EbWHTi4qF4,1849
+energiapy/model/constraints/constraints.py,sha256=f8bt7hsIT0LWzSsThPyK9eyaBQD0sJNNKtuE3smHNXs,768
+energiapy/model/constraints/cost.py,sha256=p3_1MIMi4OosDUjk3x9u7PszlfUi56SxjQgaHmRyqmY,25403
+energiapy/model/constraints/credit.py,sha256=naebqOeoAeFSIVh3x7TiWAYFZcu_Kc1sAIydojlL7O0,3588
+energiapy/model/constraints/emission.py,sha256=Or0W4LeXT87DtLKKnJhyo0010WY6thJPQCbdNAKcU3M,11547
+energiapy/model/constraints/failure.py,sha256=GeiqepSMbOfUPZVtIvVVg1PWzUMROurgbi8ufN2wB6c,2565
+energiapy/model/constraints/integer_cuts.py,sha256=vnAFWxV33G13QfdZml0jc5XmNJ4Wex_c1PC1-80uD1c,4044
+energiapy/model/constraints/inventory.py,sha256=ARjky-07wPtHo6CxfUlD7bQOpNK8wXCu_y2dFBONIZc,8663
+energiapy/model/constraints/land.py,sha256=S_zn5j3emcZ4tTuVF2aZS5f3G1SDA7X7gCQ_RXnbUBE,4287
+energiapy/model/constraints/lifecyle.py,sha256=fot5CxQnko8AB_AonsKPxedzogpyg3hYAXwijN53oMk,778
+energiapy/model/constraints/material.py,sha256=QDzzwlKeuo3hVvrB7dplzYworyg3G-ASEqhucE-DfBw,3760
+energiapy/model/constraints/mode.py,sha256=eQtuPU_o5AsYoxbNS_O8BI8WR2o9Z3hFztcODyR5KHU,7247
+energiapy/model/constraints/network.py,sha256=VFApKXx5xmrzgd_L1-4xGcV9BcYPUrcV-eUXuA7AICs,8815
+energiapy/model/constraints/production.py,sha256=bIFMUb5F20F__R5nvJ8A7KZML4JOFIi7_BNJRImTSCw,9642
+energiapy/model/constraints/resource_balance.py,sha256=EiBMP_Fr3I6vzRfQfDnZ_A7u0I8Y4DQLQ_RBoxt7l7Q,28903
+energiapy/model/constraints/transport.py,sha256=ou9RSTIQBdbexG7_IdDstAQxOc4k1VQhhAK9OfsbxGo,8751
+energiapy/model/constraints/uncertain.py,sha256=t5-HyPJe8V5kSuR_-pKFcN9wIqGMpwCRLj6HmYbtD5A,3127
 energiapy/model/variables/__init__.py,sha256=Yw9LXhOXYS76ZVvhHfBlGnQaAOwabTzR9Tq6eJbR9AI,362
-energiapy/model/variables/binary.py,sha256=m-PySCyDikYPrjLxWnwo2ZYaeIz2Z7NM5lR5M3CHlMk,1258
-energiapy/model/variables/cost.py,sha256=YwtJE-oc1C6xhk23tX3YZzS8Ec5upfXZKVIWM1MNN7Y,594
-energiapy/model/variables/mode.py,sha256=pK6_Jc5jMkyuqn5WqGzcqdZEZizvy471j36Y-E-R8Lg,1511
-energiapy/model/variables/network.py,sha256=RRNjTIIljc2mUQEv-ZcUwiDKXCxY5MnU5tFdp9EhU78,7311
-energiapy/model/variables/schedule.py,sha256=FkBIj6oTS6AxQRSGnFVwCeZoF6XzTcDidm6r6V15G7s,2258
-energiapy/model/variables/transport.py,sha256=fwRPtI32Nz7nkJiLSaBjlCVyb5PwbW0oTt_6Ugut1co,2002
-energiapy/model/variables/uncertain.py,sha256=NlcFFv6vARiL9_rscUbwlDVKk6WgnKarugzhV3q6J_8,2499
+energiapy/model/variables/binary.py,sha256=3f2NOodNOJZCfWi44-PApnka_5WxQlwoRrx6xyL606s,1252
+energiapy/model/variables/cost.py,sha256=BQV9bgufK9HvDtDm6xjVP1PlvNq8_JRe7EEEcoC8egk,676
+energiapy/model/variables/credit.py,sha256=eGZkh_jDRHIVkXTxHfqxNOfcJadgrPxBViTu44ph9Nw,1415
+energiapy/model/variables/emission.py,sha256=TMFCMG6S_eBHgt-pK9JHaBBo4SE0K7deTEo_-myiSU8,2372
+energiapy/model/variables/land.py,sha256=oXHFdzSkK5uajuN7FV81SS_bQ7J6blWQo02-TRYzsSE,1829
+energiapy/model/variables/material.py,sha256=OGM0Y0VRY9B4pabYiKy3Wdjkwn0p-cQ9qgt76kO0M-A,1536
+energiapy/model/variables/mode.py,sha256=PO2BPIVDog64vcuRfnd4cdkRzQwn1ncCCHAb1EqerdE,1670
+energiapy/model/variables/network.py,sha256=jeT4ch1IXIHEQGZ7TZ9xoErwM-r8k2dnVjdku9m79dw,5342
+energiapy/model/variables/schedule.py,sha256=VM7lXFPI-YLxp4O4wckrUmW0eOTdKmbl0wvqVP2sVjw,2713
+energiapy/model/variables/transport.py,sha256=-ILXCboPzopbDm8b0JD9Cvz4GcrqbnVDHd7_f_uKoPE,1996
+energiapy/model/variables/uncertain.py,sha256=kw-dNQHSlYjlXS5qlrfaby1oPAHxu53AkI_Yg3pBS98,1620
 energiapy/plot/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-energiapy/plot/plot_fit.py,sha256=sz_JTnm-RbBEhrNtjsY6ldocVdO1nLeFSwG58wT5rsk,4172
+energiapy/plot/plot_fit.py,sha256=SymoDPxNfjn2xagMUKlHJmLFzhNA3txSW9XLS6_6noE,4162
 energiapy/plot/plot_results.py,sha256=0uTMjA6Xee7D2D4wiilmmeNmzbIOiLljxEY3S48L7QU,12614
-energiapy/plot/plot_scenario.py,sha256=mXFoFK5OQDbSxHZaJxAQqtF3gdVpkCP3UnpVEUO3q4o,8743
+energiapy/plot/plot_scenario.py,sha256=8QuJVtzjtyH1Fv_9xL8SFua-PTBmEFk24CAPWfXnvUA,11560
 energiapy/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 energiapy/utils/cluster_utils.py,sha256=vSrZMp2960n_icnHkG52UMEJ8cGh6EQE4j2R6nLWzEY,416
-energiapy/utils/data_utils.py,sha256=2XllYVzkUNCtm16j_I9np98RYmDPozToCu0YE_H0bA4,14438
+energiapy/utils/data_utils.py,sha256=vTd6JZS6AsN_4m5-eA1CTb79-PQ1eUSS69iESPDU66Y,14792
 energiapy/utils/latex_utils.py,sha256=cyACH7EbGjJ3_5xbtoV3uUC-EFCGaTBJ_bIGtgW-UlY,3360
 energiapy/utils/math_utils.py,sha256=UI1b_UDC9qUDJkeFRRKLOMP8tdFqkHrSqBkDadxbgjY,2900
-energiapy/utils/nsrdb_utils.py,sha256=qWjfyT42OPGN30iIVjoD1bNzNvFy2E4C88Jvn8JpgUU,4849
+energiapy/utils/nsrdb_utils.py,sha256=hgXQznOKKku31_JRMmNOedIDLDuxGnsFmKGzWp7-c7Q,5052
 energiapy/utils/plot_utils.py,sha256=7wF9qtYeboNndVwxD53DJq_xW7xIFjruQJStt-XJi-g,1542
-energiapy/utils/process_utils.py,sha256=zrmlj0c4oWCh6wUXSws8VU6WU84meM_Hcdxg7gtXBSg,1041
+energiapy/utils/process_utils.py,sha256=kidCpO40Wp0pjBA_yG_ZW_Mz3Iix7HoW1y_KEnqEU5o,1053
 energiapy/utils/pwl_utils.py,sha256=bZvS5FIGD1bIFKlsLfyATi7bw-5NQeW_vDO8Mqhxt5M,1461
-energiapy/utils/resource_utils.py,sha256=wNlWY917dg47vzZLrmzE1Tgso_AJ--HH4tV_j5DfELg,1289
-energiapy/utils/scale_utils.py,sha256=Sx-21JbQBXzswHAS9BsqDJkb4IvYut8Zgh54TqRq60A,2912
-energiapy-1.0.6.dist-info/LICENSE,sha256=o_gL4AWsiOKuUvYAhbQkb4SZfKC1SAFWRNFHJpMArHg,1092
-energiapy-1.0.6.dist-info/METADATA,sha256=y5ZeBzQAwAqx5i7Xtf6PNtPNW5sK2pE96pmFyWtGzfg,5933
-energiapy-1.0.6.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-energiapy-1.0.6.dist-info/top_level.txt,sha256=XAM0qHY6F8bIpcY2YaWXbIlhhMbdQJj25s8lNDy3m-Q,10
-energiapy-1.0.6.dist-info/RECORD,,
+energiapy/utils/resource_utils.py,sha256=Y6bDxuzZ3Lu8_acIngyiLA3AiVSMHShYtslgu4nuAfM,1391
+energiapy/utils/scale_utils.py,sha256=cNmbVs0dUKMcPNVSp3PeKoBVj4fnUTJF0b1pCCKyMD8,2937
+energiapy-1.0.7.dist-info/LICENSE,sha256=o_gL4AWsiOKuUvYAhbQkb4SZfKC1SAFWRNFHJpMArHg,1092
+energiapy-1.0.7.dist-info/METADATA,sha256=iHVMQlsFgRPciPexA8gBGg9bzX_Q3xYzYe0v1v1x9zk,6001
+energiapy-1.0.7.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+energiapy-1.0.7.dist-info/top_level.txt,sha256=XAM0qHY6F8bIpcY2YaWXbIlhhMbdQJj25s8lNDy3m-Q,10
+energiapy-1.0.7.dist-info/RECORD,,
```

